<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="Web Script" module="erp5.portal_type"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Access_contents_information_Permission</string> </key>
            <value>
              <tuple>
                <string>Anonymous</string>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Associate</string>
                <string>Auditor</string>
                <string>Manager</string>
                <string>Owner</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Add_portal_content_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Change_local_roles_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Modify_portal_content_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_View_Permission</string> </key>
            <value>
              <tuple>
                <string>Anonymous</string>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Associate</string>
                <string>Auditor</string>
                <string>Manager</string>
                <string>Owner</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>content_md5</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>default_reference</string> </key>
            <value> <string>sinon.js</string> </value>
        </item>
        <item>
            <key> <string>description</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>id</string> </key>
            <value> <string>interface_test_Sinon_js</string> </value>
        </item>
        <item>
            <key> <string>language</string> </key>
            <value> <string>en</string> </value>
        </item>
        <item>
            <key> <string>portal_type</string> </key>
            <value> <string>Web Script</string> </value>
        </item>
        <item>
            <key> <string>short_title</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>text_content</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Sinon.JS 1.15.4, 2015/06/27\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS\n
 *\n
 * (The BSD License)\n
 * \n
 * Copyright (c) 2010-2014, Christian Johansen, christian@cjohansen.no\n
 * All rights reserved.\n
 * \n
 * Redistribution and use in source and binary forms, with or without modification,\n
 * are permitted provided that the following conditions are met:\n
 * \n
 *     * Redistributions of source code must retain the above copyright notice,\n
 *       this list of conditions and the following disclaimer.\n
 *     * Redistributions in binary form must reproduce the above copyright notice,\n
 *       this list of conditions and the following disclaimer in the documentation\n
 *       and/or other materials provided with the distribution.\n
 *     * Neither the name of Christian Johansen nor the names of his contributors\n
 *       may be used to endorse or promote products derived from this software\n
 *       without specific prior written permission.\n
 * \n
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n
 */\n
\n
(function (root, factory) {\n
  \'use strict\';\n
  if (typeof define === \'function\' && define.amd) {\n
    define(\'sinon\', [], function () {\n
      return (root.sinon = factory());\n
    });\n
  } else if (typeof exports === \'object\') {\n
    module.exports = factory();\n
  } else {\n
    root.sinon = factory();\n
  }\n
}(this, function () {\n
  \'use strict\';\n
  var samsam, formatio, lolex;\n
  (function () {\n
                function define(mod, deps, fn) {\n
                  if (mod == "samsam") {\n
                    samsam = deps();\n
                  } else if (typeof deps === "function" && mod.length === 0) {\n
                    lolex = deps();\n
                  } else if (typeof fn === "function") {\n
                    formatio = fn(samsam);\n
                  }\n
                }\n
    define.amd = {};\n
((typeof define === "function" && define.amd && function (m) { define("samsam", m); }) ||\n
 (typeof module === "object" &&\n
      function (m) { module.exports = m(); }) || // Node\n
 function (m) { this.samsam = m(); } // Browser globals\n
)(function () {\n
    var o = Object.prototype;\n
    var div = typeof document !== "undefined" && document.createElement("div");\n
\n
    function isNaN(value) {\n
        // Unlike global isNaN, this avoids type coercion\n
        // typeof check avoids IE host object issues, hat tip to\n
        // lodash\n
        var val = value; // JsLint thinks value !== value is "weird"\n
        return typeof value === "number" && value !== val;\n
    }\n
\n
    function getClass(value) {\n
        // Returns the internal [[Class]] by calling Object.prototype.toString\n
        // with the provided value as this. Return value is a string, naming the\n
        // internal class, e.g. "Array"\n
        return o.toString.call(value).split(/[ \\]]/)[1];\n
    }\n
\n
    /**\n
     * @name samsam.isArguments\n
     * @param Object object\n
     *\n
     * Returns ``true`` if ``object`` is an ``arguments`` object,\n
     * ``false`` otherwise.\n
     */\n
    function isArguments(object) {\n
        if (getClass(object) === \'Arguments\') { return true; }\n
        if (typeof object !== "object" || typeof object.length !== "number" ||\n
                getClass(object) === "Array") {\n
            return false;\n
        }\n
        if (typeof object.callee == "function") { return true; }\n
        try {\n
            object[object.length] = 6;\n
            delete object[object.length];\n
        } catch (e) {\n
            return true;\n
        }\n
        return false;\n
    }\n
\n
    /**\n
     * @name samsam.isElement\n
     * @param Object object\n
     *\n
     * Returns ``true`` if ``object`` is a DOM element node. Unlike\n
     * Underscore.js/lodash, this function will return ``false`` if ``object``\n
     * is an *element-like* object, i.e. a regular object with a ``nodeType``\n
     * property that holds the value ``1``.\n
     */\n
    function isElement(object) {\n
        if (!object || object.nodeType !== 1 || !div) { return false; }\n
        try {\n
            object.appendChild(div);\n
            object.removeChild(div);\n
        } catch (e) {\n
            return false;\n
        }\n
        return true;\n
    }\n
\n
    /**\n
     * @name samsam.keys\n
     * @param Object object\n
     *\n
     * Return an array of own property names.\n
     */\n
    function keys(object) {\n
        var ks = [], prop;\n
        for (prop in object) {\n
            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }\n
        }\n
        return ks;\n
    }\n
\n
    /**\n
     * @name samsam.isDate\n
     * @param Object value\n
     *\n
     * Returns true if the object is a ``Date``, or *date-like*. Duck typing\n
     * of date objects work by checking that the object has a ``getTime``\n
     * function whose return value equals the return value from the object\'s\n
     * ``valueOf``.\n
     */\n
    function isDate(value) {\n
        return typeof value.getTime == "function" &&\n
            value.getTime() == value.valueOf();\n
    }\n
\n
    /**\n
     * @name samsam.isNegZero\n
     * @param Object value\n
     *\n
     * Returns ``true`` if ``value`` is ``-0``.\n
     */\n
    function isNegZero(value) {\n
        return value === 0 && 1 / value === -Infinity;\n
    }\n
\n
    /**\n
     * @name samsam.equal\n
     * @param Object obj1\n
     * @param Object obj2\n
     *\n
     * Returns ``true`` if two objects are strictly equal. Compared to\n
     * ``===`` there are two exceptions:\n
     *\n
     *   - NaN is considered equal to NaN\n
     *   - -0 and +0 are not considered equal\n
     */\n
    function identical(obj1, obj2) {\n
        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {\n
            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);\n
        }\n
    }\n
\n
\n
    /**\n
     * @name samsam.deepEqual\n
     * @param Object obj1\n
     * @param Object obj2\n
     *\n
     * Deep equal comparison. Two values are "deep equal" if:\n
     *\n
     *   - They are equal, according to samsam.identical\n
     *   - They are both date objects representing the same time\n
     *   - They are both arrays containing elements that are all deepEqual\n
     *   - They are objects with the same set of properties, and each property\n
     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``\n
     *\n
     * Supports cyclic objects.\n
     */\n
    function deepEqualCyclic(obj1, obj2) {\n
\n
        // used for cyclic comparison\n
        // contain already visited objects\n
        var objects1 = [],\n
            objects2 = [],\n
        // contain pathes (position in the object structure)\n
        // of the already visited objects\n
        // indexes same as in objects arrays\n
            paths1 = [],\n
            paths2 = [],\n
        // contains combinations of already compared objects\n
        // in the manner: { "$1[\'ref\']$2[\'ref\']": true }\n
            compared = {};\n
\n
        /**\n
         * used to check, if the value of a property is an object\n
         * (cyclic logic is only needed for objects)\n
         * only needed for cyclic logic\n
         */\n
        function isObject(value) {\n
\n
            if (typeof value === \'object\' && value !== null &&\n
                    !(value instanceof Boolean) &&\n
                    !(value instanceof Date)    &&\n
                    !(value instanceof Number)  &&\n
                    !(value instanceof RegExp)  &&\n
                    !(value instanceof String)) {\n
\n
                return true;\n
            }\n
\n
            return false;\n
        }\n
\n
        /**\n
         * returns the index of the given object in the\n
         * given objects array, -1 if not contained\n
         * only needed for cyclic logic\n
         */\n
        function getIndex(objects, obj) {\n
\n
            var i;\n
            for (i = 0; i < objects.length; i++) {\n
                if (objects[i] === obj) {\n
                    return i;\n
                }\n
            }\n
\n
            return -1;\n
        }\n
\n
        // does the recursion for the deep equal check\n
        return (function deepEqual(obj1, obj2, path1, path2) {\n
            var type1 = typeof obj1;\n
            var type2 = typeof obj2;\n
\n
            // == null also matches undefined\n
            if (obj1 === obj2 ||\n
                    isNaN(obj1) || isNaN(obj2) ||\n
                    obj1 == null || obj2 == null ||\n
                    type1 !== "object" || type2 !== "object") {\n
\n
                return identical(obj1, obj2);\n
            }\n
\n
            // Elements are only equal if identical(expected, actual)\n
            if (isElement(obj1) || isElement(obj2)) { return false; }\n
\n
            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);\n
            if (isDate1 || isDate2) {\n
                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {\n
                    return false;\n
                }\n
            }\n
\n
            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {\n
                if (obj1.toString() !== obj2.toString()) { return false; }\n
            }\n
\n
            var class1 = getClass(obj1);\n
            var class2 = getClass(obj2);\n
            var keys1 = keys(obj1);\n
            var keys2 = keys(obj2);\n
\n
            if (isArguments(obj1) || isArguments(obj2)) {\n
                if (obj1.length !== obj2.length) { return false; }\n
            } else {\n
                if (type1 !== type2 || class1 !== class2 ||\n
                        keys1.length !== keys2.length) {\n
                    return false;\n
                }\n
            }\n
\n
            var key, i, l,\n
                // following vars are used for the cyclic logic\n
                value1, value2,\n
                isObject1, isObject2,\n
                index1, index2,\n
                newPath1, newPath2;\n
\n
            for (i = 0, l = keys1.length; i < l; i++) {\n
                key = keys1[i];\n
                if (!o.hasOwnProperty.call(obj2, key)) {\n
                    return false;\n
                }\n
\n
                // Start of the cyclic logic\n
\n
                value1 = obj1[key];\n
                value2 = obj2[key];\n
\n
                isObject1 = isObject(value1);\n
                isObject2 = isObject(value2);\n
\n
                // determine, if the objects were already visited\n
                // (it\'s faster to check for isObject first, than to\n
                // get -1 from getIndex for non objects)\n
                index1 = isObject1 ? getIndex(objects1, value1) : -1;\n
                index2 = isObject2 ? getIndex(objects2, value2) : -1;\n
\n
                // determine the new pathes of the objects\n
                // - for non cyclic objects the current path will be extended\n
                //   by current property name\n
                // - for cyclic objects the stored path is taken\n
                newPath1 = index1 !== -1\n
                    ? paths1[index1]\n
                    : path1 + \'[\' + JSON.stringify(key) + \']\';\n
                newPath2 = index2 !== -1\n
                    ? paths2[index2]\n
                    : path2 + \'[\' + JSON.stringify(key) + \']\';\n
\n
                // stop recursion if current objects are already compared\n
                if (compared[newPath1 + newPath2]) {\n
                    return true;\n
                }\n
\n
                // remember the current objects and their pathes\n
                if (index1 === -1 && isObject1) {\n
                    objects1.push(value1);\n
                    paths1.push(newPath1);\n
                }\n
                if (index2 === -1 && isObject2) {\n
                    objects2.push(value2);\n
                    paths2.push(newPath2);\n
                }\n
\n
                // remember that the current objects are already compared\n
                if (isObject1 && isObject2) {\n
                    compared[newPath1 + newPath2] = true;\n
                }\n
\n
                // End of cyclic logic\n
\n
                // neither value1 nor value2 is a cycle\n
                // continue with next level\n
                if (!deepEqual(value1, value2, newPath1, newPath2)) {\n
                    return false;\n
                }\n
            }\n
\n
            return true;\n
\n
        }(obj1, obj2, \'$1\', \'$2\'));\n
    }\n
\n
    var match;\n
\n
    function arrayContains(array, subset) {\n
        if (subset.length === 0) { return true; }\n
        var i, l, j, k;\n
        for (i = 0, l = array.length; i < l; ++i) {\n
            if (match(array[i], subset[0])) {\n
                for (j = 0, k = subset.length; j < k; ++j) {\n
                    if (!match(array[i + j], subset[j])) { return false; }\n
                }\n
                return true;\n
            }\n
        }\n
        return false;\n
    }\n
\n
    /**\n
     * @name samsam.match\n
     * @param Object object\n
     * @param Object matcher\n
     *\n
     * Compare arbitrary value ``object`` with matcher.\n
     */\n
    match = function match(object, matcher) {\n
        if (matcher && typeof matcher.test === "function") {\n
            return matcher.test(object);\n
        }\n
\n
        if (typeof matcher === "function") {\n
            return matcher(object) === true;\n
        }\n
\n
        if (typeof matcher === "string") {\n
            matcher = matcher.toLowerCase();\n
            var notNull = typeof object === "string" || !!object;\n
            return notNull &&\n
                (String(object)).toLowerCase().indexOf(matcher) >= 0;\n
        }\n
\n
        if (typeof matcher === "number") {\n
            return matcher === object;\n
        }\n
\n
        if (typeof matcher === "boolean") {\n
            return matcher === object;\n
        }\n
\n
        if (typeof(matcher) === "undefined") {\n
            return typeof(object) === "undefined";\n
        }\n
\n
        if (matcher === null) {\n
            return object === null;\n
        }\n
\n
        if (getClass(object) === "Array" && getClass(matcher) === "Array") {\n
            return arrayContains(object, matcher);\n
        }\n
\n
        if (matcher && typeof matcher === "object") {\n
            if (matcher === object) {\n
                return true;\n
            }\n
            var prop;\n
            for (prop in matcher) {\n
                var value = object[prop];\n
                if (typeof value === "undefined" &&\n
                        typeof object.getAttribute === "function") {\n
                    value = object.getAttribute(prop);\n
                }\n
                if (matcher[prop] === null || typeof matcher[prop] === \'undefined\') {\n
                    if (value !== matcher[prop]) {\n
                        return false;\n
                    }\n
                } else if (typeof  value === "undefined" || !match(value, matcher[prop])) {\n
                    return false;\n
                }\n
            }\n
            return true;\n
        }\n
\n
        throw new Error("Matcher was not a string, a number, a " +\n
                        "function, a boolean or an object");\n
    };\n
\n
    return {\n
        isArguments: isArguments,\n
        isElement: isElement,\n
        isDate: isDate,\n
        isNegZero: isNegZero,\n
        identical: identical,\n
        deepEqual: deepEqualCyclic,\n
        match: match,\n
        keys: keys\n
    };\n
});\n
((typeof define === "function" && define.amd && function (m) {\n
    define("formatio", ["samsam"], m);\n
}) || (typeof module === "object" && function (m) {\n
    module.exports = m(require("samsam"));\n
}) || function (m) { this.formatio = m(this.samsam); }\n
)(function (samsam) {\n
    \n
    var formatio = {\n
        excludeConstructors: ["Object", /^.$/],\n
        quoteStrings: true,\n
        limitChildrenCount: 0\n
    };\n
\n
    var hasOwn = Object.prototype.hasOwnProperty;\n
\n
    var specialObjects = [];\n
    if (typeof global !== "undefined") {\n
        specialObjects.push({ object: global, value: "[object global]" });\n
    }\n
    if (typeof document !== "undefined") {\n
        specialObjects.push({\n
            object: document,\n
            value: "[object HTMLDocument]"\n
        });\n
    }\n
    if (typeof window !== "undefined") {\n
        specialObjects.push({ object: window, value: "[object Window]" });\n
    }\n
\n
    function functionName(func) {\n
        if (!func) { return ""; }\n
        if (func.displayName) { return func.displayName; }\n
        if (func.name) { return func.name; }\n
        var matches = func.toString().match(/function\\s+([^\\(]+)/m);\n
        return (matches && matches[1]) || "";\n
    }\n
\n
    function constructorName(f, object) {\n
        var name = functionName(object && object.constructor);\n
        var excludes = f.excludeConstructors ||\n
                formatio.excludeConstructors || [];\n
\n
        var i, l;\n
        for (i = 0, l = excludes.length; i < l; ++i) {\n
            if (typeof excludes[i] === "string" && excludes[i] === name) {\n
                return "";\n
            } else if (excludes[i].test && excludes[i].test(name)) {\n
                return "";\n
            }\n
        }\n
\n
        return name;\n
    }\n
\n
    function isCircular(object, objects) {\n
        if (typeof object !== "object") { return false; }\n
        var i, l;\n
        for (i = 0, l = objects.length; i < l; ++i) {\n
            if (objects[i] === object) { return true; }\n
        }\n
        return false;\n
    }\n
\n
    function ascii(f, object, processed, indent) {\n
        if (typeof object === "string") {\n
            var qs = f.quoteStrings;\n
            var quote = typeof qs !== "boolean" || qs;\n
            return processed || quote ? \'"\' + object + \'"\' : object;\n
        }\n
\n
        if (typeof object === "function" && !(object instanceof RegExp)) {\n
            return ascii.func(object);\n
        }\n
\n
        processed = processed || [];\n
\n
        if (isCircular(object, processed)) { return "[Circular]"; }\n
\n
        if (Object.prototype.toString.call(object) === "[object Array]") {\n
            return ascii.array.call(f, object, processed);\n
        }\n
\n
        if (!object) { return String((1/object) === -Infinity ? "-0" : object); }\n
        if (samsam.isElement(object)) { return ascii.element(object); }\n
\n
        if (typeof object.toString === "function" &&\n
                object.toString !== Object.prototype.toString) {\n
            return object.toString();\n
        }\n
\n
        var i, l;\n
        for (i = 0, l = specialObjects.length; i < l; i++) {\n
            if (object === specialObjects[i].object) {\n
                return specialObjects[i].value;\n
            }\n
        }\n
\n
        return ascii.object.call(f, object, processed, indent);\n
    }\n
\n
    ascii.func = function (func) {\n
        return "function " + functionName(func) + "() {}";\n
    };\n
\n
    ascii.array = function (array, processed) {\n
        processed = processed || [];\n
        processed.push(array);\n
        var pieces = [];\n
        var i, l;\n
        l = (this.limitChildrenCount > 0) ? \n
            Math.min(this.limitChildrenCount, array.length) : array.length;\n
\n
        for (i = 0; i < l; ++i) {\n
            pieces.push(ascii(this, array[i], processed));\n
        }\n
\n
        if(l < array.length)\n
            pieces.push("[... " + (array.length - l) + " more elements]");\n
\n
        return "[" + pieces.join(", ") + "]";\n
    };\n
\n
    ascii.object = function (object, processed, indent) {\n
        processed = processed || [];\n
        processed.push(object);\n
        indent = indent || 0;\n
        var pieces = [], properties = samsam.keys(object).sort();\n
        var length = 3;\n
        var prop, str, obj, i, k, l;\n
        l = (this.limitChildrenCount > 0) ? \n
            Math.min(this.limitChildrenCount, properties.length) : properties.length;\n
\n
        for (i = 0; i < l; ++i) {\n
            prop = properties[i];\n
            obj = object[prop];\n
\n
            if (isCircular(obj, processed)) {\n
                str = "[Circular]";\n
            } else {\n
                str = ascii(this, obj, processed, indent + 2);\n
            }\n
\n
            str = (/\\s/.test(prop) ? \'"\' + prop + \'"\' : prop) + ": " + str;\n
            length += str.length;\n
            pieces.push(str);\n
        }\n
\n
        var cons = constructorName(this, object);\n
        var prefix = cons ? "[" + cons + "] " : "";\n
        var is = "";\n
        for (i = 0, k = indent; i < k; ++i) { is += " "; }\n
\n
        if(l < properties.length)\n
            pieces.push("[... " + (properties.length - l) + " more elements]");\n
\n
        if (length + indent > 80) {\n
            return prefix + "{\\n  " + is + pieces.join(",\\n  " + is) + "\\n" +\n
                is + "}";\n
        }\n
        return prefix + "{ " + pieces.join(", ") + " }";\n
    };\n
\n
    ascii.element = function (element) {\n
        var tagName = element.tagName.toLowerCase();\n
        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;\n
\n
        for (i = 0, l = attrs.length; i < l; ++i) {\n
            attr = attrs.item(i);\n
            attrName = attr.nodeName.toLowerCase().replace("html:", "");\n
            val = attr.nodeValue;\n
            if (attrName !== "contenteditable" || val !== "inherit") {\n
                if (!!val) { pairs.push(attrName + "=\\"" + val + "\\""); }\n
            }\n
        }\n
\n
        var formatted = "<" + tagName + (pairs.length > 0 ? " " : "");\n
        var content = element.innerHTML;\n
\n
        if (content.length > 20) {\n
            content = content.substr(0, 20) + "[...]";\n
        }\n
\n
        var res = formatted + pairs.join(" ") + ">" + content +\n
                "</" + tagName + ">";\n
\n
        return res.replace(/ contentEditable="inherit"/, "");\n
    };\n
\n
    function Formatio(options) {\n
        for (var opt in options) {\n
            this[opt] = options[opt];\n
        }\n
    }\n
\n
    Formatio.prototype = {\n
        functionName: functionName,\n
\n
        configure: function (options) {\n
            return new Formatio(options);\n
        },\n
\n
        constructorName: function (object) {\n
            return constructorName(this, object);\n
        },\n
\n
        ascii: function (object, processed, indent) {\n
            return ascii(this, object, processed, indent);\n
        }\n
    };\n
\n
    return Formatio.prototype;\n
});\n
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.lolex=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module \'"+o+"\'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n
(function (global){\n
/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/\n
/*global global*/\n
/**\n
 * @author Christian Johansen (christian@cjohansen.no) and contributors\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2014 Christian Johansen\n
 */\n
\n
// node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()\n
// browsers, a number.\n
// see https://github.com/cjohansen/Sinon.JS/pull/436\n
var timeoutResult = setTimeout(function() {}, 0);\n
var addTimerReturnsObject = typeof timeoutResult === "object";\n
clearTimeout(timeoutResult);\n
\n
var NativeDate = Date;\n
var id = 1;\n
\n
/**\n
 * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into\n
 * number of milliseconds. This is used to support human-readable strings passed\n
 * to clock.tick()\n
 */\n
function parseTime(str) {\n
    if (!str) {\n
        return 0;\n
    }\n
\n
    var strings = str.split(":");\n
    var l = strings.length, i = l;\n
    var ms = 0, parsed;\n
\n
    if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n
        throw new Error("tick only understands numbers and \'h:m:s\'");\n
    }\n
\n
    while (i--) {\n
        parsed = parseInt(strings[i], 10);\n
\n
        if (parsed >= 60) {\n
            throw new Error("Invalid time " + str);\n
        }\n
\n
        ms += parsed * Math.pow(60, (l - i - 1));\n
    }\n
\n
    return ms * 1000;\n
}\n
\n
/**\n
 * Used to grok the `now` parameter to createClock.\n
 */\n
function getEpoch(epoch) {\n
    if (!epoch) { return 0; }\n
    if (typeof epoch.getTime === "function") { return epoch.getTime(); }\n
    if (typeof epoch === "number") { return epoch; }\n
    throw new TypeError("now should be milliseconds since UNIX epoch");\n
}\n
\n
function inRange(from, to, timer) {\n
    return timer && timer.callAt >= from && timer.callAt <= to;\n
}\n
\n
function mirrorDateProperties(target, source) {\n
    if (source.now) {\n
        target.now = function now() {\n
            return target.clock.now;\n
        };\n
    } else {\n
        delete target.now;\n
    }\n
\n
    if (source.toSource) {\n
        target.toSource = function toSource() {\n
            return source.toSource();\n
        };\n
    } else {\n
        delete target.toSource;\n
    }\n
\n
    target.toString = function toString() {\n
        return source.toString();\n
    };\n
\n
    target.prototype = source.prototype;\n
    target.parse = source.parse;\n
    target.UTC = source.UTC;\n
    target.prototype.toUTCString = source.prototype.toUTCString;\n
\n
    for (var prop in source) {\n
        if (source.hasOwnProperty(prop)) {\n
            target[prop] = source[prop];\n
        }\n
    }\n
\n
    return target;\n
}\n
\n
function createDate() {\n
    function ClockDate(year, month, date, hour, minute, second, ms) {\n
        // Defensive and verbose to avoid potential harm in passing\n
        // explicit undefined when user does not pass argument\n
        switch (arguments.length) {\n
        case 0:\n
            return new NativeDate(ClockDate.clock.now);\n
        case 1:\n
            return new NativeDate(year);\n
        case 2:\n
            return new NativeDate(year, month);\n
        case 3:\n
            return new NativeDate(year, month, date);\n
        case 4:\n
            return new NativeDate(year, month, date, hour);\n
        case 5:\n
            return new NativeDate(year, month, date, hour, minute);\n
        case 6:\n
            return new NativeDate(year, month, date, hour, minute, second);\n
        default:\n
            return new NativeDate(year, month, date, hour, minute, second, ms);\n
        }\n
    }\n
\n
    return mirrorDateProperties(ClockDate, NativeDate);\n
}\n
\n
function addTimer(clock, timer) {\n
    if (typeof timer.func === "undefined") {\n
        throw new Error("Callback must be provided to timer calls");\n
    }\n
\n
    if (!clock.timers) {\n
        clock.timers = {};\n
    }\n
\n
    timer.id = id++;\n
    timer.createdAt = clock.now;\n
    timer.callAt = clock.now + (timer.delay || 0);\n
\n
    clock.timers[timer.id] = timer;\n
\n
    if (addTimerReturnsObject) {\n
        return {\n
            id: timer.id,\n
            ref: function() {},\n
            unref: function() {}\n
        };\n
    }\n
    else {\n
        return timer.id;\n
    }\n
}\n
\n
function firstTimerInRange(clock, from, to) {\n
    var timers = clock.timers, timer = null;\n
\n
    for (var id in timers) {\n
        if (!inRange(from, to, timers[id])) {\n
            continue;\n
        }\n
\n
        if (!timer || ~compareTimers(timer, timers[id])) {\n
            timer = timers[id];\n
        }\n
    }\n
\n
    return timer;\n
}\n
\n
function compareTimers(a, b) {\n
    // Sort first by absolute timing\n
    if (a.callAt < b.callAt) {\n
        return -1;\n
    }\n
    if (a.callAt > b.callAt) {\n
        return 1;\n
    }\n
\n
    // Sort next by immediate, immediate timers take precedence\n
    if (a.immediate && !b.immediate) {\n
        return -1;\n
    }\n
    if (!a.immediate && b.immediate) {\n
        return 1;\n
    }\n
\n
    // Sort next by creation time, earlier-created timers take precedence\n
    if (a.createdAt < b.createdAt) {\n
        return -1;\n
    }\n
    if (a.createdAt > b.createdAt) {\n
        return 1;\n
    }\n
\n
    // Sort next by id, lower-id timers take precedence\n
    if (a.id < b.id) {\n
        return -1;\n
    }\n
    if (a.id > b.id) {\n
        return 1;\n
    }\n
\n
    // As timer ids are unique, no fallback `0` is necessary\n
}\n
\n
function callTimer(clock, timer) {\n
    if (typeof timer.interval == "number") {\n
        clock.timers[timer.id].callAt += timer.interval;\n
    } else {\n
        delete clock.timers[timer.id];\n
    }\n
\n
    try {\n
        if (typeof timer.func == "function") {\n
            timer.func.apply(null, timer.args);\n
        } else {\n
            eval(timer.func);\n
        }\n
    } catch (e) {\n
        var exception = e;\n
    }\n
\n
    if (!clock.timers[timer.id]) {\n
        if (exception) {\n
            throw exception;\n
        }\n
        return;\n
    }\n
\n
    if (exception) {\n
        throw exception;\n
    }\n
}\n
\n
function uninstall(clock, target) {\n
    var method;\n
\n
    for (var i = 0, l = clock.methods.length; i < l; i++) {\n
        method = clock.methods[i];\n
\n
        if (target[method].hadOwnProperty) {\n
            target[method] = clock["_" + method];\n
        } else {\n
            try {\n
                delete target[method];\n
            } catch (e) {}\n
        }\n
    }\n
\n
    // Prevent multiple executions which will completely remove these props\n
    clock.methods = [];\n
}\n
\n
function hijackMethod(target, method, clock) {\n
    clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);\n
    clock["_" + method] = target[method];\n
\n
    if (method == "Date") {\n
        var date = mirrorDateProperties(clock[method], target[method]);\n
        target[method] = date;\n
    } else {\n
        target[method] = function () {\n
            return clock[method].apply(clock, arguments);\n
        };\n
\n
        for (var prop in clock[method]) {\n
            if (clock[method].hasOwnProperty(prop)) {\n
                target[method][prop] = clock[method][prop];\n
            }\n
        }\n
    }\n
\n
    target[method].clock = clock;\n
}\n
\n
var timers = {\n
    setTimeout: setTimeout,\n
    clearTimeout: clearTimeout,\n
    setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),\n
    clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate: undefined),\n
    setInterval: setInterval,\n
    clearInterval: clearInterval,\n
    Date: Date\n
};\n
\n
var keys = Object.keys || function (obj) {\n
    var ks = [];\n
    for (var key in obj) {\n
        ks.push(key);\n
    }\n
    return ks;\n
};\n
\n
exports.timers = timers;\n
\n
var createClock = exports.createClock = function (now) {\n
    var clock = {\n
        now: getEpoch(now),\n
        timeouts: {},\n
        Date: createDate()\n
    };\n
\n
    clock.Date.clock = clock;\n
\n
    clock.setTimeout = function setTimeout(func, timeout) {\n
        return addTimer(clock, {\n
            func: func,\n
            args: Array.prototype.slice.call(arguments, 2),\n
            delay: timeout\n
        });\n
    };\n
\n
    clock.clearTimeout = function clearTimeout(timerId) {\n
        if (!timerId) {\n
            // null appears to be allowed in most browsers, and appears to be\n
            // relied upon by some libraries, like Bootstrap carousel\n
            return;\n
        }\n
        if (!clock.timers) {\n
            clock.timers = [];\n
        }\n
        // in Node, timerId is an object with .ref()/.unref(), and\n
        // its .id field is the actual timer id.\n
        if (typeof timerId === "object") {\n
            timerId = timerId.id\n
        }\n
        if (timerId in clock.timers) {\n
            delete clock.timers[timerId];\n
        }\n
    };\n
\n
    clock.setInterval = function setInterval(func, timeout) {\n
        return addTimer(clock, {\n
            func: func,\n
            args: Array.prototype.slice.call(arguments, 2),\n
            delay: timeout,\n
            interval: timeout\n
        });\n
    };\n
\n
    clock.clearInterval = function clearInterval(timerId) {\n
        clock.clearTimeout(timerId);\n
    };\n
\n
    clock.setImmediate = function setImmediate(func) {\n
        return addTimer(clock, {\n
            func: func,\n
            args: Array.prototype.slice.call(arguments, 1),\n
            immediate: true\n
        });\n
    };\n
\n
    clock.clearImmediate = function clearImmediate(timerId) {\n
        clock.clearTimeout(timerId);\n
    };\n
\n
    clock.tick = function tick(ms) {\n
        ms = typeof ms == "number" ? ms : parseTime(ms);\n
        var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now;\n
        var timer = firstTimerInRange(clock, tickFrom, tickTo);\n
\n
        var firstException;\n
        while (timer && tickFrom <= tickTo) {\n
            if (clock.timers[timer.id]) {\n
                tickFrom = clock.now = timer.callAt;\n
                try {\n
                    callTimer(clock, timer);\n
                } catch (e) {\n
                    firstException = firstException || e;\n
                }\n
            }\n
\n
            timer = firstTimerInRange(clock, previous, tickTo);\n
            previous = tickFrom;\n
        }\n
\n
        clock.now = tickTo;\n
\n
        if (firstException) {\n
            throw firstException;\n
        }\n
\n
        return clock.now;\n
    };\n
\n
    clock.reset = function reset() {\n
        clock.timers = {};\n
    };\n
\n
    return clock;\n
};\n
\n
exports.install = function install(target, now, toFake) {\n
    if (typeof target === "number") {\n
        toFake = now;\n
        now = target;\n
        target = null;\n
    }\n
\n
    if (!target) {\n
        target = global;\n
    }\n
\n
    var clock = createClock(now);\n
\n
    clock.uninstall = function () {\n
        uninstall(clock, target);\n
    };\n
\n
    clock.methods = toFake || [];\n
\n
    if (clock.methods.length === 0) {\n
        clock.methods = keys(timers);\n
    }\n
\n
    for (var i = 0, l = clock.methods.length; i < l; i++) {\n
        hijackMethod(target, clock.methods[i], clock);\n
    }\n
\n
    return clock;\n
};\n
\n
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n
},{}]},{},[1])(1)\n
});\n
  })();\n
  var define;\n
/**\n
 * Sinon core utilities. For internal use only.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
var sinon = (function () {\n
"use strict";\n
\n
    var sinon;\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        sinon = module.exports = require("./sinon/util/core");\n
        require("./sinon/extend");\n
        require("./sinon/typeOf");\n
        require("./sinon/times_in_words");\n
        require("./sinon/spy");\n
        require("./sinon/call");\n
        require("./sinon/behavior");\n
        require("./sinon/stub");\n
        require("./sinon/mock");\n
        require("./sinon/collection");\n
        require("./sinon/assert");\n
        require("./sinon/sandbox");\n
        require("./sinon/test");\n
        require("./sinon/test_case");\n
        require("./sinon/match");\n
        require("./sinon/format");\n
        require("./sinon/log_error");\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
        sinon = module.exports;\n
    } else {\n
        sinon = {};\n
    }\n
\n
    return sinon;\n
}());\n
\n
/**\n
 * @depend ../../sinon.js\n
 */\n
/**\n
 * Sinon core utilities. For internal use only.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    var div = typeof document != "undefined" && document.createElement("div");\n
    var hasOwn = Object.prototype.hasOwnProperty;\n
\n
    function isDOMNode(obj) {\n
        var success = false;\n
\n
        try {\n
            obj.appendChild(div);\n
            success = div.parentNode == obj;\n
        } catch (e) {\n
            return false;\n
        } finally {\n
            try {\n
                obj.removeChild(div);\n
            } catch (e) {\n
                // Remove failed, not much we can do about that\n
            }\n
        }\n
\n
        return success;\n
    }\n
\n
    function isElement(obj) {\n
        return div && obj && obj.nodeType === 1 && isDOMNode(obj);\n
    }\n
\n
    function isFunction(obj) {\n
        return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);\n
    }\n
\n
    function isReallyNaN(val) {\n
        return typeof val === "number" && isNaN(val);\n
    }\n
\n
    function mirrorProperties(target, source) {\n
        for (var prop in source) {\n
            if (!hasOwn.call(target, prop)) {\n
                target[prop] = source[prop];\n
            }\n
        }\n
    }\n
\n
    function isRestorable(obj) {\n
        return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;\n
    }\n
\n
    // Cheap way to detect if we have ES5 support.\n
    var hasES5Support = "keys" in Object;\n
\n
    function makeApi(sinon) {\n
        sinon.wrapMethod = function wrapMethod(object, property, method) {\n
            if (!object) {\n
                throw new TypeError("Should wrap property of object");\n
            }\n
\n
            if (typeof method != "function" && typeof method != "object") {\n
                throw new TypeError("Method wrapper should be a function or a property descriptor");\n
            }\n
\n
            function checkWrappedMethod(wrappedMethod) {\n
                if (!isFunction(wrappedMethod)) {\n
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +\n
                                        property + " as function");\n
                } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");\n
                } else if (wrappedMethod.calledBefore) {\n
                    var verb = !!wrappedMethod.returns ? "stubbed" : "spied on";\n
                    error = new TypeError("Attempted to wrap " + property + " which is already " + verb);\n
                }\n
\n
                if (error) {\n
                    if (wrappedMethod && wrappedMethod.stackTrace) {\n
                        error.stack += "\\n--------------\\n" + wrappedMethod.stackTrace;\n
                    }\n
                    throw error;\n
                }\n
            }\n
\n
            var error, wrappedMethod;\n
\n
            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem\n
            // when using hasOwn.call on objects from other frames.\n
            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n
\n
            if (hasES5Support) {\n
                var methodDesc = (typeof method == "function") ? {value: method} : method,\n
                    wrappedMethodDesc = sinon.getPropertyDescriptor(object, property),\n
                    i;\n
\n
                if (!wrappedMethodDesc) {\n
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +\n
                                        property + " as function");\n
                } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");\n
                }\n
                if (error) {\n
                    if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n
                        error.stack += "\\n--------------\\n" + wrappedMethodDesc.stackTrace;\n
                    }\n
                    throw error;\n
                }\n
\n
                var types = sinon.objectKeys(methodDesc);\n
                for (i = 0; i < types.length; i++) {\n
                    wrappedMethod = wrappedMethodDesc[types[i]];\n
                    checkWrappedMethod(wrappedMethod);\n
                }\n
\n
                mirrorProperties(methodDesc, wrappedMethodDesc);\n
                for (i = 0; i < types.length; i++) {\n
                    mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n
                }\n
                Object.defineProperty(object, property, methodDesc);\n
            } else {\n
                wrappedMethod = object[property];\n
                checkWrappedMethod(wrappedMethod);\n
                object[property] = method;\n
                method.displayName = property;\n
            }\n
\n
            method.displayName = property;\n
\n
            // Set up a stack trace which can be used later to find what line of\n
            // code the original method was created on.\n
            method.stackTrace = (new Error("Stack Trace for original")).stack;\n
\n
            method.restore = function () {\n
                // For prototype properties try to reset by delete first.\n
                // If this fails (ex: localStorage on mobile safari) then force a reset\n
                // via direct assignment.\n
                if (!owned) {\n
                    // In some cases `delete` may throw an error\n
                    try {\n
                        delete object[property];\n
                    } catch (e) {}\n
                    // For native code functions `delete` fails without throwing an error\n
                    // on Chrome < 43, PhantomJS, etc.\n
                } else if (hasES5Support) {\n
                    Object.defineProperty(object, property, wrappedMethodDesc);\n
                }\n
\n
                // Use strict equality comparison to check failures then force a reset\n
                // via direct assignment.\n
                if (object[property] === method) {\n
                    object[property] = wrappedMethod;\n
                }\n
            };\n
\n
            method.restore.sinon = true;\n
\n
            if (!hasES5Support) {\n
                mirrorProperties(method, wrappedMethod);\n
            }\n
\n
            return method;\n
        };\n
\n
        sinon.create = function create(proto) {\n
            var F = function () {};\n
            F.prototype = proto;\n
            return new F();\n
        };\n
\n
        sinon.deepEqual = function deepEqual(a, b) {\n
            if (sinon.match && sinon.match.isMatcher(a)) {\n
                return a.test(b);\n
            }\n
\n
            if (typeof a != "object" || typeof b != "object") {\n
                if (isReallyNaN(a) && isReallyNaN(b)) {\n
                    return true;\n
                } else {\n
                    return a === b;\n
                }\n
            }\n
\n
            if (isElement(a) || isElement(b)) {\n
                return a === b;\n
            }\n
\n
            if (a === b) {\n
                return true;\n
            }\n
\n
            if ((a === null && b !== null) || (a !== null && b === null)) {\n
                return false;\n
            }\n
\n
            if (a instanceof RegExp && b instanceof RegExp) {\n
                return (a.source === b.source) && (a.global === b.global) &&\n
                    (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);\n
            }\n
\n
            var aString = Object.prototype.toString.call(a);\n
            if (aString != Object.prototype.toString.call(b)) {\n
                return false;\n
            }\n
\n
            if (aString == "[object Date]") {\n
                return a.valueOf() === b.valueOf();\n
            }\n
\n
            var prop, aLength = 0, bLength = 0;\n
\n
            if (aString == "[object Array]" && a.length !== b.length) {\n
                return false;\n
            }\n
\n
            for (prop in a) {\n
                aLength += 1;\n
\n
                if (!(prop in b)) {\n
                    return false;\n
                }\n
\n
                if (!deepEqual(a[prop], b[prop])) {\n
                    return false;\n
                }\n
            }\n
\n
            for (prop in b) {\n
                bLength += 1;\n
            }\n
\n
            return aLength == bLength;\n
        };\n
\n
        sinon.functionName = function functionName(func) {\n
            var name = func.displayName || func.name;\n
\n
            // Use function decomposition as a last resort to get function\n
            // name. Does not rely on function decomposition to work - if it\n
            // doesn\'t debugging will be slightly less informative\n
            // (i.e. toString will say \'spy\' rather than \'myFunc\').\n
            if (!name) {\n
                var matches = func.toString().match(/function ([^\\s\\(]+)/);\n
                name = matches && matches[1];\n
            }\n
\n
            return name;\n
        };\n
\n
        sinon.functionToString = function toString() {\n
            if (this.getCall && this.callCount) {\n
                var thisValue, prop, i = this.callCount;\n
\n
                while (i--) {\n
                    thisValue = this.getCall(i).thisValue;\n
\n
                    for (prop in thisValue) {\n
                        if (thisValue[prop] === this) {\n
                            return prop;\n
                        }\n
                    }\n
                }\n
            }\n
\n
            return this.displayName || "sinon fake";\n
        };\n
\n
        sinon.objectKeys = function objectKeys(obj) {\n
            if (obj !== Object(obj)) {\n
                throw new TypeError("sinon.objectKeys called on a non-object");\n
            }\n
\n
            var keys = [];\n
            var key;\n
            for (key in obj) {\n
                if (hasOwn.call(obj, key)) {\n
                    keys.push(key);\n
                }\n
            }\n
\n
            return keys;\n
        };\n
\n
        sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) {\n
            var proto = object, descriptor;\n
            while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {\n
                proto = Object.getPrototypeOf(proto);\n
            }\n
            return descriptor;\n
        }\n
\n
        sinon.getConfig = function (custom) {\n
            var config = {};\n
            custom = custom || {};\n
            var defaults = sinon.defaultConfig;\n
\n
            for (var prop in defaults) {\n
                if (defaults.hasOwnProperty(prop)) {\n
                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];\n
                }\n
            }\n
\n
            return config;\n
        };\n
\n
        sinon.defaultConfig = {\n
            injectIntoThis: true,\n
            injectInto: null,\n
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],\n
            useFakeTimers: true,\n
            useFakeServer: true\n
        };\n
\n
        sinon.timesInWords = function timesInWords(count) {\n
            return count == 1 && "once" ||\n
                count == 2 && "twice" ||\n
                count == 3 && "thrice" ||\n
                (count || 0) + " times";\n
        };\n
\n
        sinon.calledInOrder = function (spies) {\n
            for (var i = 1, l = spies.length; i < l; i++) {\n
                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {\n
                    return false;\n
                }\n
            }\n
\n
            return true;\n
        };\n
\n
        sinon.orderByFirstCall = function (spies) {\n
            return spies.sort(function (a, b) {\n
                // uuid, won\'t ever be equal\n
                var aCall = a.getCall(0);\n
                var bCall = b.getCall(0);\n
                var aId = aCall && aCall.callId || -1;\n
                var bId = bCall && bCall.callId || -1;\n
\n
                return aId < bId ? -1 : 1;\n
            });\n
        };\n
\n
        sinon.createStubInstance = function (constructor) {\n
            if (typeof constructor !== "function") {\n
                throw new TypeError("The constructor should be a function.");\n
            }\n
            return sinon.stub(sinon.create(constructor.prototype));\n
        };\n
\n
        sinon.restore = function (object) {\n
            if (object !== null && typeof object === "object") {\n
                for (var prop in object) {\n
                    if (isRestorable(object[prop])) {\n
                        object[prop].restore();\n
                    }\n
                }\n
            } else if (isRestorable(object)) {\n
                object.restore();\n
            }\n
        };\n
\n
        return sinon;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports) {\n
        makeApi(exports);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
\n
        // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n
        var hasDontEnumBug = (function () {\n
            var obj = {\n
                constructor: function () {\n
                    return "0";\n
                },\n
                toString: function () {\n
                    return "1";\n
                },\n
                valueOf: function () {\n
                    return "2";\n
                },\n
                toLocaleString: function () {\n
                    return "3";\n
                },\n
                prototype: function () {\n
                    return "4";\n
                },\n
                isPrototypeOf: function () {\n
                    return "5";\n
                },\n
                propertyIsEnumerable: function () {\n
                    return "6";\n
                },\n
                hasOwnProperty: function () {\n
                    return "7";\n
                },\n
                length: function () {\n
                    return "8";\n
                },\n
                unique: function () {\n
                    return "9"\n
                }\n
            };\n
\n
            var result = [];\n
            for (var prop in obj) {\n
                result.push(obj[prop]());\n
            }\n
            return result.join("") !== "0123456789";\n
        })();\n
\n
        /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will\n
         *         override properties in previous sources.\n
         *\n
         * target - The Object to extend\n
         * sources - Objects to copy properties from.\n
         *\n
         * Returns the extended target\n
         */\n
        function extend(target /*, sources */) {\n
            var sources = Array.prototype.slice.call(arguments, 1),\n
                source, i, prop;\n
\n
            for (i = 0; i < sources.length; i++) {\n
                source = sources[i];\n
\n
                for (prop in source) {\n
                    if (source.hasOwnProperty(prop)) {\n
                        target[prop] = source[prop];\n
                    }\n
                }\n
\n
                // Make sure we copy (own) toString method even when in JScript with DontEnum bug\n
                // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n
                if (hasDontEnumBug && source.hasOwnProperty("toString") && source.toString !== target.toString) {\n
                    target.toString = source.toString;\n
                }\n
            }\n
\n
            return target;\n
        };\n
\n
        sinon.extend = extend;\n
        return sinon.extend;\n
    }\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
\n
        function timesInWords(count) {\n
            switch (count) {\n
                case 1:\n
                    return "once";\n
                case 2:\n
                    return "twice";\n
                case 3:\n
                    return "thrice";\n
                default:\n
                    return (count || 0) + " times";\n
            }\n
        }\n
\n
        sinon.timesInWords = timesInWords;\n
        return sinon.timesInWords;\n
    }\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 */\n
/**\n
 * Format functions\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2014 Christian Johansen\n
 */\n
\n
(function (sinon, formatio) {\n
    function makeApi(sinon) {\n
        function typeOf(value) {\n
            if (value === null) {\n
                return "null";\n
            } else if (value === undefined) {\n
                return "undefined";\n
            }\n
            var string = Object.prototype.toString.call(value);\n
            return string.substring(8, string.length - 1).toLowerCase();\n
        };\n
\n
        sinon.typeOf = typeOf;\n
        return sinon.typeOf;\n
    }\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(\n
    (typeof sinon == "object" && sinon || null),\n
    (typeof formatio == "object" && formatio)\n
));\n
\n
/**\n
 * @depend util/core.js\n
 * @depend typeOf.js\n
 */\n
/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n
/*global module, require, sinon*/\n
/**\n
 * Match functions\n
 *\n
 * @author Maximilian Antoni (mail@maxantoni.de)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2012 Maximilian Antoni\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
        function assertType(value, type, name) {\n
            var actual = sinon.typeOf(value);\n
            if (actual !== type) {\n
                throw new TypeError("Expected type of " + name + " to be " +\n
                    type + ", but was " + actual);\n
            }\n
        }\n
\n
        var matcher = {\n
            toString: function () {\n
                return this.message;\n
            }\n
        };\n
\n
        function isMatcher(object) {\n
            return matcher.isPrototypeOf(object);\n
        }\n
\n
        function matchObject(expectation, actual) {\n
            if (actual === null || actual === undefined) {\n
                return false;\n
            }\n
            for (var key in expectation) {\n
                if (expectation.hasOwnProperty(key)) {\n
                    var exp = expectation[key];\n
                    var act = actual[key];\n
                    if (match.isMatcher(exp)) {\n
                        if (!exp.test(act)) {\n
                            return false;\n
                        }\n
                    } else if (sinon.typeOf(exp) === "object") {\n
                        if (!matchObject(exp, act)) {\n
                            return false;\n
                        }\n
                    } else if (!sinon.deepEqual(exp, act)) {\n
                        return false;\n
                    }\n
                }\n
            }\n
            return true;\n
        }\n
\n
        matcher.or = function (m2) {\n
            if (!arguments.length) {\n
                throw new TypeError("Matcher expected");\n
            } else if (!isMatcher(m2)) {\n
                m2 = match(m2);\n
            }\n
            var m1 = this;\n
            var or = sinon.create(matcher);\n
            or.test = function (actual) {\n
                return m1.test(actual) || m2.test(actual);\n
            };\n
            or.message = m1.message + ".or(" + m2.message + ")";\n
            return or;\n
        };\n
\n
        matcher.and = function (m2) {\n
            if (!arguments.length) {\n
                throw new TypeError("Matcher expected");\n
            } else if (!isMatcher(m2)) {\n
                m2 = match(m2);\n
            }\n
            var m1 = this;\n
            var and = sinon.create(matcher);\n
            and.test = function (actual) {\n
                return m1.test(actual) && m2.test(actual);\n
            };\n
            and.message = m1.message + ".and(" + m2.message + ")";\n
            return and;\n
        };\n
\n
        var match = function (expectation, message) {\n
            var m = sinon.create(matcher);\n
            var type = sinon.typeOf(expectation);\n
            switch (type) {\n
            case "object":\n
                if (typeof expectation.test === "function") {\n
                    m.test = function (actual) {\n
                        return expectation.test(actual) === true;\n
                    };\n
                    m.message = "match(" + sinon.functionName(expectation.test) + ")";\n
                    return m;\n
                }\n
                var str = [];\n
                for (var key in expectation) {\n
                    if (expectation.hasOwnProperty(key)) {\n
                        str.push(key + ": " + expectation[key]);\n
                    }\n
                }\n
                m.test = function (actual) {\n
                    return matchObject(expectation, actual);\n
                };\n
                m.message = "match(" + str.join(", ") + ")";\n
                break;\n
            case "number":\n
                m.test = function (actual) {\n
                    return expectation == actual;\n
                };\n
                break;\n
            case "string":\n
                m.test = function (actual) {\n
                    if (typeof actual !== "string") {\n
                        return false;\n
                    }\n
                    return actual.indexOf(expectation) !== -1;\n
                };\n
                m.message = "match(\\"" + expectation + "\\")";\n
                break;\n
            case "regexp":\n
                m.test = function (actual) {\n
                    if (typeof actual !== "string") {\n
                        return false;\n
                    }\n
                    return expectation.test(actual);\n
                };\n
                break;\n
            case "function":\n
                m.test = expectation;\n
                if (message) {\n
                    m.message = message;\n
                } else {\n
                    m.message = "match(" + sinon.functionName(expectation) + ")";\n
                }\n
                break;\n
            default:\n
                m.test = function (actual) {\n
                    return sinon.deepEqual(expectation, actual);\n
                };\n
            }\n
            if (!m.message) {\n
                m.message = "match(" + expectation + ")";\n
            }\n
            return m;\n
        };\n
\n
        match.isMatcher = isMatcher;\n
\n
        match.any = match(function () {\n
            return true;\n
        }, "any");\n
\n
        match.defined = match(function (actual) {\n
            return actual !== null && actual !== undefined;\n
        }, "defined");\n
\n
        match.truthy = match(function (actual) {\n
            return !!actual;\n
        }, "truthy");\n
\n
        match.falsy = match(function (actual) {\n
            return !actual;\n
        }, "falsy");\n
\n
        match.same = function (expectation) {\n
            return match(function (actual) {\n
                return expectation === actual;\n
            }, "same(" + expectation + ")");\n
        };\n
\n
        match.typeOf = function (type) {\n
            assertType(type, "string", "type");\n
            return match(function (actual) {\n
                return sinon.typeOf(actual) === type;\n
            }, "typeOf(\\"" + type + "\\")");\n
        };\n
\n
        match.instanceOf = function (type) {\n
            assertType(type, "function", "type");\n
            return match(function (actual) {\n
                return actual instanceof type;\n
            }, "instanceOf(" + sinon.functionName(type) + ")");\n
        };\n
\n
        function createPropertyMatcher(propertyTest, messagePrefix) {\n
            return function (property, value) {\n
                assertType(property, "string", "property");\n
                var onlyProperty = arguments.length === 1;\n
                var message = messagePrefix + "(\\"" + property + "\\"";\n
                if (!onlyProperty) {\n
                    message += ", " + value;\n
                }\n
                message += ")";\n
                return match(function (actual) {\n
                    if (actual === undefined || actual === null ||\n
                            !propertyTest(actual, property)) {\n
                        return false;\n
                    }\n
                    return onlyProperty || sinon.deepEqual(value, actual[property]);\n
                }, message);\n
            };\n
        }\n
\n
        match.has = createPropertyMatcher(function (actual, property) {\n
            if (typeof actual === "object") {\n
                return property in actual;\n
            }\n
            return actual[property] !== undefined;\n
        }, "has");\n
\n
        match.hasOwn = createPropertyMatcher(function (actual, property) {\n
            return actual.hasOwnProperty(property);\n
        }, "hasOwn");\n
\n
        match.bool = match.typeOf("boolean");\n
        match.number = match.typeOf("number");\n
        match.string = match.typeOf("string");\n
        match.object = match.typeOf("object");\n
        match.func = match.typeOf("function");\n
        match.array = match.typeOf("array");\n
        match.regexp = match.typeOf("regexp");\n
        match.date = match.typeOf("date");\n
\n
        sinon.match = match;\n
        return match;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./typeOf");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 */\n
/**\n
 * Format functions\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2014 Christian Johansen\n
 */\n
\n
(function (sinon, formatio) {\n
    function makeApi(sinon) {\n
        function valueFormatter(value) {\n
            return "" + value;\n
        }\n
\n
        function getFormatioFormatter() {\n
            var formatter = formatio.configure({\n
                    quoteStrings: false,\n
                    limitChildrenCount: 250\n
                });\n
\n
            function format() {\n
                return formatter.ascii.apply(formatter, arguments);\n
            };\n
\n
            return format;\n
        }\n
\n
        function getNodeFormatter(value) {\n
            function format(value) {\n
                return typeof value == "object" && value.toString === Object.prototype.toString ? util.inspect(value) : value;\n
            };\n
\n
            try {\n
                var util = require("util");\n
            } catch (e) {\n
                /* Node, but no util module - would be very old, but better safe than sorry */\n
            }\n
\n
            return util ? format : valueFormatter;\n
        }\n
\n
        var isNode = typeof module !== "undefined" && module.exports && typeof require == "function",\n
            formatter;\n
\n
        if (isNode) {\n
            try {\n
                formatio = require("formatio");\n
            } catch (e) {}\n
        }\n
\n
        if (formatio) {\n
            formatter = getFormatioFormatter()\n
        } else if (isNode) {\n
            formatter = getNodeFormatter();\n
        } else {\n
            formatter = valueFormatter;\n
        }\n
\n
        sinon.format = formatter;\n
        return sinon.format;\n
    }\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(\n
    (typeof sinon == "object" && sinon || null),\n
    (typeof formatio == "object" && formatio)\n
));\n
\n
/**\n
  * @depend util/core.js\n
  * @depend match.js\n
  * @depend format.js\n
  */\n
/**\n
  * Spy calls\n
  *\n
  * @author Christian Johansen (christian@cjohansen.no)\n
  * @author Maximilian Antoni (mail@maxantoni.de)\n
  * @license BSD\n
  *\n
  * Copyright (c) 2010-2013 Christian Johansen\n
  * Copyright (c) 2013 Maximilian Antoni\n
  */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
        function throwYieldError(proxy, text, args) {\n
            var msg = sinon.functionName(proxy) + text;\n
            if (args.length) {\n
                msg += " Received [" + slice.call(args).join(", ") + "]";\n
            }\n
            throw new Error(msg);\n
        }\n
\n
        var slice = Array.prototype.slice;\n
\n
        var callProto = {\n
            calledOn: function calledOn(thisValue) {\n
                if (sinon.match && sinon.match.isMatcher(thisValue)) {\n
                    return thisValue.test(this.thisValue);\n
                }\n
                return this.thisValue === thisValue;\n
            },\n
\n
            calledWith: function calledWith() {\n
                var l = arguments.length;\n
                if (l > this.args.length) {\n
                    return false;\n
                }\n
                for (var i = 0; i < l; i += 1) {\n
                    if (!sinon.deepEqual(arguments[i], this.args[i])) {\n
                        return false;\n
                    }\n
                }\n
\n
                return true;\n
            },\n
\n
            calledWithMatch: function calledWithMatch() {\n
                var l = arguments.length;\n
                if (l > this.args.length) {\n
                    return false;\n
                }\n
                for (var i = 0; i < l; i += 1) {\n
                    var actual = this.args[i];\n
                    var expectation = arguments[i];\n
                    if (!sinon.match || !sinon.match(expectation).test(actual)) {\n
                        return false;\n
                    }\n
                }\n
                return true;\n
            },\n
\n
            calledWithExactly: function calledWithExactly() {\n
                return arguments.length == this.args.length &&\n
                    this.calledWith.apply(this, arguments);\n
            },\n
\n
            notCalledWith: function notCalledWith() {\n
                return !this.calledWith.apply(this, arguments);\n
            },\n
\n
            notCalledWithMatch: function notCalledWithMatch() {\n
                return !this.calledWithMatch.apply(this, arguments);\n
            },\n
\n
            returned: function returned(value) {\n
                return sinon.deepEqual(value, this.returnValue);\n
            },\n
\n
            threw: function threw(error) {\n
                if (typeof error === "undefined" || !this.exception) {\n
                    return !!this.exception;\n
                }\n
\n
                return this.exception === error || this.exception.name === error;\n
            },\n
\n
            calledWithNew: function calledWithNew() {\n
                return this.proxy.prototype && this.thisValue instanceof this.proxy;\n
            },\n
\n
            calledBefore: function (other) {\n
                return this.callId < other.callId;\n
            },\n
\n
            calledAfter: function (other) {\n
                return this.callId > other.callId;\n
            },\n
\n
            callArg: function (pos) {\n
                this.args[pos]();\n
            },\n
\n
            callArgOn: function (pos, thisValue) {\n
                this.args[pos].apply(thisValue);\n
            },\n
\n
            callArgWith: function (pos) {\n
                this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));\n
            },\n
\n
            callArgOnWith: function (pos, thisValue) {\n
                var args = slice.call(arguments, 2);\n
                this.args[pos].apply(thisValue, args);\n
            },\n
\n
            yield: function () {\n
                this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));\n
            },\n
\n
            yieldOn: function (thisValue) {\n
                var args = this.args;\n
                for (var i = 0, l = args.length; i < l; ++i) {\n
                    if (typeof args[i] === "function") {\n
                        args[i].apply(thisValue, slice.call(arguments, 1));\n
                        return;\n
                    }\n
                }\n
                throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);\n
            },\n
\n
            yieldTo: function (prop) {\n
                this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));\n
            },\n
\n
            yieldToOn: function (prop, thisValue) {\n
                var args = this.args;\n
                for (var i = 0, l = args.length; i < l; ++i) {\n
                    if (args[i] && typeof args[i][prop] === "function") {\n
                        args[i][prop].apply(thisValue, slice.call(arguments, 2));\n
                        return;\n
                    }\n
                }\n
                throwYieldError(this.proxy, " cannot yield to \'" + prop +\n
                    "\' since no callback was passed.", args);\n
            },\n
\n
            toString: function () {\n
                var callStr = this.proxy.toString() + "(";\n
                var args = [];\n
\n
                for (var i = 0, l = this.args.length; i < l; ++i) {\n
                    args.push(sinon.format(this.args[i]));\n
                }\n
\n
                callStr = callStr + args.join(", ") + ")";\n
\n
                if (typeof this.returnValue != "undefined") {\n
                    callStr += " => " + sinon.format(this.returnValue);\n
                }\n
\n
                if (this.exception) {\n
                    callStr += " !" + this.exception.name;\n
\n
                    if (this.exception.message) {\n
                        callStr += "(" + this.exception.message + ")";\n
                    }\n
                }\n
\n
                return callStr;\n
            }\n
        };\n
\n
        callProto.invokeCallback = callProto.yield;\n
\n
        function createSpyCall(spy, thisValue, args, returnValue, exception, id) {\n
            if (typeof id !== "number") {\n
                throw new TypeError("Call id is not a number");\n
            }\n
            var proxyCall = sinon.create(callProto);\n
            proxyCall.proxy = spy;\n
            proxyCall.thisValue = thisValue;\n
            proxyCall.args = args;\n
            proxyCall.returnValue = returnValue;\n
            proxyCall.exception = exception;\n
            proxyCall.callId = id;\n
\n
            return proxyCall;\n
        }\n
        createSpyCall.toString = callProto.toString; // used by mocks\n
\n
        sinon.spyCall = createSpyCall;\n
        return createSpyCall;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./match");\n
        require("./format");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
  * @depend times_in_words.js\n
  * @depend util/core.js\n
  * @depend extend.js\n
  * @depend call.js\n
  * @depend format.js\n
  */\n
/**\n
  * Spy functions\n
  *\n
  * @author Christian Johansen (christian@cjohansen.no)\n
  * @license BSD\n
  *\n
  * Copyright (c) 2010-2013 Christian Johansen\n
  */\n
\n
(function (sinon) {\n
\n
    function makeApi(sinon) {\n
        var push = Array.prototype.push;\n
        var slice = Array.prototype.slice;\n
        var callId = 0;\n
\n
        function spy(object, property, types) {\n
            if (!property && typeof object == "function") {\n
                return spy.create(object);\n
            }\n
\n
            if (!object && !property) {\n
                return spy.create(function () { });\n
            }\n
\n
            if (types) {\n
                var methodDesc = sinon.getPropertyDescriptor(object, property);\n
                for (var i = 0; i < types.length; i++) {\n
                    methodDesc[types[i]] = spy.create(methodDesc[types[i]]);\n
                }\n
                return sinon.wrapMethod(object, property, methodDesc);\n
            } else {\n
                var method = object[property];\n
                return sinon.wrapMethod(object, property, spy.create(method));\n
            }\n
        }\n
\n
        function matchingFake(fakes, args, strict) {\n
            if (!fakes) {\n
                return;\n
            }\n
\n
            for (var i = 0, l = fakes.length; i < l; i++) {\n
                if (fakes[i].matches(args, strict)) {\n
                    return fakes[i];\n
                }\n
            }\n
        }\n
\n
        function incrementCallCount() {\n
            this.called = true;\n
            this.callCount += 1;\n
            this.notCalled = false;\n
            this.calledOnce = this.callCount == 1;\n
            this.calledTwice = this.callCount == 2;\n
            this.calledThrice = this.callCount == 3;\n
        }\n
\n
        function createCallProperties() {\n
            this.firstCall = this.getCall(0);\n
            this.secondCall = this.getCall(1);\n
            this.thirdCall = this.getCall(2);\n
            this.lastCall = this.getCall(this.callCount - 1);\n
        }\n
\n
        var vars = "a,b,c,d,e,f,g,h,i,j,k,l";\n
        function createProxy(func, proxyLength) {\n
            // Retain the function length:\n
            var p;\n
            if (proxyLength) {\n
                eval("p = (function proxy(" + vars.substring(0, proxyLength * 2 - 1) +\n
                    ") { return p.invoke(func, this, slice.call(arguments)); });");\n
            } else {\n
                p = function proxy() {\n
                    return p.invoke(func, this, slice.call(arguments));\n
                };\n
            }\n
            p.isSinonProxy = true;\n
            return p;\n
        }\n
\n
        var uuid = 0;\n
\n
        // Public API\n
        var spyApi = {\n
            reset: function () {\n
                if (this.invoking) {\n
                    var err = new Error("Cannot reset Sinon function while invoking it. " +\n
                                        "Move the call to .reset outside of the callback.");\n
                    err.name = "InvalidResetException";\n
                    throw err;\n
                }\n
\n
                this.called = false;\n
                this.notCalled = true;\n
                this.calledOnce = false;\n
                this.calledTwice = false;\n
                this.calledThrice = false;\n
                this.callCount = 0;\n
                this.firstCall = null;\n
                this.secondCall = null;\n
                this.thirdCall = null;\n
                this.lastCall = null;\n
                this.args = [];\n
                this.returnValues = [];\n
                this.thisValues = [];\n
                this.exceptions = [];\n
                this.callIds = [];\n
                if (this.fakes) {\n
                    for (var i = 0; i < this.fakes.length; i++) {\n
                        this.fakes[i].reset();\n
                    }\n
                }\n
\n
                return this;\n
            },\n
\n
            create: function create(func, spyLength) {\n
                var name;\n
\n
                if (typeof func != "function") {\n
                    func = function () { };\n
                } else {\n
                    name = sinon.functionName(func);\n
                }\n
\n
                if (!spyLength) {\n
                    spyLength = func.length;\n
                }\n
\n
                var proxy = createProxy(func, spyLength);\n
\n
                sinon.extend(proxy, spy);\n
                delete proxy.create;\n
                sinon.extend(proxy, func);\n
\n
                proxy.reset();\n
                proxy.prototype = func.prototype;\n
                proxy.displayName = name || "spy";\n
                proxy.toString = sinon.functionToString;\n
                proxy.instantiateFake = sinon.spy.create;\n
                proxy.id = "spy#" + uuid++;\n
\n
                return proxy;\n
            },\n
\n
            invoke: function invoke(func, thisValue, args) {\n
                var matching = matchingFake(this.fakes, args);\n
                var exception, returnValue;\n
\n
                incrementCallCount.call(this);\n
                push.call(this.thisValues, thisValue);\n
                push.call(this.args, args);\n
                push.call(this.callIds, callId++);\n
\n
                // Make call properties available from within the spied function:\n
                createCallProperties.call(this);\n
\n
                try {\n
                    this.invoking = true;\n
\n
                    if (matching) {\n
                        returnValue = matching.invoke(func, thisValue, args);\n
                    } else {\n
                        returnValue = (this.func || func).apply(thisValue, args);\n
                    }\n
\n
                    var thisCall = this.getCall(this.callCount - 1);\n
                    if (thisCall.calledWithNew() && typeof returnValue !== "object") {\n
                        returnValue = thisValue;\n
                    }\n
                } catch (e) {\n
                    exception = e;\n
                } finally {\n
                    delete this.invoking;\n
                }\n
\n
                push.call(this.exceptions, exception);\n
                push.call(this.returnValues, returnValue);\n
\n
                // Make return value and exception available in the calls:\n
                createCallProperties.call(this);\n
\n
                if (exception !== undefined) {\n
                    throw exception;\n
                }\n
\n
                return returnValue;\n
            },\n
\n
            named: function named(name) {\n
                this.displayName = name;\n
                return this;\n
            },\n
\n
            getCall: function getCall(i) {\n
                if (i < 0 || i >= this.callCount) {\n
                    return null;\n
                }\n
\n
                return sinon.spyCall(this, this.thisValues[i], this.args[i],\n
                                        this.returnValues[i], this.exceptions[i],\n
                                        this.callIds[i]);\n
            },\n
\n
            getCalls: function () {\n
                var calls = [];\n
                var i;\n
\n
                for (i = 0; i < this.callCount; i++) {\n
                    calls.push(this.getCall(i));\n
                }\n
\n
                return calls;\n
            },\n
\n
            calledBefore: function calledBefore(spyFn) {\n
                if (!this.called) {\n
                    return false;\n
                }\n
\n
                if (!spyFn.called) {\n
                    return true;\n
                }\n
\n
                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\n
            },\n
\n
            calledAfter: function calledAfter(spyFn) {\n
                if (!this.called || !spyFn.called) {\n
                    return false;\n
                }\n
\n
                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\n
            },\n
\n
            withArgs: function () {\n
                var args = slice.call(arguments);\n
\n
                if (this.fakes) {\n
                    var match = matchingFake(this.fakes, args, true);\n
\n
                    if (match) {\n
                        return match;\n
                    }\n
                } else {\n
                    this.fakes = [];\n
                }\n
\n
                var original = this;\n
                var fake = this.instantiateFake();\n
                fake.matchingAguments = args;\n
                fake.parent = this;\n
                push.call(this.fakes, fake);\n
\n
                fake.withArgs = function () {\n
                    return original.withArgs.apply(original, arguments);\n
                };\n
\n
                for (var i = 0; i < this.args.length; i++) {\n
                    if (fake.matches(this.args[i])) {\n
                        incrementCallCount.call(fake);\n
                        push.call(fake.thisValues, this.thisValues[i]);\n
                        push.call(fake.args, this.args[i]);\n
                        push.call(fake.returnValues, this.returnValues[i]);\n
                        push.call(fake.exceptions, this.exceptions[i]);\n
                        push.call(fake.callIds, this.callIds[i]);\n
                    }\n
                }\n
                createCallProperties.call(fake);\n
\n
                return fake;\n
            },\n
\n
            matches: function (args, strict) {\n
                var margs = this.matchingAguments;\n
\n
                if (margs.length <= args.length &&\n
                    sinon.deepEqual(margs, args.slice(0, margs.length))) {\n
                    return !strict || margs.length == args.length;\n
                }\n
            },\n
\n
            printf: function (format) {\n
                var spy = this;\n
                var args = slice.call(arguments, 1);\n
                var formatter;\n
\n
                return (format || "").replace(/%(.)/g, function (match, specifyer) {\n
                    formatter = spyApi.formatters[specifyer];\n
\n
                    if (typeof formatter == "function") {\n
                        return formatter.call(null, spy, args);\n
                    } else if (!isNaN(parseInt(specifyer, 10))) {\n
                        return sinon.format(args[specifyer - 1]);\n
                    }\n
\n
                    return "%" + specifyer;\n
                });\n
            }\n
        };\n
\n
        function delegateToCalls(method, matchAny, actual, notCalled) {\n
            spyApi[method] = function () {\n
                if (!this.called) {\n
                    if (notCalled) {\n
                        return notCalled.apply(this, arguments);\n
                    }\n
                    return false;\n
                }\n
\n
                var currentCall;\n
                var matches = 0;\n
\n
                for (var i = 0, l = this.callCount; i < l; i += 1) {\n
                    currentCall = this.getCall(i);\n
\n
                    if (currentCall[actual || method].apply(currentCall, arguments)) {\n
                        matches += 1;\n
\n
                        if (matchAny) {\n
                            return true;\n
                        }\n
                    }\n
                }\n
\n
                return matches === this.callCount;\n
            };\n
        }\n
\n
        delegateToCalls("calledOn", true);\n
        delegateToCalls("alwaysCalledOn", false, "calledOn");\n
        delegateToCalls("calledWith", true);\n
        delegateToCalls("calledWithMatch", true);\n
        delegateToCalls("alwaysCalledWith", false, "calledWith");\n
        delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");\n
        delegateToCalls("calledWithExactly", true);\n
        delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");\n
        delegateToCalls("neverCalledWith", false, "notCalledWith", function () {\n
            return true;\n
        });\n
        delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch", function () {\n
            return true;\n
        });\n
        delegateToCalls("threw", true);\n
        delegateToCalls("alwaysThrew", false, "threw");\n
        delegateToCalls("returned", true);\n
        delegateToCalls("alwaysReturned", false, "returned");\n
        delegateToCalls("calledWithNew", true);\n
        delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");\n
        delegateToCalls("callArg", false, "callArgWith", function () {\n
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");\n
        });\n
        spyApi.callArgWith = spyApi.callArg;\n
        delegateToCalls("callArgOn", false, "callArgOnWith", function () {\n
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");\n
        });\n
        spyApi.callArgOnWith = spyApi.callArgOn;\n
        delegateToCalls("yield", false, "yield", function () {\n
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");\n
        });\n
        // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.\n
        spyApi.invokeCallback = spyApi.yield;\n
        delegateToCalls("yieldOn", false, "yieldOn", function () {\n
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");\n
        });\n
        delegateToCalls("yieldTo", false, "yieldTo", function (property) {\n
            throw new Error(this.toString() + " cannot yield to \'" + property +\n
                "\' since it was not yet invoked.");\n
        });\n
        delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {\n
            throw new Error(this.toString() + " cannot yield to \'" + property +\n
                "\' since it was not yet invoked.");\n
        });\n
\n
        spyApi.formatters = {\n
            c: function (spy) {\n
                return sinon.timesInWords(spy.callCount);\n
            },\n
\n
            n: function (spy) {\n
                return spy.toString();\n
            },\n
\n
            C: function (spy) {\n
                var calls = [];\n
\n
                for (var i = 0, l = spy.callCount; i < l; ++i) {\n
                    var stringifiedCall = "    " + spy.getCall(i).toString();\n
                    if (/\\n/.test(calls[i - 1])) {\n
                        stringifiedCall = "\\n" + stringifiedCall;\n
                    }\n
                    push.call(calls, stringifiedCall);\n
                }\n
\n
                return calls.length > 0 ? "\\n" + calls.join("\\n") : "";\n
            },\n
\n
            t: function (spy) {\n
                var objects = [];\n
\n
                for (var i = 0, l = spy.callCount; i < l; ++i) {\n
                    push.call(objects, sinon.format(spy.thisValues[i]));\n
                }\n
\n
                return objects.join(", ");\n
            },\n
\n
            "*": function (spy, args) {\n
                var formatted = [];\n
\n
                for (var i = 0, l = args.length; i < l; ++i) {\n
                    push.call(formatted, sinon.format(args[i]));\n
                }\n
\n
                return formatted.join(", ");\n
            }\n
        };\n
\n
        sinon.extend(spy, spyApi);\n
\n
        spy.spyCall = sinon.spyCall;\n
        sinon.spy = spy;\n
\n
        return spy;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./call");\n
        require("./extend");\n
        require("./times_in_words");\n
        require("./format");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 * @depend extend.js\n
 */\n
/**\n
 * Stub behavior\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @author Tim Fischbach (mail@timfischbach.de)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    var slice = Array.prototype.slice;\n
    var join = Array.prototype.join;\n
    var useLeftMostCallback = -1;\n
    var useRightMostCallback = -2;\n
\n
    var nextTick = (function () {\n
        if (typeof process === "object" && typeof process.nextTick === "function") {\n
            return process.nextTick;\n
        } else if (typeof setImmediate === "function") {\n
            return setImmediate;\n
        } else {\n
            return function (callback) {\n
                setTimeout(callback, 0);\n
            };\n
        }\n
    })();\n
\n
    function throwsException(error, message) {\n
        if (typeof error == "string") {\n
            this.exception = new Error(message || "");\n
            this.exception.name = error;\n
        } else if (!error) {\n
            this.exception = new Error("Error");\n
        } else {\n
            this.exception = error;\n
        }\n
\n
        return this;\n
    }\n
\n
    function getCallback(behavior, args) {\n
        var callArgAt = behavior.callArgAt;\n
\n
        if (callArgAt >= 0) {\n
            return args[callArgAt];\n
        }\n
\n
        var argumentList;\n
\n
        if (callArgAt === useLeftMostCallback) {\n
            argumentList = args;\n
        }\n
\n
        if (callArgAt === useRightMostCallback) {\n
            argumentList = slice.call(args).reverse();\n
        }\n
\n
        var callArgProp = behavior.callArgProp;\n
\n
        for (var i = 0, l = argumentList.length; i < l; ++i) {\n
            if (!callArgProp && typeof argumentList[i] == "function") {\n
                return argumentList[i];\n
            }\n
\n
            if (callArgProp && argumentList[i] &&\n
                typeof argumentList[i][callArgProp] == "function") {\n
                return argumentList[i][callArgProp];\n
            }\n
        }\n
\n
        return null;\n
    }\n
\n
    function makeApi(sinon) {\n
        function getCallbackError(behavior, func, args) {\n
            if (behavior.callArgAt < 0) {\n
                var msg;\n
\n
                if (behavior.callArgProp) {\n
                    msg = sinon.functionName(behavior.stub) +\n
                        " expected to yield to \'" + behavior.callArgProp +\n
                        "\', but no object with such a property was passed.";\n
                } else {\n
                    msg = sinon.functionName(behavior.stub) +\n
                        " expected to yield, but no callback was passed.";\n
                }\n
\n
                if (args.length > 0) {\n
                    msg += " Received [" + join.call(args, ", ") + "]";\n
                }\n
\n
                return msg;\n
            }\n
\n
            return "argument at index " + behavior.callArgAt + " is not a function: " + func;\n
        }\n
\n
        function callCallback(behavior, args) {\n
            if (typeof behavior.callArgAt == "number") {\n
                var func = getCallback(behavior, args);\n
\n
                if (typeof func != "function") {\n
                    throw new TypeError(getCallbackError(behavior, func, args));\n
                }\n
\n
                if (behavior.callbackAsync) {\n
                    nextTick(function () {\n
                        func.apply(behavior.callbackContext, behavior.callbackArguments);\n
                    });\n
                } else {\n
                    func.apply(behavior.callbackContext, behavior.callbackArguments);\n
                }\n
            }\n
        }\n
\n
        var proto = {\n
            create: function create(stub) {\n
                var behavior = sinon.extend({}, sinon.behavior);\n
                delete behavior.create;\n
                behavior.stub = stub;\n
\n
                return behavior;\n
            },\n
\n
            isPresent: function isPresent() {\n
                return (typeof this.callArgAt == "number" ||\n
                        this.exception ||\n
                        typeof this.returnArgAt == "number" ||\n
                        this.returnThis ||\n
                        this.returnValueDefined);\n
            },\n
\n
            invoke: function invoke(context, args) {\n
                callCallback(this, args);\n
\n
                if (this.exception) {\n
                    throw this.exception;\n
                } else if (typeof this.returnArgAt == "number") {\n
                    return args[this.returnArgAt];\n
                } else if (this.returnThis) {\n
                    return context;\n
                }\n
\n
                return this.returnValue;\n
            },\n
\n
            onCall: function onCall(index) {\n
                return this.stub.onCall(index);\n
            },\n
\n
            onFirstCall: function onFirstCall() {\n
                return this.stub.onFirstCall();\n
            },\n
\n
            onSecondCall: function onSecondCall() {\n
                return this.stub.onSecondCall();\n
            },\n
\n
            onThirdCall: function onThirdCall() {\n
                return this.stub.onThirdCall();\n
            },\n
\n
            withArgs: function withArgs(/* arguments */) {\n
                throw new Error("Defining a stub by invoking \\"stub.onCall(...).withArgs(...)\\" is not supported. " +\n
                                "Use \\"stub.withArgs(...).onCall(...)\\" to define sequential behavior for calls with certain arguments.");\n
            },\n
\n
            callsArg: function callsArg(pos) {\n
                if (typeof pos != "number") {\n
                    throw new TypeError("argument index is not number");\n
                }\n
\n
                this.callArgAt = pos;\n
                this.callbackArguments = [];\n
                this.callbackContext = undefined;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            callsArgOn: function callsArgOn(pos, context) {\n
                if (typeof pos != "number") {\n
                    throw new TypeError("argument index is not number");\n
                }\n
                if (typeof context != "object") {\n
                    throw new TypeError("argument context is not an object");\n
                }\n
\n
                this.callArgAt = pos;\n
                this.callbackArguments = [];\n
                this.callbackContext = context;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            callsArgWith: function callsArgWith(pos) {\n
                if (typeof pos != "number") {\n
                    throw new TypeError("argument index is not number");\n
                }\n
\n
                this.callArgAt = pos;\n
                this.callbackArguments = slice.call(arguments, 1);\n
                this.callbackContext = undefined;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            callsArgOnWith: function callsArgWith(pos, context) {\n
                if (typeof pos != "number") {\n
                    throw new TypeError("argument index is not number");\n
                }\n
                if (typeof context != "object") {\n
                    throw new TypeError("argument context is not an object");\n
                }\n
\n
                this.callArgAt = pos;\n
                this.callbackArguments = slice.call(arguments, 2);\n
                this.callbackContext = context;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            yields: function () {\n
                this.callArgAt = useLeftMostCallback;\n
                this.callbackArguments = slice.call(arguments, 0);\n
                this.callbackContext = undefined;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            yieldsRight: function () {\n
                this.callArgAt = useRightMostCallback;\n
                this.callbackArguments = slice.call(arguments, 0);\n
                this.callbackContext = undefined;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            yieldsOn: function (context) {\n
                if (typeof context != "object") {\n
                    throw new TypeError("argument context is not an object");\n
                }\n
\n
                this.callArgAt = useLeftMostCallback;\n
                this.callbackArguments = slice.call(arguments, 1);\n
                this.callbackContext = context;\n
                this.callArgProp = undefined;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            yieldsTo: function (prop) {\n
                this.callArgAt = useLeftMostCallback;\n
                this.callbackArguments = slice.call(arguments, 1);\n
                this.callbackContext = undefined;\n
                this.callArgProp = prop;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            yieldsToOn: function (prop, context) {\n
                if (typeof context != "object") {\n
                    throw new TypeError("argument context is not an object");\n
                }\n
\n
                this.callArgAt = useLeftMostCallback;\n
                this.callbackArguments = slice.call(arguments, 2);\n
                this.callbackContext = context;\n
                this.callArgProp = prop;\n
                this.callbackAsync = false;\n
\n
                return this;\n
            },\n
\n
            throws: throwsException,\n
            throwsException: throwsException,\n
\n
            returns: function returns(value) {\n
                this.returnValue = value;\n
                this.returnValueDefined = true;\n
\n
                return this;\n
            },\n
\n
            returnsArg: function returnsArg(pos) {\n
                if (typeof pos != "number") {\n
                    throw new TypeError("argument index is not number");\n
                }\n
\n
                this.returnArgAt = pos;\n
\n
                return this;\n
            },\n
\n
            returnsThis: function returnsThis() {\n
                this.returnThis = true;\n
\n
                return this;\n
            }\n
        };\n
\n
        // create asynchronous versions of callsArg* and yields* methods\n
        for (var method in proto) {\n
            // need to avoid creating anotherasync versions of the newly added async methods\n
            if (proto.hasOwnProperty(method) &&\n
                method.match(/^(callsArg|yields)/) &&\n
                !method.match(/Async/)) {\n
                proto[method + "Async"] = (function (syncFnName) {\n
                    return function () {\n
                        var result = this[syncFnName].apply(this, arguments);\n
                        this.callbackAsync = true;\n
                        return result;\n
                    };\n
                })(method);\n
            }\n
        }\n
\n
        sinon.behavior = proto;\n
        return proto;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./extend");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 * @depend extend.js\n
 * @depend spy.js\n
 * @depend behavior.js\n
 */\n
/**\n
 * Stub functions\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
        function stub(object, property, func) {\n
            if (!!func && typeof func != "function" && typeof func != "object") {\n
                throw new TypeError("Custom stub should be a function or a property descriptor");\n
            }\n
\n
            var wrapper;\n
\n
            if (func) {\n
                if (typeof func == "function") {\n
                    wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;\n
                } else {\n
                    wrapper = func;\n
                    if (sinon.spy && sinon.spy.create) {\n
                        var types = sinon.objectKeys(wrapper);\n
                        for (var i = 0; i < types.length; i++) {\n
                            wrapper[types[i]] = sinon.spy.create(wrapper[types[i]]);\n
                        }\n
                    }\n
                }\n
            } else {\n
                var stubLength = 0;\n
                if (typeof object == "object" && typeof object[property] == "function") {\n
                    stubLength = object[property].length;\n
                }\n
                wrapper = stub.create(stubLength);\n
            }\n
\n
            if (!object && typeof property === "undefined") {\n
                return sinon.stub.create();\n
            }\n
\n
            if (typeof property === "undefined" && typeof object == "object") {\n
                for (var prop in object) {\n
                    if (typeof sinon.getPropertyDescriptor(object, prop).value === "function") {\n
                        stub(object, prop);\n
                    }\n
                }\n
\n
                return object;\n
            }\n
\n
            return sinon.wrapMethod(object, property, wrapper);\n
        }\n
\n
        function getDefaultBehavior(stub) {\n
            return stub.defaultBehavior || getParentBehaviour(stub) || sinon.behavior.create(stub);\n
        }\n
\n
        function getParentBehaviour(stub) {\n
            return (stub.parent && getCurrentBehavior(stub.parent));\n
        }\n
\n
        function getCurrentBehavior(stub) {\n
            var behavior = stub.behaviors[stub.callCount - 1];\n
            return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stub);\n
        }\n
\n
        var uuid = 0;\n
\n
        var proto = {\n
            create: function create(stubLength) {\n
                var functionStub = function () {\n
                    return getCurrentBehavior(functionStub).invoke(this, arguments);\n
                };\n
\n
                functionStub.id = "stub#" + uuid++;\n
                var orig = functionStub;\n
                functionStub = sinon.spy.create(functionStub, stubLength);\n
                functionStub.func = orig;\n
\n
                sinon.extend(functionStub, stub);\n
                functionStub.instantiateFake = sinon.stub.create;\n
                functionStub.displayName = "stub";\n
                functionStub.toString = sinon.functionToString;\n
\n
                functionStub.defaultBehavior = null;\n
                functionStub.behaviors = [];\n
\n
                return functionStub;\n
            },\n
\n
            resetBehavior: function () {\n
                var i;\n
\n
                this.defaultBehavior = null;\n
                this.behaviors = [];\n
\n
                delete this.returnValue;\n
                delete this.returnArgAt;\n
                this.returnThis = false;\n
\n
                if (this.fakes) {\n
                    for (i = 0; i < this.fakes.length; i++) {\n
                        this.fakes[i].resetBehavior();\n
                    }\n
                }\n
            },\n
\n
            onCall: function onCall(index) {\n
                if (!this.behaviors[index]) {\n
                    this.behaviors[index] = sinon.behavior.create(this);\n
                }\n
\n
                return this.behaviors[index];\n
            },\n
\n
            onFirstCall: function onFirstCall() {\n
                return this.onCall(0);\n
            },\n
\n
            onSecondCall: function onSecondCall() {\n
                return this.onCall(1);\n
            },\n
\n
            onThirdCall: function onThirdCall() {\n
                return this.onCall(2);\n
            }\n
        };\n
\n
        for (var method in sinon.behavior) {\n
            if (sinon.behavior.hasOwnProperty(method) &&\n
                !proto.hasOwnProperty(method) &&\n
                method != "create" &&\n
                method != "withArgs" &&\n
                method != "invoke") {\n
                proto[method] = (function (behaviorMethod) {\n
                    return function () {\n
                        this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);\n
                        this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);\n
                        return this;\n
                    };\n
                }(method));\n
            }\n
        }\n
\n
        sinon.extend(stub, proto);\n
        sinon.stub = stub;\n
\n
        return stub;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./behavior");\n
        require("./spy");\n
        require("./extend");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend times_in_words.js\n
 * @depend util/core.js\n
 * @depend call.js\n
 * @depend extend.js\n
 * @depend match.js\n
 * @depend spy.js\n
 * @depend stub.js\n
 * @depend format.js\n
 */\n
/**\n
 * Mock functions.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
        var push = [].push;\n
        var match = sinon.match;\n
\n
        function mock(object) {\n
            // if (typeof console !== undefined && console.warn) {\n
            //     console.warn("mock will be removed from Sinon.JS v2.0");\n
            // }\n
\n
            if (!object) {\n
                return sinon.expectation.create("Anonymous mock");\n
            }\n
\n
            return mock.create(object);\n
        }\n
\n
        function each(collection, callback) {\n
            if (!collection) {\n
                return;\n
            }\n
\n
            for (var i = 0, l = collection.length; i < l; i += 1) {\n
                callback(collection[i]);\n
            }\n
        }\n
\n
        sinon.extend(mock, {\n
            create: function create(object) {\n
                if (!object) {\n
                    throw new TypeError("object is null");\n
                }\n
\n
                var mockObject = sinon.extend({}, mock);\n
                mockObject.object = object;\n
                delete mockObject.create;\n
\n
                return mockObject;\n
            },\n
\n
            expects: function expects(method) {\n
                if (!method) {\n
                    throw new TypeError("method is falsy");\n
                }\n
\n
                if (!this.expectations) {\n
                    this.expectations = {};\n
                    this.proxies = [];\n
                }\n
\n
                if (!this.expectations[method]) {\n
                    this.expectations[method] = [];\n
                    var mockObject = this;\n
\n
                    sinon.wrapMethod(this.object, method, function () {\n
                        return mockObject.invokeMethod(method, this, arguments);\n
                    });\n
\n
                    push.call(this.proxies, method);\n
                }\n
\n
                var expectation = sinon.expectation.create(method);\n
                push.call(this.expectations[method], expectation);\n
\n
                return expectation;\n
            },\n
\n
            restore: function restore() {\n
                var object = this.object;\n
\n
                each(this.proxies, function (proxy) {\n
                    if (typeof object[proxy].restore == "function") {\n
                        object[proxy].restore();\n
                    }\n
                });\n
            },\n
\n
            verify: function verify() {\n
                var expectations = this.expectations || {};\n
                var messages = [], met = [];\n
\n
                each(this.proxies, function (proxy) {\n
                    each(expectations[proxy], function (expectation) {\n
                        if (!expectation.met()) {\n
                            push.call(messages, expectation.toString());\n
                        } else {\n
                            push.call(met, expectation.toString());\n
                        }\n
                    });\n
                });\n
\n
                this.restore();\n
\n
                if (messages.length > 0) {\n
                    sinon.expectation.fail(messages.concat(met).join("\\n"));\n
                } else if (met.length > 0) {\n
                    sinon.expectation.pass(messages.concat(met).join("\\n"));\n
                }\n
\n
                return true;\n
            },\n
\n
            invokeMethod: function invokeMethod(method, thisValue, args) {\n
                var expectations = this.expectations && this.expectations[method];\n
                var length = expectations && expectations.length || 0, i;\n
\n
                for (i = 0; i < length; i += 1) {\n
                    if (!expectations[i].met() &&\n
                        expectations[i].allowsCall(thisValue, args)) {\n
                        return expectations[i].apply(thisValue, args);\n
                    }\n
                }\n
\n
                var messages = [], available, exhausted = 0;\n
\n
                for (i = 0; i < length; i += 1) {\n
                    if (expectations[i].allowsCall(thisValue, args)) {\n
                        available = available || expectations[i];\n
                    } else {\n
                        exhausted += 1;\n
                    }\n
                    push.call(messages, "    " + expectations[i].toString());\n
                }\n
\n
                if (exhausted === 0) {\n
                    return available.apply(thisValue, args);\n
                }\n
\n
                messages.unshift("Unexpected call: " + sinon.spyCall.toString.call({\n
                    proxy: method,\n
                    args: args\n
                }));\n
\n
                sinon.expectation.fail(messages.join("\\n"));\n
            }\n
        });\n
\n
        var times = sinon.timesInWords;\n
        var slice = Array.prototype.slice;\n
\n
        function callCountInWords(callCount) {\n
            if (callCount == 0) {\n
                return "never called";\n
            } else {\n
                return "called " + times(callCount);\n
            }\n
        }\n
\n
        function expectedCallCountInWords(expectation) {\n
            var min = expectation.minCalls;\n
            var max = expectation.maxCalls;\n
\n
            if (typeof min == "number" && typeof max == "number") {\n
                var str = times(min);\n
\n
                if (min != max) {\n
                    str = "at least " + str + " and at most " + times(max);\n
                }\n
\n
                return str;\n
            }\n
\n
            if (typeof min == "number") {\n
                return "at least " + times(min);\n
            }\n
\n
            return "at most " + times(max);\n
        }\n
\n
        function receivedMinCalls(expectation) {\n
            var hasMinLimit = typeof expectation.minCalls == "number";\n
            return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n
        }\n
\n
        function receivedMaxCalls(expectation) {\n
            if (typeof expectation.maxCalls != "number") {\n
                return false;\n
            }\n
\n
            return expectation.callCount == expectation.maxCalls;\n
        }\n
\n
        function verifyMatcher(possibleMatcher, arg) {\n
            if (match && match.isMatcher(possibleMatcher)) {\n
                return possibleMatcher.test(arg);\n
            } else {\n
                return true;\n
            }\n
        }\n
\n
        sinon.expectation = {\n
            minCalls: 1,\n
            maxCalls: 1,\n
\n
            create: function create(methodName) {\n
                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);\n
                delete expectation.create;\n
                expectation.method = methodName;\n
\n
                return expectation;\n
            },\n
\n
            invoke: function invoke(func, thisValue, args) {\n
                this.verifyCallAllowed(thisValue, args);\n
\n
                return sinon.spy.invoke.apply(this, arguments);\n
            },\n
\n
            atLeast: function atLeast(num) {\n
                if (typeof num != "number") {\n
                    throw new TypeError("\'" + num + "\' is not number");\n
                }\n
\n
                if (!this.limitsSet) {\n
                    this.maxCalls = null;\n
                    this.limitsSet = true;\n
                }\n
\n
                this.minCalls = num;\n
\n
                return this;\n
            },\n
\n
            atMost: function atMost(num) {\n
                if (typeof num != "number") {\n
                    throw new TypeError("\'" + num + "\' is not number");\n
                }\n
\n
                if (!this.limitsSet) {\n
                    this.minCalls = null;\n
                    this.limitsSet = true;\n
                }\n
\n
                this.maxCalls = num;\n
\n
                return this;\n
            },\n
\n
            never: function never() {\n
                return this.exactly(0);\n
            },\n
\n
            once: function once() {\n
                return this.exactly(1);\n
            },\n
\n
            twice: function twice() {\n
                return this.exactly(2);\n
            },\n
\n
            thrice: function thrice() {\n
                return this.exactly(3);\n
            },\n
\n
            exactly: function exactly(num) {\n
                if (typeof num != "number") {\n
                    throw new TypeError("\'" + num + "\' is not a number");\n
                }\n
\n
                this.atLeast(num);\n
                return this.atMost(num);\n
            },\n
\n
            met: function met() {\n
                return !this.failed && receivedMinCalls(this);\n
            },\n
\n
            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n
                if (receivedMaxCalls(this)) {\n
                    this.failed = true;\n
                    sinon.expectation.fail(this.method + " already called " + times(this.maxCalls));\n
                }\n
\n
                if ("expectedThis" in this && this.expectedThis !== thisValue) {\n
                    sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " +\n
                        this.expectedThis);\n
                }\n
\n
                if (!("expectedArguments" in this)) {\n
                    return;\n
                }\n
\n
                if (!args) {\n
                    sinon.expectation.fail(this.method + " received no arguments, expected " +\n
                        sinon.format(this.expectedArguments));\n
                }\n
\n
                if (args.length < this.expectedArguments.length) {\n
                    sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) +\n
                        "), expected " + sinon.format(this.expectedArguments));\n
                }\n
\n
                if (this.expectsExactArgCount &&\n
                    args.length != this.expectedArguments.length) {\n
                    sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) +\n
                        "), expected " + sinon.format(this.expectedArguments));\n
                }\n
\n
                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n
\n
                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {\n
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +\n
                            ", didn\'t match " + this.expectedArguments.toString());\n
                    }\n
\n
                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +\n
                            ", expected " + sinon.format(this.expectedArguments));\n
                    }\n
                }\n
            },\n
\n
            allowsCall: function allowsCall(thisValue, args) {\n
                if (this.met() && receivedMaxCalls(this)) {\n
                    return false;\n
                }\n
\n
                if ("expectedThis" in this && this.expectedThis !== thisValue) {\n
                    return false;\n
                }\n
\n
                if (!("expectedArguments" in this)) {\n
                    return true;\n
                }\n
\n
                args = args || [];\n
\n
                if (args.length < this.expectedArguments.length) {\n
                    return false;\n
                }\n
\n
                if (this.expectsExactArgCount &&\n
                    args.length != this.expectedArguments.length) {\n
                    return false;\n
                }\n
\n
                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n
                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {\n
                        return false;\n
                    }\n
\n
                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n
                        return false;\n
                    }\n
                }\n
\n
                return true;\n
            },\n
\n
            withArgs: function withArgs() {\n
                this.expectedArguments = slice.call(arguments);\n
                return this;\n
            },\n
\n
            withExactArgs: function withExactArgs() {\n
                this.withArgs.apply(this, arguments);\n
                this.expectsExactArgCount = true;\n
                return this;\n
            },\n
\n
            on: function on(thisValue) {\n
                this.expectedThis = thisValue;\n
                return this;\n
            },\n
\n
            toString: function () {\n
                var args = (this.expectedArguments || []).slice();\n
\n
                if (!this.expectsExactArgCount) {\n
                    push.call(args, "[...]");\n
                }\n
\n
                var callStr = sinon.spyCall.toString.call({\n
                    proxy: this.method || "anonymous mock expectation",\n
                    args: args\n
                });\n
\n
                var message = callStr.replace(", [...", "[, ...") + " " +\n
                    expectedCallCountInWords(this);\n
\n
                if (this.met()) {\n
                    return "Expectation met: " + message;\n
                }\n
\n
                return "Expected " + message + " (" +\n
                    callCountInWords(this.callCount) + ")";\n
            },\n
\n
            verify: function verify() {\n
                if (!this.met()) {\n
                    sinon.expectation.fail(this.toString());\n
                } else {\n
                    sinon.expectation.pass(this.toString());\n
                }\n
\n
                return true;\n
            },\n
\n
            pass: function pass(message) {\n
                sinon.assert.pass(message);\n
            },\n
\n
            fail: function fail(message) {\n
                var exception = new Error(message);\n
                exception.name = "ExpectationError";\n
\n
                throw exception;\n
            }\n
        };\n
\n
        sinon.mock = mock;\n
        return mock;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./times_in_words");\n
        require("./call");\n
        require("./extend");\n
        require("./match");\n
        require("./spy");\n
        require("./stub");\n
        require("./format");\n
\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 * @depend spy.js\n
 * @depend stub.js\n
 * @depend mock.js\n
 */\n
/**\n
 * Collections of stubs, spies and mocks.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    var push = [].push;\n
    var hasOwnProperty = Object.prototype.hasOwnProperty;\n
\n
    function getFakes(fakeCollection) {\n
        if (!fakeCollection.fakes) {\n
            fakeCollection.fakes = [];\n
        }\n
\n
        return fakeCollection.fakes;\n
    }\n
\n
    function each(fakeCollection, method) {\n
        var fakes = getFakes(fakeCollection);\n
\n
        for (var i = 0, l = fakes.length; i < l; i += 1) {\n
            if (typeof fakes[i][method] == "function") {\n
                fakes[i][method]();\n
            }\n
        }\n
    }\n
\n
    function compact(fakeCollection) {\n
        var fakes = getFakes(fakeCollection);\n
        var i = 0;\n
        while (i < fakes.length) {\n
            fakes.splice(i, 1);\n
        }\n
    }\n
\n
    function makeApi(sinon) {\n
        var collection = {\n
            verify: function resolve() {\n
                each(this, "verify");\n
            },\n
\n
            restore: function restore() {\n
                each(this, "restore");\n
                compact(this);\n
            },\n
\n
            reset: function restore() {\n
                each(this, "reset");\n
            },\n
\n
            verifyAndRestore: function verifyAndRestore() {\n
                var exception;\n
\n
                try {\n
                    this.verify();\n
                } catch (e) {\n
                    exception = e;\n
                }\n
\n
                this.restore();\n
\n
                if (exception) {\n
                    throw exception;\n
                }\n
            },\n
\n
            add: function add(fake) {\n
                push.call(getFakes(this), fake);\n
                return fake;\n
            },\n
\n
            spy: function spy() {\n
                return this.add(sinon.spy.apply(sinon, arguments));\n
            },\n
\n
            stub: function stub(object, property, value) {\n
                if (property) {\n
                    var original = object[property];\n
\n
                    if (typeof original != "function") {\n
                        if (!hasOwnProperty.call(object, property)) {\n
                            throw new TypeError("Cannot stub non-existent own property " + property);\n
                        }\n
\n
                        object[property] = value;\n
\n
                        return this.add({\n
                            restore: function () {\n
                                object[property] = original;\n
                            }\n
                        });\n
                    }\n
                }\n
                if (!property && !!object && typeof object == "object") {\n
                    var stubbedObj = sinon.stub.apply(sinon, arguments);\n
\n
                    for (var prop in stubbedObj) {\n
                        if (typeof stubbedObj[prop] === "function") {\n
                            this.add(stubbedObj[prop]);\n
                        }\n
                    }\n
\n
                    return stubbedObj;\n
                }\n
\n
                return this.add(sinon.stub.apply(sinon, arguments));\n
            },\n
\n
            mock: function mock() {\n
                return this.add(sinon.mock.apply(sinon, arguments));\n
            },\n
\n
            inject: function inject(obj) {\n
                var col = this;\n
\n
                obj.spy = function () {\n
                    return col.spy.apply(col, arguments);\n
                };\n
\n
                obj.stub = function () {\n
                    return col.stub.apply(col, arguments);\n
                };\n
\n
                obj.mock = function () {\n
                    return col.mock.apply(col, arguments);\n
                };\n
\n
                return obj;\n
            }\n
        };\n
\n
        sinon.collection = collection;\n
        return collection;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./mock");\n
        require("./spy");\n
        require("./stub");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/*global lolex */\n
\n
/**\n
 * Fake timer API\n
 * setTimeout\n
 * setInterval\n
 * clearTimeout\n
 * clearInterval\n
 * tick\n
 * reset\n
 * Date\n
 *\n
 * Inspired by jsUnitMockTimeOut from JsUnit\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
if (typeof sinon == "undefined") {\n
    var sinon = {};\n
}\n
\n
(function (global) {\n
    function makeApi(sinon, lol) {\n
        var llx = typeof lolex !== "undefined" ? lolex : lol;\n
\n
        sinon.useFakeTimers = function () {\n
            var now, methods = Array.prototype.slice.call(arguments);\n
\n
            if (typeof methods[0] === "string") {\n
                now = 0;\n
            } else {\n
                now = methods.shift();\n
            }\n
\n
            var clock = llx.install(now || 0, methods);\n
            clock.restore = clock.uninstall;\n
            return clock;\n
        };\n
\n
        sinon.clock = {\n
            create: function (now) {\n
                return llx.createClock(now);\n
            }\n
        };\n
\n
        sinon.timers = {\n
            setTimeout: setTimeout,\n
            clearTimeout: clearTimeout,\n
            setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),\n
            clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate : undefined),\n
            setInterval: setInterval,\n
            clearInterval: clearInterval,\n
            Date: Date\n
        };\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, epxorts, module, lolex) {\n
        var sinon = require("./core");\n
        makeApi(sinon, lolex);\n
        module.exports = sinon;\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module, require("lolex"));\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof global != "undefined" && typeof global !== "function" ? global : this));\n
\n
/**\n
 * Minimal Event interface implementation\n
 *\n
 * Original implementation by Sven Fuchs: https://gist.github.com/995028\n
 * Modifications and tests by Christian Johansen.\n
 *\n
 * @author Sven Fuchs (svenfuchs@artweb-design.de)\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n
 */\n
\n
if (typeof sinon == "undefined") {\n
    this.sinon = {};\n
}\n
\n
(function () {\n
    var push = [].push;\n
\n
    function makeApi(sinon) {\n
        sinon.Event = function Event(type, bubbles, cancelable, target) {\n
            this.initEvent(type, bubbles, cancelable, target);\n
        };\n
\n
        sinon.Event.prototype = {\n
            initEvent: function (type, bubbles, cancelable, target) {\n
                this.type = type;\n
                this.bubbles = bubbles;\n
                this.cancelable = cancelable;\n
                this.target = target;\n
            },\n
\n
            stopPropagation: function () {},\n
\n
            preventDefault: function () {\n
                this.defaultPrevented = true;\n
            }\n
        };\n
\n
        sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {\n
            this.initEvent(type, false, false, target);\n
            this.loaded = progressEventRaw.loaded || null;\n
            this.total = progressEventRaw.total || null;\n
            this.lengthComputable = !!progressEventRaw.total;\n
        };\n
\n
        sinon.ProgressEvent.prototype = new sinon.Event();\n
\n
        sinon.ProgressEvent.prototype.constructor =  sinon.ProgressEvent;\n
\n
        sinon.CustomEvent = function CustomEvent(type, customData, target) {\n
            this.initEvent(type, false, false, target);\n
            this.detail = customData.detail || null;\n
        };\n
\n
        sinon.CustomEvent.prototype = new sinon.Event();\n
\n
        sinon.CustomEvent.prototype.constructor =  sinon.CustomEvent;\n
\n
        sinon.EventTarget = {\n
            addEventListener: function addEventListener(event, listener) {\n
                this.eventListeners = this.eventListeners || {};\n
                this.eventListeners[event] = this.eventListeners[event] || [];\n
                push.call(this.eventListeners[event], listener);\n
            },\n
\n
            removeEventListener: function removeEventListener(event, listener) {\n
                var listeners = this.eventListeners && this.eventListeners[event] || [];\n
\n
                for (var i = 0, l = listeners.length; i < l; ++i) {\n
                    if (listeners[i] == listener) {\n
                        return listeners.splice(i, 1);\n
                    }\n
                }\n
            },\n
\n
            dispatchEvent: function dispatchEvent(event) {\n
                var type = event.type;\n
                var listeners = this.eventListeners && this.eventListeners[type] || [];\n
\n
                for (var i = 0; i < listeners.length; i++) {\n
                    if (typeof listeners[i] == "function") {\n
                        listeners[i].call(this, event);\n
                    } else {\n
                        listeners[i].handleEvent(event);\n
                    }\n
                }\n
\n
                return !!event.defaultPrevented;\n
            }\n
        };\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require) {\n
        var sinon = require("./core");\n
        makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require);\n
    } else {\n
        makeApi(sinon);\n
    }\n
}());\n
\n
/**\n
 * @depend util/core.js\n
 */\n
/**\n
 * Logs errors\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2014 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    // cache a reference to setTimeout, so that our reference won\'t be stubbed out\n
    // when using fake timers and errors will still get logged\n
    // https://github.com/cjohansen/Sinon.JS/issues/381\n
    var realSetTimeout = setTimeout;\n
\n
    function makeApi(sinon) {\n
\n
        function log() {}\n
\n
        function logError(label, err) {\n
            var msg = label + " threw exception: ";\n
\n
            sinon.log(msg + "[" + err.name + "] " + err.message);\n
\n
            if (err.stack) {\n
                sinon.log(err.stack);\n
            }\n
\n
            logError.setTimeout(function () {\n
                err.message = msg + err.message;\n
                throw err;\n
            }, 0);\n
        };\n
\n
        // wrap realSetTimeout with something we can stub in tests\n
        logError.setTimeout = function (func, timeout) {\n
            realSetTimeout(func, timeout);\n
        }\n
\n
        var exports = {};\n
        exports.log = sinon.log = log;\n
        exports.logError = sinon.logError = logError;\n
\n
        return exports;\n
    }\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend core.js\n
 * @depend ../extend.js\n
 * @depend event.js\n
 * @depend ../log_error.js\n
 */\n
/**\n
 * Fake XDomainRequest object\n
 */\n
\n
if (typeof sinon == "undefined") {\n
    this.sinon = {};\n
}\n
\n
// wrapper for global\n
(function (global) {\n
    var xdr = { XDomainRequest: global.XDomainRequest };\n
    xdr.GlobalXDomainRequest = global.XDomainRequest;\n
    xdr.supportsXDR = typeof xdr.GlobalXDomainRequest != "undefined";\n
    xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest :  false;\n
\n
    function makeApi(sinon) {\n
        sinon.xdr = xdr;\n
\n
        function FakeXDomainRequest() {\n
            this.readyState = FakeXDomainRequest.UNSENT;\n
            this.requestBody = null;\n
            this.requestHeaders = {};\n
            this.status = 0;\n
            this.timeout = null;\n
\n
            if (typeof FakeXDomainRequest.onCreate == "function") {\n
                FakeXDomainRequest.onCreate(this);\n
            }\n
        }\n
\n
        function verifyState(xdr) {\n
            if (xdr.readyState !== FakeXDomainRequest.OPENED) {\n
                throw new Error("INVALID_STATE_ERR");\n
            }\n
\n
            if (xdr.sendFlag) {\n
                throw new Error("INVALID_STATE_ERR");\n
            }\n
        }\n
\n
        function verifyRequestSent(xdr) {\n
            if (xdr.readyState == FakeXDomainRequest.UNSENT) {\n
                throw new Error("Request not sent");\n
            }\n
            if (xdr.readyState == FakeXDomainRequest.DONE) {\n
                throw new Error("Request done");\n
            }\n
        }\n
\n
        function verifyResponseBodyType(body) {\n
            if (typeof body != "string") {\n
                var error = new Error("Attempted to respond to fake XDomainRequest with " +\n
                                    body + ", which is not a string.");\n
                error.name = "InvalidBodyException";\n
                throw error;\n
            }\n
        }\n
\n
        sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {\n
            open: function open(method, url) {\n
                this.method = method;\n
                this.url = url;\n
\n
                this.responseText = null;\n
                this.sendFlag = false;\n
\n
                this.readyStateChange(FakeXDomainRequest.OPENED);\n
            },\n
\n
            readyStateChange: function readyStateChange(state) {\n
                this.readyState = state;\n
                var eventName = "";\n
                switch (this.readyState) {\n
                case FakeXDomainRequest.UNSENT:\n
                    break;\n
                case FakeXDomainRequest.OPENED:\n
                    break;\n
                case FakeXDomainRequest.LOADING:\n
                    if (this.sendFlag) {\n
                        //raise the progress event\n
                        eventName = "onprogress";\n
                    }\n
                    break;\n
                case FakeXDomainRequest.DONE:\n
                    if (this.isTimeout) {\n
                        eventName = "ontimeout"\n
                    } else if (this.errorFlag || (this.status < 200 || this.status > 299)) {\n
                        eventName = "onerror";\n
                    } else {\n
                        eventName = "onload"\n
                    }\n
                    break;\n
                }\n
\n
                // raising event (if defined)\n
                if (eventName) {\n
                    if (typeof this[eventName] == "function") {\n
                        try {\n
                            this[eventName]();\n
                        } catch (e) {\n
                            sinon.logError("Fake XHR " + eventName + " handler", e);\n
                        }\n
                    }\n
                }\n
            },\n
\n
            send: function send(data) {\n
                verifyState(this);\n
\n
                if (!/^(get|head)$/i.test(this.method)) {\n
                    this.requestBody = data;\n
                }\n
                this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";\n
\n
                this.errorFlag = false;\n
                this.sendFlag = true;\n
                this.readyStateChange(FakeXDomainRequest.OPENED);\n
\n
                if (typeof this.onSend == "function") {\n
                    this.onSend(this);\n
                }\n
            },\n
\n
            abort: function abort() {\n
                this.aborted = true;\n
                this.responseText = null;\n
                this.errorFlag = true;\n
\n
                if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {\n
                    this.readyStateChange(sinon.FakeXDomainRequest.DONE);\n
                    this.sendFlag = false;\n
                }\n
            },\n
\n
            setResponseBody: function setResponseBody(body) {\n
                verifyRequestSent(this);\n
                verifyResponseBodyType(body);\n
\n
                var chunkSize = this.chunkSize || 10;\n
                var index = 0;\n
                this.responseText = "";\n
\n
                do {\n
                    this.readyStateChange(FakeXDomainRequest.LOADING);\n
                    this.responseText += body.substring(index, index + chunkSize);\n
                    index += chunkSize;\n
                } while (index < body.length);\n
\n
                this.readyStateChange(FakeXDomainRequest.DONE);\n
            },\n
\n
            respond: function respond(status, contentType, body) {\n
                // content-type ignored, since XDomainRequest does not carry this\n
                // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease\n
                // test integration across browsers\n
                this.status = typeof status == "number" ? status : 200;\n
                this.setResponseBody(body || "");\n
            },\n
\n
            simulatetimeout: function simulatetimeout() {\n
                this.status = 0;\n
                this.isTimeout = true;\n
                // Access to this should actually throw an error\n
                this.responseText = undefined;\n
                this.readyStateChange(FakeXDomainRequest.DONE);\n
            }\n
        });\n
\n
        sinon.extend(FakeXDomainRequest, {\n
            UNSENT: 0,\n
            OPENED: 1,\n
            LOADING: 3,\n
            DONE: 4\n
        });\n
\n
        sinon.useFakeXDomainRequest = function useFakeXDomainRequest() {\n
            sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {\n
                if (xdr.supportsXDR) {\n
                    global.XDomainRequest = xdr.GlobalXDomainRequest;\n
                }\n
\n
                delete sinon.FakeXDomainRequest.restore;\n
\n
                if (keepOnCreate !== true) {\n
                    delete sinon.FakeXDomainRequest.onCreate;\n
                }\n
            };\n
            if (xdr.supportsXDR) {\n
                global.XDomainRequest = sinon.FakeXDomainRequest;\n
            }\n
            return sinon.FakeXDomainRequest;\n
        };\n
\n
        sinon.FakeXDomainRequest = FakeXDomainRequest;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./core");\n
        require("../extend");\n
        require("./event");\n
        require("../log_error");\n
        makeApi(sinon);\n
        module.exports = sinon;\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else {\n
        makeApi(sinon);\n
    }\n
})(typeof global !== "undefined" ? global : self);\n
\n
/**\n
 * @depend core.js\n
 * @depend ../extend.js\n
 * @depend event.js\n
 * @depend ../log_error.js\n
 */\n
/**\n
 * Fake XMLHttpRequest object\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (global) {\n
\n
    var supportsProgress = typeof ProgressEvent !== "undefined";\n
    var supportsCustomEvent = typeof CustomEvent !== "undefined";\n
    var supportsFormData = typeof FormData !== "undefined";\n
    var sinonXhr = { XMLHttpRequest: global.XMLHttpRequest };\n
    sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\n
    sinonXhr.GlobalActiveXObject = global.ActiveXObject;\n
    sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject != "undefined";\n
    sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest != "undefined";\n
    sinonXhr.workingXHR = sinonXhr.supportsXHR ? sinonXhr.GlobalXMLHttpRequest : sinonXhr.supportsActiveX\n
                                     ? function () {\n
                                        return new sinonXhr.GlobalActiveXObject("MSXML2.XMLHTTP.3.0")\n
                                    } : false;\n
    sinonXhr.supportsCORS = sinonXhr.supportsXHR && "withCredentials" in (new sinonXhr.GlobalXMLHttpRequest());\n
\n
    /*jsl:ignore*/\n
    var unsafeHeaders = {\n
        "Accept-Charset": true,\n
        "Accept-Encoding": true,\n
        Connection: true,\n
        "Content-Length": true,\n
        Cookie: true,\n
        Cookie2: true,\n
        "Content-Transfer-Encoding": true,\n
        Date: true,\n
        Expect: true,\n
        Host: true,\n
        "Keep-Alive": true,\n
        Referer: true,\n
        TE: true,\n
        Trailer: true,\n
        "Transfer-Encoding": true,\n
        Upgrade: true,\n
        "User-Agent": true,\n
        Via: true\n
    };\n
    /*jsl:end*/\n
\n
    // Note that for FakeXMLHttpRequest to work pre ES5\n
    // we lose some of the alignment with the spec.\n
    // To ensure as close a match as possible,\n
    // set responseType before calling open, send or respond;\n
    function FakeXMLHttpRequest() {\n
        this.readyState = FakeXMLHttpRequest.UNSENT;\n
        this.requestHeaders = {};\n
        this.requestBody = null;\n
        this.status = 0;\n
        this.statusText = "";\n
        this.upload = new UploadProgress();\n
        this.responseType = "";\n
        this.response = "";\n
        if (sinonXhr.supportsCORS) {\n
            this.withCredentials = false;\n
        }\n
\n
        var xhr = this;\n
        var events = ["loadstart", "load", "abort", "loadend"];\n
\n
        function addEventListener(eventName) {\n
            xhr.addEventListener(eventName, function (event) {\n
                var listener = xhr["on" + eventName];\n
\n
                if (listener && typeof listener == "function") {\n
                    listener.call(this, event);\n
                }\n
            });\n
        }\n
\n
        for (var i = events.length - 1; i >= 0; i--) {\n
            addEventListener(events[i]);\n
        }\n
\n
        if (typeof FakeXMLHttpRequest.onCreate == "function") {\n
            FakeXMLHttpRequest.onCreate(this);\n
        }\n
    }\n
\n
    // An upload object is created for each\n
    // FakeXMLHttpRequest and allows upload\n
    // events to be simulated using uploadProgress\n
    // and uploadError.\n
    function UploadProgress() {\n
        this.eventListeners = {\n
            progress: [],\n
            load: [],\n
            abort: [],\n
            error: []\n
        }\n
    }\n
\n
    UploadProgress.prototype.addEventListener = function addEventListener(event, listener) {\n
        this.eventListeners[event].push(listener);\n
    };\n
\n
    UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) {\n
        var listeners = this.eventListeners[event] || [];\n
\n
        for (var i = 0, l = listeners.length; i < l; ++i) {\n
            if (listeners[i] == listener) {\n
                return listeners.splice(i, 1);\n
            }\n
        }\n
    };\n
\n
    UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) {\n
        var listeners = this.eventListeners[event.type] || [];\n
\n
        for (var i = 0, listener; (listener = listeners[i]) != null; i++) {\n
            listener(event);\n
        }\n
    };\n
\n
    function verifyState(xhr) {\n
        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n
            throw new Error("INVALID_STATE_ERR");\n
        }\n
\n
        if (xhr.sendFlag) {\n
            throw new Error("INVALID_STATE_ERR");\n
        }\n
    }\n
\n
    function getHeader(headers, header) {\n
        header = header.toLowerCase();\n
\n
        for (var h in headers) {\n
            if (h.toLowerCase() == header) {\n
                return h;\n
            }\n
        }\n
\n
        return null;\n
    }\n
\n
    // filtering to enable a white-list version of Sinon FakeXhr,\n
    // where whitelisted requests are passed through to real XHR\n
    function each(collection, callback) {\n
        if (!collection) {\n
            return;\n
        }\n
\n
        for (var i = 0, l = collection.length; i < l; i += 1) {\n
            callback(collection[i]);\n
        }\n
    }\n
    function some(collection, callback) {\n
        for (var index = 0; index < collection.length; index++) {\n
            if (callback(collection[index]) === true) {\n
                return true;\n
            }\n
        }\n
        return false;\n
    }\n
    // largest arity in XHR is 5 - XHR#open\n
    var apply = function (obj, method, args) {\n
        switch (args.length) {\n
        case 0: return obj[method]();\n
        case 1: return obj[method](args[0]);\n
        case 2: return obj[method](args[0], args[1]);\n
        case 3: return obj[method](args[0], args[1], args[2]);\n
        case 4: return obj[method](args[0], args[1], args[2], args[3]);\n
        case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]);\n
        }\n
    };\n
\n
    FakeXMLHttpRequest.filters = [];\n
    FakeXMLHttpRequest.addFilter = function addFilter(fn) {\n
        this.filters.push(fn)\n
    };\n
    var IE6Re = /MSIE 6/;\n
    FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {\n
        var xhr = new sinonXhr.workingXHR();\n
        each([\n
            "open",\n
            "setRequestHeader",\n
            "send",\n
            "abort",\n
            "getResponseHeader",\n
            "getAllResponseHeaders",\n
            "addEventListener",\n
            "overrideMimeType",\n
            "removeEventListener"\n
        ], function (method) {\n
            fakeXhr[method] = function () {\n
                return apply(xhr, method, arguments);\n
            };\n
        });\n
\n
        var copyAttrs = function (args) {\n
            each(args, function (attr) {\n
                try {\n
                    fakeXhr[attr] = xhr[attr]\n
                } catch (e) {\n
                    if (!IE6Re.test(navigator.userAgent)) {\n
                        throw e;\n
                    }\n
                }\n
            });\n
        };\n
\n
        var stateChange = function stateChange() {\n
            fakeXhr.readyState = xhr.readyState;\n
            if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\n
                copyAttrs(["status", "statusText"]);\n
            }\n
            if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {\n
                copyAttrs(["responseText", "response"]);\n
            }\n
            if (xhr.readyState === FakeXMLHttpRequest.DONE) {\n
                copyAttrs(["responseXML"]);\n
            }\n
            if (fakeXhr.onreadystatechange) {\n
                fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });\n
            }\n
        };\n
\n
        if (xhr.addEventListener) {\n
            for (var event in fakeXhr.eventListeners) {\n
                if (fakeXhr.eventListeners.hasOwnProperty(event)) {\n
                    each(fakeXhr.eventListeners[event], function (handler) {\n
                        xhr.addEventListener(event, handler);\n
                    });\n
                }\n
            }\n
            xhr.addEventListener("readystatechange", stateChange);\n
        } else {\n
            xhr.onreadystatechange = stateChange;\n
        }\n
        apply(xhr, "open", xhrArgs);\n
    };\n
    FakeXMLHttpRequest.useFilters = false;\n
\n
    function verifyRequestOpened(xhr) {\n
        if (xhr.readyState != FakeXMLHttpRequest.OPENED) {\n
            throw new Error("INVALID_STATE_ERR - " + xhr.readyState);\n
        }\n
    }\n
\n
    function verifyRequestSent(xhr) {\n
        if (xhr.readyState == FakeXMLHttpRequest.DONE) {\n
            throw new Error("Request done");\n
        }\n
    }\n
\n
    function verifyHeadersReceived(xhr) {\n
        if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\n
            throw new Error("No headers received");\n
        }\n
    }\n
\n
    function verifyResponseBodyType(body) {\n
        if (typeof body != "string") {\n
            var error = new Error("Attempted to respond to fake XMLHttpRequest with " +\n
                                 body + ", which is not a string.");\n
            error.name = "InvalidBodyException";\n
            throw error;\n
        }\n
    }\n
\n
    FakeXMLHttpRequest.parseXML = function parseXML(text) {\n
        var xmlDoc;\n
\n
        if (typeof DOMParser != "undefined") {\n
            var parser = new DOMParser();\n
            xmlDoc = parser.parseFromString(text, "text/xml");\n
        } else {\n
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");\n
            xmlDoc.async = "false";\n
            xmlDoc.loadXML(text);\n
        }\n
\n
        return xmlDoc;\n
    };\n
\n
    FakeXMLHttpRequest.statusCodes = {\n
        100: "Continue",\n
        101: "Switching Protocols",\n
        200: "OK",\n
        201: "Created",\n
        202: "Accepted",\n
        203: "Non-Authoritative Information",\n
        204: "No Content",\n
        205: "Reset Content",\n
        206: "Partial Content",\n
        207: "Multi-Status",\n
        300: "Multiple Choice",\n
        301: "Moved Permanently",\n
        302: "Found",\n
        303: "See Other",\n
        304: "Not Modified",\n
        305: "Use Proxy",\n
        307: "Temporary Redirect",\n
        400: "Bad Request",\n
        401: "Unauthorized",\n
        402: "Payment Required",\n
        403: "Forbidden",\n
        404: "Not Found",\n
        405: "Method Not Allowed",\n
        406: "Not Acceptable",\n
        407: "Proxy Authentication Required",\n
        408: "Request Timeout",\n
        409: "Conflict",\n
        410: "Gone",\n
        411: "Length Required",\n
        412: "Precondition Failed",\n
        413: "Request Entity Too Large",\n
        414: "Request-URI Too Long",\n
        415: "Unsupported Media Type",\n
        416: "Requested Range Not Satisfiable",\n
        417: "Expectation Failed",\n
        422: "Unprocessable Entity",\n
        500: "Internal Server Error",\n
        501: "Not Implemented",\n
        502: "Bad Gateway",\n
        503: "Service Unavailable",\n
        504: "Gateway Timeout",\n
        505: "HTTP Version Not Supported"\n
    };\n
\n
    function makeApi(sinon) {\n
        sinon.xhr = sinonXhr;\n
\n
        sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {\n
            async: true,\n
\n
            open: function open(method, url, async, username, password) {\n
                this.method = method;\n
                this.url = url;\n
                this.async = typeof async == "boolean" ? async : true;\n
                this.username = username;\n
                this.password = password;\n
                this.responseText = null;\n
                this.response = this.responseType === "json" ? null : "";\n
                this.responseXML = null;\n
                this.requestHeaders = {};\n
                this.sendFlag = false;\n
\n
                if (FakeXMLHttpRequest.useFilters === true) {\n
                    var xhrArgs = arguments;\n
                    var defake = some(FakeXMLHttpRequest.filters, function (filter) {\n
                        return filter.apply(this, xhrArgs)\n
                    });\n
                    if (defake) {\n
                        return FakeXMLHttpRequest.defake(this, arguments);\n
                    }\n
                }\n
                this.readyStateChange(FakeXMLHttpRequest.OPENED);\n
            },\n
\n
            readyStateChange: function readyStateChange(state) {\n
                this.readyState = state;\n
\n
                if (typeof this.onreadystatechange == "function") {\n
                    try {\n
                        this.onreadystatechange();\n
                    } catch (e) {\n
                        sinon.logError("Fake XHR onreadystatechange handler", e);\n
                    }\n
                }\n
\n
                switch (this.readyState) {\n
                    case FakeXMLHttpRequest.DONE:\n
                        if (supportsProgress) {\n
                            this.upload.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));\n
                            this.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));\n
                        }\n
                        this.upload.dispatchEvent(new sinon.Event("load", false, false, this));\n
                        this.dispatchEvent(new sinon.Event("load", false, false, this));\n
                        this.dispatchEvent(new sinon.Event("loadend", false, false, this));\n
                        break;\n
                }\n
\n
                this.dispatchEvent(new sinon.Event("readystatechange"));\n
            },\n
\n
            setRequestHeader: function setRequestHeader(header, value) {\n
                verifyState(this);\n
\n
                if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n
                    throw new Error("Refused to set unsafe header \\"" + header + "\\"");\n
                }\n
\n
                if (this.requestHeaders[header]) {\n
                    this.requestHeaders[header] += "," + value;\n
                } else {\n
                    this.requestHeaders[header] = value;\n
                }\n
            },\n
\n
            // Helps testing\n
            setResponseHeaders: function setResponseHeaders(headers) {\n
                verifyRequestOpened(this);\n
                this.responseHeaders = {};\n
\n
                for (var header in headers) {\n
                    if (headers.hasOwnProperty(header)) {\n
                        this.responseHeaders[header] = headers[header];\n
                    }\n
                }\n
\n
                if (this.async) {\n
                    this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n
                } else {\n
                    this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n
                }\n
            },\n
\n
            // Currently treats ALL data as a DOMString (i.e. no Document)\n
            send: function send(data) {\n
                verifyState(this);\n
\n
                if (!/^(get|head)$/i.test(this.method)) {\n
                    var contentType = getHeader(this.requestHeaders, "Content-Type");\n
                    if (this.requestHeaders[contentType]) {\n
                        var value = this.requestHeaders[contentType].split(";");\n
                        this.requestHeaders[contentType] = value[0] + ";charset=utf-8";\n
                    } else if (supportsFormData && !(data instanceof FormData)) {\n
                        this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";\n
                    }\n
\n
                    this.requestBody = data;\n
                }\n
\n
                this.errorFlag = false;\n
                this.sendFlag = this.async;\n
                this.response = this.responseType === "json" ? null : "";\n
                this.readyStateChange(FakeXMLHttpRequest.OPENED);\n
\n
                if (typeof this.onSend == "function") {\n
                    this.onSend(this);\n
                }\n
\n
                this.dispatchEvent(new sinon.Event("loadstart", false, false, this));\n
            },\n
\n
            abort: function abort() {\n
                this.aborted = true;\n
                this.responseText = null;\n
                this.response = this.responseType === "json" ? null : "";\n
                this.errorFlag = true;\n
                this.requestHeaders = {};\n
                this.responseHeaders = {};\n
\n
                if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n
                    this.readyStateChange(FakeXMLHttpRequest.DONE);\n
                    this.sendFlag = false;\n
                }\n
\n
                this.readyState = FakeXMLHttpRequest.UNSENT;\n
\n
                this.dispatchEvent(new sinon.Event("abort", false, false, this));\n
\n
                this.upload.dispatchEvent(new sinon.Event("abort", false, false, this));\n
\n
                if (typeof this.onerror === "function") {\n
                    this.onerror();\n
                }\n
            },\n
\n
            getResponseHeader: function getResponseHeader(header) {\n
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n
                    return null;\n
                }\n
\n
                if (/^Set-Cookie2?$/i.test(header)) {\n
                    return null;\n
                }\n
\n
                header = getHeader(this.responseHeaders, header);\n
\n
                return this.responseHeaders[header] || null;\n
            },\n
\n
            getAllResponseHeaders: function getAllResponseHeaders() {\n
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n
                    return "";\n
                }\n
\n
                var headers = "";\n
\n
                for (var header in this.responseHeaders) {\n
                    if (this.responseHeaders.hasOwnProperty(header) &&\n
                        !/^Set-Cookie2?$/i.test(header)) {\n
                        headers += header + ": " + this.responseHeaders[header] + "\\r\\n";\n
                    }\n
                }\n
\n
                return headers;\n
            },\n
\n
            setResponseBody: function setResponseBody(body) {\n
                verifyRequestSent(this);\n
                verifyHeadersReceived(this);\n
                verifyResponseBodyType(body);\n
\n
                var chunkSize = this.chunkSize || 10;\n
                var index = 0;\n
                this.responseText = "";\n
\n
                do {\n
                    if (this.async) {\n
                        this.readyStateChange(FakeXMLHttpRequest.LOADING);\n
                    }\n
\n
                    this.responseText += body.substring(index, index + chunkSize);\n
                    index += chunkSize;\n
                } while (index < body.length);\n
\n
                var type = this.getResponseHeader("Content-Type");\n
\n
                if (this.responseText &&\n
                    (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\n
                    try {\n
                        this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\n
                    } catch (e) {\n
                        // Unable to parse XML - no biggie\n
                    }\n
                }\n
\n
                this.response = this.responseType === "json" ? JSON.parse(this.responseText) : this.responseText;\n
                this.readyStateChange(FakeXMLHttpRequest.DONE);\n
            },\n
\n
            respond: function respond(status, headers, body) {\n
                this.status = typeof status == "number" ? status : 200;\n
                this.statusText = FakeXMLHttpRequest.statusCodes[this.status];\n
                this.setResponseHeaders(headers || {});\n
                this.setResponseBody(body || "");\n
            },\n
\n
            uploadProgress: function uploadProgress(progressEventRaw) {\n
                if (supportsProgress) {\n
                    this.upload.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));\n
                }\n
            },\n
\n
            downloadProgress: function downloadProgress(progressEventRaw) {\n
                if (supportsProgress) {\n
                    this.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));\n
                }\n
            },\n
\n
            uploadError: function uploadError(error) {\n
                if (supportsCustomEvent) {\n
                    this.upload.dispatchEvent(new sinon.CustomEvent("error", {detail: error}));\n
                }\n
            }\n
        });\n
\n
        sinon.extend(FakeXMLHttpRequest, {\n
            UNSENT: 0,\n
            OPENED: 1,\n
            HEADERS_RECEIVED: 2,\n
            LOADING: 3,\n
            DONE: 4\n
        });\n
\n
        sinon.useFakeXMLHttpRequest = function () {\n
            FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\n
                if (sinonXhr.supportsXHR) {\n
                    global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;\n
                }\n
\n
                if (sinonXhr.supportsActiveX) {\n
                    global.ActiveXObject = sinonXhr.GlobalActiveXObject;\n
                }\n
\n
                delete FakeXMLHttpRequest.restore;\n
\n
                if (keepOnCreate !== true) {\n
                    delete FakeXMLHttpRequest.onCreate;\n
                }\n
            };\n
            if (sinonXhr.supportsXHR) {\n
                global.XMLHttpRequest = FakeXMLHttpRequest;\n
            }\n
\n
            if (sinonXhr.supportsActiveX) {\n
                global.ActiveXObject = function ActiveXObject(objId) {\n
                    if (objId == "Microsoft.XMLHTTP" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\n
\n
                        return new FakeXMLHttpRequest();\n
                    }\n
\n
                    return new sinonXhr.GlobalActiveXObject(objId);\n
                };\n
            }\n
\n
            return FakeXMLHttpRequest;\n
        };\n
\n
        sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./core");\n
        require("../extend");\n
        require("./event");\n
        require("../log_error");\n
        makeApi(sinon);\n
        module.exports = sinon;\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (typeof sinon === "undefined") {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
\n
})(typeof global !== "undefined" ? global : self);\n
\n
/**\n
 * @depend fake_xdomain_request.js\n
 * @depend fake_xml_http_request.js\n
 * @depend ../format.js\n
 * @depend ../log_error.js\n
 */\n
/**\n
 * The Sinon "server" mimics a web server that receives requests from\n
 * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,\n
 * both synchronously and asynchronously. To respond synchronuously, canned\n
 * answers have to be provided upfront.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
if (typeof sinon == "undefined") {\n
    var sinon = {};\n
}\n
\n
(function () {\n
    var push = [].push;\n
    function F() {}\n
\n
    function create(proto) {\n
        F.prototype = proto;\n
        return new F();\n
    }\n
\n
    function responseArray(handler) {\n
        var response = handler;\n
\n
        if (Object.prototype.toString.call(handler) != "[object Array]") {\n
            response = [200, {}, handler];\n
        }\n
\n
        if (typeof response[2] != "string") {\n
            throw new TypeError("Fake server response body should be string, but was " +\n
                                typeof response[2]);\n
        }\n
\n
        return response;\n
    }\n
\n
    var wloc = typeof window !== "undefined" ? window.location : {};\n
    var rCurrLoc = new RegExp("^" + wloc.protocol + "//" + wloc.host);\n
\n
    function matchOne(response, reqMethod, reqUrl) {\n
        var rmeth = response.method;\n
        var matchMethod = !rmeth || rmeth.toLowerCase() == reqMethod.toLowerCase();\n
        var url = response.url;\n
        var matchUrl = !url || url == reqUrl || (typeof url.test == "function" && url.test(reqUrl));\n
\n
        return matchMethod && matchUrl;\n
    }\n
\n
    function match(response, request) {\n
        var requestUrl = request.url;\n
\n
        if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n
            requestUrl = requestUrl.replace(rCurrLoc, "");\n
        }\n
\n
        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n
            if (typeof response.response == "function") {\n
                var ru = response.url;\n
                var args = [request].concat(ru && typeof ru.exec == "function" ? ru.exec(requestUrl).slice(1) : []);\n
                return response.response.apply(response, args);\n
            }\n
\n
            return true;\n
        }\n
\n
        return false;\n
    }\n
\n
    function makeApi(sinon) {\n
        sinon.fakeServer = {\n
            create: function () {\n
                var server = create(this);\n
                if (!sinon.xhr.supportsCORS) {\n
                    this.xhr = sinon.useFakeXDomainRequest();\n
                } else {\n
                    this.xhr = sinon.useFakeXMLHttpRequest();\n
                }\n
                server.requests = [];\n
\n
                this.xhr.onCreate = function (xhrObj) {\n
                    server.addRequest(xhrObj);\n
                };\n
\n
                return server;\n
            },\n
\n
            addRequest: function addRequest(xhrObj) {\n
                var server = this;\n
                push.call(this.requests, xhrObj);\n
\n
                xhrObj.onSend = function () {\n
                    server.handleRequest(this);\n
\n
                    if (server.respondImmediately) {\n
                        server.respond();\n
                    } else if (server.autoRespond && !server.responding) {\n
                        setTimeout(function () {\n
                            server.responding = false;\n
                            server.respond();\n
                        }, server.autoRespondAfter || 10);\n
\n
                        server.responding = true;\n
                    }\n
                };\n
            },\n
\n
            getHTTPMethod: function getHTTPMethod(request) {\n
                if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n
                    var matches = (request.requestBody || "").match(/_method=([^\\b;]+)/);\n
                    return !!matches ? matches[1] : request.method;\n
                }\n
\n
                return request.method;\n
            },\n
\n
            handleRequest: function handleRequest(xhr) {\n
                if (xhr.async) {\n
                    if (!this.queue) {\n
                        this.queue = [];\n
                    }\n
\n
                    push.call(this.queue, xhr);\n
                } else {\n
                    this.processRequest(xhr);\n
                }\n
            },\n
\n
            log: function log(response, request) {\n
                var str;\n
\n
                str =  "Request:\\n"  + sinon.format(request)  + "\\n\\n";\n
                str += "Response:\\n" + sinon.format(response) + "\\n\\n";\n
\n
                sinon.log(str);\n
            },\n
\n
            respondWith: function respondWith(method, url, body) {\n
                if (arguments.length == 1 && typeof method != "function") {\n
                    this.response = responseArray(method);\n
                    return;\n
                }\n
\n
                if (!this.responses) {\n
                    this.responses = [];\n
                }\n
\n
                if (arguments.length == 1) {\n
                    body = method;\n
                    url = method = null;\n
                }\n
\n
                if (arguments.length == 2) {\n
                    body = url;\n
                    url = method;\n
                    method = null;\n
                }\n
\n
                push.call(this.responses, {\n
                    method: method,\n
                    url: url,\n
                    response: typeof body == "function" ? body : responseArray(body)\n
                });\n
            },\n
\n
            respond: function respond() {\n
                if (arguments.length > 0) {\n
                    this.respondWith.apply(this, arguments);\n
                }\n
\n
                var queue = this.queue || [];\n
                var requests = queue.splice(0, queue.length);\n
                var request;\n
\n
                while (request = requests.shift()) {\n
                    this.processRequest(request);\n
                }\n
            },\n
\n
            processRequest: function processRequest(request) {\n
                try {\n
                    if (request.aborted) {\n
                        return;\n
                    }\n
\n
                    var response = this.response || [404, {}, ""];\n
\n
                    if (this.responses) {\n
                        for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n
                            if (match.call(this, this.responses[i], request)) {\n
                                response = this.responses[i].response;\n
                                break;\n
                            }\n
                        }\n
                    }\n
\n
                    if (request.readyState != 4) {\n
                        this.log(response, request);\n
\n
                        request.respond(response[0], response[1], response[2]);\n
                    }\n
                } catch (e) {\n
                    sinon.logError("Fake server request processing", e);\n
                }\n
            },\n
\n
            restore: function restore() {\n
                return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n
            }\n
        };\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./core");\n
        require("./fake_xdomain_request");\n
        require("./fake_xml_http_request");\n
        require("../format");\n
        makeApi(sinon);\n
        module.exports = sinon;\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else {\n
        makeApi(sinon);\n
    }\n
}());\n
\n
/**\n
 * @depend fake_server.js\n
 * @depend fake_timers.js\n
 */\n
/**\n
 * Add-on for sinon.fakeServer that automatically handles a fake timer along with\n
 * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery\n
 * 1.3.x, which does not use xhr object\'s onreadystatehandler at all - instead,\n
 * it polls the object for completion with setInterval. Dispite the direct\n
 * motivation, there is nothing jQuery-specific in this file, so it can be used\n
 * in any environment where the ajax implementation depends on setInterval or\n
 * setTimeout.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function () {\n
    function makeApi(sinon) {\n
        function Server() {}\n
        Server.prototype = sinon.fakeServer;\n
\n
        sinon.fakeServerWithClock = new Server();\n
\n
        sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {\n
            if (xhr.async) {\n
                if (typeof setTimeout.clock == "object") {\n
                    this.clock = setTimeout.clock;\n
                } else {\n
                    this.clock = sinon.useFakeTimers();\n
                    this.resetClock = true;\n
                }\n
\n
                if (!this.longestTimeout) {\n
                    var clockSetTimeout = this.clock.setTimeout;\n
                    var clockSetInterval = this.clock.setInterval;\n
                    var server = this;\n
\n
                    this.clock.setTimeout = function (fn, timeout) {\n
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n
\n
                        return clockSetTimeout.apply(this, arguments);\n
                    };\n
\n
                    this.clock.setInterval = function (fn, timeout) {\n
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n
\n
                        return clockSetInterval.apply(this, arguments);\n
                    };\n
                }\n
            }\n
\n
            return sinon.fakeServer.addRequest.call(this, xhr);\n
        };\n
\n
        sinon.fakeServerWithClock.respond = function respond() {\n
            var returnVal = sinon.fakeServer.respond.apply(this, arguments);\n
\n
            if (this.clock) {\n
                this.clock.tick(this.longestTimeout || 0);\n
                this.longestTimeout = 0;\n
\n
                if (this.resetClock) {\n
                    this.clock.restore();\n
                    this.resetClock = false;\n
                }\n
            }\n
\n
            return returnVal;\n
        };\n
\n
        sinon.fakeServerWithClock.restore = function restore() {\n
            if (this.clock) {\n
                this.clock.restore();\n
            }\n
\n
            return sinon.fakeServer.restore.apply(this, arguments);\n
        };\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require) {\n
        var sinon = require("./core");\n
        require("./fake_server");\n
        require("./fake_timers");\n
        makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require);\n
    } else {\n
        makeApi(sinon);\n
    }\n
}());\n
\n
/**\n
 * @depend util/core.js\n
 * @depend extend.js\n
 * @depend collection.js\n
 * @depend util/fake_timers.js\n
 * @depend util/fake_server_with_clock.js\n
 */\n
/**\n
 * Manages fake collections as well as fake utilities such as Sinon\'s\n
 * timers and fake XHR implementation in one convenient object.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function () {\n
    function makeApi(sinon) {\n
        var push = [].push;\n
\n
        function exposeValue(sandbox, config, key, value) {\n
            if (!value) {\n
                return;\n
            }\n
\n
            if (config.injectInto && !(key in config.injectInto)) {\n
                config.injectInto[key] = value;\n
                sandbox.injectedKeys.push(key);\n
            } else {\n
                push.call(sandbox.args, value);\n
            }\n
        }\n
\n
        function prepareSandboxFromConfig(config) {\n
            var sandbox = sinon.create(sinon.sandbox);\n
\n
            if (config.useFakeServer) {\n
                if (typeof config.useFakeServer == "object") {\n
                    sandbox.serverPrototype = config.useFakeServer;\n
                }\n
\n
                sandbox.useFakeServer();\n
            }\n
\n
            if (config.useFakeTimers) {\n
                if (typeof config.useFakeTimers == "object") {\n
                    sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\n
                } else {\n
                    sandbox.useFakeTimers();\n
                }\n
            }\n
\n
            return sandbox;\n
        }\n
\n
        sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {\n
            useFakeTimers: function useFakeTimers() {\n
                this.clock = sinon.useFakeTimers.apply(sinon, arguments);\n
\n
                return this.add(this.clock);\n
            },\n
\n
            serverPrototype: sinon.fakeServer,\n
\n
            useFakeServer: function useFakeServer() {\n
                var proto = this.serverPrototype || sinon.fakeServer;\n
\n
                if (!proto || !proto.create) {\n
                    return null;\n
                }\n
\n
                this.server = proto.create();\n
                return this.add(this.server);\n
            },\n
\n
            inject: function (obj) {\n
                sinon.collection.inject.call(this, obj);\n
\n
                if (this.clock) {\n
                    obj.clock = this.clock;\n
                }\n
\n
                if (this.server) {\n
                    obj.server = this.server;\n
                    obj.requests = this.server.requests;\n
                }\n
\n
                obj.match = sinon.match;\n
\n
                return obj;\n
            },\n
\n
            restore: function () {\n
                sinon.collection.restore.apply(this, arguments);\n
                this.restoreContext();\n
            },\n
\n
            restoreContext: function () {\n
                if (this.injectedKeys) {\n
                    for (var i = 0, j = this.injectedKeys.length; i < j; i++) {\n
                        delete this.injectInto[this.injectedKeys[i]];\n
                    }\n
                    this.injectedKeys = [];\n
                }\n
            },\n
\n
            create: function (config) {\n
                if (!config) {\n
                    return sinon.create(sinon.sandbox);\n
                }\n
\n
                var sandbox = prepareSandboxFromConfig(config);\n
                sandbox.args = sandbox.args || [];\n
                sandbox.injectedKeys = [];\n
                sandbox.injectInto = config.injectInto;\n
                var prop, value, exposed = sandbox.inject({});\n
\n
                if (config.properties) {\n
                    for (var i = 0, l = config.properties.length; i < l; i++) {\n
                        prop = config.properties[i];\n
                        value = exposed[prop] || prop == "sandbox" && sandbox;\n
                        exposeValue(sandbox, config, prop, value);\n
                    }\n
                } else {\n
                    exposeValue(sandbox, config, "sandbox", value);\n
                }\n
\n
                return sandbox;\n
            },\n
\n
            match: sinon.match\n
        });\n
\n
        sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;\n
\n
        return sinon.sandbox;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./extend");\n
        require("./util/fake_server_with_clock");\n
        require("./util/fake_timers");\n
        require("./collection");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}());\n
\n
/**\n
 * @depend util/core.js\n
 * @depend sandbox.js\n
 */\n
/**\n
 * Test function, sandboxes fakes\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    function makeApi(sinon) {\n
        var slice = Array.prototype.slice;\n
\n
        function test(callback) {\n
            var type = typeof callback;\n
\n
            if (type != "function") {\n
                throw new TypeError("sinon.test needs to wrap a test function, got " + type);\n
            }\n
\n
            function sinonSandboxedTest() {\n
                var config = sinon.getConfig(sinon.config);\n
                config.injectInto = config.injectIntoThis && this || config.injectInto;\n
                var sandbox = sinon.sandbox.create(config);\n
                var args = slice.call(arguments);\n
                var oldDone = args.length && args[args.length - 1];\n
                var exception, result;\n
\n
                if (typeof oldDone == "function") {\n
                    args[args.length - 1] = function sinonDone(result) {\n
                        if (result) {\n
                            sandbox.restore();\n
                            throw exception;\n
                        } else {\n
                            sandbox.verifyAndRestore();\n
                        }\n
                        oldDone(result);\n
                    };\n
                }\n
\n
                try {\n
                    result = callback.apply(this, args.concat(sandbox.args));\n
                } catch (e) {\n
                    exception = e;\n
                }\n
\n
                if (typeof oldDone != "function") {\n
                    if (typeof exception !== "undefined") {\n
                        sandbox.restore();\n
                        throw exception;\n
                    } else {\n
                        sandbox.verifyAndRestore();\n
                    }\n
                }\n
\n
                return result;\n
            }\n
\n
            if (callback.length) {\n
                return function sinonAsyncSandboxedTest(callback) {\n
                    return sinonSandboxedTest.apply(this, arguments);\n
                };\n
            }\n
\n
            return sinonSandboxedTest;\n
        }\n
\n
        test.config = {\n
            injectIntoThis: true,\n
            injectInto: null,\n
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],\n
            useFakeTimers: true,\n
            useFakeServer: true\n
        };\n
\n
        sinon.test = test;\n
        return test;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./sandbox");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (sinon) {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend util/core.js\n
 * @depend test.js\n
 */\n
/**\n
 * Test case, sandboxes all test functions\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon) {\n
    function createTest(property, setUp, tearDown) {\n
        return function () {\n
            if (setUp) {\n
                setUp.apply(this, arguments);\n
            }\n
\n
            var exception, result;\n
\n
            try {\n
                result = property.apply(this, arguments);\n
            } catch (e) {\n
                exception = e;\n
            }\n
\n
            if (tearDown) {\n
                tearDown.apply(this, arguments);\n
            }\n
\n
            if (exception) {\n
                throw exception;\n
            }\n
\n
            return result;\n
        };\n
    }\n
\n
    function makeApi(sinon) {\n
        function testCase(tests, prefix) {\n
            if (!tests || typeof tests != "object") {\n
                throw new TypeError("sinon.testCase needs an object with test functions");\n
            }\n
\n
            prefix = prefix || "test";\n
            var rPrefix = new RegExp("^" + prefix);\n
            var methods = {}, testName, property, method;\n
            var setUp = tests.setUp;\n
            var tearDown = tests.tearDown;\n
\n
            for (testName in tests) {\n
                if (tests.hasOwnProperty(testName) && !/^(setUp|tearDown)$/.test(testName)) {\n
                    property = tests[testName];\n
\n
                    if (typeof property == "function" && rPrefix.test(testName)) {\n
                        method = property;\n
\n
                        if (setUp || tearDown) {\n
                            method = createTest(property, setUp, tearDown);\n
                        }\n
\n
                        methods[testName] = sinon.test(method);\n
                    } else {\n
                        methods[testName] = tests[testName];\n
                    }\n
                }\n
            }\n
\n
            return methods;\n
        }\n
\n
        sinon.testCase = testCase;\n
        return testCase;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./test");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
}(typeof sinon == "object" && sinon || null));\n
\n
/**\n
 * @depend times_in_words.js\n
 * @depend util/core.js\n
 * @depend match.js\n
 * @depend format.js\n
 */\n
/**\n
 * Assertions matching the test spy retrieval interface.\n
 *\n
 * @author Christian Johansen (christian@cjohansen.no)\n
 * @license BSD\n
 *\n
 * Copyright (c) 2010-2013 Christian Johansen\n
 */\n
\n
(function (sinon, global) {\n
    var slice = Array.prototype.slice;\n
\n
    function makeApi(sinon) {\n
        var assert;\n
\n
        function verifyIsStub() {\n
            var method;\n
\n
            for (var i = 0, l = arguments.length; i < l; ++i) {\n
                method = arguments[i];\n
\n
                if (!method) {\n
                    assert.fail("fake is not a spy");\n
                }\n
\n
                if (method.proxy && method.proxy.isSinonProxy) {\n
                    verifyIsStub(method.proxy);\n
                } else {\n
                    if (typeof method != "function") {\n
                        assert.fail(method + " is not a function");\n
                    }\n
\n
                    if (typeof method.getCall != "function") {\n
                        assert.fail(method + " is not stubbed");\n
                    }\n
                }\n
\n
            }\n
        }\n
\n
        function failAssertion(object, msg) {\n
            object = object || global;\n
            var failMethod = object.fail || assert.fail;\n
            failMethod.call(object, msg);\n
        }\n
\n
        function mirrorPropAsAssertion(name, method, message) {\n
            if (arguments.length == 2) {\n
                message = method;\n
                method = name;\n
            }\n
\n
            assert[name] = function (fake) {\n
                verifyIsStub(fake);\n
\n
                var args = slice.call(arguments, 1);\n
                var failed = false;\n
\n
                if (typeof method == "function") {\n
                    failed = !method(fake);\n
                } else {\n
                    failed = typeof fake[method] == "function" ?\n
                        !fake[method].apply(fake, args) : !fake[method];\n
                }\n
\n
                if (failed) {\n
                    failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));\n
                } else {\n
                    assert.pass(name);\n
                }\n
            };\n
        }\n
\n
        function exposedName(prefix, prop) {\n
            return !prefix || /^fail/.test(prop) ? prop :\n
                prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n
        }\n
\n
        assert = {\n
            failException: "AssertError",\n
\n
            fail: function fail(message) {\n
                var error = new Error(message);\n
                error.name = this.failException || assert.failException;\n
\n
                throw error;\n
            },\n
\n
            pass: function pass(assertion) {},\n
\n
            callOrder: function assertCallOrder() {\n
                verifyIsStub.apply(null, arguments);\n
                var expected = "", actual = "";\n
\n
                if (!sinon.calledInOrder(arguments)) {\n
                    try {\n
                        expected = [].join.call(arguments, ", ");\n
                        var calls = slice.call(arguments);\n
                        var i = calls.length;\n
                        while (i) {\n
                            if (!calls[--i].called) {\n
                                calls.splice(i, 1);\n
                            }\n
                        }\n
                        actual = sinon.orderByFirstCall(calls).join(", ");\n
                    } catch (e) {\n
                        // If this fails, we\'ll just fall back to the blank string\n
                    }\n
\n
                    failAssertion(this, "expected " + expected + " to be " +\n
                                "called in order but were called as " + actual);\n
                } else {\n
                    assert.pass("callOrder");\n
                }\n
            },\n
\n
            callCount: function assertCallCount(method, count) {\n
                verifyIsStub(method);\n
\n
                if (method.callCount != count) {\n
                    var msg = "expected %n to be called " + sinon.timesInWords(count) +\n
                        " but was called %c%C";\n
                    failAssertion(this, method.printf(msg));\n
                } else {\n
                    assert.pass("callCount");\n
                }\n
            },\n
\n
            expose: function expose(target, options) {\n
                if (!target) {\n
                    throw new TypeError("target is null or undefined");\n
                }\n
\n
                var o = options || {};\n
                var prefix = typeof o.prefix == "undefined" && "assert" || o.prefix;\n
                var includeFail = typeof o.includeFail == "undefined" || !!o.includeFail;\n
\n
                for (var method in this) {\n
                    if (method != "expose" && (includeFail || !/^(fail)/.test(method))) {\n
                        target[exposedName(prefix, method)] = this[method];\n
                    }\n
                }\n
\n
                return target;\n
            },\n
\n
            match: function match(actual, expectation) {\n
                var matcher = sinon.match(expectation);\n
                if (matcher.test(actual)) {\n
                    assert.pass("match");\n
                } else {\n
                    var formatted = [\n
                        "expected value to match",\n
                        "    expected = " + sinon.format(expectation),\n
                        "    actual = " + sinon.format(actual)\n
                    ]\n
                    failAssertion(this, formatted.join("\\n"));\n
                }\n
            }\n
        };\n
\n
        mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");\n
        mirrorPropAsAssertion("notCalled", function (spy) {\n
            return !spy.called;\n
        }, "expected %n to not have been called but was called %c%C");\n
        mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");\n
        mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");\n
        mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");\n
        mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");\n
        mirrorPropAsAssertion("alwaysCalledOn", "expected %n to always be called with %1 as this but was called with %t");\n
        mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");\n
        mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");\n
        mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");\n
        mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");\n
        mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");\n
        mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");\n
        mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");\n
        mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");\n
        mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");\n
        mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");\n
        mirrorPropAsAssertion("threw", "%n did not throw exception%C");\n
        mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");\n
\n
        sinon.assert = assert;\n
        return assert;\n
    }\n
\n
    var isNode = typeof module !== "undefined" && module.exports && typeof require == "function";\n
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;\n
\n
    function loadDependencies(require, exports, module) {\n
        var sinon = require("./util/core");\n
        require("./match");\n
        require("./format");\n
        module.exports = makeApi(sinon);\n
    }\n
\n
    if (isAMD) {\n
        define(loadDependencies);\n
    } else if (isNode) {\n
        loadDependencies(require, module.exports, module);\n
    } else if (!sinon) {\n
        return;\n
    } else {\n
        makeApi(sinon);\n
    }\n
\n
}(typeof sinon == "object" && sinon || null, typeof window != "undefined" ? window : (typeof self != "undefined") ? self : global));\n
\n
  return sinon;\n
}));

]]></string> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Sinon JS</string> </value>
        </item>
        <item>
            <key> <string>version</string> </key>
            <value> <string>1.15.4</string> </value>
        </item>
        <item>
            <key> <string>workflow_history</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="PersistentMapping" module="Persistence.mapping"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value>
              <dictionary>
                <item>
                    <key> <string>document_publication_workflow</string> </key>
                    <value>
                      <persistent> <string encoding="base64">AAAAAAAAAAM=</string> </persistent>
                    </value>
                </item>
                <item>
                    <key> <string>edit_workflow</string> </key>
                    <value>
                      <persistent> <string encoding="base64">AAAAAAAAAAQ=</string> </persistent>
                    </value>
                </item>
                <item>
                    <key> <string>processing_status_workflow</string> </key>
                    <value>
                      <persistent> <string encoding="base64">AAAAAAAAAAU=</string> </persistent>
                    </value>
                </item>
              </dictionary>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="3" aka="AAAAAAAAAAM=">
    <pickle>
      <global name="WorkflowHistoryList" module="Products.ERP5Type.patches.WorkflowTool"/>
    </pickle>
    <pickle>
      <tuple>
        <none/>
        <list>
          <dictionary>
            <item>
                <key> <string>action</string> </key>
                <value> <string>publish_alive</string> </value>
            </item>
            <item>
                <key> <string>actor</string> </key>
                <value> <string>zope1</string> </value>
            </item>
            <item>
                <key> <string>comment</string> </key>
                <value> <string></string> </value>
            </item>
            <item>
                <key> <string>error_message</string> </key>
                <value> <string></string> </value>
            </item>
            <item>
                <key> <string>time</string> </key>
                <value>
                  <object>
                    <klass>
                      <global name="DateTime" module="DateTime.DateTime"/>
                    </klass>
                    <tuple>
                      <none/>
                    </tuple>
                    <state>
                      <tuple>
                        <float>1437140856.93</float>
                        <string>GMT</string>
                      </tuple>
                    </state>
                  </object>
                </value>
            </item>
            <item>
                <key> <string>validation_state</string> </key>
                <value> <string>published_alive</string> </value>
            </item>
          </dictionary>
        </list>
      </tuple>
    </pickle>
  </record>
  <record id="4" aka="AAAAAAAAAAQ=">
    <pickle>
      <global name="WorkflowHistoryList" module="Products.ERP5Type.patches.WorkflowTool"/>
    </pickle>
    <pickle>
      <tuple>
        <none/>
        <list>
          <dictionary>
            <item>
                <key> <string>action</string> </key>
                <value> <string>edit</string> </value>
            </item>
            <item>
                <key> <string>actor</string> </key>
                <value> <string>zope</string> </value>
            </item>
            <item>
                <key> <string>comment</string> </key>
                <value>
                  <none/>
                </value>
            </item>
            <item>
                <key> <string>error_message</string> </key>
                <value> <string></string> </value>
            </item>
            <item>
                <key> <string>serial</string> </key>
                <value> <string>944.38935.8320.57019</string> </value>
            </item>
            <item>
                <key> <string>state</string> </key>
                <value> <string>current</string> </value>
            </item>
            <item>
                <key> <string>time</string> </key>
                <value>
                  <object>
                    <klass>
                      <global name="DateTime" module="DateTime.DateTime"/>
                    </klass>
                    <tuple>
                      <none/>
                    </tuple>
                    <state>
                      <tuple>
                        <float>1437746152.78</float>
                        <string>GMT</string>
                      </tuple>
                    </state>
                  </object>
                </value>
            </item>
          </dictionary>
        </list>
      </tuple>
    </pickle>
  </record>
  <record id="5" aka="AAAAAAAAAAU=">
    <pickle>
      <global name="WorkflowHistoryList" module="Products.ERP5Type.patches.WorkflowTool"/>
    </pickle>
    <pickle>
      <tuple>
        <none/>
        <list>
          <dictionary>
            <item>
                <key> <string>action</string> </key>
                <value>
                  <none/>
                </value>
            </item>
            <item>
                <key> <string>actor</string> </key>
                <value> <string>zope</string> </value>
            </item>
            <item>
                <key> <string>comment</string> </key>
                <value> <string></string> </value>
            </item>
            <item>
                <key> <string>error_message</string> </key>
                <value> <string></string> </value>
            </item>
            <item>
                <key> <string>external_processing_state</string> </key>
                <value> <string>empty</string> </value>
            </item>
            <item>
                <key> <string>serial</string> </key>
                <value> <string>0.0.0.0</string> </value>
            </item>
            <item>
                <key> <string>time</string> </key>
                <value>
                  <object>
                    <klass>
                      <global name="DateTime" module="DateTime.DateTime"/>
                    </klass>
                    <tuple>
                      <none/>
                    </tuple>
                    <state>
                      <tuple>
                        <float>1437138966.02</float>
                        <string>GMT</string>
                      </tuple>
                    </state>
                  </object>
                </value>
            </item>
          </dictionary>
        </list>
      </tuple>
    </pickle>
  </record>
</ZopeData>
