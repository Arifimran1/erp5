<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="Web Script" module="erp5.portal_type"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_Access_contents_information_Permission</string> </key>
            <value>
              <tuple>
                <string>Anonymous</string>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Associate</string>
                <string>Auditor</string>
                <string>Manager</string>
                <string>Owner</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Add_portal_content_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Change_local_roles_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_Modify_portal_content_Permission</string> </key>
            <value>
              <tuple>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Manager</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>_View_Permission</string> </key>
            <value>
              <tuple>
                <string>Anonymous</string>
                <string>Assignee</string>
                <string>Assignor</string>
                <string>Associate</string>
                <string>Auditor</string>
                <string>Manager</string>
                <string>Owner</string>
              </tuple>
            </value>
        </item>
        <item>
            <key> <string>content_md5</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>default_reference</string> </key>
            <value> <string>uritemplate.js</string> </value>
        </item>
        <item>
            <key> <string>description</string> </key>
            <value> <string>http://git.erp5.org/gitweb/uritemplate-js.git/blob_plain/HEAD:/bin/uritemplate.js</string> </value>
        </item>
        <item>
            <key> <string>id</string> </key>
            <value> <string>rjs_uritemplate_js</string> </value>
        </item>
        <item>
            <key> <string>language</string> </key>
            <value> <string>en</string> </value>
        </item>
        <item>
            <key> <string>portal_type</string> </key>
            <value> <string>Web Script</string> </value>
        </item>
        <item>
            <key> <string>short_title</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>text_content</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*global unescape, module, define, window, global*/\n
\n
/*\n
 UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.\n
 Available via the MIT license.\n
*/\n
\n
(function (exportCallback) {\n
    "use strict";\n
\n
var UriTemplateError = (function () {\n
\n
    function UriTemplateError (options) {\n
        this.options = options;\n
    }\n
\n
    UriTemplateError.prototype.toString = function () {\n
        if (JSON && JSON.stringify) {\n
            return JSON.stringify(this.options);\n
        }\n
        else {\n
            return this.options;\n
        }\n
    };\n
\n
    return UriTemplateError;\n
}());\n
\n
var objectHelper = (function () {\n
    function isArray (value) {\n
        return Object.prototype.toString.apply(value) === \'[object Array]\';\n
    }\n
\n
    function isString (value) {\n
        return Object.prototype.toString.apply(value) === \'[object String]\';\n
    }\n
    \n
    function isNumber (value) {\n
        return Object.prototype.toString.apply(value) === \'[object Number]\';\n
    }\n
    \n
    function isBoolean (value) {\n
        return Object.prototype.toString.apply(value) === \'[object Boolean]\';\n
    }\n
    \n
    function join (arr, separator) {\n
        var\n
            result = \'\',\n
            first = true,\n
            index;\n
        for (index = 0; index < arr.length; index += 1) {\n
            if (first) {\n
                first = false;\n
            }\n
            else {\n
                result += separator;\n
            }\n
            result += arr[index];\n
        }\n
        return result;\n
    }\n
\n
    function map (arr, mapper) {\n
        var\n
            result = [],\n
            index = 0;\n
        for (; index < arr.length; index += 1) {\n
            result.push(mapper(arr[index]));\n
        }\n
        return result;\n
    }\n
\n
    function filter (arr, predicate) {\n
        var\n
            result = [],\n
            index = 0;\n
        for (; index < arr.length; index += 1) {\n
            if (predicate(arr[index])) {\n
                result.push(arr[index]);\n
            }\n
        }\n
        return result;\n
    }\n
\n
    function deepFreezeUsingObjectFreeze (object) {\n
        if (typeof object !== "object" || object === null) {\n
            return object;\n
        }\n
        Object.freeze(object);\n
        var property, propertyName;\n
        for (propertyName in object) {\n
            if (object.hasOwnProperty(propertyName)) {\n
                property = object[propertyName];\n
                // be aware, arrays are \'object\', too\n
                if (typeof property === "object") {\n
                    deepFreeze(property);\n
                }\n
            }\n
        }\n
        return object;\n
    }\n
\n
    function deepFreeze (object) {\n
        if (typeof Object.freeze === \'function\') {\n
            return deepFreezeUsingObjectFreeze(object);\n
        }\n
        return object;\n
    }\n
\n
\n
    return {\n
        isArray: isArray,\n
        isString: isString,\n
        isNumber: isNumber,\n
        isBoolean: isBoolean,\n
        join: join,\n
        map: map,\n
        filter: filter,\n
        deepFreeze: deepFreeze\n
    };\n
}());\n
\n
var charHelper = (function () {\n
\n
    function isAlpha (chr) {\n
        return (chr >= \'a\' && chr <= \'z\') || ((chr >= \'A\' && chr <= \'Z\'));\n
    }\n
\n
    function isDigit (chr) {\n
        return chr >= \'0\' && chr <= \'9\';\n
    }\n
\n
    function isHexDigit (chr) {\n
        return isDigit(chr) || (chr >= \'a\' && chr <= \'f\') || (chr >= \'A\' && chr <= \'F\');\n
    }\n
\n
    return {\n
        isAlpha: isAlpha,\n
        isDigit: isDigit,\n
        isHexDigit: isHexDigit\n
    };\n
}());\n
\n
var pctEncoder = (function () {\n
    var utf8 = {\n
        encode: function (chr) {\n
            // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html\n
            return unescape(encodeURIComponent(chr));\n
        },\n
        numBytes: function (firstCharCode) {\n
            if (firstCharCode <= 0x7F) {\n
                return 1;\n
            }\n
            else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {\n
                return 2;\n
            }\n
            else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {\n
                return 3;\n
            }\n
            else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {\n
                return 4;\n
            }\n
            // no valid first octet\n
            return 0;\n
        },\n
        isValidFollowingCharCode: function (charCode) {\n
            return 0x80 <= charCode && charCode <= 0xBF;\n
        }\n
    };\n
\n
    /**\n
     * encodes a character, if needed or not.\n
     * @param chr\n
     * @return pct-encoded character\n
     */\n
    function encodeCharacter (chr) {\n
        var\n
            result = \'\',\n
            octets = utf8.encode(chr),\n
            octet,\n
            index;\n
        for (index = 0; index < octets.length; index += 1) {\n
            octet = octets.charCodeAt(index);\n
            result += \'%\' + (octet < 0x10 ? \'0\' : \'\') + octet.toString(16).toUpperCase();\n
        }\n
        return result;\n
    }\n
\n
    /**\n
     * Returns, whether the given text at start is in the form \'percent hex-digit hex-digit\', like \'%3F\'\n
     * @param text\n
     * @param start\n
     * @return {boolean|*|*}\n
     */\n
    function isPercentDigitDigit (text, start) {\n
        return text.charAt(start) === \'%\' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));\n
    }\n
\n
    /**\n
     * Parses a hex number from start with length 2.\n
     * @param text a string\n
     * @param start the start index of the 2-digit hex number\n
     * @return {Number}\n
     */\n
    function parseHex2 (text, start) {\n
        return parseInt(text.substr(start, 2), 16);\n
    }\n
\n
    /**\n
     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.\n
     * @param chr\n
     * @return {boolean}\n
     */\n
    function isPctEncoded (chr) {\n
        if (!isPercentDigitDigit(chr, 0)) {\n
            return false;\n
        }\n
        var firstCharCode = parseHex2(chr, 1);\n
        var numBytes = utf8.numBytes(firstCharCode);\n
        if (numBytes === 0) {\n
            return false;\n
        }\n
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n
            if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {\n
                return false;\n
            }\n
        }\n
        return true;\n
    }\n
\n
    /**\n
     * Reads as much as needed from the text, e.g. \'%20\' or \'%C3%B6\'. It does not decode!\n
     * @param text\n
     * @param startIndex\n
     * @return the character or pct-string of the text at startIndex\n
     */\n
    function pctCharAt(text, startIndex) {\n
        var chr = text.charAt(startIndex);\n
        if (!isPercentDigitDigit(text, startIndex)) {\n
            return chr;\n
        }\n
        var utf8CharCode = parseHex2(text, startIndex + 1);\n
        var numBytes = utf8.numBytes(utf8CharCode);\n
        if (numBytes === 0) {\n
            return chr;\n
        }\n
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n
            if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {\n
                return chr;\n
            }\n
        }\n
        return text.substr(startIndex, 3 * numBytes);\n
    }\n
\n
    return {\n
        encodeCharacter: encodeCharacter,\n
        isPctEncoded: isPctEncoded,\n
        pctCharAt: pctCharAt\n
    };\n
}());\n
\n
var rfcCharHelper = (function () {\n
\n
    /**\n
     * Returns if an character is an varchar character according 2.3 of rfc 6570\n
     * @param chr\n
     * @return (Boolean)\n
     */\n
    function isVarchar (chr) {\n
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === \'_\' || pctEncoder.isPctEncoded(chr);\n
    }\n
\n
    /**\n
     * Returns if chr is an unreserved character according 1.5 of rfc 6570\n
     * @param chr\n
     * @return {Boolean}\n
     */\n
    function isUnreserved (chr) {\n
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === \'-\' || chr === \'.\' || chr === \'_\' || chr === \'~\';\n
    }\n
\n
    /**\n
     * Returns if chr is an reserved character according 1.5 of rfc 6570\n
     * or the percent character mentioned in 3.2.1.\n
     * @param chr\n
     * @return {Boolean}\n
     */\n
    function isReserved (chr) {\n
        return chr === \':\' || chr === \'/\' || chr === \'?\' || chr === \'#\' || chr === \'[\' || chr === \']\' || chr === \'@\' || chr === \'!\' || chr === \'$\' || chr === \'&\' || chr === \'(\' ||\n
            chr === \')\' || chr === \'*\' || chr === \'+\' || chr === \',\' || chr === \';\' || chr === \'=\' || chr === "\'";\n
    }\n
\n
    return {\n
        isVarchar: isVarchar,\n
        isUnreserved: isUnreserved,\n
        isReserved: isReserved\n
    };\n
\n
}());\n
\n
/**\n
 * encoding of rfc 6570\n
 */\n
var encodingHelper = (function () {\n
\n
    function encode (text, passReserved) {\n
        var\n
            result = \'\',\n
            index,\n
            chr = \'\';\n
        if (typeof text === "number" || typeof text === "boolean") {\n
            text = text.toString();\n
        }\n
        for (index = 0; index < text.length; index += chr.length) {\n
            chr = text.charAt(index);\n
            result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);\n
        }\n
        return result;\n
    }\n
\n
    function encodePassReserved (text) {\n
        return encode(text, true);\n
    }\n
\n
    function encodeLiteralCharacter (literal, index) {\n
        var chr = pctEncoder.pctCharAt(literal, index);\n
        if (chr.length > 1) {\n
            return chr;\n
        }\n
        else {\n
            return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n
        }\n
    }\n
\n
    function encodeLiteral (literal) {\n
        var\n
            result = \'\',\n
            index,\n
            chr = \'\';\n
        for (index = 0; index < literal.length; index += chr.length) {\n
            chr = pctEncoder.pctCharAt(literal, index);\n
            if (chr.length > 1) {\n
                result += chr;\n
            }\n
            else {\n
                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n
            }\n
        }\n
        return result;\n
    }\n
\n
    return {\n
        encode: encode,\n
        encodePassReserved: encodePassReserved,\n
        encodeLiteral: encodeLiteral,\n
        encodeLiteralCharacter: encodeLiteralCharacter\n
    };\n
\n
}());\n
\n
\n
// the operators defined by rfc 6570\n
var operators = (function () {\n
\n
    var\n
        bySymbol = {};\n
\n
    function create (symbol) {\n
        bySymbol[symbol] = {\n
            symbol: symbol,\n
            separator: (symbol === \'?\') ? \'&\' : (symbol === \'\' || symbol === \'+\' || symbol === \'#\') ? \',\' : symbol,\n
            named: symbol === \';\' || symbol === \'&\' || symbol === \'?\',\n
            ifEmpty: (symbol === \'&\' || symbol === \'?\') ? \'=\' : \'\',\n
            first: (symbol === \'+\' ) ? \'\' : symbol,\n
            encode: (symbol === \'+\' || symbol === \'#\') ? encodingHelper.encodePassReserved : encodingHelper.encode,\n
            toString: function () {\n
                return this.symbol;\n
            }\n
        };\n
    }\n
\n
    create(\'\');\n
    create(\'+\');\n
    create(\'#\');\n
    create(\'.\');\n
    create(\'/\');\n
    create(\';\');\n
    create(\'?\');\n
    create(\'&\');\n
    return {\n
        valueOf: function (chr) {\n
            if (bySymbol[chr]) {\n
                return bySymbol[chr];\n
            }\n
            if ("=,!@|".indexOf(chr) >= 0) {\n
                return null;\n
            }\n
            return bySymbol[\'\'];\n
        }\n
    };\n
}());\n
\n
\n
/**\n
 * Detects, whether a given element is defined in the sense of rfc 6570\n
 * Section 2.3 of the RFC makes clear defintions:\n
 * * undefined and null are not defined.\n
 * * the empty string is defined\n
 * * an array ("list") is defined, if it is not empty (even if all elements are not defined)\n
 * * an object ("map") is defined, if it contains at least one property with defined value\n
 * @param object\n
 * @return {Boolean}\n
 */\n
function isDefined (object) {\n
    var\n
        propertyName;\n
    if (object === null || object === undefined) {\n
        return false;\n
    }\n
    if (objectHelper.isArray(object)) {\n
        // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members\n
        return object.length > 0;\n
    }\n
    if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {\n
        // falsy values like empty strings, false or 0 are "defined"\n
        return true;\n
    }\n
    // else Object\n
    for (propertyName in object) {\n
        if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {\n
            return true;\n
        }\n
    }\n
    return false;\n
}\n
\n
var LiteralExpression = (function () {\n
    function LiteralExpression (literal) {\n
        this.literal = encodingHelper.encodeLiteral(literal);\n
    }\n
\n
    LiteralExpression.prototype.expand = function () {\n
        return this.literal;\n
    };\n
\n
    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;\n
\n
    return LiteralExpression;\n
}());\n
\n
var parse = (function () {\n
\n
    function parseExpression (expressionText) {\n
        var\n
            operator,\n
            varspecs = [],\n
            varspec = null,\n
            varnameStart = null,\n
            maxLengthStart = null,\n
            index,\n
            chr = \'\';\n
\n
        function closeVarname () {\n
            var varname = expressionText.substring(varnameStart, index);\n
            if (varname.length === 0) {\n
                throw new UriTemplateError({expressionText: expressionText, message: "a varname must be specified", position: index});\n
            }\n
            varspec = {varname: varname, exploded: false, maxLength: null};\n
            varnameStart = null;\n
        }\n
\n
        function closeMaxLength () {\n
            if (maxLengthStart === index) {\n
                throw new UriTemplateError({expressionText: expressionText, message: "after a \':\' you have to specify the length", position: index});\n
            }\n
            varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);\n
            maxLengthStart = null;\n
        }\n
\n
        operator = (function (operatorText) {\n
            var op = operators.valueOf(operatorText);\n
            if (op === null) {\n
                throw new UriTemplateError({expressionText: expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText});\n
            }\n
            return op;\n
        }(expressionText.charAt(0)));\n
        index = operator.symbol.length;\n
\n
        varnameStart = index;\n
\n
        for (; index < expressionText.length; index += chr.length) {\n
            chr = pctEncoder.pctCharAt(expressionText, index);\n
\n
            if (varnameStart !== null) {\n
                // the spec says: varname =  varchar *( ["."] varchar )\n
                // so a dot is allowed except for the first char\n
                if (chr === \'.\') {\n
                    if (varnameStart === index) {\n
                        throw new UriTemplateError({expressionText: expressionText, message: "a varname MUST NOT start with a dot", position: index});\n
                    }\n
                    continue;\n
                }\n
                if (rfcCharHelper.isVarchar(chr)) {\n
                    continue;\n
                }\n
                closeVarname();\n
            }\n
            if (maxLengthStart !== null) {\n
                if (index === maxLengthStart && chr === \'0\') {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must not start with digit 0", position: index});\n
                }\n
                if (charHelper.isDigit(chr)) {\n
                    if (index - maxLengthStart >= 4) {\n
                        throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must have max 4 digits", position: index});\n
                    }\n
                    continue;\n
                }\n
                closeMaxLength();\n
            }\n
            if (chr === \':\') {\n
                if (varspec.maxLength !== null) {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "only one :maxLength is allowed per varspec", position: index});\n
                }\n
                if (varspec.exploded) {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index});\n
                }\n
                maxLengthStart = index + 1;\n
                continue;\n
            }\n
            if (chr === \'*\') {\n
                if (varspec === null) {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded without varspec", position: index});\n
                }\n
                if (varspec.exploded) {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded twice", position: index});\n
                }\n
                if (varspec.maxLength) {\n
                    throw new UriTemplateError({expressionText: expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index});\n
                }\n
                varspec.exploded = true;\n
                continue;\n
            }\n
            // the only legal character now is the comma\n
            if (chr === \',\') {\n
                varspecs.push(varspec);\n
                varspec = null;\n
                varnameStart = index + 1;\n
                continue;\n
            }\n
            throw new UriTemplateError({expressionText: expressionText, message: "illegal character", character: chr, position: index});\n
        } // for chr\n
        if (varnameStart !== null) {\n
            closeVarname();\n
        }\n
        if (maxLengthStart !== null) {\n
            closeMaxLength();\n
        }\n
        varspecs.push(varspec);\n
        return new VariableExpression(expressionText, operator, varspecs);\n
    }\n
\n
    function escape_regexp_string(string) {\n
      // http://simonwillison.net/2006/Jan/20/escape/\n
      return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, "\\\\$&");\n
    }\n
\n
    function parse (uriTemplateText) {\n
        // assert filled string\n
        var\n
            index,\n
            chr,\n
            expressions = [],\n
            expression,\n
            braceOpenIndex = null,\n
            regexp_string = \'\',\n
            can_match = true,\n
            literalStart = 0;\n
        for (index = 0; index < uriTemplateText.length; index += 1) {\n
            chr = uriTemplateText.charAt(index);\n
            if (literalStart !== null) {\n
                if (chr === \'}\') {\n
                    throw new UriTemplateError({templateText: uriTemplateText, message: "unopened brace closed", position: index});\n
                }\n
                if (chr === \'{\') {\n
                    if (literalStart < index) {\n
                        expression = new LiteralExpression(uriTemplateText.substring(literalStart, index));\n
                        expressions.push(expression);\n
                        regexp_string += escape_regexp_string(\n
                            expression.literal);\n
                    }\n
                    literalStart = null;\n
                    braceOpenIndex = index;\n
                }\n
                continue;\n
            }\n
\n
            if (braceOpenIndex !== null) {\n
                // here just { is forbidden\n
                if (chr === \'{\') {\n
                    throw new UriTemplateError({templateText: uriTemplateText, message: "brace already opened", position: index});\n
                }\n
                if (chr === \'}\') {\n
                    if (braceOpenIndex + 1 === index) {\n
                        throw new UriTemplateError({templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex});\n
                    }\n
                    try {\n
                        expression = parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index));\n
                    }\n
                    catch (error) {\n
                        if (error.prototype === UriTemplateError.prototype) {\n
                            throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});\n
                        }\n
                        throw error;\n
                    }\n
                    expressions.push(expression);\n
                    if (expression.operator.symbol.length === 0) {\n
                      regexp_string += "([^/]+)";\n
                    } else {\n
                      can_match = false;\n
                    }\n
                    braceOpenIndex = null;\n
                    literalStart = index + 1;\n
                }\n
                continue;\n
            }\n
            throw new Error(\'reached unreachable code\');\n
        }\n
        if (braceOpenIndex !== null) {\n
            throw new UriTemplateError({templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex});\n
        }\n
        if (literalStart < uriTemplateText.length) {\n
            expression = new LiteralExpression(uriTemplateText.substring(literalStart));\n
            expressions.push(expression);\n
            regexp_string += escape_regexp_string(expression.literal);\n
        }\n
        if (can_match === false) {\n
          regexp_string = undefined;\n
        }\n
        return new UriTemplate(uriTemplateText, expressions, regexp_string);\n
    }\n
\n
    return parse;\n
}());\n
\n
var VariableExpression = (function () {\n
    // helper function if JSON is not available\n
    function prettyPrint (value) {\n
        return (JSON && JSON.stringify) ? JSON.stringify(value) : value;\n
    }\n
\n
    function isEmpty (value) {\n
        if (!isDefined(value)) {\n
            return true;\n
        }\n
        if (objectHelper.isString(value)) {\n
            return value === \'\';\n
        }\n
        if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {\n
            return false;\n
        }\n
        if (objectHelper.isArray(value)) {\n
            return value.length === 0;\n
        }\n
        for (var propertyName in value) {\n
            if (value.hasOwnProperty(propertyName)) {\n
                return false;\n
            }\n
        }\n
        return true;\n
    }\n
\n
    function propertyArray (object) {\n
        var\n
            result = [],\n
            propertyName;\n
        for (propertyName in object) {\n
            if (object.hasOwnProperty(propertyName)) {\n
                result.push({name: propertyName, value: object[propertyName]});\n
            }\n
        }\n
        return result;\n
    }\n
\n
    function VariableExpression (templateText, operator, varspecs) {\n
        this.templateText = templateText;\n
        this.operator = operator;\n
        this.varspecs = varspecs;\n
    }\n
\n
    VariableExpression.prototype.toString = function () {\n
        return this.templateText;\n
    };\n
\n
    function expandSimpleValue(varspec, operator, value) {\n
        var result = \'\';\n
        value = value.toString();\n
        if (operator.named) {\n
            result += encodingHelper.encodeLiteral(varspec.varname);\n
            if (value === \'\') {\n
                result += operator.ifEmpty;\n
                return result;\n
            }\n
            result += \'=\';\n
        }\n
        if (varspec.maxLength !== null) {\n
            value = value.substr(0, varspec.maxLength);\n
        }\n
        result += operator.encode(value);\n
        return result;\n
    }\n
\n
    function valueDefined (nameValue) {\n
        return isDefined(nameValue.value);\n
    }\n
\n
    function expandNotExploded(varspec, operator, value) {\n
        var\n
            arr = [],\n
            result = \'\';\n
        if (operator.named) {\n
            result += encodingHelper.encodeLiteral(varspec.varname);\n
            if (isEmpty(value)) {\n
                result += operator.ifEmpty;\n
                return result;\n
            }\n
            result += \'=\';\n
        }\n
        if (objectHelper.isArray(value)) {\n
            arr = value;\n
            arr = objectHelper.filter(arr, isDefined);\n
            arr = objectHelper.map(arr, operator.encode);\n
            result += objectHelper.join(arr, \',\');\n
        }\n
        else {\n
            arr = propertyArray(value);\n
            arr = objectHelper.filter(arr, valueDefined);\n
            arr = objectHelper.map(arr, function (nameValue) {\n
                return operator.encode(nameValue.name) + \',\' + operator.encode(nameValue.value);\n
            });\n
            result += objectHelper.join(arr, \',\');\n
        }\n
        return result;\n
    }\n
\n
    function expandExplodedNamed (varspec, operator, value) {\n
        var\n
            isArray = objectHelper.isArray(value),\n
            arr = [];\n
        if (isArray) {\n
            arr = value;\n
            arr = objectHelper.filter(arr, isDefined);\n
            arr = objectHelper.map(arr, function (listElement) {\n
                var tmp = encodingHelper.encodeLiteral(varspec.varname);\n
                if (isEmpty(listElement)) {\n
                    tmp += operator.ifEmpty;\n
                }\n
                else {\n
                    tmp += \'=\' + operator.encode(listElement);\n
                }\n
                return tmp;\n
            });\n
        }\n
        else {\n
            arr = propertyArray(value);\n
            arr = objectHelper.filter(arr, valueDefined);\n
            arr = objectHelper.map(arr, function (nameValue) {\n
                var tmp = encodingHelper.encodeLiteral(nameValue.name);\n
                if (isEmpty(nameValue.value)) {\n
                    tmp += operator.ifEmpty;\n
                }\n
                else {\n
                    tmp += \'=\' + operator.encode(nameValue.value);\n
                }\n
                return tmp;\n
            });\n
        }\n
        return objectHelper.join(arr, operator.separator);\n
    }\n
\n
    function expandExplodedUnnamed (operator, value) {\n
        var\n
            arr = [],\n
            result = \'\';\n
        if (objectHelper.isArray(value)) {\n
            arr = value;\n
            arr = objectHelper.filter(arr, isDefined);\n
            arr = objectHelper.map(arr, operator.encode);\n
            result += objectHelper.join(arr, operator.separator);\n
        }\n
        else {\n
            arr = propertyArray(value);\n
            arr = objectHelper.filter(arr, function (nameValue) {\n
                return isDefined(nameValue.value);\n
            });\n
            arr = objectHelper.map(arr, function (nameValue) {\n
                return operator.encode(nameValue.name) + \'=\' + operator.encode(nameValue.value);\n
            });\n
            result += objectHelper.join(arr, operator.separator);\n
        }\n
        return result;\n
    }\n
\n
\n
    VariableExpression.prototype.expand = function (variables) {\n
        var\n
            expanded = [],\n
            index,\n
            varspec,\n
            value,\n
            valueIsArr,\n
            oneExploded = false,\n
            operator = this.operator;\n
\n
        // expand each varspec and join with operator\'s separator\n
        for (index = 0; index < this.varspecs.length; index += 1) {\n
            varspec = this.varspecs[index];\n
            value = variables[varspec.varname];\n
            // if (!isDefined(value)) {\n
            // if (variables.hasOwnProperty(varspec.name)) {\n
            if (value === null || value === undefined) {\n
                continue;\n
            }\n
            if (varspec.exploded) {\n
                oneExploded = true;\n
            }\n
            valueIsArr = objectHelper.isArray(value);\n
            if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {\n
                expanded.push(expandSimpleValue(varspec, operator, value));\n
            }\n
            else if (varspec.maxLength && isDefined(value)) {\n
                // 2.4.1 of the spec says: "Prefix modifiers are not applicable to variables that have composite values."\n
                throw new Error(\'Prefix modifiers are not applicable to variables that have composite values. You tried to expand \' + this + " with " + prettyPrint(value));\n
            }\n
            else if (!varspec.exploded) {\n
                if (operator.named || !isEmpty(value)) {\n
                    expanded.push(expandNotExploded(varspec, operator, value));\n
                }\n
            }\n
            else if (isDefined(value)) {\n
                if (operator.named) {\n
                    expanded.push(expandExplodedNamed(varspec, operator, value));\n
                }\n
                else {\n
                    expanded.push(expandExplodedUnnamed(operator, value));\n
                }\n
            }\n
        }\n
\n
        if (expanded.length === 0) {\n
            return "";\n
        }\n
        else {\n
            return operator.first + objectHelper.join(expanded, operator.separator);\n
        }\n
    };\n
\n
    return VariableExpression;\n
}());\n
\n
var UriTemplate = (function () {\n
    function UriTemplate (templateText, expressions, regexp_string) {\n
        this.templateText = templateText;\n
        this.expressions = expressions;\n
\n
        if (regexp_string !== undefined) {\n
          this.regexp = new RegExp("^" + regexp_string + "$");\n
        }\n
\n
        objectHelper.deepFreeze(this);\n
    }\n
\n
    UriTemplate.prototype.toString = function () {\n
        return this.templateText;\n
    };\n
\n
    UriTemplate.prototype.expand = function (variables) {\n
        // this.expressions.map(function (expression) {return expression.expand(variables);}).join(\'\');\n
        var\n
            index,\n
            result = \'\';\n
        for (index = 0; index < this.expressions.length; index += 1) {\n
            result += this.expressions[index].expand(variables);\n
        }\n
        return result;\n
    };\n
\n
    UriTemplate.prototype.extract = function (text) {\n
      var expression_index,\n
          extracted_index = 1,\n
          expression,\n
          varspec,\n
          matched = true,\n
          variables = {},\n
          result;\n
\n
      if ((this.regexp !== undefined) && (this.regexp.test(text))) {\n
        result = this.regexp.exec(text);\n
        for (expression_index = 0; expression_index < this.expressions.length; expression_index += 1) {\n
          expression = this.expressions[expression_index];\n
          if (expression.literal === undefined) {\n
            if ((expression.operator !== undefined) && (expression.operator.symbol.length === 0) && (expression.varspecs.length === 1)) {\n
              varspec = expression.varspecs[0];\n
              if ((varspec.exploded === false) && (varspec.maxLength === null)) {\n
                if (result[extracted_index].indexOf(\',\') === -1) {\n
                  variables[varspec.varname] = decodeURIComponent(result[extracted_index]);\n
                  extracted_index += 1;\n
                } else {\n
                  matched = false;\n
                }\n
              } else {\n
                matched = false;\n
              }\n
            } else {\n
              matched = false;\n
            }\n
          }\n
        }\n
        if (matched) {\n
          return variables;\n
        }\n
      }\n
      return false;\n
    };\n
\n
    UriTemplate.parse = parse;\n
    UriTemplate.UriTemplateError = UriTemplateError;\n
    return UriTemplate;\n
}());\n
\n
    exportCallback(UriTemplate);\n
\n
}(function (UriTemplate) {\n
        "use strict";\n
        // export UriTemplate, when module is present, or pass it to window or global\n
        if (typeof module !== "undefined") {\n
            module.exports = UriTemplate;\n
        }\n
        else if (typeof define === "function") {\n
            define([],function() {\n
                return UriTemplate;\n
            });\n
        }\n
        else if (typeof window !== "undefined") {\n
            window.UriTemplate = UriTemplate;\n
        }\n
        else {\n
            global.UriTemplate = UriTemplate;\n
        }\n
    }\n
));

]]></string> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>uritemplate.js</string> </value>
        </item>
        <item>
            <key> <string>version</string> </key>
            <value> <string>1.12.0</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
