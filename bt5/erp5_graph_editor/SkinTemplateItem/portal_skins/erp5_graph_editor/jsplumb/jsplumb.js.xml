<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts17687421.03</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>jsplumb.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* ===========================================================================\n
 * Copyright 2013 Nexedi SA and Contributors\n
 *\n
 * This file is part of DREAM.\n
 *\n
 * DREAM is free software: you can redistribute it and/or modify\n
 * it under the terms of the GNU Lesser General Public License as published by\n
 * the Free Software Foundation, either version 3 of the License, or\n
 * (at your option) any later version.\n
 *\n
 * DREAM is distributed in the hope that it will be useful,\n
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\n
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n
 * GNU Lesser General Public License for more details.\n
 *\n
 * You should have received a copy of the GNU Lesser General Public License\n
 * along with DREAM.  If not, see <http://www.gnu.org/licenses/>.\n
 * ==========================================================================*/\n
/*global RSVP, rJS, $, jsPlumb, Handlebars,\n
  loopEventListener, promiseEventListener, DOMParser, confirm */\n
/*jslint unparam: true todo: true */\n
(function(RSVP, rJS, $, jsPlumb, Handlebars, loopEventListener, promiseEventListener, DOMParser) {\n
    "use strict";\n
    /* TODO:\n
 * drop jquery ui dependency\n
 * less dependancies ( promise event listner ? )\n
 * document exposed css / jsplumb config\n
 * no more handlebars\n
 * auto springy layout\n
 * drop zoom level\n
 * edge edit popup on click\n
 * rename draggable()\n
 * somehow choose edge class on connect\n
 */\n
    /*jslint nomen: true */\n
    var gadget_klass = rJS(window),\n
    domParser = new DOMParser(),\n
    node_template_source = gadget_klass.__template_element.getElementById("node-template").innerHTML,\n
    node_template = Handlebars.compile(node_template_source),\n
    popup_edit_template = gadget_klass.__template_element.getElementById("popup-edit-template");\n
    \n
    function loopJsplumbBind(gadget, type, callback) {\n
        //////////////////////////\n
        // Infinite event listener (promise is never resolved)\n
        // eventListener is removed when promise is cancelled/rejected\n
        //////////////////////////\n
        var handle_event_callback, callback_promise, jsplumb_instance = gadget.props.jsplumb_instance;\n
        function cancelResolver() {\n
            if (callback_promise !== undefined && typeof callback_promise.cancel === "function") {\n
                callback_promise.cancel();\n
            }\n
        }\n
        function canceller() {\n
            if (handle_event_callback !== undefined) {\n
                jsplumb_instance.unbind(type);\n
            }\n
            cancelResolver();\n
        }\n
        function resolver(resolve, reject) {\n
            handle_event_callback = function() {\n
                var args = arguments;\n
                cancelResolver();\n
                callback_promise = new RSVP.Queue().push(function() {\n
                    return callback.apply(jsplumb_instance, args);\n
                }).push(undefined, function(error) {\n
                    if (!(error instanceof RSVP.CancellationError)) {\n
                        canceller();\n
                        reject(error);\n
                    }\n
                });\n
            };\n
            jsplumb_instance.bind(type, handle_event_callback);\n
        }\n
        return new RSVP.Promise(resolver, canceller);\n
    }\n
    function getNodeId(gadget, element_id) {\n
        // returns the ID of the node in the graph from its DOM element id\n
        var node_id;\n
        $.each(gadget.props.node_id_to_dom_element_id, function(k, v) {\n
            if (v === element_id) {\n
                node_id = k;\n
                return false;\n
            }\n
        });\n
        return node_id;\n
    }\n
    function generateNodeId(gadget, element) {\n
        // Generate a node id\n
        var n = 1, class_def = gadget.props.data.class_definition[element._class], id = class_def.short_id || element._class;\n
        while (gadget.props.data.graph.node[id + n] !== undefined) {\n
            n += 1;\n
        }\n
        return id + n;\n
    }\n
    function generateDomElementId(gadget_element) {\n
        // Generate a probably unique DOM element ID.\n
        var n = 1;\n
        while ($(gadget_element).find("#DreamNode_" + n).length > 0) {\n
            n += 1;\n
        }\n
        return "DreamNode_" + n;\n
    }\n
    function updateConnectionData(gadget, connection, remove, edge_data) {\n
        if (remove) {\n
            delete gadget.props.data.graph.edge[connection.id];\n
        } else {\n
            edge_data = edge_data || {\n
                _class: "Dream.Edge"\n
            };\n
            edge_data.source = getNodeId(gadget, connection.sourceId);\n
            edge_data.destination = getNodeId(gadget, connection.targetId);\n
            gadget.props.data.graph.edge[connection.id] = edge_data;\n
        }\n
        gadget.notifyDataChanged();\n
    }\n
    function waitForConnection(gadget) {\n
        loopJsplumbBind(gadget, "connection", function(info, originalEvent) {\n
            updateConnectionData(gadget, info.connection);\n
        });\n
    }\n
    function waitForConnectionDetached(gadget) {\n
        loopJsplumbBind(gadget, "connectionDetached", function(info, originalEvent) {\n
            updateConnectionData(gadget, info.connection, true);\n
        });\n
    }\n
    function waitForConnectionClick(gadget) {\n
        // TODO: dialog to edit connection properties\n
        loopJsplumbBind(gadget, "click", function(connection) {\n
            if (confirm("Delete connection ?")) {\n
                gadget.props.jsplumb_instance.detach(connection);\n
            }\n
        });\n
    }\n
    function convertToAbsolutePosition(gadget, x, y) {\n
        var zoom_level = gadget.props.zoom_level * 1.1111, canvas_size_x = $(gadget.props.main).width(), canvas_size_y = $(gadget.props.main).height(), size_x = $(gadget.props.element).find(".dummy_window").width() * zoom_level, size_y = $(gadget.props.element).find(".dummy_window").height() * zoom_level, top = Math.floor(y * (canvas_size_y - size_y)) + "px", left = Math.floor(x * (canvas_size_x - size_x)) + "px";\n
        return [ left, top ];\n
    }\n
    function convertToRelativePosition(gadget, x, y) {\n
        var zoom_level = gadget.props.zoom_level * 1.1111, canvas_size_x = $(gadget.props.main).width(), canvas_size_y = $(gadget.props.main).height(), size_x = $(gadget.props.element).find(".dummy_window").width() * zoom_level, size_y = $(gadget.props.element).find(".dummy_window").height() * zoom_level, top = Math.max(Math.min(y.replace("px", "") / (canvas_size_y - size_y), 1), 0), left = Math.max(Math.min(x.replace("px", "") / (canvas_size_x - size_x), 1), 0);\n
        return [ left, top ];\n
    }\n
    function updateElementCoordinate(gadget, node_id, coordinate) {\n
        var element_id = gadget.props.node_id_to_dom_element_id[node_id], element, relative_position;\n
        if (coordinate === undefined) {\n
            element = $(gadget.props.element).find("#" + element_id);\n
            relative_position = convertToRelativePosition(gadget, element.css("left"), element.css("top"));\n
            coordinate = {\n
                left: relative_position[0],\n
                top: relative_position[1]\n
            };\n
        }\n
        gadget.props.data.graph.node[node_id].coordinate = coordinate;\n
        gadget.notifyDataChanged();\n
        return coordinate;\n
    }\n
    function draggable(gadget) {\n
        var jsplumb_instance = gadget.props.jsplumb_instance, stop = function(element) {\n
            updateElementCoordinate(gadget, getNodeId(gadget, element.target.id));\n
        };\n
        // XXX This function should only touch the node element that we just added.\n
        jsplumb_instance.draggable(jsplumb_instance.getSelector(".window"), {\n
            containment: "parent",\n
            grid: [ 10, 10 ],\n
            stop: stop\n
        });\n
        jsplumb_instance.makeSource(jsplumb_instance.getSelector(".window"), {\n
            filter: ".ep",\n
            anchor: "Continuous",\n
            connector: [ "StateMachine", {\n
                curviness: 20\n
            } ],\n
            connectorStyle: {\n
                strokeStyle: "#5c96bc",\n
                lineWidth: 2,\n
                outlineColor: "transparent",\n
                outlineWidth: 4\n
            }\n
        });\n
        jsplumb_instance.makeTarget(jsplumb_instance.getSelector(".window"), {\n
            dropOptions: {\n
                hoverClass: "dragHover"\n
            },\n
            anchor: "Continuous"\n
        });\n
    }\n
    function updateNodeStyle(gadget, element_id) {\n
        // Update node size according to the zoom level\n
        // XXX does nothing for now\n
        var zoom_level = gadget.props.zoom_level * 1.1111, element = $(gadget.props.element).find("#" + element_id), new_value;\n
        $.each(gadget.props.style_attr_list, function(i, j) {\n
            new_value = $(gadget.props.element).find(".dummy_window").css(j).replace("px", "") * zoom_level + "px";\n
            element.css(j, new_value);\n
        });\n
    }\n
    // function redraw(gadget) {\n
    //   var coordinates = gadget.props.preference_container.coordinates || {},\n
    //     absolute_position,\n
    //     element;\n
    //   $.each(coordinates, function (node_id, v) {\n
    //     absolute_position = convertToAbsolutePosition(\n
    //       gadget,\n
    //       v.left,\n
    //       v.top\n
    //     );\n
    //     element = $(gadget.props.element).find(\n
    //       \'#\' + gadget.props.node_id_to_dom_element_id[node_id];\n
    //     );\n
    //     element.css(\'top\', absolute_position[1]);\n
    //     element.css(\'left\', absolute_position[0]);\n
    //     gadget.props.jsplumb_instance.repaint(element);\n
    //   });\n
    // }\n
    // function positionGraph(gadget) {\n
    //   $.ajax(\n
    //     \'/positionGraph\',\n
    //     {\n
    //       data: JSON.stringify(getData()),\n
    //       contentType: \'application/json\',\n
    //       type: \'POST\',\n
    //       success: function (data, textStatus, jqXHR) {\n
    //         $.each(data, function (node, pos) {\n
    //           convertToAbsolutePosition(\n
    //             gadget,\n
    //             pos.left,\n
    //             pos.top\n
    //           );\n
    //           updateElementCoordinate(gadget, node, {\n
    //             top: pos.top,\n
    //             left: pos.left\n
    //           });\n
    //         });\n
    //         redraw(gadget);\n
    //       }\n
    //     }\n
    //   );\n
    // }\n
    function removeElement(gadget, node_id) {\n
        var element_id = gadget.props.node_id_to_dom_element_id[node_id];\n
        gadget.props.jsplumb_instance.removeAllEndpoints($(gadget.props.element).find("#" + element_id));\n
        $(gadget.props.element).find("#" + element_id).remove();\n
        delete gadget.props.data.graph.node[node_id];\n
        $.each(gadget.props.data.graph.edge, function(k, v) {\n
            if (node_id === v.source || node_id === v.destination) {\n
                delete gadget.props.data.graph.edge[k];\n
            }\n
        });\n
        gadget.notifyDataChanged();\n
    }\n
    function updateElementData(gadget, node_id, data) {\n
        var element_id = gadget.props.node_id_to_dom_element_id[node_id], new_id = data.id;\n
        if (data.data.name) {\n
            $(gadget.props.element).find("#" + element_id).text(data.data.name).attr("title", data.data.name).append(\'<div class="ep"></div></div>\');\n
            gadget.props.data.graph.node[node_id].name = data.data.name;\n
        }\n
        delete data.id;\n
        $.extend(gadget.props.data.graph.node[node_id], data.data);\n
        if (new_id && new_id !== node_id) {\n
            gadget.props.data.graph.node[new_id] = gadget.props.data.graph.node[node_id];\n
            delete gadget.props.data.graph.node[node_id];\n
            gadget.props.node_id_to_dom_element_id[new_id] = gadget.props.node_id_to_dom_element_id[node_id];\n
            delete gadget.props.node_id_to_dom_element_id[node_id];\n
            delete gadget.props.data.graph.node[new_id].id;\n
            $.each(gadget.props.data.graph.edge, function(k, v) {\n
                if (v.source === node_id) {\n
                    v.source = new_id;\n
                }\n
                if (v.destination === node_id) {\n
                    v.destination = new_id;\n
                }\n
            });\n
        }\n
        gadget.notifyDataChanged();\n
    }\n
    function addEdge(gadget, edge_id, edge_data) {\n
        var overlays = [], connection;\n
        if (edge_data.name) {\n
            overlays = [ [ "Label", {\n
                cssClass: "l1 component label",\n
                label: edge_data.name\n
            } ] ];\n
        }\n
        if (gadget.props.data.graph.node[edge_data.source] === undefined) {\n
            throw new Error("Edge Source " + edge_data.source + " does not exist");\n
        }\n
        if (gadget.props.data.graph.node[edge_data.source] === undefined) {\n
            throw new Error("Edge Destination " + edge_data.source + " does not exist");\n
        }\n
        // If an edge has this data:\n
        // { _class: \'Edge\', \n
        //   source: \'N1\',\n
        //   destination: \'N2\',\n
        //   jsplumb_source_endpoint: \'BottomCenter\',\n
        //   jsplumb_destination_endpoint: \'LeftMiddle\',\n
        //   jsplumb_connector: \'Flowchart\' }\n
        // Then it is rendered using a flowchart connector. The difficulty is that\n
        // jsplumb does not let you configure the connector type on the edge, but\n
        // on the source endpoint. One solution seem to create all types of\n
        // endpoints on nodes.\n
        if (edge_data.jsplumb_connector === "Flowchart") {\n
            connection = gadget.props.jsplumb_instance.connect({\n
                uuids: [ edge_data.source + ".flowChart" + edge_data.jsplumb_source_endpoint, edge_data.destination + ".flowChart" + edge_data.jsplumb_destination_endpoint ],\n
                overlays: overlays\n
            });\n
        } else {\n
            connection = gadget.props.jsplumb_instance.connect({\n
                source: gadget.props.node_id_to_dom_element_id[edge_data.source],\n
                target: gadget.props.node_id_to_dom_element_id[edge_data.destination],\n
                Connector: [ "Bezier", {\n
                    curviness: 75\n
                } ],\n
                overlays: overlays\n
            });\n
        }\n
        // jsplumb assigned an id, but we are controlling ids ourselves.\n
        connection.id = edge_id;\n
    }\n
    function expandSchema(class_definition, full_schema) {\n
        // minimal expanding of json schema, supports merging allOf and $ref\n
        // references\n
        // TODO: check for a library that would provide full support\n
        var property, referenced, i, expanded_class_definition = {\n
            properties: class_definition.properties || {}\n
        };\n
        if (class_definition.allOf) {\n
            for (i = 0; i < class_definition.allOf.length; i += 1) {\n
                referenced = class_definition.allOf[i];\n
                if (referenced.$ref) {\n
                    referenced = expandSchema(full_schema.class_definition[referenced.$ref.substr(1, referenced.$ref.length)], full_schema);\n
                }\n
                if (referenced.properties) {\n
                    for (property in referenced.properties) {\n
                        if (referenced.properties.hasOwnProperty(property)) {\n
                            if (referenced.properties[property].type) {\n
                                expanded_class_definition.properties[property] = referenced.properties[property];\n
                            }\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        return expanded_class_definition;\n
    }\n
    function openNodeDialog(gadget, element) {\n
        var node_id = getNodeId(gadget, element.id), node_data = gadget.props.data.graph.node[node_id], node_edit_popup = $(gadget.props.element).find("#popup-edit-template"), schema, fieldset_element, delete_promise;\n
        // If we have no definition for this, we do not allow edition.\n
        if (gadget.props.data.class_definition[node_data._class] === undefined) {\n
            return;\n
        }\n
        schema = expandSchema(gadget.props.data.class_definition[node_data._class], gadget.props.data);\n
        if (node_edit_popup.length !== 0) {\n
            node_edit_popup.remove();\n
        }\n
        gadget.props.element.appendChild(document.importNode(popup_edit_template.content, true).children[0]);\n
        node_edit_popup = $(gadget.props.element).find("#node-edit-popup");\n
        // Set the name of the popup to the node class\n
        node_edit_popup.find(".node_class").text(node_data._class);\n
        fieldset_element = node_edit_popup.find("fieldset")[0];\n
        node_edit_popup.popup();\n
        node_data.id = node_id;\n
        // XXX\n
        function save_promise(fieldset_gadget, node_id) {\n
            return RSVP.Queue().push(function() {\n
                return promiseEventListener(node_edit_popup.find("form")[0], "submit", false);\n
            }).push(function(evt) {\n
                var data = {\n
                    // XXX id should not be handled differently ...\n
                    id: $(evt.target[1]).val(),\n
                    data: {}\n
                };\n
                return fieldset_gadget.getContent().then(function(r) {\n
                    $.extend(data.data, r);\n
                    updateElementData(gadget, node_id, data);\n
                });\n
            });\n
        }\n
        delete_promise = new RSVP.Queue().push(function() {\n
            return promiseEventListener(node_edit_popup.find("form [type=\'button\']")[0], "click", false);\n
        }).push(function() {\n
            return removeElement(gadget, node_id);\n
        });\n
        return gadget.declareGadget("../fieldset/index.html", {\n
            element: fieldset_element,\n
            scope: "fieldset"\n
        }).push(function(fieldset_gadget) {\n
            return RSVP.all([ fieldset_gadget, fieldset_gadget.render({\n
                value: node_data,\n
                property_definition: schema\n
            }, node_id) ]);\n
        }).push(function(fieldset_gadget) {\n
            node_edit_popup.enhanceWithin();\n
            node_edit_popup.popup("open");\n
            return fieldset_gadget[0];\n
        }).push(function(fieldset_gadget) {\n
            // Expose the dialog handling promise so that we can wait for it in\n
            // test.\n
            gadget.props.dialog_promise = RSVP.any([ save_promise(fieldset_gadget, node_id), delete_promise ]);\n
            return gadget.props.dialog_promise;\n
        }).push(function() {\n
            node_edit_popup.popup("close");\n
            node_edit_popup.remove();\n
            delete gadget.props.dialog_promise;\n
        });\n
    }\n
    function waitForNodeClick(gadget, node) {\n
        gadget.props.nodes_click_monitor.monitor(loopEventListener(node, "dblclick", false, openNodeDialog.bind(null, gadget, node)));\n
    }\n
    function addNode(gadget, node_id, node_data) {\n
        var render_element = $(gadget.props.main), class_definition = gadget.props.data.class_definition[node_data._class], coordinate = node_data.coordinate, dom_element_id, box, absolute_position, domElement;\n
        dom_element_id = generateDomElementId(gadget.props.element);\n
        gadget.props.node_id_to_dom_element_id[node_id] = dom_element_id;\n
        node_data.name = node_data.name || class_definition.name;\n
        gadget.props.data.graph.node[node_id] = node_data;\n
        if (coordinate === undefined) {\n
            coordinate = {\n
                top: 0,\n
                left: 0\n
            };\n
        }\n
        node_data.coordinate = updateElementCoordinate(gadget, node_id, coordinate);\n
        // XXX make node template an option, or use CSS from class_definition\n
        /*jslint nomen: true*/\n
        domElement = domParser.parseFromString(node_template({\n
            "class": node_data._class.replace(".", "-"),\n
            element_id: dom_element_id,\n
            title: node_data.name || node_data.id,\n
            name: node_data.name || node_data.id\n
        }), "text/html").querySelector(".window");\n
        render_element.append(domElement);\n
        waitForNodeClick(gadget, domElement);\n
        box = $(gadget.props.element).find("#" + dom_element_id);\n
        absolute_position = convertToAbsolutePosition(gadget, coordinate.left, coordinate.top);\n
        box.css("top", absolute_position[1]);\n
        box.css("left", absolute_position[0]);\n
        updateNodeStyle(gadget, dom_element_id);\n
        draggable(gadget);\n
        // XXX make only this element draggable.\n
        // Add some flowchart endpoints\n
        // TODO: add them all !\n
        gadget.props.jsplumb_instance.addEndpoint(dom_element_id, {\n
            isSource: true,\n
            maxConnections: -1,\n
            connector: [ "Flowchart", {\n
                stub: [ 40, 60 ],\n
                gap: 10,\n
                cornerRadius: 5,\n
                alwaysRespectStubs: true\n
            } ]\n
        }, {\n
            anchor: "BottomCenter",\n
            uuid: node_id + ".flowchartBottomCenter"\n
        });\n
        gadget.props.jsplumb_instance.addEndpoint(dom_element_id, {\n
            isTarget: true,\n
            maxConnections: -1\n
        }, {\n
            anchor: "LeftMiddle",\n
            uuid: node_id + ".flowChartLeftMiddle"\n
        });\n
        gadget.notifyDataChanged();\n
    }\n
    function waitForDrop(gadget) {\n
        var callback;\n
        function canceller() {\n
            if (callback !== undefined) {\n
                gadget.props.main.removeEventListener("drop", callback, false);\n
            }\n
        }\n
        /*jslint unparam: true*/\n
        function resolver(resolve, reject) {\n
            callback = function(evt) {\n
                try {\n
                    var class_name = JSON.parse(evt.dataTransfer.getData("application/json")), offset = $(gadget.props.main).offset(), relative_position = convertToRelativePosition(gadget, evt.clientX - offset.left + "px", evt.clientY - offset.top + "px");\n
                    addNode(gadget, generateNodeId(gadget, {\n
                        _class: class_name\n
                    }), {\n
                        coordinate: {\n
                            left: relative_position[0],\n
                            top: relative_position[1]\n
                        },\n
                        _class: class_name\n
                    });\n
                } catch (e) {\n
                    reject(e);\n
                }\n
            };\n
            gadget.props.main.addEventListener("drop", callback, false);\n
        }\n
        return new RSVP.all([ // loopEventListener adds an event listener that will prevent default for\n
        // dragover\n
        loopEventListener(gadget.props.main, "dragover", false, function() {\n
            return undefined;\n
        }), RSVP.Promise(resolver, canceller) ]);\n
    }\n
    gadget_klass.ready(function(g) {\n
        g.props = {};\n
        g.props.node_id_to_dom_element_id = {};\n
        g.props.zoom_level = 1;\n
        g.props.style_attr_list = [ "width", "height", "padding-top", "line-height" ];\n
        g.getElement().then(function(element) {\n
            g.props.element = element;\n
        });\n
    }).declareAcquiredMethod("notifyDataChanged", "notifyDataChanged").declareMethod("render", function(data) {\n
        var gadget = this;\n
        this.props.data = {};\n
        console.log("render", data);\n
        if (data.value) {\n
          // Gadget embedded in ERP5\n
          this.props.erp5_key = data.key;\n
          data = data.value;\n
        }\n
        \n
        if (data) {\n
          this.props.data = JSON.parse(data);\n
          // load the data\n
          $.each(this.props.data.graph.node, function(key, value) {\n
              addNode(gadget, key, value);\n
          });\n
          $.each(this.props.data.graph.edge, function(key, value) {\n
              addEdge(gadget, key, value);\n
          });\n
        }\n
        this.props.jsplumb_instance = jsPlumb.getInstance();\n
    }).declareMethod("getContent", function() {\n
        if (this.props.erp5_key) {\n
          // ERP5\n
          return JSON.stringify({key: this.props.erp5_key, value: this.props.data});\n
        }\n
        return JSON.stringify(this.props.data);\n
    }).declareMethod("startService", function() {\n
      // no more needed, see below\n
    }).declareService(function() {\n
        var gadget = this, jsplumb_instance;\n
        this.props.jsplumb_instance = jsPlumb.getInstance();\n
        jsplumb_instance= gadget.props.jsplumb_instance;\n
        this.props.main = this.props.element.querySelector("#main");\n
        jsplumb_instance.setRenderMode(jsplumb_instance.SVG);\n
        jsplumb_instance.importDefaults({\n
            HoverPaintStyle: {\n
                strokeStyle: "#1e8151",\n
                lineWidth: 2\n
            },\n
            Endpoint: [ "Dot", {\n
                radius: 2\n
            } ],\n
            ConnectionOverlays: [ [ "Arrow", {\n
                location: 1,\n
                id: "arrow",\n
                length: 14,\n
                foldback: .8\n
            } ] ],\n
            Container: this.props.main\n
        });\n
        draggable(gadget);\n
        this.props.nodes_click_monitor = RSVP.Monitor();\n
                console.log(this.props.data);\n
        if (this.props.data) {\n
          // load the data\n
          $.each(this.props.data.graph.node, function(key, value) {\n
              addNode(gadget, key, value);\n
          });\n
          $.each(this.props.data.graph.edge, function(key, value) {\n
              addEdge(gadget, key, value);\n
          });\n
        }\n
        return RSVP.all([ waitForDrop(gadget), waitForConnection(gadget), waitForConnectionDetached(gadget), waitForConnectionClick(gadget), gadget.props.nodes_click_monitor ]);\n
    });\n
})(RSVP, rJS, $, jsPlumb, Handlebars, loopEventListener, promiseEventListener, DOMParser);

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>25449</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
