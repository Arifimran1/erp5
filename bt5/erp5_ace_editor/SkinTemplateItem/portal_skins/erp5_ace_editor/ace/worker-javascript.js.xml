<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts77155570.31</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>worker-javascript.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>163954</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>worker-javascript.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

"no use strict";\n
;(function(window) {\n
if (typeof window.window != "undefined" && window.document) {\n
    return;\n
}\n
\n
window.console = {\n
    log: function() {\n
        var msgs = Array.prototype.slice.call(arguments, 0);\n
        postMessage({type: "log", data: msgs});\n
    },\n
    error: function() {\n
        var msgs = Array.prototype.slice.call(arguments, 0);\n
        postMessage({type: "log", data: msgs});\n
    }\n
};\n
window.window = window;\n
window.ace = window;\n
\n
window.normalizeModule = function(parentId, moduleName) {\n
    if (moduleName.indexOf("!") !== -1) {\n
        var chunks = moduleName.split("!");\n
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);\n
    }\n
    if (moduleName.charAt(0) == ".") {\n
        var base = parentId.split("/").slice(0, -1).join("/");\n
        moduleName = base + "/" + moduleName;\n
        \n
        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {\n
            var previous = moduleName;\n
            moduleName = moduleName.replace(/\\/\\.\\//, "/").replace(/[^\\/]+\\/\\.\\.\\//, "");\n
        }\n
    }\n
    \n
    return moduleName;\n
};\n
\n
window.require = function(parentId, id) {\n
    if (!id) {\n
        id = parentId\n
        parentId = null;\n
    }\n
    if (!id.charAt)\n
        throw new Error("worker.js require() accepts only (parentId, id) as arguments");\n
\n
    id = normalizeModule(parentId, id);\n
\n
    var module = require.modules[id];\n
    if (module) {\n
        if (!module.initialized) {\n
            module.initialized = true;\n
            module.exports = module.factory().exports;\n
        }\n
        return module.exports;\n
    }\n
    \n
    var chunks = id.split("/");\n
    chunks[0] = require.tlns[chunks[0]] || chunks[0];\n
    var path = chunks.join("/") + ".js";\n
    \n
    require.id = id;\n
    importScripts(path);\n
    return require(parentId, id);\n
};\n
\n
require.modules = {};\n
require.tlns = {};\n
\n
window.define = function(id, deps, factory) {\n
    if (arguments.length == 2) {\n
        factory = deps;\n
        if (typeof id != "string") {\n
            deps = id;\n
            id = require.id;\n
        }\n
    } else if (arguments.length == 1) {\n
        factory = id;\n
        id = require.id;\n
    }\n
\n
    if (id.indexOf("text!") === 0) \n
        return;\n
    \n
    var req = function(deps, factory) {\n
        return require(id, deps, factory);\n
    };\n
\n
    require.modules[id] = {\n
        factory: function() {\n
            var module = {\n
                exports: {}\n
            };\n
            var returnExports = factory(req, module.exports, module);\n
            if (returnExports)\n
                module.exports = returnExports;\n
            return module;\n
        }\n
    };\n
};\n
\n
window.initBaseUrls  = function initBaseUrls(topLevelNamespaces) {\n
    require.tlns = topLevelNamespaces;\n
}\n
\n
window.initSender = function initSender() {\n
\n
    var EventEmitter = require("ace/lib/event_emitter").EventEmitter;\n
    var oop = require("ace/lib/oop");\n
    \n
    var Sender = function() {};\n
    \n
    (function() {\n
        \n
        oop.implement(this, EventEmitter);\n
                \n
        this.callback = function(data, callbackId) {\n
            postMessage({\n
                type: "call",\n
                id: callbackId,\n
                data: data\n
            });\n
        };\n
    \n
        this.emit = function(name, data) {\n
            postMessage({\n
                type: "event",\n
                name: name,\n
                data: data\n
            });\n
        };\n
        \n
    }).call(Sender.prototype);\n
    \n
    return new Sender();\n
}\n
\n
window.main = null;\n
window.sender = null;\n
\n
window.onmessage = function(e) {\n
    var msg = e.data;\n
    if (msg.command) {\n
        if (main[msg.command])\n
            main[msg.command].apply(main, msg.args);\n
        else\n
            throw new Error("Unknown command:" + msg.command);\n
    }\n
    else if (msg.init) {        \n
        initBaseUrls(msg.tlns);\n
        require("ace/lib/es5-shim");\n
        sender = initSender();\n
        var clazz = require(msg.module)[msg.classname];\n
        main = new clazz(sender);\n
    } \n
    else if (msg.event && sender) {\n
        sender._emit(msg.event, msg.data);\n
    }\n
};\n
})(this);\n
\n
define(\'ace/lib/event_emitter\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
\n
var EventEmitter = {};\n
var stopPropagation = function() { this.propagationStopped = true; };\n
var preventDefault = function() { this.defaultPrevented = true; };\n
\n
EventEmitter._emit =\n
EventEmitter._dispatchEvent = function(eventName, e) {\n
    this._eventRegistry || (this._eventRegistry = {});\n
    this._defaultHandlers || (this._defaultHandlers = {});\n
\n
    var listeners = this._eventRegistry[eventName] || [];\n
    var defaultHandler = this._defaultHandlers[eventName];\n
    if (!listeners.length && !defaultHandler)\n
        return;\n
\n
    if (typeof e != "object" || !e)\n
        e = {};\n
\n
    if (!e.type)\n
        e.type = eventName;\n
    if (!e.stopPropagation)\n
        e.stopPropagation = stopPropagation;\n
    if (!e.preventDefault)\n
        e.preventDefault = preventDefault;\n
\n
    for (var i=0; i<listeners.length; i++) {\n
        listeners[i](e, this);\n
        if (e.propagationStopped)\n
            break;\n
    }\n
    \n
    if (defaultHandler && !e.defaultPrevented)\n
        return defaultHandler(e, this);\n
};\n
\n
\n
EventEmitter._signal = function(eventName, e) {\n
    var listeners = (this._eventRegistry || {})[eventName];\n
    if (!listeners)\n
        return;\n
\n
    for (var i=0; i<listeners.length; i++)\n
        listeners[i](e, this);\n
};\n
\n
EventEmitter.once = function(eventName, callback) {\n
    var _self = this;\n
    callback && this.addEventListener(eventName, function newCallback() {\n
        _self.removeEventListener(eventName, newCallback);\n
        callback.apply(null, arguments);\n
    });\n
};\n
\n
\n
EventEmitter.setDefaultHandler = function(eventName, callback) {\n
    var handlers = this._defaultHandlers\n
    if (!handlers)\n
        handlers = this._defaultHandlers = {_disabled_: {}};\n
    \n
    if (handlers[eventName]) {\n
        var old = handlers[eventName];\n
        var disabled = handlers._disabled_[eventName];\n
        if (!disabled)\n
            handlers._disabled_[eventName] = disabled = [];\n
        disabled.push(old);\n
        var i = disabled.indexOf(callback);\n
        if (i != -1) \n
            disabled.splice(i, 1);\n
    }\n
    handlers[eventName] = callback;\n
};\n
EventEmitter.removeDefaultHandler = function(eventName, callback) {\n
    var handlers = this._defaultHandlers\n
    if (!handlers)\n
        return;\n
    var disabled = handlers._disabled_[eventName];\n
    \n
    if (handlers[eventName] == callback) {\n
        var old = handlers[eventName];\n
        if (disabled)\n
            this.setDefaultHandler(eventName, disabled.pop());\n
    } else if (disabled) {\n
        var i = disabled.indexOf(callback);\n
        if (i != -1)\n
            disabled.splice(i, 1);\n
    }\n
};\n
\n
EventEmitter.on =\n
EventEmitter.addEventListener = function(eventName, callback, capturing) {\n
    this._eventRegistry = this._eventRegistry || {};\n
\n
    var listeners = this._eventRegistry[eventName];\n
    if (!listeners)\n
        listeners = this._eventRegistry[eventName] = [];\n
\n
    if (listeners.indexOf(callback) == -1)\n
        listeners[capturing ? "unshift" : "push"](callback);\n
    return callback;\n
};\n
\n
EventEmitter.off =\n
EventEmitter.removeListener =\n
EventEmitter.removeEventListener = function(eventName, callback) {\n
    this._eventRegistry = this._eventRegistry || {};\n
\n
    var listeners = this._eventRegistry[eventName];\n
    if (!listeners)\n
        return;\n
\n
    var index = listeners.indexOf(callback);\n
    if (index !== -1)\n
        listeners.splice(index, 1);\n
};\n
\n
EventEmitter.removeAllListeners = function(eventName) {\n
    if (this._eventRegistry) this._eventRegistry[eventName] = [];\n
};\n
\n
exports.EventEmitter = EventEmitter;\n
\n
});\n
\n
define(\'ace/lib/oop\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
\n
exports.inherits = (function() {\n
    var tempCtor = function() {};\n
    return function(ctor, superCtor) {\n
        tempCtor.prototype = superCtor.prototype;\n
        ctor.super_ = superCtor.prototype;\n
        ctor.prototype = new tempCtor();\n
        ctor.prototype.constructor = ctor;\n
    };\n
}());\n
\n
exports.mixin = function(obj, mixin) {\n
    for (var key in mixin) {\n
        obj[key] = mixin[key];\n
    }\n
    return obj;\n
};\n
\n
exports.implement = function(proto, mixin) {\n
    exports.mixin(proto, mixin);\n
};\n
\n
});\n
\n
define(\'ace/lib/es5-shim\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
function Empty() {}\n
\n
if (!Function.prototype.bind) {\n
    Function.prototype.bind = function bind(that) { // .length is 1\n
        var target = this;\n
        if (typeof target != "function") {\n
            throw new TypeError("Function.prototype.bind called on incompatible " + target);\n
        }\n
        var args = slice.call(arguments, 1); // for normal call\n
        var bound = function () {\n
\n
            if (this instanceof bound) {\n
\n
                var result = target.apply(\n
                    this,\n
                    args.concat(slice.call(arguments))\n
                );\n
                if (Object(result) === result) {\n
                    return result;\n
                }\n
                return this;\n
\n
            } else {\n
                return target.apply(\n
                    that,\n
                    args.concat(slice.call(arguments))\n
                );\n
\n
            }\n
\n
        };\n
        if(target.prototype) {\n
            Empty.prototype = target.prototype;\n
            bound.prototype = new Empty();\n
            Empty.prototype = null;\n
        }\n
        return bound;\n
    };\n
}\n
var call = Function.prototype.call;\n
var prototypeOfArray = Array.prototype;\n
var prototypeOfObject = Object.prototype;\n
var slice = prototypeOfArray.slice;\n
var _toString = call.bind(prototypeOfObject.toString);\n
var owns = call.bind(prototypeOfObject.hasOwnProperty);\n
var defineGetter;\n
var defineSetter;\n
var lookupGetter;\n
var lookupSetter;\n
var supportsAccessors;\n
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {\n
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n
}\n
if ([1,2].splice(0).length != 2) {\n
    if(function() { // test IE < 9 to splice bug - see issue #138\n
        function makeArray(l) {\n
            var a = new Array(l+2);\n
            a[0] = a[1] = 0;\n
            return a;\n
        }\n
        var array = [], lengthBefore;\n
        \n
        array.splice.apply(array, makeArray(20));\n
        array.splice.apply(array, makeArray(26));\n
\n
        lengthBefore = array.length; //46\n
        array.splice(5, 0, "XXX"); // add one element\n
\n
        lengthBefore + 1 == array.length\n
\n
        if (lengthBefore + 1 == array.length) {\n
            return true;// has right splice implementation without bugs\n
        }\n
    }()) {//IE 6/7\n
        var array_splice = Array.prototype.splice;\n
        Array.prototype.splice = function(start, deleteCount) {\n
            if (!arguments.length) {\n
                return [];\n
            } else {\n
                return array_splice.apply(this, [\n
                    start === void 0 ? 0 : start,\n
                    deleteCount === void 0 ? (this.length - start) : deleteCount\n
                ].concat(slice.call(arguments, 2)))\n
            }\n
        };\n
    } else {//IE8\n
        Array.prototype.splice = function(pos, removeCount){\n
            var length = this.length;\n
            if (pos > 0) {\n
                if (pos > length)\n
                    pos = length;\n
            } else if (pos == void 0) {\n
                pos = 0;\n
            } else if (pos < 0) {\n
                pos = Math.max(length + pos, 0);\n
            }\n
\n
            if (!(pos+removeCount < length))\n
                removeCount = length - pos;\n
\n
            var removed = this.slice(pos, pos+removeCount);\n
            var insert = slice.call(arguments, 2);\n
            var add = insert.length;            \n
            if (pos === length) {\n
                if (add) {\n
                    this.push.apply(this, insert);\n
                }\n
            } else {\n
                var remove = Math.min(removeCount, length - pos);\n
                var tailOldPos = pos + remove;\n
                var tailNewPos = tailOldPos + add - remove;\n
                var tailCount = length - tailOldPos;\n
                var lengthAfterRemove = length - remove;\n
\n
                if (tailNewPos < tailOldPos) { // case A\n
                    for (var i = 0; i < tailCount; ++i) {\n
                        this[tailNewPos+i] = this[tailOldPos+i];\n
                    }\n
                } else if (tailNewPos > tailOldPos) { // case B\n
                    for (i = tailCount; i--; ) {\n
                        this[tailNewPos+i] = this[tailOldPos+i];\n
                    }\n
                } // else, add == remove (nothing to do)\n
\n
                if (add && pos === lengthAfterRemove) {\n
                    this.length = lengthAfterRemove; // truncate array\n
                    this.push.apply(this, insert);\n
                } else {\n
                    this.length = lengthAfterRemove + add; // reserves space\n
                    for (i = 0; i < add; ++i) {\n
                        this[pos+i] = insert[i];\n
                    }\n
                }\n
            }\n
            return removed;\n
        };\n
    }\n
}\n
if (!Array.isArray) {\n
    Array.isArray = function isArray(obj) {\n
        return _toString(obj) == "[object Array]";\n
    };\n
}\n
var boxedString = Object("a"),\n
    splitString = boxedString[0] != "a" || !(0 in boxedString);\n
\n
if (!Array.prototype.forEach) {\n
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            thisp = arguments[1],\n
            i = -1,\n
            length = self.length >>> 0;\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(); // TODO message\n
        }\n
\n
        while (++i < length) {\n
            if (i in self) {\n
                fun.call(thisp, self[i], i, object);\n
            }\n
        }\n
    };\n
}\n
if (!Array.prototype.map) {\n
    Array.prototype.map = function map(fun /*, thisp*/) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            length = self.length >>> 0,\n
            result = Array(length),\n
            thisp = arguments[1];\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
\n
        for (var i = 0; i < length; i++) {\n
            if (i in self)\n
                result[i] = fun.call(thisp, self[i], i, object);\n
        }\n
        return result;\n
    };\n
}\n
if (!Array.prototype.filter) {\n
    Array.prototype.filter = function filter(fun /*, thisp */) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                    object,\n
            length = self.length >>> 0,\n
            result = [],\n
            value,\n
            thisp = arguments[1];\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
\n
        for (var i = 0; i < length; i++) {\n
            if (i in self) {\n
                value = self[i];\n
                if (fun.call(thisp, value, i, object)) {\n
                    result.push(value);\n
                }\n
            }\n
        }\n
        return result;\n
    };\n
}\n
if (!Array.prototype.every) {\n
    Array.prototype.every = function every(fun /*, thisp */) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            length = self.length >>> 0,\n
            thisp = arguments[1];\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
\n
        for (var i = 0; i < length; i++) {\n
            if (i in self && !fun.call(thisp, self[i], i, object)) {\n
                return false;\n
            }\n
        }\n
        return true;\n
    };\n
}\n
if (!Array.prototype.some) {\n
    Array.prototype.some = function some(fun /*, thisp */) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            length = self.length >>> 0,\n
            thisp = arguments[1];\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
\n
        for (var i = 0; i < length; i++) {\n
            if (i in self && fun.call(thisp, self[i], i, object)) {\n
                return true;\n
            }\n
        }\n
        return false;\n
    };\n
}\n
if (!Array.prototype.reduce) {\n
    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            length = self.length >>> 0;\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
        if (!length && arguments.length == 1) {\n
            throw new TypeError("reduce of empty array with no initial value");\n
        }\n
\n
        var i = 0;\n
        var result;\n
        if (arguments.length >= 2) {\n
            result = arguments[1];\n
        } else {\n
            do {\n
                if (i in self) {\n
                    result = self[i++];\n
                    break;\n
                }\n
                if (++i >= length) {\n
                    throw new TypeError("reduce of empty array with no initial value");\n
                }\n
            } while (true);\n
        }\n
\n
        for (; i < length; i++) {\n
            if (i in self) {\n
                result = fun.call(void 0, result, self[i], i, object);\n
            }\n
        }\n
\n
        return result;\n
    };\n
}\n
if (!Array.prototype.reduceRight) {\n
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n
        var object = toObject(this),\n
            self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                object,\n
            length = self.length >>> 0;\n
        if (_toString(fun) != "[object Function]") {\n
            throw new TypeError(fun + " is not a function");\n
        }\n
        if (!length && arguments.length == 1) {\n
            throw new TypeError("reduceRight of empty array with no initial value");\n
        }\n
\n
        var result, i = length - 1;\n
        if (arguments.length >= 2) {\n
            result = arguments[1];\n
        } else {\n
            do {\n
                if (i in self) {\n
                    result = self[i--];\n
                    break;\n
                }\n
                if (--i < 0) {\n
                    throw new TypeError("reduceRight of empty array with no initial value");\n
                }\n
            } while (true);\n
        }\n
\n
        do {\n
            if (i in this) {\n
                result = fun.call(void 0, result, self[i], i, object);\n
            }\n
        } while (i--);\n
\n
        return result;\n
    };\n
}\n
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {\n
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n
        var self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                toObject(this),\n
            length = self.length >>> 0;\n
\n
        if (!length) {\n
            return -1;\n
        }\n
\n
        var i = 0;\n
        if (arguments.length > 1) {\n
            i = toInteger(arguments[1]);\n
        }\n
        i = i >= 0 ? i : Math.max(0, length + i);\n
        for (; i < length; i++) {\n
            if (i in self && self[i] === sought) {\n
                return i;\n
            }\n
        }\n
        return -1;\n
    };\n
}\n
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {\n
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n
        var self = splitString && _toString(this) == "[object String]" ?\n
                this.split("") :\n
                toObject(this),\n
            length = self.length >>> 0;\n
\n
        if (!length) {\n
            return -1;\n
        }\n
        var i = length - 1;\n
        if (arguments.length > 1) {\n
            i = Math.min(i, toInteger(arguments[1]));\n
        }\n
        i = i >= 0 ? i : length - Math.abs(i);\n
        for (; i >= 0; i--) {\n
            if (i in self && sought === self[i]) {\n
                return i;\n
            }\n
        }\n
        return -1;\n
    };\n
}\n
if (!Object.getPrototypeOf) {\n
    Object.getPrototypeOf = function getPrototypeOf(object) {\n
        return object.__proto__ || (\n
            object.constructor ?\n
            object.constructor.prototype :\n
            prototypeOfObject\n
        );\n
    };\n
}\n
if (!Object.getOwnPropertyDescriptor) {\n
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +\n
                         "non-object: ";\n
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n
        if ((typeof object != "object" && typeof object != "function") || object === null)\n
            throw new TypeError(ERR_NON_OBJECT + object);\n
        if (!owns(object, property))\n
            return;\n
\n
        var descriptor, getter, setter;\n
        descriptor =  { enumerable: true, configurable: true };\n
        if (supportsAccessors) {\n
            var prototype = object.__proto__;\n
            object.__proto__ = prototypeOfObject;\n
\n
            var getter = lookupGetter(object, property);\n
            var setter = lookupSetter(object, property);\n
            object.__proto__ = prototype;\n
\n
            if (getter || setter) {\n
                if (getter) descriptor.get = getter;\n
                if (setter) descriptor.set = setter;\n
                return descriptor;\n
            }\n
        }\n
        descriptor.value = object[property];\n
        return descriptor;\n
    };\n
}\n
if (!Object.getOwnPropertyNames) {\n
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n
        return Object.keys(object);\n
    };\n
}\n
if (!Object.create) {\n
    var createEmpty;\n
    if (Object.prototype.__proto__ === null) {\n
        createEmpty = function () {\n
            return { "__proto__": null };\n
        };\n
    } else {\n
        createEmpty = function () {\n
            var empty = {};\n
            for (var i in empty)\n
                empty[i] = null;\n
            empty.constructor =\n
            empty.hasOwnProperty =\n
            empty.propertyIsEnumerable =\n
            empty.isPrototypeOf =\n
            empty.toLocaleString =\n
            empty.toString =\n
            empty.valueOf =\n
            empty.__proto__ = null;\n
            return empty;\n
        }\n
    }\n
\n
    Object.create = function create(prototype, properties) {\n
        var object;\n
        if (prototype === null) {\n
            object = createEmpty();\n
        } else {\n
            if (typeof prototype != "object")\n
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != \'object\'");\n
            var Type = function () {};\n
            Type.prototype = prototype;\n
            object = new Type();\n
            object.__proto__ = prototype;\n
        }\n
        if (properties !== void 0)\n
            Object.defineProperties(object, properties);\n
        return object;\n
    };\n
}\n
\n
function doesDefinePropertyWork(object) {\n
    try {\n
        Object.defineProperty(object, "sentinel", {});\n
        return "sentinel" in object;\n
    } catch (exception) {\n
    }\n
}\n
if (Object.defineProperty) {\n
    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n
    var definePropertyWorksOnDom = typeof document == "undefined" ||\n
        doesDefinePropertyWork(document.createElement("div"));\n
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n
        var definePropertyFallback = Object.defineProperty;\n
    }\n
}\n
\n
if (!Object.defineProperty || definePropertyFallback) {\n
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";\n
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "\n
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +\n
                                      "on this javascript engine";\n
\n
    Object.defineProperty = function defineProperty(object, property, descriptor) {\n
        if ((typeof object != "object" && typeof object != "function") || object === null)\n
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)\n
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n
        if (definePropertyFallback) {\n
            try {\n
                return definePropertyFallback.call(Object, object, property, descriptor);\n
            } catch (exception) {\n
            }\n
        }\n
        if (owns(descriptor, "value")) {\n
\n
            if (supportsAccessors && (lookupGetter(object, property) ||\n
                                      lookupSetter(object, property)))\n
            {\n
                var prototype = object.__proto__;\n
                object.__proto__ = prototypeOfObject;\n
                delete object[property];\n
                object[property] = descriptor.value;\n
                object.__proto__ = prototype;\n
            } else {\n
                object[property] = descriptor.value;\n
            }\n
        } else {\n
            if (!supportsAccessors)\n
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n
            if (owns(descriptor, "get"))\n
                defineGetter(object, property, descriptor.get);\n
            if (owns(descriptor, "set"))\n
                defineSetter(object, property, descriptor.set);\n
        }\n
\n
        return object;\n
    };\n
}\n
if (!Object.defineProperties) {\n
    Object.defineProperties = function defineProperties(object, properties) {\n
        for (var property in properties) {\n
            if (owns(properties, property))\n
                Object.defineProperty(object, property, properties[property]);\n
        }\n
        return object;\n
    };\n
}\n
if (!Object.seal) {\n
    Object.seal = function seal(object) {\n
        return object;\n
    };\n
}\n
if (!Object.freeze) {\n
    Object.freeze = function freeze(object) {\n
        return object;\n
    };\n
}\n
try {\n
    Object.freeze(function () {});\n
} catch (exception) {\n
    Object.freeze = (function freeze(freezeObject) {\n
        return function freeze(object) {\n
            if (typeof object == "function") {\n
                return object;\n
            } else {\n
                return freezeObject(object);\n
            }\n
        };\n
    })(Object.freeze);\n
}\n
if (!Object.preventExtensions) {\n
    Object.preventExtensions = function preventExtensions(object) {\n
        return object;\n
    };\n
}\n
if (!Object.isSealed) {\n
    Object.isSealed = function isSealed(object) {\n
        return false;\n
    };\n
}\n
if (!Object.isFrozen) {\n
    Object.isFrozen = function isFrozen(object) {\n
        return false;\n
    };\n
}\n
if (!Object.isExtensible) {\n
    Object.isExtensible = function isExtensible(object) {\n
        if (Object(object) === object) {\n
            throw new TypeError(); // TODO message\n
        }\n
        var name = \'\';\n
        while (owns(object, name)) {\n
            name += \'?\';\n
        }\n
        object[name] = true;\n
        var returnValue = owns(object, name);\n
        delete object[name];\n
        return returnValue;\n
    };\n
}\n
if (!Object.keys) {\n
    var hasDontEnumBug = true,\n
        dontEnums = [\n
            "toString",\n
            "toLocaleString",\n
            "valueOf",\n
            "hasOwnProperty",\n
            "isPrototypeOf",\n
            "propertyIsEnumerable",\n
            "constructor"\n
        ],\n
        dontEnumsLength = dontEnums.length;\n
\n
    for (var key in {"toString": null}) {\n
        hasDontEnumBug = false;\n
    }\n
\n
    Object.keys = function keys(object) {\n
\n
        if (\n
            (typeof object != "object" && typeof object != "function") ||\n
            object === null\n
        ) {\n
            throw new TypeError("Object.keys called on a non-object");\n
        }\n
\n
        var keys = [];\n
        for (var name in object) {\n
            if (owns(object, name)) {\n
                keys.push(name);\n
            }\n
        }\n
\n
        if (hasDontEnumBug) {\n
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n
                var dontEnum = dontEnums[i];\n
                if (owns(object, dontEnum)) {\n
                    keys.push(dontEnum);\n
                }\n
            }\n
        }\n
        return keys;\n
    };\n
\n
}\n
if (!Date.now) {\n
    Date.now = function now() {\n
        return new Date().getTime();\n
    };\n
}\n
var ws = "\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003" +\n
    "\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028" +\n
    "\\u2029\\uFEFF";\n
if (!String.prototype.trim || ws.trim()) {\n
    ws = "[" + ws + "]";\n
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),\n
        trimEndRegexp = new RegExp(ws + ws + "*$");\n
    String.prototype.trim = function trim() {\n
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");\n
    };\n
}\n
\n
function toInteger(n) {\n
    n = +n;\n
    if (n !== n) { // isNaN\n
        n = 0;\n
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n
        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n
    }\n
    return n;\n
}\n
\n
function isPrimitive(input) {\n
    var type = typeof input;\n
    return (\n
        input === null ||\n
        type === "undefined" ||\n
        type === "boolean" ||\n
        type === "number" ||\n
        type === "string"\n
    );\n
}\n
\n
function toPrimitive(input) {\n
    var val, valueOf, toString;\n
    if (isPrimitive(input)) {\n
        return input;\n
    }\n
    valueOf = input.valueOf;\n
    if (typeof valueOf === "function") {\n
        val = valueOf.call(input);\n
        if (isPrimitive(val)) {\n
            return val;\n
        }\n
    }\n
    toString = input.toString;\n
    if (typeof toString === "function") {\n
        val = toString.call(input);\n
        if (isPrimitive(val)) {\n
            return val;\n
        }\n
    }\n
    throw new TypeError();\n
}\n
var toObject = function (o) {\n
    if (o == null) { // this matches both null and undefined\n
        throw new TypeError("can\'t convert "+o+" to object");\n
    }\n
    return Object(o);\n
};\n
\n
});\n
\n
define(\'ace/mode/javascript_worker\', [\'require\', \'exports\', \'module\' , \'ace/lib/oop\', \'ace/worker/mirror\', \'ace/mode/javascript/jshint\'], function(require, exports, module) {\n
\n
\n
var oop = require("../lib/oop");\n
var Mirror = require("../worker/mirror").Mirror;\n
var lint = require("./javascript/jshint").JSHINT;\n
\n
function startRegex(arr) {\n
    return RegExp("^(" + arr.join("|") + ")");\n
}\n
\n
var disabledWarningsRe = startRegex([\n
    "Bad for in variable \'(.+)\'.",\n
    \'Missing "use strict"\'\n
]);\n
var errorsRe = startRegex([\n
    "Unexpected",\n
    "Expected ",\n
    "Confusing (plus|minus)",\n
    "\\\\{a\\\\} unterminated regular expression",\n
    "Unclosed ",\n
    "Unmatched ",\n
    "Unbegun comment",\n
    "Bad invocation",\n
    "Missing space after",\n
    "Missing operator at"\n
]);\n
var infoRe = startRegex([\n
    "Expected an assignment",\n
    "Bad escapement of EOL",\n
    "Unexpected comma",\n
    "Unexpected space",\n
    "Missing radix parameter.",\n
    "A leading decimal point can",\n
    "\\\\[\'{a}\'\\\\] is better written in dot notation.",\n
    "\'{a}\' used out of scope"\n
]);\n
\n
var JavaScriptWorker = exports.JavaScriptWorker = function(sender) {\n
    Mirror.call(this, sender);\n
    this.setTimeout(500);\n
    this.setOptions();\n
};\n
\n
oop.inherits(JavaScriptWorker, Mirror);\n
\n
(function() {\n
    this.setOptions = function(options) {\n
        this.options = options || {\n
            es5: true,\n
            esnext: true,\n
            devel: true,\n
            browser: true,\n
            node: true,\n
            laxcomma: true,\n
            laxbreak: true,\n
            lastsemic: true,\n
            onevar: false,\n
            passfail: false,\n
            maxerr: 100,\n
            expr: true,\n
            multistr: true,\n
            globalstrict: true\n
        };\n
        this.doc.getValue() && this.deferredUpdate.schedule(100);\n
    };\n
\n
    this.changeOptions = function(newOptions) {\n
        oop.mixin(this.options, newOptions);\n
        this.doc.getValue() && this.deferredUpdate.schedule(100);\n
    };\n
\n
    this.isValidJS = function(str) {\n
        try {\n
            eval("throw 0;" + str);\n
        } catch(e) {\n
            if (e === 0)\n
                return true;\n
        }\n
        return false\n
    };\n
\n
    this.onUpdate = function() {\n
        var value = this.doc.getValue();\n
        value = value.replace(/^#!.*\\n/, "\\n");\n
        if (!value) {\n
            this.sender.emit("jslint", []);\n
            return;\n
        }\n
        var errors = [];\n
        var maxErrorLevel = this.isValidJS(value) ? "warning" : "error";\n
        lint(value, this.options);\n
        var results = lint.errors;\n
\n
        var errorAdded = false\n
        for (var i = 0; i < results.length; i++) {\n
            var error = results[i];\n
            if (!error)\n
                continue;\n
            var raw = error.raw;\n
            var type = "warning";\n
\n
            if (raw == "Missing semicolon.") {\n
                var str = error.evidence.substr(error.character);\n
                str = str.charAt(str.search(/\\S/));\n
                if (maxErrorLevel == "error" && str && /[\\w\\d{([\'"]/.test(str)) {\n
                    error.reason = \'Missing ";" before statement\';\n
                    type = "error";\n
                } else {\n
                    type = "info";\n
                }\n
            }\n
            else if (disabledWarningsRe.test(raw)) {\n
                continue;\n
            }\n
            else if (infoRe.test(raw)) {\n
                type = "info"\n
            }\n
            else if (errorsRe.test(raw)) {\n
                errorAdded  = true;\n
                type = maxErrorLevel;\n
            }\n
            else if (raw == "\'{a}\' is not defined.") {\n
                type = "warning";\n
            }\n
            else if (raw == "\'{a}\' is defined but never used.") {\n
                type = "info";\n
            }\n
\n
            errors.push({\n
                row: error.line-1,\n
                column: error.character-1,\n
                text: error.reason,\n
                type: type,\n
                raw: raw\n
            });\n
\n
            if (errorAdded) {\n
            }\n
        }\n
\n
        this.sender.emit("jslint", errors);\n
    };\n
\n
}).call(JavaScriptWorker.prototype);\n
\n
});\n
define(\'ace/worker/mirror\', [\'require\', \'exports\', \'module\' , \'ace/document\', \'ace/lib/lang\'], function(require, exports, module) {\n
\n
\n
var Document = require("../document").Document;\n
var lang = require("../lib/lang");\n
    \n
var Mirror = exports.Mirror = function(sender) {\n
    this.sender = sender;\n
    var doc = this.doc = new Document("");\n
    \n
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n
    \n
    var _self = this;\n
    sender.on("change", function(e) {\n
        doc.applyDeltas(e.data);\n
        deferredUpdate.schedule(_self.$timeout);\n
    });\n
};\n
\n
(function() {\n
    \n
    this.$timeout = 500;\n
    \n
    this.setTimeout = function(timeout) {\n
        this.$timeout = timeout;\n
    };\n
    \n
    this.setValue = function(value) {\n
        this.doc.setValue(value);\n
        this.deferredUpdate.schedule(this.$timeout);\n
    };\n
    \n
    this.getValue = function(callbackId) {\n
        this.sender.callback(this.doc.getValue(), callbackId);\n
    };\n
    \n
    this.onUpdate = function() {\n
    };\n
    \n
}).call(Mirror.prototype);\n
\n
});\n
\n
define(\'ace/document\', [\'require\', \'exports\', \'module\' , \'ace/lib/oop\', \'ace/lib/event_emitter\', \'ace/range\', \'ace/anchor\'], function(require, exports, module) {\n
\n
\n
var oop = require("./lib/oop");\n
var EventEmitter = require("./lib/event_emitter").EventEmitter;\n
var Range = require("./range").Range;\n
var Anchor = require("./anchor").Anchor;\n
\n
var Document = function(text) {\n
    this.$lines = [];\n
    if (text.length == 0) {\n
        this.$lines = [""];\n
    } else if (Array.isArray(text)) {\n
        this._insertLines(0, text);\n
    } else {\n
        this.insert({row: 0, column:0}, text);\n
    }\n
};\n
\n
(function() {\n
\n
    oop.implement(this, EventEmitter);\n
    this.setValue = function(text) {\n
        var len = this.getLength();\n
        this.remove(new Range(0, 0, len, this.getLine(len-1).length));\n
        this.insert({row: 0, column:0}, text);\n
    };\n
    this.getValue = function() {\n
        return this.getAllLines().join(this.getNewLineCharacter());\n
    };\n
    this.createAnchor = function(row, column) {\n
        return new Anchor(this, row, column);\n
    };\n
    if ("aaa".split(/a/).length == 0)\n
        this.$split = function(text) {\n
            return text.replace(/\\r\\n|\\r/g, "\\n").split("\\n");\n
        }\n
    else\n
        this.$split = function(text) {\n
            return text.split(/\\r\\n|\\r|\\n/);\n
        };\n
\n
\n
    this.$detectNewLine = function(text) {\n
        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n
        this.$autoNewLine = match ? match[1] : "\\n";\n
    };\n
    this.getNewLineCharacter = function() {\n
        switch (this.$newLineMode) {\n
          case "windows":\n
            return "\\r\\n";\n
          case "unix":\n
            return "\\n";\n
          default:\n
            return this.$autoNewLine;\n
        }\n
    };\n
\n
    this.$autoNewLine = "\\n";\n
    this.$newLineMode = "auto";\n
    this.setNewLineMode = function(newLineMode) {\n
        if (this.$newLineMode === newLineMode)\n
            return;\n
\n
        this.$newLineMode = newLineMode;\n
    };\n
    this.getNewLineMode = function() {\n
        return this.$newLineMode;\n
    };\n
    this.isNewLine = function(text) {\n
        return (text == "\\r\\n" || text == "\\r" || text == "\\n");\n
    };\n
    this.getLine = function(row) {\n
        return this.$lines[row] || "";\n
    };\n
    this.getLines = function(firstRow, lastRow) {\n
        return this.$lines.slice(firstRow, lastRow + 1);\n
    };\n
    this.getAllLines = function() {\n
        return this.getLines(0, this.getLength());\n
    };\n
    this.getLength = function() {\n
        return this.$lines.length;\n
    };\n
    this.getTextRange = function(range) {\n
        if (range.start.row == range.end.row) {\n
            return this.$lines[range.start.row]\n
                .substring(range.start.column, range.end.column);\n
        }\n
        var lines = this.getLines(range.start.row, range.end.row);\n
        lines[0] = (lines[0] || "").substring(range.start.column);\n
        var l = lines.length - 1;\n
        if (range.end.row - range.start.row == l)\n
            lines[l] = lines[l].substring(0, range.end.column);\n
        return lines.join(this.getNewLineCharacter());\n
    };\n
\n
    this.$clipPosition = function(position) {\n
        var length = this.getLength();\n
        if (position.row >= length) {\n
            position.row = Math.max(0, length - 1);\n
            position.column = this.getLine(length-1).length;\n
        } else if (position.row < 0)\n
            position.row = 0;\n
        return position;\n
    };\n
    this.insert = function(position, text) {\n
        if (!text || text.length === 0)\n
            return position;\n
\n
        position = this.$clipPosition(position);\n
        if (this.getLength() <= 1)\n
            this.$detectNewLine(text);\n
\n
        var lines = this.$split(text);\n
        var firstLine = lines.splice(0, 1)[0];\n
        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];\n
\n
        position = this.insertInLine(position, firstLine);\n
        if (lastLine !== null) {\n
            position = this.insertNewLine(position); // terminate first line\n
            position = this._insertLines(position.row, lines);\n
            position = this.insertInLine(position, lastLine || "");\n
        }\n
        return position;\n
    };\n
    this.insertLines = function(row, lines) {\n
        if (row >= this.getLength())\n
            return this.insert({row: row, column: 0}, "\\n" + lines.join("\\n"));\n
        return this._insertLines(Math.max(row, 0), lines);\n
    };\n
    this._insertLines = function(row, lines) {\n
        if (lines.length == 0)\n
            return {row: row, column: 0};\n
        if (lines.length > 0xFFFF) {\n
            var end = this._insertLines(row, lines.slice(0xFFFF));\n
            lines = lines.slice(0, 0xFFFF);\n
        }\n
\n
        var args = [row, 0];\n
        args.push.apply(args, lines);\n
        this.$lines.splice.apply(this.$lines, args);\n
\n
        var range = new Range(row, 0, row + lines.length, 0);\n
        var delta = {\n
            action: "insertLines",\n
            range: range,\n
            lines: lines\n
        };\n
        this._emit("change", { data: delta });\n
        return end || range.end;\n
    };\n
    this.insertNewLine = function(position) {\n
        position = this.$clipPosition(position);\n
        var line = this.$lines[position.row] || "";\n
\n
        this.$lines[position.row] = line.substring(0, position.column);\n
        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));\n
\n
        var end = {\n
            row : position.row + 1,\n
            column : 0\n
        };\n
\n
        var delta = {\n
            action: "insertText",\n
            range: Range.fromPoints(position, end),\n
            text: this.getNewLineCharacter()\n
        };\n
        this._emit("change", { data: delta });\n
\n
        return end;\n
    };\n
    this.insertInLine = function(position, text) {\n
        if (text.length == 0)\n
            return position;\n
\n
        var line = this.$lines[position.row] || "";\n
\n
        this.$lines[position.row] = line.substring(0, position.column) + text\n
                + line.substring(position.column);\n
\n
        var end = {\n
            row : position.row,\n
            column : position.column + text.length\n
        };\n
\n
        var delta = {\n
            action: "insertText",\n
            range: Range.fromPoints(position, end),\n
            text: text\n
        };\n
        this._emit("change", { data: delta });\n
\n
        return end;\n
    };\n
    this.remove = function(range) {\n
        range.start = this.$clipPosition(range.start);\n
        range.end = this.$clipPosition(range.end);\n
\n
        if (range.isEmpty())\n
            return range.start;\n
\n
        var firstRow = range.start.row;\n
        var lastRow = range.end.row;\n
\n
        if (range.isMultiLine()) {\n
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;\n
            var lastFullRow = lastRow - 1;\n
\n
            if (range.end.column > 0)\n
                this.removeInLine(lastRow, 0, range.end.column);\n
\n
            if (lastFullRow >= firstFullRow)\n
                this._removeLines(firstFullRow, lastFullRow);\n
\n
            if (firstFullRow != firstRow) {\n
                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);\n
                this.removeNewLine(range.start.row);\n
            }\n
        }\n
        else {\n
            this.removeInLine(firstRow, range.start.column, range.end.column);\n
        }\n
        return range.start;\n
    };\n
    this.removeInLine = function(row, startColumn, endColumn) {\n
        if (startColumn == endColumn)\n
            return;\n
\n
        var range = new Range(row, startColumn, row, endColumn);\n
        var line = this.getLine(row);\n
        var removed = line.substring(startColumn, endColumn);\n
        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);\n
        this.$lines.splice(row, 1, newLine);\n
\n
        var delta = {\n
            action: "removeText",\n
            range: range,\n
            text: removed\n
        };\n
        this._emit("change", { data: delta });\n
        return range.start;\n
    };\n
    this.removeLines = function(firstRow, lastRow) {\n
        if (firstRow < 0 || lastRow >= this.getLength())\n
            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));\n
        return this._removeLines(firstRow, lastRow);\n
    };\n
\n
    this._removeLines = function(firstRow, lastRow) {\n
        var range = new Range(firstRow, 0, lastRow + 1, 0);\n
        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);\n
\n
        var delta = {\n
            action: "removeLines",\n
            range: range,\n
            nl: this.getNewLineCharacter(),\n
            lines: removed\n
        };\n
        this._emit("change", { data: delta });\n
        return removed;\n
    };\n
    this.removeNewLine = function(row) {\n
        var firstLine = this.getLine(row);\n
        var secondLine = this.getLine(row+1);\n
\n
        var range = new Range(row, firstLine.length, row+1, 0);\n
        var line = firstLine + secondLine;\n
\n
        this.$lines.splice(row, 2, line);\n
\n
        var delta = {\n
            action: "removeText",\n
            range: range,\n
            text: this.getNewLineCharacter()\n
        };\n
        this._emit("change", { data: delta });\n
    };\n
    this.replace = function(range, text) {\n
        if (text.length == 0 && range.isEmpty())\n
            return range.start;\n
        if (text == this.getTextRange(range))\n
            return range.end;\n
\n
        this.remove(range);\n
        if (text) {\n
            var end = this.insert(range.start, text);\n
        }\n
        else {\n
            end = range.start;\n
        }\n
\n
        return end;\n
    };\n
    this.applyDeltas = function(deltas) {\n
        for (var i=0; i<deltas.length; i++) {\n
            var delta = deltas[i];\n
            var range = Range.fromPoints(delta.range.start, delta.range.end);\n
\n
            if (delta.action == "insertLines")\n
                this.insertLines(range.start.row, delta.lines);\n
            else if (delta.action == "insertText")\n
                this.insert(range.start, delta.text);\n
            else if (delta.action == "removeLines")\n
                this._removeLines(range.start.row, range.end.row - 1);\n
            else if (delta.action == "removeText")\n
                this.remove(range);\n
        }\n
    };\n
    this.revertDeltas = function(deltas) {\n
        for (var i=deltas.length-1; i>=0; i--) {\n
            var delta = deltas[i];\n
\n
            var range = Range.fromPoints(delta.range.start, delta.range.end);\n
\n
            if (delta.action == "insertLines")\n
                this._removeLines(range.start.row, range.end.row - 1);\n
            else if (delta.action == "insertText")\n
                this.remove(range);\n
            else if (delta.action == "removeLines")\n
                this._insertLines(range.start.row, delta.lines);\n
            else if (delta.action == "removeText")\n
                this.insert(range.start, delta.text);\n
        }\n
    };\n
    this.indexToPosition = function(index, startRow) {\n
        var lines = this.$lines || this.getAllLines();\n
        var newlineLength = this.getNewLineCharacter().length;\n
        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n
            index -= lines[i].length + newlineLength;\n
            if (index < 0)\n
                return {row: i, column: index + lines[i].length + newlineLength};\n
        }\n
        return {row: l-1, column: lines[l-1].length};\n
    };\n
    this.positionToIndex = function(pos, startRow) {\n
        var lines = this.$lines || this.getAllLines();\n
        var newlineLength = this.getNewLineCharacter().length;\n
        var index = 0;\n
        var row = Math.min(pos.row, lines.length);\n
        for (var i = startRow || 0; i < row; ++i)\n
            index += lines[i].length + newlineLength;\n
\n
        return index + pos.column;\n
    };\n
\n
}).call(Document.prototype);\n
\n
exports.Document = Document;\n
});\n
\n
define(\'ace/range\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
var comparePoints = function(p1, p2) {\n
    return p1.row - p2.row || p1.column - p2.column;\n
};\n
var Range = function(startRow, startColumn, endRow, endColumn) {\n
    this.start = {\n
        row: startRow,\n
        column: startColumn\n
    };\n
\n
    this.end = {\n
        row: endRow,\n
        column: endColumn\n
    };\n
};\n
\n
(function() {\n
    this.isEqual = function(range) {\n
        return this.start.row === range.start.row &&\n
            this.end.row === range.end.row &&\n
            this.start.column === range.start.column &&\n
            this.end.column === range.end.column;\n
    };\n
    this.toString = function() {\n
        return ("Range: [" + this.start.row + "/" + this.start.column +\n
            "] -> [" + this.end.row + "/" + this.end.column + "]");\n
    };\n
\n
    this.contains = function(row, column) {\n
        return this.compare(row, column) == 0;\n
    };\n
    this.compareRange = function(range) {\n
        var cmp,\n
            end = range.end,\n
            start = range.start;\n
\n
        cmp = this.compare(end.row, end.column);\n
        if (cmp == 1) {\n
            cmp = this.compare(start.row, start.column);\n
            if (cmp == 1) {\n
                return 2;\n
            } else if (cmp == 0) {\n
                return 1;\n
            } else {\n
                return 0;\n
            }\n
        } else if (cmp == -1) {\n
            return -2;\n
        } else {\n
            cmp = this.compare(start.row, start.column);\n
            if (cmp == -1) {\n
                return -1;\n
            } else if (cmp == 1) {\n
                return 42;\n
            } else {\n
                return 0;\n
            }\n
        }\n
    };\n
    this.comparePoint = function(p) {\n
        return this.compare(p.row, p.column);\n
    };\n
    this.containsRange = function(range) {\n
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n
    };\n
    this.intersects = function(range) {\n
        var cmp = this.compareRange(range);\n
        return (cmp == -1 || cmp == 0 || cmp == 1);\n
    };\n
    this.isEnd = function(row, column) {\n
        return this.end.row == row && this.end.column == column;\n
    };\n
    this.isStart = function(row, column) {\n
        return this.start.row == row && this.start.column == column;\n
    };\n
    this.setStart = function(row, column) {\n
        if (typeof row == "object") {\n
            this.start.column = row.column;\n
            this.start.row = row.row;\n
        } else {\n
            this.start.row = row;\n
            this.start.column = column;\n
        }\n
    };\n
    this.setEnd = function(row, column) {\n
        if (typeof row == "object") {\n
            this.end.column = row.column;\n
            this.end.row = row.row;\n
        } else {\n
            this.end.row = row;\n
            this.end.column = column;\n
        }\n
    };\n
    this.inside = function(row, column) {\n
        if (this.compare(row, column) == 0) {\n
            if (this.isEnd(row, column) || this.isStart(row, column)) {\n
                return false;\n
            } else {\n
                return true;\n
            }\n
        }\n
        return false;\n
    };\n
    this.insideStart = function(row, column) {\n
        if (this.compare(row, column) == 0) {\n
            if (this.isEnd(row, column)) {\n
                return false;\n
            } else {\n
                return true;\n
            }\n
        }\n
        return false;\n
    };\n
    this.insideEnd = function(row, column) {\n
        if (this.compare(row, column) == 0) {\n
            if (this.isStart(row, column)) {\n
                return false;\n
            } else {\n
                return true;\n
            }\n
        }\n
        return false;\n
    };\n
    this.compare = function(row, column) {\n
        if (!this.isMultiLine()) {\n
            if (row === this.start.row) {\n
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n
            };\n
        }\n
\n
        if (row < this.start.row)\n
            return -1;\n
\n
        if (row > this.end.row)\n
            return 1;\n
\n
        if (this.start.row === row)\n
            return column >= this.start.column ? 0 : -1;\n
\n
        if (this.end.row === row)\n
            return column <= this.end.column ? 0 : 1;\n
\n
        return 0;\n
    };\n
    this.compareStart = function(row, column) {\n
        if (this.start.row == row && this.start.column == column) {\n
            return -1;\n
        } else {\n
            return this.compare(row, column);\n
        }\n
    };\n
    this.compareEnd = function(row, column) {\n
        if (this.end.row == row && this.end.column == column) {\n
            return 1;\n
        } else {\n
            return this.compare(row, column);\n
        }\n
    };\n
    this.compareInside = function(row, column) {\n
        if (this.end.row == row && this.end.column == column) {\n
            return 1;\n
        } else if (this.start.row == row && this.start.column == column) {\n
            return -1;\n
        } else {\n
            return this.compare(row, column);\n
        }\n
    };\n
    this.clipRows = function(firstRow, lastRow) {\n
        if (this.end.row > lastRow)\n
            var end = {row: lastRow + 1, column: 0};\n
        else if (this.end.row < firstRow)\n
            var end = {row: firstRow, column: 0};\n
\n
        if (this.start.row > lastRow)\n
            var start = {row: lastRow + 1, column: 0};\n
        else if (this.start.row < firstRow)\n
            var start = {row: firstRow, column: 0};\n
\n
        return Range.fromPoints(start || this.start, end || this.end);\n
    };\n
    this.extend = function(row, column) {\n
        var cmp = this.compare(row, column);\n
\n
        if (cmp == 0)\n
            return this;\n
        else if (cmp == -1)\n
            var start = {row: row, column: column};\n
        else\n
            var end = {row: row, column: column};\n
\n
        return Range.fromPoints(start || this.start, end || this.end);\n
    };\n
\n
    this.isEmpty = function() {\n
        return (this.start.row === this.end.row && this.start.column === this.end.column);\n
    };\n
    this.isMultiLine = function() {\n
        return (this.start.row !== this.end.row);\n
    };\n
    this.clone = function() {\n
        return Range.fromPoints(this.start, this.end);\n
    };\n
    this.collapseRows = function() {\n
        if (this.end.column == 0)\n
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)\n
        else\n
            return new Range(this.start.row, 0, this.end.row, 0)\n
    };\n
    this.toScreenRange = function(session) {\n
        var screenPosStart = session.documentToScreenPosition(this.start);\n
        var screenPosEnd = session.documentToScreenPosition(this.end);\n
\n
        return new Range(\n
            screenPosStart.row, screenPosStart.column,\n
            screenPosEnd.row, screenPosEnd.column\n
        );\n
    };\n
    this.moveBy = function(row, column) {\n
        this.start.row += row;\n
        this.start.column += column;\n
        this.end.row += row;\n
        this.end.column += column;\n
    };\n
\n
}).call(Range.prototype);\n
Range.fromPoints = function(start, end) {\n
    return new Range(start.row, start.column, end.row, end.column);\n
};\n
Range.comparePoints = comparePoints;\n
\n
Range.comparePoints = function(p1, p2) {\n
    return p1.row - p2.row || p1.column - p2.column;\n
};\n
\n
\n
exports.Range = Range;\n
});\n
\n
define(\'ace/anchor\', [\'require\', \'exports\', \'module\' , \'ace/lib/oop\', \'ace/lib/event_emitter\'], function(require, exports, module) {\n
\n
\n
var oop = require("./lib/oop");\n
var EventEmitter = require("./lib/event_emitter").EventEmitter;\n
\n
var Anchor = exports.Anchor = function(doc, row, column) {\n
    this.document = doc;\n
\n
    if (typeof column == "undefined")\n
        this.setPosition(row.row, row.column);\n
    else\n
        this.setPosition(row, column);\n
\n
    this.$onChange = this.onChange.bind(this);\n
    doc.on("change", this.$onChange);\n
};\n
\n
(function() {\n
\n
    oop.implement(this, EventEmitter);\n
\n
    this.getPosition = function() {\n
        return this.$clipPositionToDocument(this.row, this.column);\n
    };\n
\n
    this.getDocument = function() {\n
        return this.document;\n
    };\n
\n
    this.onChange = function(e) {\n
        var delta = e.data;\n
        var range = delta.range;\n
\n
        if (range.start.row == range.end.row && range.start.row != this.row)\n
            return;\n
\n
        if (range.start.row > this.row)\n
            return;\n
\n
        if (range.start.row == this.row && range.start.column > this.column)\n
            return;\n
\n
        var row = this.row;\n
        var column = this.column;\n
        var start = range.start;\n
        var end = range.end;\n
\n
        if (delta.action === "insertText") {\n
            if (start.row === row && start.column <= column) {\n
                if (start.row === end.row) {\n
                    column += end.column - start.column;\n
                } else {\n
                    column -= start.column;\n
                    row += end.row - start.row;\n
                }\n
            } else if (start.row !== end.row && start.row < row) {\n
                row += end.row - start.row;\n
            }\n
        } else if (delta.action === "insertLines") {\n
            if (start.row <= row) {\n
                row += end.row - start.row;\n
            }\n
        } else if (delta.action === "removeText") {\n
            if (start.row === row && start.column < column) {\n
                if (end.column >= column)\n
                    column = start.column;\n
                else\n
                    column = Math.max(0, column - (end.column - start.column));\n
\n
            } else if (start.row !== end.row && start.row < row) {\n
                if (end.row === row)\n
                    column = Math.max(0, column - end.column) + start.column;\n
                row -= (end.row - start.row);\n
            } else if (end.row === row) {\n
                row -= end.row - start.row;\n
                column = Math.max(0, column - end.column) + start.column;\n
            }\n
        } else if (delta.action == "removeLines") {\n
            if (start.row <= row) {\n
                if (end.row <= row)\n
                    row -= end.row - start.row;\n
                else {\n
                    row = start.row;\n
                    column = 0;\n
                }\n
            }\n
        }\n
\n
        this.setPosition(row, column, true);\n
    };\n
\n
    this.setPosition = function(row, column, noClip) {\n
        var pos;\n
        if (noClip) {\n
            pos = {\n
                row: row,\n
                column: column\n
            };\n
        } else {\n
            pos = this.$clipPositionToDocument(row, column);\n
        }\n
\n
        if (this.row == pos.row && this.column == pos.column)\n
            return;\n
\n
        var old = {\n
            row: this.row,\n
            column: this.column\n
        };\n
\n
        this.row = pos.row;\n
        this.column = pos.column;\n
        this._emit("change", {\n
            old: old,\n
            value: pos\n
        });\n
    };\n
\n
    this.detach = function() {\n
        this.document.removeEventListener("change", this.$onChange);\n
    };\n
    this.$clipPositionToDocument = function(row, column) {\n
        var pos = {};\n
\n
        if (row >= this.document.getLength()) {\n
            pos.row = Math.max(0, this.document.getLength() - 1);\n
            pos.column = this.document.getLine(pos.row).length;\n
        }\n
        else if (row < 0) {\n
            pos.row = 0;\n
            pos.column = 0;\n
        }\n
        else {\n
            pos.row = row;\n
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n
        }\n
\n
        if (column < 0)\n
            pos.column = 0;\n
\n
        return pos;\n
    };\n
\n
}).call(Anchor.prototype);\n
\n
});\n
\n
define(\'ace/lib/lang\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
\n
exports.stringReverse = function(string) {\n
    return string.split("").reverse().join("");\n
};\n
\n
exports.stringRepeat = function (string, count) {\n
    var result = \'\';\n
    while (count > 0) {\n
        if (count & 1)\n
            result += string;\n
\n
        if (count >>= 1)\n
            string += string;\n
    }\n
    return result;\n
};\n
\n
var trimBeginRegexp = /^\\s\\s*/;\n
var trimEndRegexp = /\\s\\s*$/;\n
\n
exports.stringTrimLeft = function (string) {\n
    return string.replace(trimBeginRegexp, \'\');\n
};\n
\n
exports.stringTrimRight = function (string) {\n
    return string.replace(trimEndRegexp, \'\');\n
};\n
\n
exports.copyObject = function(obj) {\n
    var copy = {};\n
    for (var key in obj) {\n
        copy[key] = obj[key];\n
    }\n
    return copy;\n
};\n
\n
exports.copyArray = function(array){\n
    var copy = [];\n
    for (var i=0, l=array.length; i<l; i++) {\n
        if (array[i] && typeof array[i] == "object")\n
            copy[i] = this.copyObject( array[i] );\n
        else \n
            copy[i] = array[i];\n
    }\n
    return copy;\n
};\n
\n
exports.deepCopy = function (obj) {\n
    if (typeof obj != "object") {\n
        return obj;\n
    }\n
    \n
    var copy = obj.constructor();\n
    for (var key in obj) {\n
        if (typeof obj[key] == "object") {\n
            copy[key] = this.deepCopy(obj[key]);\n
        } else {\n
            copy[key] = obj[key];\n
        }\n
    }\n
    return copy;\n
};\n
\n
exports.arrayToMap = function(arr) {\n
    var map = {};\n
    for (var i=0; i<arr.length; i++) {\n
        map[arr[i]] = 1;\n
    }\n
    return map;\n
\n
};\n
\n
exports.createMap = function(props) {\n
    var map = Object.create(null);\n
    for (var i in props) {\n
        map[i] = props[i];\n
    }\n
    return map;\n
};\n
exports.arrayRemove = function(array, value) {\n
  for (var i = 0; i <= array.length; i++) {\n
    if (value === array[i]) {\n
      array.splice(i, 1);\n
    }\n
  }\n
};\n
\n
exports.escapeRegExp = function(str) {\n
    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, \'\\\\$1\');\n
};\n
\n
exports.escapeHTML = function(str) {\n
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/\'/g, "&#39;").replace(/</g, "&#60;");\n
};\n
\n
exports.getMatchOffsets = function(string, regExp) {\n
    var matches = [];\n
\n
    string.replace(regExp, function(str) {\n
        matches.push({\n
            offset: arguments[arguments.length-2],\n
            length: str.length\n
        });\n
    });\n
\n
    return matches;\n
};\n
exports.deferredCall = function(fcn) {\n
\n
    var timer = null;\n
    var callback = function() {\n
        timer = null;\n
        fcn();\n
    };\n
\n
    var deferred = function(timeout) {\n
        deferred.cancel();\n
        timer = setTimeout(callback, timeout || 0);\n
        return deferred;\n
    };\n
\n
    deferred.schedule = deferred;\n
\n
    deferred.call = function() {\n
        this.cancel();\n
        fcn();\n
        return deferred;\n
    };\n
\n
    deferred.cancel = function() {\n
        clearTimeout(timer);\n
        timer = null;\n
        return deferred;\n
    };\n
\n
    return deferred;\n
};\n
\n
\n
exports.delayedCall = function(fcn, defaultTimeout) {\n
    var timer = null;\n
    var callback = function() {\n
        timer = null;\n
        fcn();\n
    };\n
\n
    var _self = function(timeout) {\n
        timer && clearTimeout(timer);\n
        timer = setTimeout(callback, timeout || defaultTimeout);\n
    };\n
\n
    _self.delay = _self;\n
    _self.schedule = function(timeout) {\n
        if (timer == null)\n
            timer = setTimeout(callback, timeout || 0);\n
    };\n
\n
    _self.call = function() {\n
        this.cancel();\n
        fcn();\n
    };\n
\n
    _self.cancel = function() {\n
        timer && clearTimeout(timer);\n
        timer = null;\n
    };\n
\n
    _self.isPending = function() {\n
        return timer;\n
    };\n
\n
    return _self;\n
};\n
});\n
define(\'ace/mode/javascript/jshint\', [\'require\', \'exports\', \'module\' ], function(require, exports, module) {\n
\n
var JSHINT = (function () {\n
\t\n
\n
\tvar anonname,\t\t// The guessed name for anonymous functions.\n
\n
\t\tbang = {\n
\t\t\t"<"  : true,\n
\t\t\t"<=" : true,\n
\t\t\t"==" : true,\n
\t\t\t"===": true,\n
\t\t\t"!==": true,\n
\t\t\t"!=" : true,\n
\t\t\t">"  : true,\n
\t\t\t">=" : true,\n
\t\t\t"+"  : true,\n
\t\t\t"-"  : true,\n
\t\t\t"*"  : true,\n
\t\t\t"/"  : true,\n
\t\t\t"%"  : true\n
\t\t},\n
\t\tboolOptions = {\n
\t\t\tasi\t\t\t: true, // if automatic semicolon insertion should be tolerated\n
\t\t\tbitwise\t\t: true, // if bitwise operators should not be allowed\n
\t\t\tboss\t\t: true, // if advanced usage of assignments should be allowed\n
\t\t\tbrowser\t\t: true, // if the standard browser globals should be predefined\n
\t\t\tcamelcase\t: true, // if identifiers should be required in camel case\n
\t\t\tcouch\t\t: true, // if CouchDB globals should be predefined\n
\t\t\tcurly\t\t: true, // if curly braces around all blocks should be required\n
\t\t\tdebug\t\t: true, // if debugger statements should be allowed\n
\t\t\tdevel\t\t: true, // if logging globals should be predefined (console,\n
\t\t\tdojo\t\t: true, // if Dojo Toolkit globals should be predefined\n
\t\t\teqeqeq\t\t: true, // if === should be required\n
\t\t\teqnull\t\t: true, // if == null comparisons should be tolerated\n
\t\t\tes5\t\t\t: true, // if ES5 syntax should be allowed\n
\t\t\tesnext\t\t: true, // if es.next specific syntax should be allowed\n
\t\t\tevil\t\t: true, // if eval should be allowed\n
\t\t\texpr\t\t: true, // if ExpressionStatement should be allowed as Programs\n
\t\t\tforin\t\t: true, // if for in statements must filter\n
\t\t\tfuncscope\t: true, // if only function scope should be used for scope tests\n
\t\t\tglobalstrict: true, // if global  should be allowed (also\n
\t\t\timmed\t\t: true, // if immediate invocations must be wrapped in parens\n
\t\t\titerator\t: true, // if the `__iterator__` property should be allowed\n
\t\t\tjquery\t\t: true, // if jQuery globals should be predefined\n
\t\t\tlastsemic\t: true, // if semicolons may be ommitted for the trailing\n
\t\t\tlatedef\t\t: true, // if the use before definition should not be tolerated\n
\t\t\tlaxbreak\t: true, // if line breaks should not be checked\n
\t\t\tlaxcomma\t: true, // if line breaks should not be checked around commas\n
\t\t\tloopfunc\t: true, // if functions should be allowed to be defined within\n
\t\t\tmootools\t: true, // if MooTools globals should be predefined\n
\t\t\tmultistr\t: true, // allow multiline strings\n
\t\t\tnewcap\t\t: true, // if constructor names must be capitalized\n
\t\t\tnoarg\t\t: true, // if arguments.caller and arguments.callee should be\n
\t\t\tnode\t\t: true, // if the Node.js environment globals should be\n
\t\t\tnoempty\t\t: true, // if empty blocks should be disallowed\n
\t\t\tnonew\t\t: true, // if using `new` for side-effects should be disallowed\n
\t\t\tnonstandard : true, // if non-standard (but widely adopted) globals should\n
\t\t\tnomen\t\t: true, // if names should be checked\n
\t\t\tonevar\t\t: true, // if only one var statement per function should be\n
\t\t\tonecase\t\t: true, // if one case switch statements should be allowed\n
\t\t\tpassfail\t: true, // if the scan should stop on first error\n
\t\t\tplusplus\t: true, // if increment/decrement should not be allowed\n
\t\t\tproto\t\t: true, // if the `__proto__` property should be allowed\n
\t\t\tprototypejs : true, // if Prototype and Scriptaculous globals should be\n
\t\t\tregexdash\t: true, // if unescaped first/last dash (-) inside brackets\n
\t\t\tregexp\t\t: true, // if the . should not be allowed in regexp literals\n
\t\t\trhino\t\t: true, // if the Rhino environment globals should be predefined\n
\t\t\tundef\t\t: true, // if variables should be declared before used\n
\t\t\tunused\t\t: true, // if variables should be always used\n
\t\t\tscripturl\t: true, // if script-targeted URLs should be tolerated\n
\t\t\tshadow\t\t: true, // if variable shadowing should be tolerated\n
\t\t\tsmarttabs\t: true, // if smarttabs should be tolerated\n
\t\t\tstrict\t\t: true, // require the  pragma\n
\t\t\tsub\t\t\t: true, // if all forms of subscript notation are tolerated\n
\t\t\tsupernew\t: true, // if `new function () { ... };` and `new Object;`\n
\t\t\ttrailing\t: true, // if trailing whitespace rules apply\n
\t\t\tvalidthis\t: true, // if \'this\' inside a non-constructor function is valid.\n
\t\t\twithstmt\t: true, // if with statements should be allowed\n
\t\t\twhite\t\t: true, // if strict whitespace rules apply\n
\t\t\tworker\t\t: true, // if Web Worker script symbols should be allowed\n
\t\t\twsh\t\t\t: true, // if the Windows Scripting Host environment globals\n
\t\t\tyui\t\t\t: true\t// YUI variables should be predefined\n
\t\t},\n
\t\tvalOptions = {\n
\t\t\tmaxlen\t\t : false,\n
\t\t\tindent\t\t : false,\n
\t\t\tmaxerr\t\t : false,\n
\t\t\tpredef\t\t : false,\n
\t\t\tquotmark\t : false, //\'single\'|\'double\'|true\n
\t\t\tscope\t\t : false,\n
\t\t\tmaxstatements: false, // {int} max statements per function\n
\t\t\tmaxdepth\t : false, // {int} max nested block depth per function\n
\t\t\tmaxparams\t : false, // {int} max params per function\n
\t\t\tmaxcomplexity: false  // {int} max cyclomatic complexity per function\n
\t\t},\n
\t\tinvertedOptions = {\n
\t\t\tbitwise\t\t: true,\n
\t\t\tforin\t\t: true,\n
\t\t\tnewcap\t\t: true,\n
\t\t\tnomen\t\t: true,\n
\t\t\tplusplus\t: true,\n
\t\t\tregexp\t\t: true,\n
\t\t\tundef\t\t: true,\n
\t\t\twhite\t\t: true,\n
\t\t\teqeqeq\t\t: true,\n
\t\t\tonevar\t\t: true\n
\t\t},\n
\t\trenamedOptions = {\n
\t\t\teqeq\t\t: "eqeqeq",\n
\t\t\tvars\t\t: "onevar",\n
\t\t\twindows\t\t: "wsh"\n
\t\t},\n
\t\tbrowser = {\n
\t\t\tArrayBuffer\t\t\t\t :\tfalse,\n
\t\t\tArrayBufferView\t\t\t :\tfalse,\n
\t\t\tAudio\t\t\t\t\t :\tfalse,\n
\t\t\tBlob\t\t\t\t\t :\tfalse,\n
\t\t\taddEventListener\t\t :\tfalse,\n
\t\t\tapplicationCache\t\t :\tfalse,\n
\t\t\tatob\t\t\t\t\t :\tfalse,\n
\t\t\tblur\t\t\t\t\t :\tfalse,\n
\t\t\tbtoa\t\t\t\t\t :\tfalse,\n
\t\t\tclearInterval\t\t\t :\tfalse,\n
\t\t\tclearTimeout\t\t\t :\tfalse,\n
\t\t\tclose\t\t\t\t\t :\tfalse,\n
\t\t\tclosed\t\t\t\t\t :\tfalse,\n
\t\t\tDataView\t\t\t\t :\tfalse,\n
\t\t\tDOMParser\t\t\t\t :\tfalse,\n
\t\t\tdefaultStatus\t\t\t :\tfalse,\n
\t\t\tdocument\t\t\t\t :\tfalse,\n
\t\t\tevent\t\t\t\t\t :\tfalse,\n
\t\t\tFileReader\t\t\t\t :\tfalse,\n
\t\t\tFloat32Array\t\t\t :\tfalse,\n
\t\t\tFloat64Array\t\t\t :\tfalse,\n
\t\t\tFormData\t\t\t\t :\tfalse,\n
\t\t\tfocus\t\t\t\t\t :\tfalse,\n
\t\t\tframes\t\t\t\t\t :\tfalse,\n
\t\t\tgetComputedStyle\t\t :\tfalse,\n
\t\t\tHTMLElement\t\t\t\t :\tfalse,\n
\t\t\tHTMLAnchorElement\t\t :\tfalse,\n
\t\t\tHTMLBaseElement\t\t\t :\tfalse,\n
\t\t\tHTMLBlockquoteElement\t :\tfalse,\n
\t\t\tHTMLBodyElement\t\t\t :\tfalse,\n
\t\t\tHTMLBRElement\t\t\t :\tfalse,\n
\t\t\tHTMLButtonElement\t\t :\tfalse,\n
\t\t\tHTMLCanvasElement\t\t :\tfalse,\n
\t\t\tHTMLDirectoryElement\t :\tfalse,\n
\t\t\tHTMLDivElement\t\t\t :\tfalse,\n
\t\t\tHTMLDListElement\t\t :\tfalse,\n
\t\t\tHTMLFieldSetElement\t\t :\tfalse,\n
\t\t\tHTMLFontElement\t\t\t :\tfalse,\n
\t\t\tHTMLFormElement\t\t\t :\tfalse,\n
\t\t\tHTMLFrameElement\t\t :\tfalse,\n
\t\t\tHTMLFrameSetElement\t\t :\tfalse,\n
\t\t\tHTMLHeadElement\t\t\t :\tfalse,\n
\t\t\tHTMLHeadingElement\t\t :\tfalse,\n
\t\t\tHTMLHRElement\t\t\t :\tfalse,\n
\t\t\tHTMLHtmlElement\t\t\t :\tfalse,\n
\t\t\tHTMLIFrameElement\t\t :\tfalse,\n
\t\t\tHTMLImageElement\t\t :\tfalse,\n
\t\t\tHTMLInputElement\t\t :\tfalse,\n
\t\t\tHTMLIsIndexElement\t\t :\tfalse,\n
\t\t\tHTMLLabelElement\t\t :\tfalse,\n
\t\t\tHTMLLayerElement\t\t :\tfalse,\n
\t\t\tHTMLLegendElement\t\t :\tfalse,\n
\t\t\tHTMLLIElement\t\t\t :\tfalse,\n
\t\t\tHTMLLinkElement\t\t\t :\tfalse,\n
\t\t\tHTMLMapElement\t\t\t :\tfalse,\n
\t\t\tHTMLMenuElement\t\t\t :\tfalse,\n
\t\t\tHTMLMetaElement\t\t\t :\tfalse,\n
\t\t\tHTMLModElement\t\t\t :\tfalse,\n
\t\t\tHTMLObjectElement\t\t :\tfalse,\n
\t\t\tHTMLOListElement\t\t :\tfalse,\n
\t\t\tHTMLOptGroupElement\t\t :\tfalse,\n
\t\t\tHTMLOptionElement\t\t :\tfalse,\n
\t\t\tHTMLParagraphElement\t :\tfalse,\n
\t\t\tHTMLParamElement\t\t :\tfalse,\n
\t\t\tHTMLPreElement\t\t\t :\tfalse,\n
\t\t\tHTMLQuoteElement\t\t :\tfalse,\n
\t\t\tHTMLScriptElement\t\t :\tfalse,\n
\t\t\tHTMLSelectElement\t\t :\tfalse,\n
\t\t\tHTMLStyleElement\t\t :\tfalse,\n
\t\t\tHTMLTableCaptionElement  :\tfalse,\n
\t\t\tHTMLTableCellElement\t :\tfalse,\n
\t\t\tHTMLTableColElement\t\t :\tfalse,\n
\t\t\tHTMLTableElement\t\t :\tfalse,\n
\t\t\tHTMLTableRowElement\t\t :\tfalse,\n
\t\t\tHTMLTableSectionElement  :\tfalse,\n
\t\t\tHTMLTextAreaElement\t\t :\tfalse,\n
\t\t\tHTMLTitleElement\t\t :\tfalse,\n
\t\t\tHTMLUListElement\t\t :\tfalse,\n
\t\t\tHTMLVideoElement\t\t :\tfalse,\n
\t\t\thistory\t\t\t\t\t :\tfalse,\n
\t\t\tInt16Array\t\t\t\t :\tfalse,\n
\t\t\tInt32Array\t\t\t\t :\tfalse,\n
\t\t\tInt8Array\t\t\t\t :\tfalse,\n
\t\t\tImage\t\t\t\t\t :\tfalse,\n
\t\t\tlength\t\t\t\t\t :\tfalse,\n
\t\t\tlocalStorage\t\t\t :\tfalse,\n
\t\t\tlocation\t\t\t\t :\tfalse,\n
\t\t\tMessageChannel\t\t\t :\tfalse,\n
\t\t\tMessageEvent\t\t\t :\tfalse,\n
\t\t\tMessagePort\t\t\t\t :\tfalse,\n
\t\t\tmoveBy\t\t\t\t\t :\tfalse,\n
\t\t\tmoveTo\t\t\t\t\t :\tfalse,\n
\t\t\tMutationObserver\t\t :\tfalse,\n
\t\t\tname\t\t\t\t\t :\tfalse,\n
\t\t\tNode\t\t\t\t\t :\tfalse,\n
\t\t\tNodeFilter\t\t\t\t :\tfalse,\n
\t\t\tnavigator\t\t\t\t :\tfalse,\n
\t\t\tonbeforeunload\t\t\t :\ttrue,\n
\t\t\tonblur\t\t\t\t\t :\ttrue,\n
\t\t\tonerror\t\t\t\t\t :\ttrue,\n
\t\t\tonfocus\t\t\t\t\t :\ttrue,\n
\t\t\tonload\t\t\t\t\t :\ttrue,\n
\t\t\tonresize\t\t\t\t :\ttrue,\n
\t\t\tonunload\t\t\t\t :\ttrue,\n
\t\t\topen\t\t\t\t\t :\tfalse,\n
\t\t\topenDatabase\t\t\t :\tfalse,\n
\t\t\topener\t\t\t\t\t :\tfalse,\n
\t\t\tOption\t\t\t\t\t :\tfalse,\n
\t\t\tparent\t\t\t\t\t :\tfalse,\n
\t\t\tprint\t\t\t\t\t :\tfalse,\n
\t\t\tremoveEventListener\t\t :\tfalse,\n
\t\t\tresizeBy\t\t\t\t :\tfalse,\n
\t\t\tresizeTo\t\t\t\t :\tfalse,\n
\t\t\tscreen\t\t\t\t\t :\tfalse,\n
\t\t\tscroll\t\t\t\t\t :\tfalse,\n
\t\t\tscrollBy\t\t\t\t :\tfalse,\n
\t\t\tscrollTo\t\t\t\t :\tfalse,\n
\t\t\tsessionStorage\t\t\t :\tfalse,\n
\t\t\tsetInterval\t\t\t\t :\tfalse,\n
\t\t\tsetTimeout\t\t\t\t :\tfalse,\n
\t\t\tSharedWorker\t\t\t :\tfalse,\n
\t\t\tstatus\t\t\t\t\t :\tfalse,\n
\t\t\ttop\t\t\t\t\t\t :\tfalse,\n
\t\t\tUint16Array\t\t\t\t :\tfalse,\n
\t\t\tUint32Array\t\t\t\t :\tfalse,\n
\t\t\tUint8Array\t\t\t\t :\tfalse,\n
\t\t\tWebSocket\t\t\t\t :\tfalse,\n
\t\t\twindow\t\t\t\t\t :\tfalse,\n
\t\t\tWorker\t\t\t\t\t :\tfalse,\n
\t\t\tXMLHttpRequest\t\t\t :\tfalse,\n
\t\t\tXMLSerializer\t\t\t :\tfalse,\n
\t\t\tXPathEvaluator\t\t\t :\tfalse,\n
\t\t\tXPathException\t\t\t :\tfalse,\n
\t\t\tXPathExpression\t\t\t :\tfalse,\n
\t\t\tXPathNamespace\t\t\t :\tfalse,\n
\t\t\tXPathNSResolver\t\t\t :\tfalse,\n
\t\t\tXPathResult\t\t\t\t :\tfalse\n
\t\t},\n
\n
\t\tcouch = {\n
\t\t\t"require" : false,\n
\t\t\trespond   : false,\n
\t\t\tgetRow\t  : false,\n
\t\t\temit\t  : false,\n
\t\t\tsend\t  : false,\n
\t\t\tstart\t  : false,\n
\t\t\tsum\t\t  : false,\n
\t\t\tlog\t\t  : false,\n
\t\t\texports   : false,\n
\t\t\tmodule\t  : false,\n
\t\t\tprovides  : false\n
\t\t},\n
\n
\t\tdeclared, // Globals that were declared using /*global ... */ syntax.\n
\n
\t\tdevel = {\n
\t\t\talert\t: false,\n
\t\t\tconfirm : false,\n
\t\t\tconsole : false,\n
\t\t\tDebug\t: false,\n
\t\t\topera\t: false,\n
\t\t\tprompt\t: false\n
\t\t},\n
\n
\t\tdojo = {\n
\t\t\tdojo\t  : false,\n
\t\t\tdijit\t  : false,\n
\t\t\tdojox\t  : false,\n
\t\t\tdefine\t  : false,\n
\t\t\t"require" : false\n
\t\t},\n
\n
\t\tfunct,\t\t\t// The current function\n
\n
\t\tfunctionicity = [\n
\t\t\t"closure", "exception", "global", "label",\n
\t\t\t"outer", "unused", "var"\n
\t\t],\n
\n
\t\tfunctions,\t\t// All of the functions\n
\n
\t\tglobal,\t\t\t// The global scope\n
\t\timplied,\t\t// Implied globals\n
\t\tinblock,\n
\t\tindent,\n
\t\tjsonmode,\n
\n
\t\tjquery = {\n
\t\t\t"$"    : false,\n
\t\t\tjQuery : false\n
\t\t},\n
\n
\t\tlines,\n
\t\tlookahead,\n
\t\tmember,\n
\t\tmembersOnly,\n
\n
\t\tmootools = {\n
\t\t\t"$"\t\t\t\t: false,\n
\t\t\t"$$"\t\t\t: false,\n
\t\t\tAsset\t\t\t: false,\n
\t\t\tBrowser\t\t\t: false,\n
\t\t\tChain\t\t\t: false,\n
\t\t\tClass\t\t\t: false,\n
\t\t\tColor\t\t\t: false,\n
\t\t\tCookie\t\t\t: false,\n
\t\t\tCore\t\t\t: false,\n
\t\t\tDocument\t\t: false,\n
\t\t\tDomReady\t\t: false,\n
\t\t\tDOMEvent\t\t: false,\n
\t\t\tDOMReady\t\t: false,\n
\t\t\tDrag\t\t\t: false,\n
\t\t\tElement\t\t\t: false,\n
\t\t\tElements\t\t: false,\n
\t\t\tEvent\t\t\t: false,\n
\t\t\tEvents\t\t\t: false,\n
\t\t\tFx\t\t\t\t: false,\n
\t\t\tGroup\t\t\t: false,\n
\t\t\tHash\t\t\t: false,\n
\t\t\tHtmlTable\t\t: false,\n
\t\t\tIframe\t\t\t: false,\n
\t\t\tIframeShim\t\t: false,\n
\t\t\tInputValidator\t: false,\n
\t\t\tinstanceOf\t\t: false,\n
\t\t\tKeyboard\t\t: false,\n
\t\t\tLocale\t\t\t: false,\n
\t\t\tMask\t\t\t: false,\n
\t\t\tMooTools\t\t: false,\n
\t\t\tNative\t\t\t: false,\n
\t\t\tOptions\t\t\t: false,\n
\t\t\tOverText\t\t: false,\n
\t\t\tRequest\t\t\t: false,\n
\t\t\tScroller\t\t: false,\n
\t\t\tSlick\t\t\t: false,\n
\t\t\tSlider\t\t\t: false,\n
\t\t\tSortables\t\t: false,\n
\t\t\tSpinner\t\t\t: false,\n
\t\t\tSwiff\t\t\t: false,\n
\t\t\tTips\t\t\t: false,\n
\t\t\tType\t\t\t: false,\n
\t\t\ttypeOf\t\t\t: false,\n
\t\t\tURI\t\t\t\t: false,\n
\t\t\tWindow\t\t\t: false\n
\t\t},\n
\n
\t\tnexttoken,\n
\n
\t\tnode = {\n
\t\t\t__filename\t  : false,\n
\t\t\t__dirname\t  : false,\n
\t\t\tBuffer\t\t  : false,\n
\t\t\tconsole\t\t  : false,\n
\t\t\texports\t\t  : true,  // In Node it is ok to exports = module.exports = foo();\n
\t\t\tGLOBAL\t\t  : false,\n
\t\t\tglobal\t\t  : false,\n
\t\t\tmodule\t\t  : false,\n
\t\t\tprocess\t\t  : false,\n
\t\t\trequire\t\t  : false,\n
\t\t\tsetTimeout\t  : false,\n
\t\t\tclearTimeout  : false,\n
\t\t\tsetInterval   : false,\n
\t\t\tclearInterval : false\n
\t\t},\n
\n
\t\tnoreach,\n
\t\toption,\n
\t\tpredefined,\t\t// Global variables defined by option\n
\t\tprereg,\n
\t\tprevtoken,\n
\n
\t\tprototypejs = {\n
\t\t\t"$"\t\t\t\t  : false,\n
\t\t\t"$$"\t\t\t  : false,\n
\t\t\t"$A"\t\t\t  : false,\n
\t\t\t"$F"\t\t\t  : false,\n
\t\t\t"$H"\t\t\t  : false,\n
\t\t\t"$R"\t\t\t  : false,\n
\t\t\t"$break"\t\t  : false,\n
\t\t\t"$continue"\t\t  : false,\n
\t\t\t"$w"\t\t\t  : false,\n
\t\t\tAbstract\t\t  : false,\n
\t\t\tAjax\t\t\t  : false,\n
\t\t\tClass\t\t\t  : false,\n
\t\t\tEnumerable\t\t  : false,\n
\t\t\tElement\t\t\t  : false,\n
\t\t\tEvent\t\t\t  : false,\n
\t\t\tField\t\t\t  : false,\n
\t\t\tForm\t\t\t  : false,\n
\t\t\tHash\t\t\t  : false,\n
\t\t\tInsertion\t\t  : false,\n
\t\t\tObjectRange\t\t  : false,\n
\t\t\tPeriodicalExecuter: false,\n
\t\t\tPosition\t\t  : false,\n
\t\t\tPrototype\t\t  : false,\n
\t\t\tSelector\t\t  : false,\n
\t\t\tTemplate\t\t  : false,\n
\t\t\tToggle\t\t\t  : false,\n
\t\t\tTry\t\t\t\t  : false,\n
\t\t\tAutocompleter\t  : false,\n
\t\t\tBuilder\t\t\t  : false,\n
\t\t\tControl\t\t\t  : false,\n
\t\t\tDraggable\t\t  : false,\n
\t\t\tDraggables\t\t  : false,\n
\t\t\tDroppables\t\t  : false,\n
\t\t\tEffect\t\t\t  : false,\n
\t\t\tSortable\t\t  : false,\n
\t\t\tSortableObserver  : false,\n
\t\t\tSound\t\t\t  : false,\n
\t\t\tScriptaculous\t  : false\n
\t\t},\n
\n
\t\tquotmark,\n
\n
\t\trhino = {\n
\t\t\tdefineClass  : false,\n
\t\t\tdeserialize  : false,\n
\t\t\tgc\t\t\t : false,\n
\t\t\thelp\t\t : false,\n
\t\t\timportPackage: false,\n
\t\t\t"java"\t\t : false,\n
\t\t\tload\t\t : false,\n
\t\t\tloadClass\t : false,\n
\t\t\tprint\t\t : false,\n
\t\t\tquit\t\t : false,\n
\t\t\treadFile\t : false,\n
\t\t\treadUrl\t\t : false,\n
\t\t\trunCommand\t : false,\n
\t\t\tseal\t\t : false,\n
\t\t\tserialize\t : false,\n
\t\t\tspawn\t\t : false,\n
\t\t\tsync\t\t : false,\n
\t\t\ttoint32\t\t : false,\n
\t\t\tversion\t\t : false\n
\t\t},\n
\n
\t\tscope,\t\t// The current scope\n
\t\tstack,\n
\t\tstandard = {\n
\t\t\tArray\t\t\t\t: false,\n
\t\t\tBoolean\t\t\t\t: false,\n
\t\t\tDate\t\t\t\t: false,\n
\t\t\tdecodeURI\t\t\t: false,\n
\t\t\tdecodeURIComponent\t: false,\n
\t\t\tencodeURI\t\t\t: false,\n
\t\t\tencodeURIComponent\t: false,\n
\t\t\tError\t\t\t\t: false,\n
\t\t\t"eval"\t\t\t\t: false,\n
\t\t\tEvalError\t\t\t: false,\n
\t\t\tFunction\t\t\t: false,\n
\t\t\thasOwnProperty\t\t: false,\n
\t\t\tisFinite\t\t\t: false,\n
\t\t\tisNaN\t\t\t\t: false,\n
\t\t\tJSON\t\t\t\t: false,\n
\t\t\tMap\t\t\t\t\t: false,\n
\t\t\tMath\t\t\t\t: false,\n
\t\t\tNaN\t\t\t\t\t: false,\n
\t\t\tNumber\t\t\t\t: false,\n
\t\t\tObject\t\t\t\t: false,\n
\t\t\tparseInt\t\t\t: false,\n
\t\t\tparseFloat\t\t\t: false,\n
\t\t\tRangeError\t\t\t: false,\n
\t\t\tReferenceError\t\t: false,\n
\t\t\tRegExp\t\t\t\t: false,\n
\t\t\tSet\t\t\t\t\t: false,\n
\t\t\tString\t\t\t\t: false,\n
\t\t\tSyntaxError\t\t\t: false,\n
\t\t\tTypeError\t\t\t: false,\n
\t\t\tURIError\t\t\t: false,\n
\t\t\tWeakMap\t\t\t\t: false\n
\t\t},\n
\t\tnonstandard = {\n
\t\t\tescape\t\t\t\t: false,\n
\t\t\tunescape\t\t\t: false\n
\t\t},\n
\n
\t\tdirective,\n
\t\tsyntax = {},\n
\t\ttab,\n
\t\ttoken,\n
\t\tunuseds,\n
\t\turls,\n
\t\tuseESNextSyntax,\n
\t\twarnings,\n
\n
\t\tworker = {\n
\t\t\timportScripts\t\t: true,\n
\t\t\tpostMessage\t\t\t: true,\n
\t\t\tself\t\t\t\t: true\n
\t\t},\n
\n
\t\twsh = {\n
\t\t\tActiveXObject\t\t\t  : true,\n
\t\t\tEnumerator\t\t\t\t  : true,\n
\t\t\tGetObject\t\t\t\t  : true,\n
\t\t\tScriptEngine\t\t\t  : true,\n
\t\t\tScriptEngineBuildVersion  : true,\n
\t\t\tScriptEngineMajorVersion  : true,\n
\t\t\tScriptEngineMinorVersion  : true,\n
\t\t\tVBArray\t\t\t\t\t  : true,\n
\t\t\tWSH\t\t\t\t\t\t  : true,\n
\t\t\tWScript\t\t\t\t\t  : true,\n
\t\t\tXDomainRequest\t\t\t  : true\n
\t\t},\n
\n
\t\tyui = {\n
\t\t\tYUI\t\t\t\t: false,\n
\t\t\tY\t\t\t\t: false,\n
\t\t\tYUI_config\t\t: false\n
\t\t};\n
\tvar ax, cx, tx, nx, nxg, lx, ix, jx, ft;\n
\t(function () {\n
\t\tax = /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i;\n
\t\tcx = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n
\t\ttx = /^\\s*([(){}\\[.,:;\'"~\\?\\]#@]|==?=?|\\/=(?!(\\S*\\/[gim]?))|\\/(\\*(jshint|jslint|members?|global)?|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|%=?|&[&=]?|\\|[|=]?|>>?>?=?|<([\\/=!]|\\!(\\[|--)?|<=?)?|\\^=?|\\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\\.[0-9]*)?([eE][+\\-]?[0-9]+)?)/;\n
\t\tnx = /[\\u0000-\\u001f&<"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n
\t\tnxg = /[\\u0000-\\u001f&<"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n
\t\tlx = /\\*\\//;\n
\t\tix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n
\t\tjx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i;\n
\t\tft = /^\\s*\\/\\*\\s*falls\\sthrough\\s*\\*\\/\\s*$/;\n
\t}());\n
\n
\tfunction F() {}\t\t// Used by Object.create\n
\n
\tfunction is_own(object, name) {\n
\t\treturn Object.prototype.hasOwnProperty.call(object, name);\n
\t}\n
\n
\tfunction checkOption(name, t) {\n
\t\tif (valOptions[name] === undefined && boolOptions[name] === undefined) {\n
\t\t\twarning("Bad option: \'" + name + "\'.", t);\n
\t\t}\n
\t}\n
\n
\tfunction isString(obj) {\n
\t\treturn Object.prototype.toString.call(obj) === "[object String]";\n
\t}\n
\n
\tif (typeof Array.isArray !== "function") {\n
\t\tArray.isArray = function (o) {\n
\t\t\treturn Object.prototype.toString.apply(o) === "[object Array]";\n
\t\t};\n
\t}\n
\n
\tif (!Array.prototype.forEach) {\n
\t\tArray.prototype.forEach = function (fn, scope) {\n
\t\t\tvar len = this.length;\n
\n
\t\t\tfor (var i = 0; i < len; i++) {\n
\t\t\t\tfn.call(scope || this, this[i], i, this);\n
\t\t\t}\n
\t\t};\n
\t}\n
\n
\tif (!Array.prototype.indexOf) {\n
\t\tArray.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n
\t\t\tif (this === null || this === undefined) {\n
\t\t\t\tthrow new TypeError();\n
\t\t\t}\n
\n
\t\t\tvar t = new Object(this);\n
\t\t\tvar len = t.length >>> 0;\n
\n
\t\t\tif (len === 0) {\n
\t\t\t\treturn -1;\n
\t\t\t}\n
\n
\t\t\tvar n = 0;\n
\t\t\tif (arguments.length > 0) {\n
\t\t\t\tn = Number(arguments[1]);\n
\t\t\t\tif (n != n) { // shortcut for verifying if it\'s NaN\n
\t\t\t\t\tn = 0;\n
\t\t\t\t} else if (n !== 0 && n != Infinity && n != -Infinity) {\n
\t\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (n >= len) {\n
\t\t\t\treturn -1;\n
\t\t\t}\n
\n
\t\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n
\t\t\tfor (; k < len; k++) {\n
\t\t\t\tif (k in t && t[k] === searchElement) {\n
\t\t\t\t\treturn k;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn -1;\n
\t\t};\n
\t}\n
\n
\tif (typeof Object.create !== "function") {\n
\t\tObject.create = function (o) {\n
\t\t\tF.prototype = o;\n
\t\t\treturn new F();\n
\t\t};\n
\t}\n
\n
\tif (typeof Object.keys !== "function") {\n
\t\tObject.keys = function (o) {\n
\t\t\tvar a = [], k;\n
\t\t\tfor (k in o) {\n
\t\t\t\tif (is_own(o, k)) {\n
\t\t\t\t\ta.push(k);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn a;\n
\t\t};\n
\t}\n
\n
\tfunction isAlpha(str) {\n
\t\treturn (str >= "a" && str <= "z\\uffff") ||\n
\t\t\t(str >= "A" && str <= "Z\\uffff");\n
\t}\n
\n
\tfunction isDigit(str) {\n
\t\treturn (str >= "0" && str <= "9");\n
\t}\n
\n
\tfunction isIdentifier(token, value) {\n
\t\tif (!token)\n
\t\t\treturn false;\n
\n
\t\tif (!token.identifier || token.value !== value)\n
\t\t\treturn false;\n
\n
\t\treturn true;\n
\t}\n
\n
\tfunction supplant(str, data) {\n
\t\treturn str.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n
\t\t\tvar r = data[b];\n
\t\t\treturn typeof r === "string" || typeof r === "number" ? r : a;\n
\t\t});\n
\t}\n
\n
\tfunction combine(t, o) {\n
\t\tvar n;\n
\t\tfor (n in o) {\n
\t\t\tif (is_own(o, n) && !is_own(JSHINT.blacklist, n)) {\n
\t\t\t\tt[n] = o[n];\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction updatePredefined() {\n
\t\tObject.keys(JSHINT.blacklist).forEach(function (key) {\n
\t\t\tdelete predefined[key];\n
\t\t});\n
\t}\n
\n
\tfunction assume() {\n
\t\tif (option.couch) {\n
\t\t\tcombine(predefined, couch);\n
\t\t}\n
\n
\t\tif (option.rhino) {\n
\t\t\tcombine(predefined, rhino);\n
\t\t}\n
\n
\t\tif (option.prototypejs) {\n
\t\t\tcombine(predefined, prototypejs);\n
\t\t}\n
\n
\t\tif (option.node) {\n
\t\t\tcombine(predefined, node);\n
\t\t\toption.globalstrict = true;\n
\t\t}\n
\n
\t\tif (option.devel) {\n
\t\t\tcombine(predefined, devel);\n
\t\t}\n
\n
\t\tif (option.dojo) {\n
\t\t\tcombine(predefined, dojo);\n
\t\t}\n
\n
\t\tif (option.browser) {\n
\t\t\tcombine(predefined, browser);\n
\t\t}\n
\n
\t\tif (option.nonstandard) {\n
\t\t\tcombine(predefined, nonstandard);\n
\t\t}\n
\n
\t\tif (option.jquery) {\n
\t\t\tcombine(predefined, jquery);\n
\t\t}\n
\n
\t\tif (option.mootools) {\n
\t\t\tcombine(predefined, mootools);\n
\t\t}\n
\n
\t\tif (option.worker) {\n
\t\t\tcombine(predefined, worker);\n
\t\t}\n
\n
\t\tif (option.wsh) {\n
\t\t\tcombine(predefined, wsh);\n
\t\t}\n
\n
\t\tif (option.esnext) {\n
\t\t\tuseESNextSyntax();\n
\t\t}\n
\n
\t\tif (option.globalstrict && option.strict !== false) {\n
\t\t\toption.strict = true;\n
\t\t}\n
\n
\t\tif (option.yui) {\n
\t\t\tcombine(predefined, yui);\n
\t\t}\n
\t}\n
\tfunction quit(message, line, chr) {\n
\t\tvar percentage = Math.floor((line / lines.length) * 100);\n
\n
\t\tthrow {\n
\t\t\tname: "JSHintError",\n
\t\t\tline: line,\n
\t\t\tcharacter: chr,\n
\t\t\tmessage: message + " (" + percentage + "% scanned).",\n
\t\t\traw: message\n
\t\t};\n
\t}\n
\n
\tfunction isundef(scope, m, t, a) {\n
\t\treturn JSHINT.undefs.push([scope, m, t, a]);\n
\t}\n
\n
\tfunction warning(m, t, a, b, c, d) {\n
\t\tvar ch, l, w;\n
\t\tt = t || nexttoken;\n
\t\tif (t.id === "(end)") {  // `~\n
\t\t\tt = token;\n
\t\t}\n
\t\tl = t.line || 0;\n
\t\tch = t.from || 0;\n
\t\tw = {\n
\t\t\tid: "(error)",\n
\t\t\traw: m,\n
\t\t\tevidence: lines[l - 1] || "",\n
\t\t\tline: l,\n
\t\t\tcharacter: ch,\n
\t\t\tscope: JSHINT.scope,\n
\t\t\ta: a,\n
\t\t\tb: b,\n
\t\t\tc: c,\n
\t\t\td: d\n
\t\t};\n
\t\tw.reason = supplant(m, w);\n
\t\tJSHINT.errors.push(w);\n
\t\tif (option.passfail) {\n
\t\t\tquit("Stopping. ", l, ch);\n
\t\t}\n
\t\twarnings += 1;\n
\t\tif (warnings >= option.maxerr) {\n
\t\t\tquit("Too many errors.", l, ch);\n
\t\t}\n
\t\treturn w;\n
\t}\n
\n
\tfunction warningAt(m, l, ch, a, b, c, d) {\n
\t\treturn warning(m, {\n
\t\t\tline: l,\n
\t\t\tfrom: ch\n
\t\t}, a, b, c, d);\n
\t}\n
\n
\tfunction error(m, t, a, b, c, d) {\n
\t\twarning(m, t, a, b, c, d);\n
\t}\n
\n
\tfunction errorAt(m, l, ch, a, b, c, d) {\n
\t\treturn error(m, {\n
\t\t\tline: l,\n
\t\t\tfrom: ch\n
\t\t}, a, b, c, d);\n
\t}\n
\tfunction addInternalSrc(elem, src) {\n
\t\tvar i;\n
\t\ti = {\n
\t\t\tid: "(internal)",\n
\t\t\telem: elem,\n
\t\t\tvalue: src\n
\t\t};\n
\t\tJSHINT.internals.push(i);\n
\t\treturn i;\n
\t}\n
\n
\tvar lex = (function lex() {\n
\t\tvar character, from, line, s;\n
\n
\t\tfunction nextLine() {\n
\t\t\tvar at,\n
\t\t\t\tmatch,\n
\t\t\t\ttw; // trailing whitespace check\n
\n
\t\t\tif (line >= lines.length)\n
\t\t\t\treturn false;\n
\n
\t\t\tcharacter = 1;\n
\t\t\ts = lines[line];\n
\t\t\tline += 1;\n
\t\t\tif (option.smarttabs) {\n
\t\t\t\tmatch = s.match(/(\\/\\/)? \\t/);\n
\t\t\t\tat = match && !match[1] ? 0 : -1;\n
\t\t\t} else {\n
\t\t\t\tat = s.search(/ \\t|\\t [^\\*]/);\n
\t\t\t}\n
\n
\t\t\tif (at >= 0)\n
\t\t\t\twarningAt("Mixed spaces and tabs.", line, at + 1);\n
\n
\t\t\ts = s.replace(/\\t/g, tab);\n
\t\t\tat = s.search(cx);\n
\n
\t\t\tif (at >= 0)\n
\t\t\t\twarningAt("Unsafe character.", line, at);\n
\n
\t\t\tif (option.maxlen && option.maxlen < s.length)\n
\t\t\t\twarningAt("Line too long.", line, s.length);\n
\t\t\ttw = option.trailing && s.match(/^(.*?)\\s+$/);\n
\t\t\tif (tw && !/^\\s+$/.test(s)) {\n
\t\t\t\twarningAt("Trailing whitespace.", line, tw[1].length + 1);\n
\t\t\t}\n
\t\t\treturn true;\n
\t\t}\n
\n
\t\tfunction it(type, value) {\n
\t\t\tvar i, t;\n
\n
\t\t\tfunction checkName(name) {\n
\t\t\t\tif (!option.proto && name === "__proto__") {\n
\t\t\t\t\twarningAt("The \'{a}\' property is deprecated.", line, from, name);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!option.iterator && name === "__iterator__") {\n
\t\t\t\t\twarningAt("\'{a}\' is only available in JavaScript 1.7.", line, from, name);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tvar hasDangling = /^(_+.*|.*_+)$/.test(name);\n
\n
\t\t\t\tif (option.nomen && hasDangling && name !== "_") {\n
\t\t\t\t\tif (option.node && token.id !== "." && /^(__dirname|__filename)$/.test(name))\n
\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\twarningAt("Unexpected {a} in \'{b}\'.", line, from, "dangling \'_\'", name);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (option.camelcase) {\n
\t\t\t\t\tif (name.replace(/^_+/, "").indexOf("_") > -1 && !name.match(/^[A-Z0-9_]*$/)) {\n
\t\t\t\t\t\twarningAt("Identifier \'{a}\' is not in camel case.", line, from, value);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (type === "(color)" || type === "(range)") {\n
\t\t\t\tt = {type: type};\n
\t\t\t} else if (type === "(punctuator)" ||\n
\t\t\t\t\t(type === "(identifier)" && is_own(syntax, value))) {\n
\t\t\t\tt = syntax[value] || syntax["(error)"];\n
\t\t\t} else {\n
\t\t\t\tt = syntax[type];\n
\t\t\t}\n
\n
\t\t\tt = Object.create(t);\n
\n
\t\t\tif (type === "(string)" || type === "(range)") {\n
\t\t\t\tif (!option.scripturl && jx.test(value)) {\n
\t\t\t\t\twarningAt("Script URL.", line, from);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (type === "(identifier)") {\n
\t\t\t\tt.identifier = true;\n
\t\t\t\tcheckName(value);\n
\t\t\t}\n
\n
\t\t\tt.value = value;\n
\t\t\tt.line = line;\n
\t\t\tt.character = character;\n
\t\t\tt.from = from;\n
\t\t\ti = t.id;\n
\t\t\tif (i !== "(endline)") {\n
\t\t\t\tprereg = i &&\n
\t\t\t\t\t(("(,=:[!&|?{};".indexOf(i.charAt(i.length - 1)) >= 0) ||\n
\t\t\t\t\ti === "return" ||\n
\t\t\t\t\ti === "case");\n
\t\t\t}\n
\t\t\treturn t;\n
\t\t}\n
\t\treturn {\n
\t\t\tinit: function (source) {\n
\t\t\t\tif (typeof source === "string") {\n
\t\t\t\t\tlines = source\n
\t\t\t\t\t\t.replace(/\\r\\n/g, "\\n")\n
\t\t\t\t\t\t.replace(/\\r/g, "\\n")\n
\t\t\t\t\t\t.split("\\n");\n
\t\t\t\t} else {\n
\t\t\t\t\tlines = source;\n
\t\t\t\t}\n
\t\t\t\tif (lines[0] && lines[0].substr(0, 2) === "#!")\n
\t\t\t\t\tlines[0] = "";\n
\n
\t\t\t\tline = 0;\n
\t\t\t\tnextLine();\n
\t\t\t\tfrom = 1;\n
\t\t\t},\n
\n
\t\t\trange: function (begin, end) {\n
\t\t\t\tvar c, value = "";\n
\t\t\t\tfrom = character;\n
\t\t\t\tif (s.charAt(0) !== begin) {\n
\t\t\t\t\terrorAt("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\t\t\tline, character, begin, s.charAt(0));\n
\t\t\t\t}\n
\t\t\t\tfor (;;) {\n
\t\t\t\t\ts = s.slice(1);\n
\t\t\t\t\tcharacter += 1;\n
\t\t\t\t\tc = s.charAt(0);\n
\t\t\t\t\tswitch (c) {\n
\t\t\t\t\tcase "":\n
\t\t\t\t\t\terrorAt("Missing \'{a}\'.", line, character, c);\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\tcase end:\n
\t\t\t\t\t\ts = s.slice(1);\n
\t\t\t\t\t\tcharacter += 1;\n
\t\t\t\t\t\treturn it("(range)", value);\n
\t\t\t\t\tcase "\\\\":\n
\t\t\t\t\t\twarningAt("Unexpected \'{a}\'.", line, character, c);\n
\t\t\t\t\t}\n
\t\t\t\t\tvalue += c;\n
\t\t\t\t}\n
\n
\t\t\t},\n
\t\t\ttoken: function () {\n
\t\t\t\tvar b, c, captures, d, depth, high, i, l, low, q, t, isLiteral, isInRange, n;\n
\n
\t\t\t\tfunction match(x) {\n
\t\t\t\t\tvar r = x.exec(s), r1;\n
\n
\t\t\t\t\tif (r) {\n
\t\t\t\t\t\tl = r[0].length;\n
\t\t\t\t\t\tr1 = r[1];\n
\t\t\t\t\t\tc = r1.charAt(0);\n
\t\t\t\t\t\ts = s.substr(l);\n
\t\t\t\t\t\tfrom = character + l - r1.length;\n
\t\t\t\t\t\tcharacter += l;\n
\t\t\t\t\t\treturn r1;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction string(x) {\n
\t\t\t\t\tvar c, j, r = "", allowNewLine = false;\n
\n
\t\t\t\t\tif (jsonmode && x !== "\\"") {\n
\t\t\t\t\t\twarningAt("Strings must use doublequote.",\n
\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (option.quotmark) {\n
\t\t\t\t\t\tif (option.quotmark === "single" && x !== "\'") {\n
\t\t\t\t\t\t\twarningAt("Strings must use singlequote.",\n
\t\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t\t} else if (option.quotmark === "double" && x !== "\\"") {\n
\t\t\t\t\t\t\twarningAt("Strings must use doublequote.",\n
\t\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t\t} else if (option.quotmark === true) {\n
\t\t\t\t\t\t\tquotmark = quotmark || x;\n
\t\t\t\t\t\t\tif (quotmark !== x) {\n
\t\t\t\t\t\t\t\twarningAt("Mixed double and single quotes.",\n
\t\t\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfunction esc(n) {\n
\t\t\t\t\t\tvar i = parseInt(s.substr(j + 1, n), 16);\n
\t\t\t\t\t\tj += n;\n
\t\t\t\t\t\tif (i >= 32 && i <= 126 &&\n
\t\t\t\t\t\t\t\ti !== 34 && i !== 92 && i !== 39) {\n
\t\t\t\t\t\t\twarningAt("Unnecessary escapement.", line, character);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tcharacter += n;\n
\t\t\t\t\t\tc = String.fromCharCode(i);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tj = 0;\n
\n
unclosedString:\n
\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\twhile (j >= s.length) {\n
\t\t\t\t\t\t\tj = 0;\n
\n
\t\t\t\t\t\t\tvar cl = line, cf = from;\n
\t\t\t\t\t\t\tif (!nextLine()) {\n
\t\t\t\t\t\t\t\terrorAt("Unclosed string.", cl, cf);\n
\t\t\t\t\t\t\t\tbreak unclosedString;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (allowNewLine) {\n
\t\t\t\t\t\t\t\tallowNewLine = false;\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\twarningAt("Unclosed string.", cl, cf);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tc = s.charAt(j);\n
\t\t\t\t\t\tif (c === x) {\n
\t\t\t\t\t\t\tcharacter += 1;\n
\t\t\t\t\t\t\ts = s.substr(j + 1);\n
\t\t\t\t\t\t\treturn it("(string)", r, x);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (c < " ") {\n
\t\t\t\t\t\t\tif (c === "\\n" || c === "\\r") {\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\twarningAt("Control character in string: {a}.",\n
\t\t\t\t\t\t\t\t\tline, character + j, s.slice(0, j));\n
\t\t\t\t\t\t} else if (c === "\\\\") {\n
\t\t\t\t\t\t\tj += 1;\n
\t\t\t\t\t\t\tcharacter += 1;\n
\t\t\t\t\t\t\tc = s.charAt(j);\n
\t\t\t\t\t\t\tn = s.charAt(j + 1);\n
\t\t\t\t\t\t\tswitch (c) {\n
\t\t\t\t\t\t\tcase "\\\\":\n
\t\t\t\t\t\t\tcase "\\"":\n
\t\t\t\t\t\t\tcase "/":\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "\\\'":\n
\t\t\t\t\t\t\t\tif (jsonmode) {\n
\t\t\t\t\t\t\t\t\twarningAt("Avoid \\\\\'.", line, character);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "b":\n
\t\t\t\t\t\t\t\tc = "\\b";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "f":\n
\t\t\t\t\t\t\t\tc = "\\f";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "n":\n
\t\t\t\t\t\t\t\tc = "\\n";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "r":\n
\t\t\t\t\t\t\t\tc = "\\r";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "t":\n
\t\t\t\t\t\t\t\tc = "\\t";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "0":\n
\t\t\t\t\t\t\t\tc = "\\0";\n
\t\t\t\t\t\t\t\tif (n >= 0 && n <= 7 && directive["use strict"]) {\n
\t\t\t\t\t\t\t\t\twarningAt(\n
\t\t\t\t\t\t\t\t\t"Octal literals are not allowed in strict mode.",\n
\t\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "u":\n
\t\t\t\t\t\t\t\tesc(4);\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "v":\n
\t\t\t\t\t\t\t\tif (jsonmode) {\n
\t\t\t\t\t\t\t\t\twarningAt("Avoid \\\\v.", line, character);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tc = "\\v";\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "x":\n
\t\t\t\t\t\t\t\tif (jsonmode) {\n
\t\t\t\t\t\t\t\t\twarningAt("Avoid \\\\x-.", line, character);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tesc(2);\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "":\n
\t\t\t\t\t\t\t\tallowNewLine = true;\n
\t\t\t\t\t\t\t\tif (option.multistr) {\n
\t\t\t\t\t\t\t\t\tif (jsonmode) {\n
\t\t\t\t\t\t\t\t\t\twarningAt("Avoid EOL escapement.", line, character);\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\tc = "";\n
\t\t\t\t\t\t\t\t\tcharacter -= 1;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\twarningAt("Bad escapement of EOL. Use option multistr if needed.",\n
\t\t\t\t\t\t\t\t\tline, character);\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tcase "!":\n
\t\t\t\t\t\t\t\tif (s.charAt(j - 2) === "<")\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\tdefault:\n
\t\t\t\t\t\t\t\twarningAt("Bad escapement.", line, character);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tr += c;\n
\t\t\t\t\t\tcharacter += 1;\n
\t\t\t\t\t\tj += 1;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfor (;;) {\n
\t\t\t\t\tif (!s) {\n
\t\t\t\t\t\treturn it(nextLine() ? "(endline)" : "(end)", "");\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tt = match(tx);\n
\n
\t\t\t\t\tif (!t) {\n
\t\t\t\t\t\tt = "";\n
\t\t\t\t\t\tc = "";\n
\t\t\t\t\t\twhile (s && s < "!") {\n
\t\t\t\t\t\t\ts = s.substr(1);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tif (s) {\n
\t\t\t\t\t\t\terrorAt("Unexpected \'{a}\'.", line, character, s.substr(0, 1));\n
\t\t\t\t\t\t\ts = "";\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\n
\t\t\t\t\t\tif (isAlpha(c) || c === "_" || c === "$") {\n
\t\t\t\t\t\t\treturn it("(identifier)", t);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (isDigit(c)) {\n
\t\t\t\t\t\t\tif (!isFinite(Number(t))) {\n
\t\t\t\t\t\t\t\twarningAt("Bad number \'{a}\'.",\n
\t\t\t\t\t\t\t\t\tline, character, t);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\tif (isAlpha(s.substr(0, 1))) {\n
\t\t\t\t\t\t\t\twarningAt("Missing space after \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\tline, character, t);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\tif (c === "0") {\n
\t\t\t\t\t\t\t\td = t.substr(1, 1);\n
\t\t\t\t\t\t\t\tif (isDigit(d)) {\n
\t\t\t\t\t\t\t\t\tif (token.id !== ".") {\n
\t\t\t\t\t\t\t\t\t\twarningAt("Don\'t use extra leading zeros \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\tline, character, t);\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t} else if (jsonmode && (d === "x" || d === "X")) {\n
\t\t\t\t\t\t\t\t\twarningAt("Avoid 0x-. \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\tline, character, t);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\tif (t.substr(t.length - 1) === ".") {\n
\t\t\t\t\t\t\t\twarningAt(\n
"A trailing decimal point can be confused with a dot \'{a}\'.", line, character, t);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\treturn it("(number)", t);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tswitch (t) {\n
\n
\t\t\t\t\t\tcase "\\"":\n
\t\t\t\t\t\tcase "\'":\n
\t\t\t\t\t\t\treturn string(t);\n
\n
\t\t\t\t\t\tcase "//":\n
\t\t\t\t\t\t\ts = "";\n
\t\t\t\t\t\t\ttoken.comment = true;\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "/*":\n
\t\t\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\t\t\ti = s.search(lx);\n
\t\t\t\t\t\t\t\tif (i >= 0) {\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tif (!nextLine()) {\n
\t\t\t\t\t\t\t\t\terrorAt("Unclosed comment.", line, character);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\ts = s.substr(i + 2);\n
\t\t\t\t\t\t\ttoken.comment = true;\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "/*members":\n
\t\t\t\t\t\tcase "/*member":\n
\t\t\t\t\t\tcase "/*jshint":\n
\t\t\t\t\t\tcase "/*jslint":\n
\t\t\t\t\t\tcase "/*global":\n
\t\t\t\t\t\tcase "*/":\n
\t\t\t\t\t\t\treturn {\n
\t\t\t\t\t\t\t\tvalue: t,\n
\t\t\t\t\t\t\t\ttype: "special",\n
\t\t\t\t\t\t\t\tline: line,\n
\t\t\t\t\t\t\t\tcharacter: character,\n
\t\t\t\t\t\t\t\tfrom: from\n
\t\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\tcase "":\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\tcase "/":\n
\t\t\t\t\t\t\tif (s.charAt(0) === "=") {\n
\t\t\t\t\t\t\t\terrorAt("A regular expression literal can be confused with \'/=\'.",\n
\t\t\t\t\t\t\t\t\tline, from);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (prereg) {\n
\t\t\t\t\t\t\t\tdepth = 0;\n
\t\t\t\t\t\t\t\tcaptures = 0;\n
\t\t\t\t\t\t\t\tl = 0;\n
\t\t\t\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\t\t\t\tb = true;\n
\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\tswitch (c) {\n
\t\t\t\t\t\t\t\t\tcase "":\n
\t\t\t\t\t\t\t\t\t\terrorAt("Unclosed regular expression.", line, from);\n
\t\t\t\t\t\t\t\t\t\treturn quit("Stopping.", line, from);\n
\t\t\t\t\t\t\t\t\tcase "/":\n
\t\t\t\t\t\t\t\t\t\tif (depth > 0) {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt("{a} unterminated regular expression " +\n
\t\t\t\t\t\t\t\t\t\t\t\t"group(s).", line, from + l, depth);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tc = s.substr(0, l - 1);\n
\t\t\t\t\t\t\t\t\t\tq = {\n
\t\t\t\t\t\t\t\t\t\t\tg: true,\n
\t\t\t\t\t\t\t\t\t\t\ti: true,\n
\t\t\t\t\t\t\t\t\t\t\tm: true\n
\t\t\t\t\t\t\t\t\t\t};\n
\t\t\t\t\t\t\t\t\t\twhile (q[s.charAt(l)] === true) {\n
\t\t\t\t\t\t\t\t\t\t\tq[s.charAt(l)] = false;\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tcharacter += l;\n
\t\t\t\t\t\t\t\t\t\ts = s.substr(l);\n
\t\t\t\t\t\t\t\t\t\tq = s.charAt(0);\n
\t\t\t\t\t\t\t\t\t\tif (q === "/" || q === "*") {\n
\t\t\t\t\t\t\t\t\t\t\terrorAt("Confusing regular expression.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\tline, from);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\treturn it("(regexp)", c);\n
\t\t\t\t\t\t\t\t\tcase "\\\\":\n
\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\tif (c < " ") {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Unexpected control character in regular expression.", line, from + l);\n
\t\t\t\t\t\t\t\t\t\t} else if (c === "<") {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Unexpected escaped character \'{a}\' in regular expression.", line, from + l, c);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase "(":\n
\t\t\t\t\t\t\t\t\t\tdepth += 1;\n
\t\t\t\t\t\t\t\t\t\tb = false;\n
\t\t\t\t\t\t\t\t\t\tif (s.charAt(l) === "?") {\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tswitch (s.charAt(l)) {\n
\t\t\t\t\t\t\t\t\t\t\tcase ":":\n
\t\t\t\t\t\t\t\t\t\t\tcase "=":\n
\t\t\t\t\t\t\t\t\t\t\tcase "!":\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tdefault:\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Expected \'{a}\' and instead saw \'{b}\'.", line, from + l, ":", s.charAt(l));\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\tcaptures += 1;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase "|":\n
\t\t\t\t\t\t\t\t\t\tb = false;\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase ")":\n
\t\t\t\t\t\t\t\t\t\tif (depth === 0) {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l, ")");\n
\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\tdepth -= 1;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase " ":\n
\t\t\t\t\t\t\t\t\t\tq = 1;\n
\t\t\t\t\t\t\t\t\t\twhile (s.charAt(l) === " ") {\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tq += 1;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tif (q > 1) {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Spaces are hard to count. Use {{a}}.", line, from + l, q);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase "[":\n
\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\tif (c === "^") {\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tif (s.charAt(l) === "]") {\n
\t\t\t\t\t\t\t\t\t\t\t\terrorAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l, "^");\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tif (c === "]") {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt("Empty class.", line,\n
\t\t\t\t\t\t\t\t\t\t\t\t\tfrom + l - 1);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tisLiteral = false;\n
\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
klass:\n
\t\t\t\t\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tswitch (c) {\n
\t\t\t\t\t\t\t\t\t\t\tcase "[":\n
\t\t\t\t\t\t\t\t\t\t\tcase "^":\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l, c);\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tcase "-":\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isLiteral && !isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else if (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else if (s.charAt(l) === "]") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tif (option.regexdash !== (l === 2 || (l === 3 &&\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\ts.charAt(1) === "^"))) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l - 1, "-");\n
\t\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tcase "]":\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange && !option.regexdash) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l - 1, "-");\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak klass;\n
\t\t\t\t\t\t\t\t\t\t\tcase "\\\\":\n
\t\t\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\t\tif (c < " ") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Unexpected control character in regular expression.", line, from + l);\n
\t\t\t\t\t\t\t\t\t\t\t\t} else if (c === "<") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Unexpected escaped character \'{a}\' in regular expression.", line, from + l, c);\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\tif (/[wsd]/i.test(c)) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l, "-");\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else if (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tcase "/":\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.",\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tline, from + l - 1, "/");\n
\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tcase "<":\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\tdefault:\n
\t\t\t\t\t\t\t\t\t\t\t\tif (isInRange) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisInRange = false;\n
\t\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tisLiteral = true;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t} while (c);\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase ".":\n
\t\t\t\t\t\t\t\t\t\tif (option.regexp) {\n
\t\t\t\t\t\t\t\t\t\t\twarningAt("Insecure \'{a}\'.", line,\n
\t\t\t\t\t\t\t\t\t\t\t\t\tfrom + l, c);\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\tcase "]":\n
\t\t\t\t\t\t\t\t\tcase "?":\n
\t\t\t\t\t\t\t\t\tcase "{":\n
\t\t\t\t\t\t\t\t\tcase "}":\n
\t\t\t\t\t\t\t\t\tcase "+":\n
\t\t\t\t\t\t\t\t\tcase "*":\n
\t\t\t\t\t\t\t\t\t\twarningAt("Unescaped \'{a}\'.", line,\n
\t\t\t\t\t\t\t\t\t\t\t\tfrom + l, c);\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\tif (b) {\n
\t\t\t\t\t\t\t\t\t\tswitch (s.charAt(l)) {\n
\t\t\t\t\t\t\t\t\t\tcase "?":\n
\t\t\t\t\t\t\t\t\t\tcase "+":\n
\t\t\t\t\t\t\t\t\t\tcase "*":\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tif (s.charAt(l) === "?") {\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\tcase "{":\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\tif (c < "0" || c > "9") {\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Expected a number and instead saw \'{a}\'.", line, from + l, c);\n
\t\t\t\t\t\t\t\t\t\t\t\tbreak; // No reason to continue checking numbers.\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\tlow = +c;\n
\t\t\t\t\t\t\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\t\tif (c < "0" || c > "9") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\tlow = +c + (low * 10);\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\thigh = low;\n
\t\t\t\t\t\t\t\t\t\t\tif (c === ",") {\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\thigh = Infinity;\n
\t\t\t\t\t\t\t\t\t\t\t

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAM=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="3" aka="AAAAAAAAAAM=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\t\tif (c >= "0" && c <= "9") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\t\thigh = +c;\n
\t\t\t\t\t\t\t\t\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = s.charAt(l);\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < "0" || c > "9") {\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t\t\t\thigh = +c + (high * 10);\n
\t\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\tif (s.charAt(l) !== "}") {\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"Expected \'{a}\' and instead saw \'{b}\'.", line, from + l, "}", c);\n
\t\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\tif (s.charAt(l) === "?") {\n
\t\t\t\t\t\t\t\t\t\t\t\tl += 1;\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t\tif (low > high) {\n
\t\t\t\t\t\t\t\t\t\t\t\twarningAt(\n
"\'{a}\' should not be greater than \'{b}\'.", line, from + l, low, high);\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\tc = s.substr(0, l - 1);\n
\t\t\t\t\t\t\t\tcharacter += l;\n
\t\t\t\t\t\t\t\ts = s.substr(l);\n
\t\t\t\t\t\t\t\treturn it("(regexp)", c);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\treturn it("(punctuator)", t);\n
\n
\t\t\t\t\t\tcase "#":\n
\t\t\t\t\t\t\treturn it("(punctuator)", t);\n
\t\t\t\t\t\tdefault:\n
\t\t\t\t\t\t\treturn it("(punctuator)", t);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\t}());\n
\n
\n
\tfunction addlabel(t, type, token) {\n
\t\tif (t === "hasOwnProperty") {\n
\t\t\twarning("\'hasOwnProperty\' is a really bad name.");\n
\t\t}\n
\t\tif (type === "exception") {\n
\t\t\tif (is_own(funct["(context)"], t)) {\n
\t\t\t\tif (funct[t] !== true && !option.node) {\n
\t\t\t\t\twarning("Value of \'{a}\' may be overwritten in IE.", nexttoken, t);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (is_own(funct, t) && !funct["(global)"]) {\n
\t\t\tif (funct[t] === true) {\n
\t\t\t\tif (option.latedef)\n
\t\t\t\t\twarning("\'{a}\' was used before it was defined.", nexttoken, t);\n
\t\t\t} else {\n
\t\t\t\tif (!option.shadow && type !== "exception") {\n
\t\t\t\t\twarning("\'{a}\' is already defined.", nexttoken, t);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunct[t] = type;\n
\n
\t\tif (token) {\n
\t\t\tfunct["(tokens)"][t] = token;\n
\t\t}\n
\n
\t\tif (funct["(global)"]) {\n
\t\t\tglobal[t] = funct;\n
\t\t\tif (is_own(implied, t)) {\n
\t\t\t\tif (option.latedef)\n
\t\t\t\t\twarning("\'{a}\' was used before it was defined.", nexttoken, t);\n
\t\t\t\tdelete implied[t];\n
\t\t\t}\n
\t\t} else {\n
\t\t\tscope[t] = funct;\n
\t\t}\n
\t}\n
\n
\n
\tfunction doOption() {\n
\t\tvar nt = nexttoken;\n
\t\tvar o  = nt.value;\n
\t\tvar quotmarkValue = option.quotmark;\n
\t\tvar predef = {};\n
\t\tvar b, obj, filter, t, tn, v, minus;\n
\n
\t\tswitch (o) {\n
\t\tcase "*/":\n
\t\t\terror("Unbegun comment.");\n
\t\t\tbreak;\n
\t\tcase "/*members":\n
\t\tcase "/*member":\n
\t\t\to = "/*members";\n
\t\t\tif (!membersOnly) {\n
\t\t\t\tmembersOnly = {};\n
\t\t\t}\n
\t\t\tobj = membersOnly;\n
\t\t\toption.quotmark = false;\n
\t\t\tbreak;\n
\t\tcase "/*jshint":\n
\t\tcase "/*jslint":\n
\t\t\tobj = option;\n
\t\t\tfilter = boolOptions;\n
\t\t\tbreak;\n
\t\tcase "/*global":\n
\t\t\tobj = predef;\n
\t\t\tbreak;\n
\t\tdefault:\n
\t\t\terror("What?");\n
\t\t}\n
\n
\t\tt = lex.token();\n
\n
\t\tfor (;;) {\n
\t\t\tminus = false;\n
\t\t\tvar breakOuterLoop;\n
\t\t\tfor (;;) {\n
\t\t\t\tif (t.type === "special" && t.value === "*/") {\n
\t\t\t\t\tbreakOuterLoop = true;\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tif (t.id !== "(endline)" && t.id !== ",") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tt = lex.token();\n
\t\t\t}\n
\t\t\tif (breakOuterLoop)\n
\t\t\t\tbreak;\n
\n
\t\t\tif (o === "/*global" && t.value === "-") {\n
\t\t\t\tminus = true;\n
\t\t\t\tt = lex.token();\n
\t\t\t}\n
\n
\t\t\tif (t.type !== "(string)" && t.type !== "(identifier)" && o !== "/*members") {\n
\t\t\t\terror("Bad option.", t);\n
\t\t\t}\n
\n
\t\t\tv = lex.token();\n
\t\t\tif (v.id === ":") {\n
\t\t\t\tv = lex.token();\n
\n
\t\t\t\tif (obj === membersOnly) {\n
\t\t\t\t\terror("Expected \'{a}\' and instead saw \'{b}\'.", t, "*/", ":");\n
\t\t\t\t}\n
\n
\t\t\t\tif (o === "/*jshint") {\n
\t\t\t\t\tcheckOption(t.value, t);\n
\t\t\t\t}\n
\n
\t\t\t\tvar numericVals = [\n
\t\t\t\t\t"maxstatements",\n
\t\t\t\t\t"maxparams",\n
\t\t\t\t\t"maxdepth",\n
\t\t\t\t\t"maxcomplexity",\n
\t\t\t\t\t"maxerr",\n
\t\t\t\t\t"maxlen",\n
\t\t\t\t\t"indent"\n
\t\t\t\t];\n
\n
\t\t\t\tif (numericVals.indexOf(t.value) > -1 && (o === "/*jshint" || o === "/*jslint")) {\n
\t\t\t\t\tb = +v.value;\n
\n
\t\t\t\t\tif (typeof b !== "number" || !isFinite(b) || b <= 0 || Math.floor(b) !== b) {\n
\t\t\t\t\t\terror("Expected a small integer and instead saw \'{a}\'.", v, v.value);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (t.value === "indent")\n
\t\t\t\t\t\tobj.white = true;\n
\n
\t\t\t\t\tobj[t.value] = b;\n
\t\t\t\t} else if (t.value === "validthis") {\n
\t\t\t\t\tif (funct["(global)"]) {\n
\t\t\t\t\t\terror("Option \'validthis\' can\'t be used in a global scope.");\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tif (v.value === "true" || v.value === "false")\n
\t\t\t\t\t\t\tobj[t.value] = v.value === "true";\n
\t\t\t\t\t\telse\n
\t\t\t\t\t\t\terror("Bad option value.", v);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (t.value === "quotmark" && (o === "/*jshint")) {\n
\t\t\t\t\tswitch (v.value) {\n
\t\t\t\t\tcase "true":\n
\t\t\t\t\t\tobj.quotmark = true;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\tcase "false":\n
\t\t\t\t\t\tobj.quotmark = false;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\tcase "double":\n
\t\t\t\t\tcase "single":\n
\t\t\t\t\t\tobj.quotmark = v.value;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\tdefault:\n
\t\t\t\t\t\terror("Bad option value.", v);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (v.value === "true" || v.value === "false") {\n
\t\t\t\t\tif (o === "/*jslint") {\n
\t\t\t\t\t\ttn = renamedOptions[t.value] || t.value;\n
\t\t\t\t\t\tobj[tn] = v.value === "true";\n
\t\t\t\t\t\tif (invertedOptions[tn] !== undefined) {\n
\t\t\t\t\t\t\tobj[tn] = !obj[tn];\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tobj[t.value] = v.value === "true";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (t.value === "newcap")\n
\t\t\t\t\t\tobj["(explicitNewcap)"] = true;\n
\t\t\t\t} else {\n
\t\t\t\t\terror("Bad option value.", v);\n
\t\t\t\t}\n
\t\t\t\tt = lex.token();\n
\t\t\t} else {\n
\t\t\t\tif (o === "/*jshint" || o === "/*jslint") {\n
\t\t\t\t\terror("Missing option value.", t);\n
\t\t\t\t}\n
\n
\t\t\t\tobj[t.value] = false;\n
\n
\t\t\t\tif (o === "/*global" && minus === true) {\n
\t\t\t\t\tJSHINT.blacklist[t.value] = t.value;\n
\t\t\t\t\tupdatePredefined();\n
\t\t\t\t}\n
\n
\t\t\t\tt = v;\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (o === "/*members") {\n
\t\t\toption.quotmark = quotmarkValue;\n
\t\t}\n
\n
\t\tcombine(predefined, predef);\n
\n
\t\tfor (var key in predef) {\n
\t\t\tif (is_own(predef, key)) {\n
\t\t\t\tdeclared[key] = nt;\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (filter) {\n
\t\t\tassume();\n
\t\t}\n
\t}\n
\n
\tfunction peek(p) {\n
\t\tvar i = p || 0, j = 0, t;\n
\n
\t\twhile (j <= i) {\n
\t\t\tt = lookahead[j];\n
\t\t\tif (!t) {\n
\t\t\t\tt = lookahead[j] = lex.token();\n
\t\t\t}\n
\t\t\tj += 1;\n
\t\t}\n
\t\treturn t;\n
\t}\n
\n
\tfunction advance(id, t) {\n
\t\tswitch (token.id) {\n
\t\tcase "(number)":\n
\t\t\tif (nexttoken.id === ".") {\n
\t\t\t\twarning("A dot following a number can be confused with a decimal point.", token);\n
\t\t\t}\n
\t\t\tbreak;\n
\t\tcase "-":\n
\t\t\tif (nexttoken.id === "-" || nexttoken.id === "--") {\n
\t\t\t\twarning("Confusing minusses.");\n
\t\t\t}\n
\t\t\tbreak;\n
\t\tcase "+":\n
\t\t\tif (nexttoken.id === "+" || nexttoken.id === "++") {\n
\t\t\t\twarning("Confusing plusses.");\n
\t\t\t}\n
\t\t\tbreak;\n
\t\t}\n
\n
\t\tif (token.type === "(string)" || token.identifier) {\n
\t\t\tanonname = token.value;\n
\t\t}\n
\n
\t\tif (id && nexttoken.id !== id) {\n
\t\t\tif (t) {\n
\t\t\t\tif (nexttoken.id === "(end)") {\n
\t\t\t\t\twarning("Unmatched \'{a}\'.", t, t.id);\n
\t\t\t\t} else {\n
\t\t\t\t\twarning("Expected \'{a}\' to match \'{b}\' from line {c} and instead saw \'{d}\'.",\n
\t\t\t\t\t\t\tnexttoken, id, t.id, t.line, nexttoken.value);\n
\t\t\t\t}\n
\t\t\t} else if (nexttoken.type !== "(identifier)" ||\n
\t\t\t\t\t\t\tnexttoken.value !== id) {\n
\t\t\t\twarning("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\t\tnexttoken, id, nexttoken.value);\n
\t\t\t}\n
\t\t}\n
\n
\t\tprevtoken = token;\n
\t\ttoken = nexttoken;\n
\t\tfor (;;) {\n
\t\t\tnexttoken = lookahead.shift() || lex.token();\n
\t\t\tif (nexttoken.id === "(end)" || nexttoken.id === "(error)") {\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t\tif (nexttoken.type === "special") {\n
\t\t\t\tdoOption();\n
\t\t\t} else {\n
\t\t\t\tif (nexttoken.id !== "(endline)") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction expression(rbp, initial) {\n
\t\tvar left, isArray = false, isObject = false;\n
\n
\t\tif (nexttoken.id === "(end)")\n
\t\t\terror("Unexpected early end of program.", token);\n
\n
\t\tadvance();\n
\t\tif (initial) {\n
\t\t\tanonname = "anonymous";\n
\t\t\tfunct["(verb)"] = token.value;\n
\t\t}\n
\t\tif (initial === true && token.fud) {\n
\t\t\tleft = token.fud();\n
\t\t} else {\n
\t\t\tif (token.nud) {\n
\t\t\t\tleft = token.nud();\n
\t\t\t} else {\n
\t\t\t\tif (nexttoken.type === "(number)" && token.id === ".") {\n
\t\t\t\t\twarning("A leading decimal point can be confused with a dot: \'.{a}\'.",\n
\t\t\t\t\t\t\ttoken, nexttoken.value);\n
\t\t\t\t\tadvance();\n
\t\t\t\t\treturn token;\n
\t\t\t\t} else {\n
\t\t\t\t\terror("Expected an identifier and instead saw \'{a}\'.",\n
\t\t\t\t\t\t\ttoken, token.id);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\twhile (rbp < nexttoken.lbp) {\n
\t\t\t\tisArray = token.value === "Array";\n
\t\t\t\tisObject = token.value === "Object";\n
\t\t\t\tif (left && (left.value || (left.first && left.first.value))) {\n
\t\t\t\t\tif (left.value !== "new" ||\n
\t\t\t\t\t  (left.first && left.first.value && left.first.value === ".")) {\n
\t\t\t\t\t\tisArray = false;\n
\t\t\t\t\t\tif (left.value !== token.value) {\n
\t\t\t\t\t\t\tisObject = false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tadvance();\n
\t\t\t\tif (isArray && token.id === "(" && nexttoken.id === ")")\n
\t\t\t\t\twarning("Use the array literal notation [].", token);\n
\t\t\t\tif (isObject && token.id === "(" && nexttoken.id === ")")\n
\t\t\t\t\twarning("Use the object literal notation {}.", token);\n
\t\t\t\tif (token.led) {\n
\t\t\t\t\tleft = token.led(left);\n
\t\t\t\t} else {\n
\t\t\t\t\terror("Expected an operator and instead saw \'{a}\'.",\n
\t\t\t\t\t\ttoken, token.id);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t\treturn left;\n
\t}\n
\n
\tfunction adjacent(left, right) {\n
\t\tleft = left || token;\n
\t\tright = right || nexttoken;\n
\t\tif (option.white) {\n
\t\t\tif (left.character !== right.from && left.line === right.line) {\n
\t\t\t\tleft.from += (left.character - left.from);\n
\t\t\t\twarning("Unexpected space after \'{a}\'.", left, left.value);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction nobreak(left, right) {\n
\t\tleft = left || token;\n
\t\tright = right || nexttoken;\n
\t\tif (option.white && (left.character !== right.from || left.line !== right.line)) {\n
\t\t\twarning("Unexpected space before \'{a}\'.", right, right.value);\n
\t\t}\n
\t}\n
\n
\tfunction nospace(left, right) {\n
\t\tleft = left || token;\n
\t\tright = right || nexttoken;\n
\t\tif (option.white && !left.comment) {\n
\t\t\tif (left.line === right.line) {\n
\t\t\t\tadjacent(left, right);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction nonadjacent(left, right) {\n
\t\tif (option.white) {\n
\t\t\tleft = left || token;\n
\t\t\tright = right || nexttoken;\n
\t\t\tif (left.value === ";" && right.value === ";") {\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t\tif (left.line === right.line && left.character === right.from) {\n
\t\t\t\tleft.from += (left.character - left.from);\n
\t\t\t\twarning("Missing space after \'{a}\'.",\n
\t\t\t\t\t\tleft, left.value);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction nobreaknonadjacent(left, right) {\n
\t\tleft = left || token;\n
\t\tright = right || nexttoken;\n
\t\tif (!option.laxbreak && left.line !== right.line) {\n
\t\t\twarning("Bad line breaking before \'{a}\'.", right, right.id);\n
\t\t} else if (option.white) {\n
\t\t\tleft = left || token;\n
\t\t\tright = right || nexttoken;\n
\t\t\tif (left.character === right.from) {\n
\t\t\t\tleft.from += (left.character - left.from);\n
\t\t\t\twarning("Missing space after \'{a}\'.",\n
\t\t\t\t\t\tleft, left.value);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction indentation(bias) {\n
\t\tvar i;\n
\t\tif (option.white && nexttoken.id !== "(end)") {\n
\t\t\ti = indent + (bias || 0);\n
\t\t\tif (nexttoken.from !== i) {\n
\t\t\t\twarning(\n
"Expected \'{a}\' to have an indentation at {b} instead at {c}.",\n
\t\t\t\t\t\tnexttoken, nexttoken.value, i, nexttoken.from);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction nolinebreak(t) {\n
\t\tt = t || token;\n
\t\tif (t.line !== nexttoken.line) {\n
\t\t\twarning("Line breaking error \'{a}\'.", t, t.value);\n
\t\t}\n
\t}\n
\n
\n
\tfunction comma() {\n
\t\tif (token.line !== nexttoken.line) {\n
\t\t\tif (!option.laxcomma) {\n
\t\t\t\tif (comma.first) {\n
\t\t\t\t\twarning("Comma warnings can be turned off with \'laxcomma\'");\n
\t\t\t\t\tcomma.first = false;\n
\t\t\t\t}\n
\t\t\t\twarning("Bad line breaking before \'{a}\'.", token, nexttoken.id);\n
\t\t\t}\n
\t\t} else if (!token.comment && token.character !== nexttoken.from && option.white) {\n
\t\t\ttoken.from += (token.character - token.from);\n
\t\t\twarning("Unexpected space after \'{a}\'.", token, token.value);\n
\t\t}\n
\t\tadvance(",");\n
\t\tnonadjacent(token, nexttoken);\n
\t}\n
\n
\tfunction symbol(s, p) {\n
\t\tvar x = syntax[s];\n
\t\tif (!x || typeof x !== "object") {\n
\t\t\tsyntax[s] = x = {\n
\t\t\t\tid: s,\n
\t\t\t\tlbp: p,\n
\t\t\t\tvalue: s\n
\t\t\t};\n
\t\t}\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction delim(s) {\n
\t\treturn symbol(s, 0);\n
\t}\n
\n
\n
\tfunction stmt(s, f) {\n
\t\tvar x = delim(s);\n
\t\tx.identifier = x.reserved = true;\n
\t\tx.fud = f;\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction blockstmt(s, f) {\n
\t\tvar x = stmt(s, f);\n
\t\tx.block = true;\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction reserveName(x) {\n
\t\tvar c = x.id.charAt(0);\n
\t\tif ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {\n
\t\t\tx.identifier = x.reserved = true;\n
\t\t}\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction prefix(s, f) {\n
\t\tvar x = symbol(s, 150);\n
\t\treserveName(x);\n
\t\tx.nud = (typeof f === "function") ? f : function () {\n
\t\t\tthis.right = expression(150);\n
\t\t\tthis.arity = "unary";\n
\t\t\tif (this.id === "++" || this.id === "--") {\n
\t\t\t\tif (option.plusplus) {\n
\t\t\t\t\twarning("Unexpected use of \'{a}\'.", this, this.id);\n
\t\t\t\t} else if ((!this.right.identifier || this.right.reserved) &&\n
\t\t\t\t\t\tthis.right.id !== "." && this.right.id !== "[") {\n
\t\t\t\t\twarning("Bad operand.", this);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn this;\n
\t\t};\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction type(s, f) {\n
\t\tvar x = delim(s);\n
\t\tx.type = s;\n
\t\tx.nud = f;\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction reserve(s, f) {\n
\t\tvar x = type(s, f);\n
\t\tx.identifier = x.reserved = true;\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction reservevar(s, v) {\n
\t\treturn reserve(s, function () {\n
\t\t\tif (typeof v === "function") {\n
\t\t\t\tv(this);\n
\t\t\t}\n
\t\t\treturn this;\n
\t\t});\n
\t}\n
\n
\n
\tfunction infix(s, f, p, w) {\n
\t\tvar x = symbol(s, p);\n
\t\treserveName(x);\n
\t\tx.led = function (left) {\n
\t\t\tif (!w) {\n
\t\t\t\tnobreaknonadjacent(prevtoken, token);\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t}\n
\t\t\tif (s === "in" && left.id === "!") {\n
\t\t\t\twarning("Confusing use of \'{a}\'.", left, "!");\n
\t\t\t}\n
\t\t\tif (typeof f === "function") {\n
\t\t\t\treturn f(left, this);\n
\t\t\t} else {\n
\t\t\t\tthis.left = left;\n
\t\t\t\tthis.right = expression(p);\n
\t\t\t\treturn this;\n
\t\t\t}\n
\t\t};\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction relation(s, f) {\n
\t\tvar x = symbol(s, 100);\n
\t\tx.led = function (left) {\n
\t\t\tnobreaknonadjacent(prevtoken, token);\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t\tvar right = expression(100);\n
\n
\t\t\tif (isIdentifier(left, "NaN") || isIdentifier(right, "NaN")) {\n
\t\t\t\twarning("Use the isNaN function to compare with NaN.", this);\n
\t\t\t} else if (f) {\n
\t\t\t\tf.apply(this, [left, right]);\n
\t\t\t}\n
\t\t\tif (left.id === "!") {\n
\t\t\t\twarning("Confusing use of \'{a}\'.", left, "!");\n
\t\t\t}\n
\t\t\tif (right.id === "!") {\n
\t\t\t\twarning("Confusing use of \'{a}\'.", right, "!");\n
\t\t\t}\n
\t\t\tthis.left = left;\n
\t\t\tthis.right = right;\n
\t\t\treturn this;\n
\t\t};\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction isPoorRelation(node) {\n
\t\treturn node &&\n
\t\t\t  ((node.type === "(number)" && +node.value === 0) ||\n
\t\t\t   (node.type === "(string)" && node.value === "") ||\n
\t\t\t   (node.type === "null" && !option.eqnull) ||\n
\t\t\t\tnode.type === "true" ||\n
\t\t\t\tnode.type === "false" ||\n
\t\t\t\tnode.type === "undefined");\n
\t}\n
\n
\n
\tfunction assignop(s) {\n
\t\tsymbol(s, 20).exps = true;\n
\n
\t\treturn infix(s, function (left, that) {\n
\t\t\tthat.left = left;\n
\n
\t\t\tif (predefined[left.value] === false &&\n
\t\t\t\t\tscope[left.value]["(global)"] === true) {\n
\t\t\t\twarning("Read only.", left);\n
\t\t\t} else if (left["function"]) {\n
\t\t\t\twarning("\'{a}\' is a function.", left, left.value);\n
\t\t\t}\n
\n
\t\t\tif (left) {\n
\t\t\t\tif (option.esnext && funct[left.value] === "const") {\n
\t\t\t\t\twarning("Attempting to override \'{a}\' which is a constant", left, left.value);\n
\t\t\t\t}\n
\n
\t\t\t\tif (left.id === "." || left.id === "[") {\n
\t\t\t\t\tif (!left.left || left.left.value === "arguments") {\n
\t\t\t\t\t\twarning("Bad assignment.", that);\n
\t\t\t\t\t}\n
\t\t\t\t\tthat.right = expression(19);\n
\t\t\t\t\treturn that;\n
\t\t\t\t} else if (left.identifier && !left.reserved) {\n
\t\t\t\t\tif (funct[left.value] === "exception") {\n
\t\t\t\t\t\twarning("Do not assign to the exception parameter.", left);\n
\t\t\t\t\t}\n
\t\t\t\t\tthat.right = expression(19);\n
\t\t\t\t\treturn that;\n
\t\t\t\t}\n
\n
\t\t\t\tif (left === syntax["function"]) {\n
\t\t\t\t\twarning(\n
"Expected an identifier in an assignment and instead saw a function invocation.",\n
\t\t\t\t\t\t\t\ttoken);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\terror("Bad assignment.", that);\n
\t\t}, 20);\n
\t}\n
\n
\n
\tfunction bitwise(s, f, p) {\n
\t\tvar x = symbol(s, p);\n
\t\treserveName(x);\n
\t\tx.led = (typeof f === "function") ? f : function (left) {\n
\t\t\tif (option.bitwise) {\n
\t\t\t\twarning("Unexpected use of \'{a}\'.", this, this.id);\n
\t\t\t}\n
\t\t\tthis.left = left;\n
\t\t\tthis.right = expression(p);\n
\t\t\treturn this;\n
\t\t};\n
\t\treturn x;\n
\t}\n
\n
\n
\tfunction bitwiseassignop(s) {\n
\t\tsymbol(s, 20).exps = true;\n
\t\treturn infix(s, function (left, that) {\n
\t\t\tif (option.bitwise) {\n
\t\t\t\twarning("Unexpected use of \'{a}\'.", that, that.id);\n
\t\t\t}\n
\t\t\tnonadjacent(prevtoken, token);\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t\tif (left) {\n
\t\t\t\tif (left.id === "." || left.id === "[" ||\n
\t\t\t\t\t\t(left.identifier && !left.reserved)) {\n
\t\t\t\t\texpression(19);\n
\t\t\t\t\treturn that;\n
\t\t\t\t}\n
\t\t\t\tif (left === syntax["function"]) {\n
\t\t\t\t\twarning(\n
"Expected an identifier in an assignment, and instead saw a function invocation.",\n
\t\t\t\t\t\t\t\ttoken);\n
\t\t\t\t}\n
\t\t\t\treturn that;\n
\t\t\t}\n
\t\t\terror("Bad assignment.", that);\n
\t\t}, 20);\n
\t}\n
\n
\n
\tfunction suffix(s) {\n
\t\tvar x = symbol(s, 150);\n
\t\tx.led = function (left) {\n
\t\t\tif (option.plusplus) {\n
\t\t\t\twarning("Unexpected use of \'{a}\'.", this, this.id);\n
\t\t\t} else if ((!left.identifier || left.reserved) &&\n
\t\t\t\t\tleft.id !== "." && left.id !== "[") {\n
\t\t\t\twarning("Bad operand.", this);\n
\t\t\t}\n
\t\t\tthis.left = left;\n
\t\t\treturn this;\n
\t\t};\n
\t\treturn x;\n
\t}\n
\tfunction optionalidentifier(fnparam) {\n
\t\tif (nexttoken.identifier) {\n
\t\t\tadvance();\n
\t\t\tif (token.reserved && !option.es5) {\n
\t\t\t\tif (!fnparam || token.value !== "undefined") {\n
\t\t\t\t\twarning("Expected an identifier and instead saw \'{a}\' (a reserved word).",\n
\t\t\t\t\t\t\ttoken, token.id);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn token.value;\n
\t\t}\n
\t}\n
\tfunction identifier(fnparam) {\n
\t\tvar i = optionalidentifier(fnparam);\n
\t\tif (i) {\n
\t\t\treturn i;\n
\t\t}\n
\t\tif (token.id === "function" && nexttoken.id === "(") {\n
\t\t\twarning("Missing name in function declaration.");\n
\t\t} else {\n
\t\t\terror("Expected an identifier and instead saw \'{a}\'.",\n
\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t}\n
\t}\n
\n
\n
\tfunction reachable(s) {\n
\t\tvar i = 0, t;\n
\t\tif (nexttoken.id !== ";" || noreach) {\n
\t\t\treturn;\n
\t\t}\n
\t\tfor (;;) {\n
\t\t\tt = peek(i);\n
\t\t\tif (t.reach) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t\tif (t.id !== "(endline)") {\n
\t\t\t\tif (t.id === "function") {\n
\t\t\t\t\tif (!option.latedef) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t\twarning(\n
"Inner functions should be listed at the top of the outer function.", t);\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\twarning("Unreachable \'{a}\' after \'{b}\'.", t, t.value, s);\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t\ti += 1;\n
\t\t}\n
\t}\n
\n
\n
\tfunction statement(noindent) {\n
\t\tvar i = indent, r, s = scope, t = nexttoken;\n
\n
\t\tif (t.id === ";") {\n
\t\t\tadvance(";");\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tif (t.identifier && !t.reserved && peek().id === ":") {\n
\t\t\tadvance();\n
\t\t\tadvance(":");\n
\t\t\tscope = Object.create(s);\n
\t\t\taddlabel(t.value, "label");\n
\n
\t\t\tif (!nexttoken.labelled && nexttoken.value !== "{") {\n
\t\t\t\twarning("Label \'{a}\' on {b} statement.", nexttoken, t.value, nexttoken.value);\n
\t\t\t}\n
\n
\t\t\tif (jx.test(t.value + ":")) {\n
\t\t\t\twarning("Label \'{a}\' looks like a javascript url.", t, t.value);\n
\t\t\t}\n
\n
\t\t\tnexttoken.label = t.value;\n
\t\t\tt = nexttoken;\n
\t\t}\n
\n
\t\tif (t.id === "{") {\n
\t\t\tblock(true, true);\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tif (!noindent) {\n
\t\t\tindentation();\n
\t\t}\n
\t\tr = expression(0, true);\n
\n
\t\tif (!t.block) {\n
\t\t\tif (!option.expr && (!r || !r.exps)) {\n
\t\t\t\twarning("Expected an assignment or function call and instead saw an expression.",\n
\t\t\t\t\ttoken);\n
\t\t\t} else if (option.nonew && r.id === "(" && r.left.id === "new") {\n
\t\t\t\twarning("Do not use \'new\' for side effects.", t);\n
\t\t\t}\n
\n
\t\t\tif (nexttoken.id === ",") {\n
\t\t\t\treturn comma();\n
\t\t\t}\n
\n
\t\t\tif (nexttoken.id !== ";") {\n
\t\t\t\tif (!option.asi) {\n
\t\t\t\t\tif (!option.lastsemic || nexttoken.id !== "}" ||\n
\t\t\t\t\t\t\tnexttoken.line !== token.line) {\n
\t\t\t\t\t\twarningAt("Missing semicolon.", token.line, token.character);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tadjacent(token, nexttoken);\n
\t\t\t\tadvance(";");\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t}\n
\t\t}\n
\n
\t\tindent = i;\n
\t\tscope = s;\n
\t\treturn r;\n
\t}\n
\n
\n
\tfunction statements(startLine) {\n
\t\tvar a = [], p;\n
\n
\t\twhile (!nexttoken.reach && nexttoken.id !== "(end)") {\n
\t\t\tif (nexttoken.id === ";") {\n
\t\t\t\tp = peek();\n
\t\t\t\tif (!p || p.id !== "(") {\n
\t\t\t\t\twarning("Unnecessary semicolon.");\n
\t\t\t\t}\n
\t\t\t\tadvance(";");\n
\t\t\t} else {\n
\t\t\t\ta.push(statement(startLine === nexttoken.line));\n
\t\t\t}\n
\t\t}\n
\t\treturn a;\n
\t}\n
\tfunction directives() {\n
\t\tvar i, p, pn;\n
\n
\t\tfor (;;) {\n
\t\t\tif (nexttoken.id === "(string)") {\n
\t\t\t\tp = peek(0);\n
\t\t\t\tif (p.id === "(endline)") {\n
\t\t\t\t\ti = 1;\n
\t\t\t\t\tdo {\n
\t\t\t\t\t\tpn = peek(i);\n
\t\t\t\t\t\ti = i + 1;\n
\t\t\t\t\t} while (pn.id === "(endline)");\n
\n
\t\t\t\t\tif (pn.id !== ";") {\n
\t\t\t\t\t\tif (pn.id !== "(string)" && pn.id !== "(number)" &&\n
\t\t\t\t\t\t\tpn.id !== "(regexp)" && pn.identifier !== true &&\n
\t\t\t\t\t\t\tpn.id !== "}") {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\twarning("Missing semicolon.", nexttoken);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tp = pn;\n
\t\t\t\t\t}\n
\t\t\t\t} else if (p.id === "}") {\n
\t\t\t\t\twarning("Missing semicolon.", p);\n
\t\t\t\t} else if (p.id !== ";") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tindentation();\n
\t\t\t\tadvance();\n
\t\t\t\tif (directive[token.value]) {\n
\t\t\t\t\twarning("Unnecessary directive \\"{a}\\".", token, token.value);\n
\t\t\t\t}\n
\n
\t\t\t\tif (token.value === "use strict") {\n
\t\t\t\t\tif (!option["(explicitNewcap)"])\n
\t\t\t\t\t\toption.newcap = true;\n
\t\t\t\t\toption.undef = true;\n
\t\t\t\t}\n
\t\t\t\tdirective[token.value] = true;\n
\n
\t\t\t\tif (p.id === ";") {\n
\t\t\t\t\tadvance(";");\n
\t\t\t\t}\n
\t\t\t\tcontinue;\n
\t\t\t}\n
\t\t\tbreak;\n
\t\t}\n
\t}\n
\tfunction block(ordinary, stmt, isfunc) {\n
\t\tvar a,\n
\t\t\tb = inblock,\n
\t\t\told_indent = indent,\n
\t\t\tm,\n
\t\t\ts = scope,\n
\t\t\tt,\n
\t\t\tline,\n
\t\t\td;\n
\n
\t\tinblock = ordinary;\n
\n
\t\tif (!ordinary || !option.funcscope)\n
\t\t\tscope = Object.create(scope);\n
\n
\t\tnonadjacent(token, nexttoken);\n
\t\tt = nexttoken;\n
\n
\t\tvar metrics = funct["(metrics)"];\n
\t\tmetrics.nestedBlockDepth += 1;\n
\t\tmetrics.verifyMaxNestedBlockDepthPerFunction();\n
\n
\t\tif (nexttoken.id === "{") {\n
\t\t\tadvance("{");\n
\t\t\tline = token.line;\n
\t\t\tif (nexttoken.id !== "}") {\n
\t\t\t\tindent += option.indent;\n
\t\t\t\twhile (!ordinary && nexttoken.from > indent) {\n
\t\t\t\t\tindent += option.indent;\n
\t\t\t\t}\n
\n
\t\t\t\tif (isfunc) {\n
\t\t\t\t\tm = {};\n
\t\t\t\t\tfor (d in directive) {\n
\t\t\t\t\t\tif (is_own(directive, d)) {\n
\t\t\t\t\t\t\tm[d] = directive[d];\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t\tdirectives();\n
\n
\t\t\t\t\tif (option.strict && funct["(context)"]["(global)"]) {\n
\t\t\t\t\t\tif (!m["use strict"] && !directive["use strict"]) {\n
\t\t\t\t\t\t\twarning("Missing \\"use strict\\" statement.");\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\ta = statements(line);\n
\n
\t\t\t\tmetrics.statementCount += a.length;\n
\n
\t\t\t\tif (isfunc) {\n
\t\t\t\t\tdirective = m;\n
\t\t\t\t}\n
\n
\t\t\t\tindent -= option.indent;\n
\t\t\t\tif (line !== nexttoken.line) {\n
\t\t\t\t\tindentation();\n
\t\t\t\t}\n
\t\t\t} else if (line !== nexttoken.line) {\n
\t\t\t\tindentation();\n
\t\t\t}\n
\t\t\tadvance("}", t);\n
\t\t\tindent = old_indent;\n
\t\t} else if (!ordinary) {\n
\t\t\terror("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t  nexttoken, "{", nexttoken.value);\n
\t\t} else {\n
\t\t\tif (!stmt || option.curly)\n
\t\t\t\twarning("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\t\tnexttoken, "{", nexttoken.value);\n
\n
\t\t\tnoreach = true;\n
\t\t\tindent += option.indent;\n
\t\t\ta = [statement(nexttoken.line === token.line)];\n
\t\t\tindent -= option.indent;\n
\t\t\tnoreach = false;\n
\t\t}\n
\t\tfunct["(verb)"] = null;\n
\t\tif (!ordinary || !option.funcscope) scope = s;\n
\t\tinblock = b;\n
\t\tif (ordinary && option.noempty && (!a || a.length === 0)) {\n
\t\t\twarning("Empty block.");\n
\t\t}\n
\t\tmetrics.nestedBlockDepth -= 1;\n
\t\treturn a;\n
\t}\n
\n
\n
\tfunction countMember(m) {\n
\t\tif (membersOnly && typeof membersOnly[m] !== "boolean") {\n
\t\t\twarning("Unexpected /*member \'{a}\'.", token, m);\n
\t\t}\n
\t\tif (typeof member[m] === "number") {\n
\t\t\tmember[m] += 1;\n
\t\t} else {\n
\t\t\tmember[m] = 1;\n
\t\t}\n
\t}\n
\n
\n
\tfunction note_implied(token) {\n
\t\tvar name = token.value, line = token.line, a = implied[name];\n
\t\tif (typeof a === "function") {\n
\t\t\ta = false;\n
\t\t}\n
\n
\t\tif (!a) {\n
\t\t\ta = [line];\n
\t\t\timplied[name] = a;\n
\t\t} else if (a[a.length - 1] !== line) {\n
\t\t\ta.push(line);\n
\t\t}\n
\t}\n
\n
\ttype("(number)", function () {\n
\t\treturn this;\n
\t});\n
\n
\ttype("(string)", function () {\n
\t\treturn this;\n
\t});\n
\n
\tsyntax["(identifier)"] = {\n
\t\ttype: "(identifier)",\n
\t\tlbp: 0,\n
\t\tidentifier: true,\n
\t\tnud: function () {\n
\t\t\tvar v = this.value,\n
\t\t\t\ts = scope[v],\n
\t\t\t\tf;\n
\n
\t\t\tif (typeof s === "function") {\n
\t\t\t\ts = undefined;\n
\t\t\t} else if (typeof s === "boolean") {\n
\t\t\t\tf = funct;\n
\t\t\t\tfunct = functions[0];\n
\t\t\t\taddlabel(v, "var");\n
\t\t\t\ts = funct;\n
\t\t\t\tfunct = f;\n
\t\t\t}\n
\t\t\tif (funct === s) {\n
\t\t\t\tswitch (funct[v]) {\n
\t\t\t\tcase "unused":\n
\t\t\t\t\tfunct[v] = "var";\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "unction":\n
\t\t\t\t\tfunct[v] = "function";\n
\t\t\t\t\tthis["function"] = true;\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "function":\n
\t\t\t\t\tthis["function"] = true;\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "label":\n
\t\t\t\t\twarning("\'{a}\' is a statement label.", token, v);\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t} else if (funct["(global)"]) {\n
\n
\t\t\t\tif (option.undef && typeof predefined[v] !== "boolean") {\n
\t\t\t\t\tif (!(anonname === "typeof" || anonname === "delete") ||\n
\t\t\t\t\t\t(nexttoken && (nexttoken.value === "." || nexttoken.value === "["))) {\n
\n
\t\t\t\t\t\tisundef(funct, "\'{a}\' is not defined.", token, v);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tnote_implied(token);\n
\t\t\t} else {\n
\n
\t\t\t\tswitch (funct[v]) {\n
\t\t\t\tcase "closure":\n
\t\t\t\tcase "function":\n
\t\t\t\tcase "var":\n
\t\t\t\tcase "unused":\n
\t\t\t\t\twarning("\'{a}\' used out of scope.", token, v);\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "label":\n
\t\t\t\t\twarning("\'{a}\' is a statement label.", token, v);\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "outer":\n
\t\t\t\tcase "global":\n
\t\t\t\t\tbreak;\n
\t\t\t\tdefault:\n
\t\t\t\t\tif (s === true) {\n
\t\t\t\t\t\tfunct[v] = true;\n
\t\t\t\t\t} else if (s === null) {\n
\t\t\t\t\t\twarning("\'{a}\' is not allowed.", token, v);\n
\t\t\t\t\t\tnote_implied(token);\n
\t\t\t\t\t} else if (typeof s !== "object") {\n
\t\t\t\t\t\tif (option.undef) {\n
\t\t\t\t\t\t\tif (!(anonname === "typeof" || anonname === "delete") ||\n
\t\t\t\t\t\t\t\t(nexttoken &&\n
\t\t\t\t\t\t\t\t\t(nexttoken.value === "." || nexttoken.value === "["))) {\n
\n
\t\t\t\t\t\t\t\tisundef(funct, "\'{a}\' is not defined.", token, v);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tfunct[v] = true;\n
\t\t\t\t\t\tnote_implied(token);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tswitch (s[v]) {\n
\t\t\t\t\t\tcase "function":\n
\t\t\t\t\t\tcase "unction":\n
\t\t\t\t\t\t\tthis["function"] = true;\n
\t\t\t\t\t\t\ts[v] = "closure";\n
\t\t\t\t\t\t\tfunct[v] = s["(global)"] ? "global" : "outer";\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\tcase "var":\n
\t\t\t\t\t\tcase "unused":\n
\t\t\t\t\t\t\ts[v] = "closure";\n
\t\t\t\t\t\t\tfunct[v] = s["(global)"] ? "global" : "outer";\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\tcase "closure":\n
\t\t\t\t\t\t\tfunct[v] = s["(global)"] ? "global" : "outer";\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\tcase "label":\n
\t\t\t\t\t\t\twarning("\'{a}\' is a statement label.", token, v);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn this;\n
\t\t},\n
\t\tled: function () {\n
\t\t\terror("Expected an operator and instead saw \'{a}\'.",\n
\t\t\t\tnexttoken, nexttoken.value);\n
\t\t}\n
\t};\n
\n
\ttype("(regexp)", function () {\n
\t\treturn this;\n
\t});\n
\n
\tdelim("(endline)");\n
\tdelim("(begin)");\n
\tdelim("(end)").reach = true;\n
\tdelim("</").reach = true;\n
\tdelim("<!");\n
\tdelim("<!--");\n
\tdelim("-->");\n
\tdelim("(error)").reach = true;\n
\tdelim("}").reach = true;\n
\tdelim(")");\n
\tdelim("]");\n
\tdelim("\\"").reach = true;\n
\tdelim("\'").reach = true;\n
\tdelim(";");\n
\tdelim(":").reach = true;\n
\tdelim(",");\n
\tdelim("#");\n
\tdelim("@");\n
\treserve("else");\n
\treserve("case").reach = true;\n
\treserve("catch");\n
\treserve("default").reach = true;\n
\treserve("finally");\n
\treservevar("arguments", function (x) {\n
\t\tif (directive["use strict"] && funct["(global)"]) {\n
\t\t\twarning("Strict violation.", x);\n
\t\t}\n
\t});\n
\treservevar("eval");\n
\treservevar("false");\n
\treservevar("Infinity");\n
\treservevar("null");\n
\treservevar("this", function (x) {\n
\t\tif (directive["use strict"] && !option.validthis && ((funct["(statement)"] &&\n
\t\t\t\tfunct["(name)"].charAt(0) > "Z") || funct["(global)"])) {\n
\t\t\twarning("Possible strict violation.", x);\n
\t\t}\n
\t});\n
\treservevar("true");\n
\treservevar("undefined");\n
\tassignop("=", "assign", 20);\n
\tassignop("+=", "assignadd", 20);\n
\tassignop("-=", "assignsub", 20);\n
\tassignop("*=", "assignmult", 20);\n
\tassignop("/=", "assigndiv", 20).nud = function () {\n
\t\terror("A regular expression literal can be confused with \'/=\'.");\n
\t};\n
\tassignop("%=", "assignmod", 20);\n
\tbitwiseassignop("&=", "assignbitand", 20);\n
\tbitwiseassignop("|=", "assignbitor", 20);\n
\tbitwiseassignop("^=", "assignbitxor", 20);\n
\tbitwiseassignop("<<=", "assignshiftleft", 20);\n
\tbitwiseassignop(">>=", "assignshiftright", 20);\n
\tbitwiseassignop(">>>=", "assignshiftrightunsigned", 20);\n
\tinfix("?", function (left, that) {\n
\t\tthat.left = left;\n
\t\tthat.right = expression(10);\n
\t\tadvance(":");\n
\t\tthat["else"] = expression(10);\n
\t\treturn that;\n
\t}, 30);\n
\n
\tinfix("||", "or", 40);\n
\tinfix("&&", "and", 50);\n
\tbitwise("|", "bitor", 70);\n
\tbitwise("^", "bitxor", 80);\n
\tbitwise("&", "bitand", 90);\n
\trelation("==", function (left, right) {\n
\t\tvar eqnull = option.eqnull && (left.value === "null" || right.value === "null");\n
\n
\t\tif (!eqnull && option.eqeqeq)\n
\t\t\twarning("Expected \'{a}\' and instead saw \'{b}\'.", this, "===", "==");\n
\t\telse if (isPoorRelation(left))\n
\t\t\twarning("Use \'{a}\' to compare with \'{b}\'.", this, "===", left.value);\n
\t\telse if (isPoorRelation(right))\n
\t\t\twarning("Use \'{a}\' to compare with \'{b}\'.", this, "===", right.value);\n
\n
\t\treturn this;\n
\t});\n
\trelation("===");\n
\trelation("!=", function (left, right) {\n
\t\tvar eqnull = option.eqnull &&\n
\t\t\t\t(left.value === "null" || right.value === "null");\n
\n
\t\tif (!eqnull && option.eqeqeq) {\n
\t\t\twarning("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\tthis, "!==", "!=");\n
\t\t} else if (isPoorRelation(left)) {\n
\t\t\twarning("Use \'{a}\' to compare with \'{b}\'.",\n
\t\t\t\t\tthis, "!==", left.value);\n
\t\t} else if (isPoorRelation(right)) {\n
\t\t\twarning("Use \'{a}\' to compare with \'{b}\'.",\n
\t\t\t\t\tthis, "!==", right.value);\n
\t\t}\n
\t\treturn this;\n
\t});\n
\trelation("!==");\n
\trelation("<");\n
\trelation(">");\n
\trelation("<=");\n
\trelation(">=");\n
\tbitwise("<<", "shiftleft", 120);\n
\tbitwise(">>", "shiftright", 120);\n
\tbitwise(">>>", "shiftrightunsigned", 120);\n
\tinfix("in", "in", 120);\n
\tinfix("instanceof", "instanceof", 120);\n
\tinfix("+", function (left, that) {\n
\t\tvar right = expression(130);\n
\t\tif (left && right && left.id === "(string)" && right.id === "(string)") {\n
\t\t\tleft.value += right.value;\n
\t\t\tleft.character = right.character;\n
\t\t\tif (!option.scripturl && jx.test(left.value)) {\n
\t\t\t\twarning("JavaScript URL.", left);\n
\t\t\t}\n
\t\t\treturn left;\n
\t\t}\n
\t\tthat.left = left;\n
\t\tthat.right = right;\n
\t\treturn that;\n
\t}, 130);\n
\tprefix("+", "num");\n
\tprefix("+++", function () {\n
\t\twarning("Confusing pluses.");\n
\t\tthis.right = expression(150);\n
\t\tthis.arity = "unary";\n
\t\treturn this;\n
\t});\n
\tinfix("+++", function (left) {\n
\t\twarning("Confusing pluses.");\n
\t\tthis.left = left;\n
\t\tthis.right = expression(130);\n
\t\treturn this;\n
\t}, 130);\n
\tinfix("-", "sub", 130);\n
\tprefix("-", "neg");\n
\tprefix("---", function () {\n
\t\twarning("Confusing minuses.");\n
\t\tthis.right = expression(150);\n
\t\tthis.arity = "unary";\n
\t\treturn this;\n
\t});\n
\tinfix("---", function (left) {\n
\t\twarning("Confusing minuses.");\n
\t\tthis.left = left;\n
\t\tthis.right = expression(130);\n
\t\treturn this;\n
\t}, 130);\n
\tinfix("*", "mult", 140);\n
\tinfix("/", "div", 140);\n
\tinfix("%", "mod", 140);\n
\n
\tsuffix("++", "postinc");\n
\tprefix("++", "preinc");\n
\tsyntax["++"].exps = true;\n
\n
\tsuffix("--", "postdec");\n
\tprefix("--", "predec");\n
\tsyntax["--"].exps = true;\n
\tprefix("delete", function () {\n
\t\tvar p = expression(0);\n
\t\tif (!p || (p.id !== "." && p.id !== "[")) {\n
\t\t\twarning("Variables should not be deleted.");\n
\t\t}\n
\t\tthis.first = p;\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\tprefix("~", function () {\n
\t\tif (option.bitwise) {\n
\t\t\twarning("Unexpected \'{a}\'.", this, "~");\n
\t\t}\n
\t\texpression(150);\n
\t\treturn this;\n
\t});\n
\n
\tprefix("!", function () {\n
\t\tthis.right = expression(150);\n
\t\tthis.arity = "unary";\n
\t\tif (bang[this.right.id] === true) {\n
\t\t\twarning("Confusing use of \'{a}\'.", this, "!");\n
\t\t}\n
\t\treturn this;\n
\t});\n
\tprefix("typeof", "typeof");\n
\tprefix("new", function () {\n
\t\tvar c = expression(155), i;\n
\t\tif (c && c.id !== "function") {\n
\t\t\tif (c.identifier) {\n
\t\t\t\tc["new"] = true;\n
\t\t\t\tswitch (c.value) {\n
\t\t\t\tcase "Number":\n
\t\t\t\tcase "String":\n
\t\t\t\tcase "Boolean":\n
\t\t\t\tcase "Math":\n
\t\t\t\tcase "JSON":\n
\t\t\t\t\twarning("Do not use {a} as a constructor.", prevtoken, c.value);\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "Function":\n
\t\t\t\t\tif (!option.evil) {\n
\t\t\t\t\t\twarning("The Function constructor is eval.");\n
\t\t\t\t\t}\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "Date":\n
\t\t\t\tcase "RegExp":\n
\t\t\t\t\tbreak;\n
\t\t\t\tdefault:\n
\t\t\t\t\tif (c.id !== "function") {\n
\t\t\t\t\t\ti = c.value.substr(0, 1);\n
\t\t\t\t\t\tif (option.newcap && (i < "A" || i > "Z") && !is_own(global, c.value)) {\n
\t\t\t\t\t\t\twarning("A constructor name should start with an uppercase letter.",\n
\t\t\t\t\t\t\t\ttoken);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tif (c.id !== "." && c.id !== "[" && c.id !== "(") {\n
\t\t\t\t\twarning("Bad constructor.", token);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t} else {\n
\t\t\tif (!option.supernew)\n
\t\t\t\twarning("Weird construction. Delete \'new\'.", this);\n
\t\t}\n
\t\tadjacent(token, nexttoken);\n
\t\tif (nexttoken.id !== "(" && !option.supernew) {\n
\t\t\twarning("Missing \'()\' invoking a constructor.",\n
\t\t\t\ttoken, token.value);\n
\t\t}\n
\t\tthis.first = c;\n
\t\treturn this;\n
\t});\n
\tsyntax["new"].exps = true;\n
\n
\tprefix("void").exps = true;\n
\n
\tinfix(".", function (left, that) {\n
\t\tadjacent(prevtoken, token);\n
\t\tnobreak();\n
\t\tvar m = identifier();\n
\t\tif (typeof m === "string") {\n
\t\t\tcountMember(m);\n
\t\t}\n
\t\tthat.left = left;\n
\t\tthat.right = m;\n
\t\tif (left && left.value === "arguments" && (m === "callee" || m === "caller")) {\n
\t\t\tif (option.noarg)\n
\t\t\t\twarning("Avoid arguments.{a}.", left, m);\n
\t\t\telse if (directive["use strict"])\n
\t\t\t\terror("Strict violation.");\n
\t\t} else if (!option.evil && left && left.value === "document" &&\n
\t\t\t\t(m === "write" || m === "writeln")) {\n
\t\t\twarning("document.write can be a form of eval.", left);\n
\t\t}\n
\t\tif (!option.evil && (m === "eval" || m === "execScript")) {\n
\t\t\twarning("eval is evil.");\n
\t\t}\n
\t\treturn that;\n
\t}, 160, true);\n
\n
\tinfix("(", function (left, that) {\n
\t\tif (prevtoken.id !== "}" && prevtoken.id !== ")") {\n
\t\t\tnobreak(prevtoken, token);\n
\t\t}\n
\t\tnospace();\n
\t\tif (option.immed && !left.immed && left.id === "function") {\n
\t\t\twarning("Wrap an immediate function invocation in parentheses " +\n
\t\t\t\t"to assist the reader in understanding that the expression " +\n
\t\t\t\t"is the result of a function, and not the function itself.");\n
\t\t}\n
\t\tvar n = 0,\n
\t\t\tp = [];\n
\t\tif (left) {\n
\t\t\tif (left.type === "(identifier)") {\n
\t\t\t\tif (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n
\t\t\t\t\tif ("Number String Boolean Date Object".indexOf(left.value) === -1) {\n
\t\t\t\t\t\tif (left.value === "Math") {\n
\t\t\t\t\t\t\twarning("Math is not a function.", left);\n
\t\t\t\t\t\t} else if (option.newcap) {\n
\t\t\t\t\t\t\twarning("Missing \'new\' prefix when invoking a constructor.", left);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t\tif (nexttoken.id !== ")") {\n
\t\t\tfor (;;) {\n
\t\t\t\tp[p.length] = expression(10);\n
\t\t\t\tn += 1;\n
\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tcomma();\n
\t\t\t}\n
\t\t}\n
\t\tadvance(")");\n
\t\tnospace(prevtoken, token);\n
\t\tif (typeof left === "object") {\n
\t\t\tif (left.value === "parseInt" && n === 1) {\n
\t\t\t\twarning("Missing radix parameter.", token);\n
\t\t\t}\n
\t\t\tif (!option.evil) {\n
\t\t\t\tif (left.value === "eval" || left.value === "Function" ||\n
\t\t\t\t\t\tleft.value === "execScript") {\n
\t\t\t\t\twarning("eval is evil.", left);\n
\n
\t\t\t\t\tif (p[0] && [0].id === "(string)") {\n
\t\t\t\t\t\taddInternalSrc(left, p[0].value);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (p[0] && p[0].id === "(string)" &&\n
\t\t\t\t\t   (left.value === "setTimeout" ||\n
\t\t\t\t\t\tleft.value === "setInterval")) {\n
\t\t\t\t\twarning(\n
\t"Implied eval is evil. Pass a function instead of a string.", left);\n
\t\t\t\t\taddInternalSrc(left, p[0].value);\n
\t\t\t\t} else if (p[0] && p[0].id === "(string)" &&\n
\t\t\t\t\t   left.value === "." &&\n
\t\t\t\t\t   left.left.value === "window" &&\n
\t\t\t\t\t   (left.right === "setTimeout" ||\n
\t\t\t\t\t\tleft.right === "setInterval")) {\n
\t\t\t\t\twarning(\n
\t"Implied eval is evil. Pass a function instead of a string.", left);\n
\t\t\t\t\taddInternalSrc(left, p[0].value);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tif (!left.identifier && left.id !== "." && left.id !== "[" &&\n
\t\t\t\t\tleft.id !== "(" && left.id !== "&&" && left.id !== "||" &&\n
\t\t\t\t\tleft.id !== "?") {\n
\t\t\t\twarning("Bad invocation.", left);\n
\t\t\t}\n
\t\t}\n
\t\tthat.left = left;\n
\t\treturn that;\n
\t}, 155, true).exps = true;\n
\n
\tprefix("(", function () {\n
\t\tnospace();\n
\t\tif (nexttoken.id === "function") {\n
\t\t\tnexttoken.immed = true;\n
\t\t}\n
\t\tvar v = expression(0);\n
\t\tadvance(")", this);\n
\t\tnospace(prevtoken, token);\n
\t\tif (option.immed && v.id === "function") {\n
\t\t\tif (nexttoken.id !== "(" &&\n
\t\t\t  (nexttoken.id !== "." || (peek().value !== "call" && peek().value !== "apply"))) {\n
\t\t\t\twarning(\n
"Do not wrap function literals in parens unless they are to be immediately invoked.",\n
\t\t\t\t\t\tthis);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn v;\n
\t});\n
\n
\tinfix("[", function (left, that) {\n
\t\tnobreak(prevtoken, token);\n
\t\tnospace();\n
\t\tvar e = expression(0), s;\n
\t\tif (e && e.type === "(string)") {\n
\t\t\tif (!option.evil && (e.value === "eval" || e.value === "execScript")) {\n
\t\t\t\twarning("eval is evil.", that);\n
\t\t\t}\n
\t\t\tcountMember(e.value);\n
\t\t\tif (!option.sub && ix.test(e.value)) {\n
\t\t\t\ts = syntax[e.value];\n
\t\t\t\tif (!s || !s.reserved) {\n
\t\t\t\t\twarning("[\'{a}\'] is better written in dot notation.",\n
\t\t\t\t\t\t\tprevtoken, e.value);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t\tadvance("]", that);\n
\t\tnospace(prevtoken, token);\n
\t\tthat.left = left;\n
\t\tthat.right = e;\n
\t\treturn that;\n
\t}, 160, true);\n
\n
\tprefix("[", function () {\n
\t\tvar b = token.line !== nexttoken.line;\n
\t\tthis.first = [];\n
\t\tif (b) {\n
\t\t\tindent += option.indent;\n
\t\t\tif (nexttoken.from === indent + option.indent) {\n
\t\t\t\tindent += option.indent;\n
\t\t\t}\n
\t\t}\n
\t\twhile (nexttoken.id !== "(end)") {\n
\t\t\twhile (nexttoken.id === ",") {\n
\t\t\t\tif (!option.es5)\n
\t\t\t\t\twarning("Extra comma.");\n
\t\t\t\tadvance(",");\n
\t\t\t}\n
\t\t\tif (nexttoken.id === "]") {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t\tif (b && token.line !== nexttoken.line) {\n
\t\t\t\tindentation();\n
\t\t\t}\n
\t\t\tthis.first.push(expression(10));\n
\t\t\tif (nexttoken.id === ",") {\n
\t\t\t\tcomma();\n
\t\t\t\tif (nexttoken.id === "]" && !option.es5) {\n
\t\t\t\t\twarning("Extra comma.", token);\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\t\tif (b) {\n
\t\t\tindent -= option.indent;\n
\t\t\tindentation();\n
\t\t}\n
\t\tadvance("]", this);\n
\t\treturn this;\n
\t}, 160);\n
\n
\n
\tfunction property_name() {\n
\t\tvar id = optionalidentifier(true);\n
\t\tif (!id) {\n
\t\t\tif (nexttoken.id === "(string)") {\n
\t\t\t\tid = nexttoken.value;\n
\t\t\t\tadvance();\n
\t\t\t} else if (nexttoken.id === "(number)") {\n
\t\t\t\tid = nexttoken.value.toString();\n
\t\t\t\tadvance();\n
\t\t\t}\n
\t\t}\n
\t\treturn id;\n
\t}\n
\n
\n
\tfunction functionparams() {\n
\t\tvar next   = nexttoken;\n
\t\tvar params = [];\n
\t\tvar ident;\n
\n
\t\tadvance("(");\n
\t\tnospace();\n
\n
\t\tif (nexttoken.id === ")") {\n
\t\t\tadvance(")");\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tfor (;;) {\n
\t\t\tident = identifier(true);\n
\t\t\tparams.push(ident);\n
\t\t\taddlabel(ident, "unused", token);\n
\t\t\tif (nexttoken.id === ",") {\n
\t\t\t\tcomma();\n
\t\t\t} else {\n
\t\t\t\tadvance(")", next);\n
\t\t\t\tnospace(prevtoken, token);\n
\t\t\t\treturn params;\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\n
\tfunction doFunction(name, statement) {\n
\t\tvar f;\n
\t\tvar oldOption = option;\n
\t\tvar oldScope  = scope;\n
\n
\t\toption = Object.create(option);\n
\t\tscope  = Object.create(scope);\n
\n
\t\tfunct = {\n
\t\t\t"(name)"\t : name || "\\"" + anonname + "\\"",\n
\t\t\t"(line)"\t : nexttoken.line,\n
\t\t\t"(character)": nexttoken.character,\n
\t\t\t"(context)"  : funct,\n
\t\t\t"(breakage)" : 0,\n
\t\t\t"(loopage)"  : 0,\n
\t\t\t"(metrics)"  : createMetrics(nexttoken),\n
\t\t\t"(scope)"\t : scope,\n
\t\t\t"(statement)": statement,\n
\t\t\t"(tokens)"\t : {}\n
\t\t};\n
\n
\t\tf = funct;\n
\t\ttoken.funct = funct;\n
\n
\t\tfunctions.push(funct);\n
\n
\t\tif (name) {\n
\t\t\taddlabel(name, "function");\n
\t\t}\n
\n
\t\tfunct["(params)"] = functionparams();\n
\t\tfunct["(metrics)"].verifyMaxParametersPerFunction(funct["(params)"]);\n
\n
\t\tblock(false, false, true);\n
\n
\t\tfunct["(metrics)"].verifyMaxStatementsPerFunction();\n
\t\tfunct["(metrics)"].verifyMaxComplexityPerFunction();\n
\n
\t\tscope = oldScope;\n
\t\toption = oldOption;\n
\t\tfunct["(last)"] = token.line;\n
\t\tfunct["(lastcharacter)"] = token.character;\n
\t\tfunct = funct["(context)"];\n
\n
\t\treturn f;\n
\t}\n
\n
\tfunction createMetrics(functionStartToken) {\n
\t\treturn {\n
\t\t\tstatementCount: 0,\n
\t\t\tnestedBlockDepth: -1,\n
\t\t\tComplexityCount: 1,\n
\t\t\tverifyMaxStatementsPerFunction: function () {\n
\t\t\t\tif (option.maxstatements &&\n
\t\t\t\t\tthis.statementCount > option.maxstatements) {\n
\t\t\t\t\tvar message = "Too many statements per function (" + this.statementCount + ").";\n
\t\t\t\t\twarning(message, functionStartToken);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tverifyMaxParametersPerFunction: function (params) {\n
\t\t\t\tparams = params || [];\n
\n
\t\t\t\tif (option.maxparams && params.length > option.maxparams) {\n
\t\t\t\t\tvar message = "Too many parameters per function (" + params.length + ").";\n
\t\t\t\t\twarning(message, functionStartToken);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tverifyMaxNestedBlockDepthPerFunction: function () {\n
\t\t\t\tif (option.maxdepth &&\n
\t\t\t\t\tthis.nestedBlockDepth > 0 &&\n
\t\t\t\t\tthis.nestedBlockDepth === option.maxdepth + 1) {\n
\t\t\t\t\tvar message = "Blocks are nested too deeply (" + this.nestedBlockDepth + ").";\n
\t\t\t\t\twarning(message);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tverifyMaxComplexityPerFunction: function () {\n
\t\t\t\tvar max = option.maxcomplexity;\n
\t\t\t\tvar cc = this.ComplexityCount;\n
\t\t\t\tif (max && cc > max) {\n
\t\t\t\t\tvar message = "Cyclomatic complexity is too high per function (" + cc + ").";\n
\t\t\t\t\twarning(message, functionStartToken);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\t}\n
\n
\tfunction increaseComplexityCount() {\n
\t\tfunct["(metrics)"].ComplexityCount += 1;\n
\t}\n
\n
\n
\t(function (x) {\n
\t\tx.nud = function () {\n
\t\t\tvar b, f, i, p, t;\n
\t\t\tvar props = {}; // All properties, including accessors\n
\n
\t\t\tfunction saveProperty(name, token) {\n
\t\t\t\tif (props[name] && is_own(props, name))\n
\t\t\t\t\twarning("Duplicate member \'{a}\'.", nexttoken, i);\n
\t\t\t\telse\n
\t\t\t\t\tprops[name] = {};\n
\n
\t\t\t\tprops[name].basic = true;\n
\t\t\t\tprops[name].basicToken = token;\n
\t\t\t}\n
\n
\t\t\tfunction saveSetter(name, token) {\n
\t\t\t\tif (props[name] && is_own(props, name)) {\n
\t\t\t\t\tif (props[name].basic || props[name].setter)\n
\t\t\t\t\t\twarning("Duplicate member \'{a}\'.", nexttoken, i);\n
\t\t\t\t} else {\n
\t\t\t\t\tprops[name] = {};\n
\t\t\t\t}\n
\n
\t\t\t\tprops[name].setter = true;\n
\t\t\t\tprops[name].setterToken = token;\n
\t\t\t}\n
\n
\t\t\tfunction saveGetter(name) {\n
\t\t\t\tif (props[name] && is_own(props, name)) {\n
\t\t\t\t\tif (props[name].basic || props[name].getter)\n
\t\t\t\t\t\twarning("Duplicate member \'{a}\'.", nexttoken, i);\n
\t\t\t\t} else {\n
\t\t\t\t\tprops[name] = {};\n
\t\t\t\t}\n
\n
\t\t\t\tprops[name].getter = true;\n
\t\t\t\tprops[name].getterToken = token;\n
\t\t\t}\n
\n
\t\t\tb = token.line !== nexttoken.line;\n
\t\t\tif (b) {\n
\t\t\t\tindent += option.indent;\n
\t\t\t\tif (nexttoken.from === indent + option.indent) {\n
\t\t\t\t\tindent += option.indent;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tfor (;;) {\n
\t\t\t\tif (nexttoken.id === "}") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tif (b) {\n
\t\t\t\t\tindentation();\n
\t\t\t\t}\n
\t\t\t\tif (nexttoken.value === "get" && peek().id !== ":") {\n
\t\t\t\t\tadvance("get");\n
\t\t\t\t\tif (!option.es5) {\n
\t\t\t\t\t\terror("get/set are ES5 features.");\n
\t\t\t\t\t}\n
\t\t\t\t\ti = property_name();\n
\t\t\t\t\tif (!i) {\n
\t\t\t\t\t\terror("Missing property name.");\n
\t\t\t\t\t}\n
\t\t\t\t\tsaveGetter(i);\n
\t\t\t\t\tt = nexttoken;\n
\t\t\t\t\tadjacent(token, nexttoken);\n
\t\t\t\t\tf = doFunction();\n
\t\t\t\t\tp = f["(params)"];\n
\t\t\t\t\tif (p) {\n
\t\t\t\t\t\twarning("Unexpected parameter \'{a}\' in get {b} function.", t, p[0], i);\n
\t\t\t\t\t}\n
\t\t\t\t\tadjacent(token, nexttoken);\n
\t\t\t\t} else if (nexttoken.value === "set" && peek().id !== ":") {\n
\t\t\t\t\tadvance("set");\n
\t\t\t\t\tif (!option.es5) {\n
\t\t\t\t\t\terror("get/set are ES5 features.");\n
\t\t\t\t\t}\n
\t\t\t\t\ti = property_name();\n
\t\t\t\t\tif (!i) {\n
\t\t\t\t\t\terror("Missing property name.");\n
\t\t\t\t\t}\n
\t\t\t\t\tsaveSetter(i, nexttoken);\n
\t\t\t\t\tt = nexttoken;\n
\t\t\t\t\tadjacent(token, nexttoken);\n
\t\t\t\t\tf = doFunction();\n
\t\t\t\t\tp = f["(params)"];\n
\t\t\t\t\tif (!p || p.length !== 1) {\n
\t\t\t\t\t\twarning("Expected a single parameter in set {a} function.", t, i);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\ti = property_name();\n
\t\t\t\t\tsaveProperty(i, nexttoken);\n
\t\t\t\t\tif (typeof i !== "string") {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t\tadvance(":");\n
\t\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\t\texpression(10);\n
\t\t\t\t}\n
\n
\t\t\t\tcountMember(i);\n
\t\t\t\tif (nexttoken.id === ",") {\n
\t\t\t\t\tcomma();\n
\t\t\t\t\tif (nexttoken.id === ",") {\n
\t\t\t\t\t\twarning("Extra comma.", token);\n
\t\t\t\t\t} else if (nexttoken.id === "}" && !option.es5) {\n
\t\t\t\t\t\twarning("Extra comma.", token);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tif (b) {\n
\t\t\t\tindent -= option.indent;\n
\t\t\t\tindentation();\n
\t\t\t}\n
\t\t\tadvance("}", this);\n
\t\t\tif (option.es5) {\n
\t\t\t\tfor (var name in props) {\n
\t\t\t\t\tif (is_own(props, name) && props[name].setter && !props[name].getter) {\n
\t\t\t\t\t\twarning("Setter is defined without getter.", props[name].setterToken);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\treturn this;\n
\t\t};\n
\t\tx.fud = function () {\n
\t\t\terror("Expected to see a statement and instead saw a block.", token);\n
\t\t};\n
\t}(delim("{")));\n
\n
\tuseESNextSyntax = function () {\n
\t\tvar conststatement = stmt("const", function (prefix) {\n
\t\t\tvar id, name, value;\n
\n
\t\t\tthis.first = [];\n
\t\t\tfor (;;) {\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\tid = identifier();\n
\t\t\t\tif (funct[id] === "const") {\n
\t\t\t\t\twarning("const \'" + id + "\' has already been declared");\n
\t\t\t\t}\n
\t\t\t\tif (funct["(global)"] && predefined[id] === false) {\n
\t\t\t\t\twarning("Redefinition of \'{a}\'.", token, id);\n
\t\t\t\t}\n
\t\t\t\taddlabel(id, "const");\n
\t\t\t\tif (prefix) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tname = token;\n
\t\t\t\tthis.first.push(token);\n
\n
\t\t\t\tif (nexttoken.id !== "=") {\n
\t\t\t\t\twarning("const " +\n
\t\t\t\t\t  "\'{a}\' is initialized to \'undefined\'.", token, id);\n
\t\t\t\t}\n
\n
\t\t\t\tif (nexttoken.id === "=") {\n
\t\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\t\tadvance("=");\n
\t\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\t\tif (nexttoken.id === "undefined") {\n
\t\t\t\t\t\twarning("It is not necessary to initialize " +\n
\t\t\t\t\t\t  "\'{a}\' to \'undefined\'.", token, id);\n
\t\t\t\t\t}\n
\t\t\t\t\tif (peek(0).id === "=" && nexttoken.identifier) {\n
\t\t\t\t\t\terror("Constant {a} was not declared correctly.",\n
\t\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t\t}\n
\t\t\t\t\tvalue = expression(0);\n
\t\t\t\t\tname.first = value;\n
\t\t\t\t}\n
\n
\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t\tcomma();\n
\t\t\t}\n
\t\t\treturn this;\n
\t\t});\n
\t\tconststatement.exps = true;\n
\t};\n
\n
\tvar varstatement = stmt("var", function (prefix) {\n
\t\tvar id, name, value;\n
\n
\t\tif (funct["(onevar)"] && option.onevar) {\n
\t\t\twarning("Too many var statements.");\n
\t\t} else if (!funct["(global)"]) {\n
\t\t\tfunct["(onevar)"] = true;\n
\t\t}\n
\n
\t\tthis.first = [];\n
\n
\t\tfor (;;) {\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t\tid = identifier();\n
\n
\t\t\tif (option.esnext && funct[id] === "const") {\n
\t\t\t\twarning("const \'" + id + "\' has already been declared");\n
\t\t\t}\n
\n
\t\t\tif (funct["(global)"] && predefined[id] === false) {\n
\t\t\t\twarning("Redefinition of \'{a}\'.", token, id);\n
\t\t\t}\n
\n
\t\t\taddlabel(id, "unused", token);\n
\n
\t\t\tif (prefix) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\n
\t\t\tname = token;\n
\t\t\tthis.first.push(token);\n
\n
\t\t\tif (nexttoken.id === "=") {\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\tadvance("=");\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\tif (nexttoken.id === "undefined") {\n
\t\t\t\t\twarning("It is not necessary to initialize \'{a}\' to \'undefined\'.", token, id);\n
\t\t\t\t}\n
\t\t\t\tif (peek(0).id === "=" && nexttoken.identifier) {\n
\t\t\t\t\terror("Variable {a} was not declared correctly.",\n
\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t}\n
\t\t\t\tvalue = expression(0);\n
\t\t\t\tname.first = value;\n
\t\t\t}\n
\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t\tcomma();\n
\t\t}\n
\t\treturn this;\n
\t});\n
\tvarstatement.exps = true;\n
\n
\tblockstmt("function", function () {\n
\t\tif (inblock) {\n
\t\t\twarning("Function declarations should not be placed in blocks. " +\n
\t\t\t\t"Use a function expression or move the statement to the top of " +\n
\t\t\t\t"the outer function.", token);\n
\n
\t\t}\n
\t\tvar i = identifier();\n
\t\tif (option.esnext && funct[i] === "const") {\n
\t\t\twarning("const \'" + i + "\' has already been declared");\n
\t\t}\n
\t\tadjacent(token, nexttoken);\n
\t\taddlabel(i, "unction", token);\n
\n
\t\tdoFunction(i, { statement: true });\n
\t\tif (nexttoken.id === "(" && nexttoken.line === token.line) {\n
\t\t\terror(\n
"Function declarations are not invocable. Wrap the whole function invocation in parens.");\n
\t\t}\n
\t\treturn this;\n
\t});\n
\n
\tprefix("function", function () {\n
\t\tvar i = optionalidentifier();\n
\t\tif (i) {\n
\t\t\tadjacent(token, nexttoken);\n
\t\t} else {\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t}\n
\t\tdoFunction(i);\n
\t\tif (!option.loopfunc && funct["(loopage)"]) {\n
\t\t\twarning("Don\'t make functions within a loop.");\n
\t\t}\n
\t\treturn this;\n
\t});\n
\n
\tblockstmt("if", function () {\n
\t\tvar t = nexttoken;\n
\t\tincreaseComplexityCount();\n
\t\tadvance("(");\n
\t\tnonadjacent(this, t);\n
\t\tnospace();\n
\t\texpression(20);\n
\t\tif (nexttoken.id === "=") {\n
\t\t\tif (!option.boss)\n
\t\t\t\twarning("Assignment in conditional expression");\n
\t\t\tadvance("=");\n
\t\t\texpression(20);\n
\t\t}\n
\t\tadvance(")", t);\n
\t\tnospace(prevtoken, token);\n
\t\tblock(true, true);\n
\t\tif (nexttoken.id === "else") {\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t\tadvance("else");\n
\t\t\tif (nexttoken.id === "if" || nexttoken.id === "switch") {\n
\t\t\t\tstatement(true);\n
\t\t\t} else {\n
\t\t\t\tblock(true, true);\n
\t\t\t}\n
\t\t}\n
\t\treturn this;\n
\t});\n
\n
\tblockstmt("try", function () {\n
\t\tvar b;\n
\n
\t\tfunction doCatch() {\n
\t\t\tvar oldScope = scope;\n
\t\t\tvar e;\n
\n
\t\t\tadvance("catch");\n
\t\t\tnonadjacent(token, nexttoken);\n
\t\t\tadvance("(");\n
\n
\t\t\tscope = Object.create(oldScope);\n
\n
\t\t\te = nexttoken.value;\n
\t\t\tif (nexttoken.type !== "(identifier)") {\n
\t\t\t\te = null;\n
\t\t\t\twarning("Expected an identifier and instead saw \'{a}\'.", nexttoken, e);\n
\t\t\t}\n
\n
\t\t\tadvance();\n
\t\t\tadvance(")");\n
\n
\t\t\tfunct = {\n
\t\t\t\t"(name)"\t : "(catch)",\n
\t\t\t\t"(line)"\t : nexttoken.line,\n
\t\t\t\t"(character)": nexttoken.character,\n
\t\t\t\t"(context)"  : funct,\n
\t\t\t\t"(breakage)" : funct["(breakage)"],\n
\t\t\t\t"(loopage)"  : funct["(loopage)"],\n
\t\t\t\t"(scope)"\t : scope,\n
\t\t\t\t"(statement)": false,\n
\t\t\t\t"(metrics)"  : createMetrics(nexttoken),\n
\t\t\t\t"(catch)"\t : true,\n
\t\t\t\t"(tokens)"\t : {}\n
\t\t\t};\n
\n
\t\t\tif (e) {\n
\t\t\t\taddlabel(e, "exception");\n
\t\t\t}\n
\n
\t\t\ttoken.funct = funct;\n
\t\t\tfunctions.push(funct);\n
\n
\t\t\tblock(false);\n
\n
\t\t\tscope = oldScope;\n
\n
\t\t\tfunct["(last)"] = token.line;\n
\t\t\tfunct["(lastcharacter)"] = token.character;\n
\t\t\tfunct = funct["(context)"];\n
\t\t}\n
\n
\t\tblock(false);\n
\n
\t\tif (nexttoken.id === "catch") {\n
\t\t\tincreaseComplexityCount();\n
\t\t\tdoCatch();\n
\t\t\tb = true;\n
\t\t}\n
\n
\t\tif (nexttoken.id === "finally") {\n
\t\t\tadvance("finally");\n
\t\t\tblock(false);\n
\t\t\treturn;\n
\t\t} else if (!b) {\n
\t\t\terror("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\tnexttoken, "catch", nexttoken.value);\n
\t\t}\n
\n
\t\treturn this;\n
\t});\n
\n
\tblockstmt("while", function () {\n
\t\tvar t = nexttoken;\n
\t\tfunct["(breakage)"] += 1;\n
\t\tfunct["(loopage)"] += 1;\n
\t\tincreaseComplexityCount();\n
\t\tadvance("(");\n
\t\tnonadjacent(this, t);\n
\t\tnospace();\n
\t\texpression(20);\n
\t\tif (nexttoken.id === "=") {\n
\t\t\tif (!option.boss)\n
\t\t\t\twarning("Assignment in conditional expression");\n
\t\t\tadvance("=");\n
\t\t\texpression(20);\n
\t\t}\n
\t\tadvance(")", t);\n
\t\tnospace(prevtoken, token);\n
\t\tblock(true, true);\n
\t\tfunct["(breakage)"] -= 1;\n
\t\tfunct["(loopage)"] -= 1;\n
\t\treturn this;\n
\t}).labelled = true;\n
\n
\tblockstmt("with", function () {\n
\t\tvar t = nexttoken;\n
\t\tif (directive["use strict"]) {\n
\t\t\terror("\'with\' is not allowed in strict mode.", token);\n
\t\t} else if (!option.withstmt) {\n
\t\t\twarning("Don\'t use \'with\'.", token);\n
\t\t}\n
\n
\t\tadvance("(");\n
\t\tnonadjacent(this, t);\n
\t\tnospace();\n
\t\texpression(0);\n
\t\tadvance(")", t);\n
\t\tnospace(prevtoken, token);\n
\t\tblock(true, true);\n
\n
\t\treturn this;\n
\t});\n
\n
\tblockstmt("switch", function () {\n
\t\tvar t = nexttoken,\n
\t\t\tg = false;\n
\t\tfunct["(breakage)"] += 1;\n
\t\tadvance("(");\n
\t\tnonadjacent(this, t);\n
\t\tnospace();\n
\t\tthis.condition = expression(20);\n
\t\tadvance(")", t);\n
\t\tnospace(prevtoken, token);\n
\t\tnonadjacent(token, nexttoken);\n
\t\tt = nexttoken;\n
\t\tadvance("{");\n
\t\tnonadjacent(token, nexttoken);\n
\t\tindent += option.indent;\n
\t\tthis.cases = [];\n
\t\tfor (;;) {\n
\t\t\tswitch (nexttoken.id) {\n
\t\t\tcase "case":\n
\t\t\t\tswitch (funct["(verb)"]) {\n
\t\t\t\tcase "break":\n
\t\t\t\tcase "case":\n
\t\t\t\tcase "continue":\n
\t\t\t\tcase "return":\n
\t\t\t\tcase "switch":\n
\t\t\t\tcase "throw":\n
\t\t\t\t\tbreak;\n
\t\t\t\tdefault:\n
\t\t\t\t\tif (!ft.test(lines[nexttoken.line - 2])) {\n
\t\t\t\t\t\twarning(\n
\t\t\t\t\t\t\t"Expected a \'break\' statement before \'case\'.",\n
\t\t\t\t\t\t\ttoken);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t\tindentation(-option.indent);\n
\t\t\t\tadvance("case");\n
\t\t\t\tthis.cases.push(expression(20));\n
\t\t\t\tincreaseComplexityCount();\n
\t\t\t\tg = true;\n
\t\t\t\tadvance(":");\n
\t\t\t\tfunct["(verb)"] = "case";\n
\t\t\t\tbreak;\n
\t\t\tcase "default":\n
\t\t\t\tswitch (funct["(verb)"]) {\n
\t\t\t\tcase "break":\n
\t\t\t\tcase "continue":\n
\t\t\t\tcase "return":\n
\t\t\t\tcase "throw":\n
\t\t\t\t\tbreak;\n
\t\t\t\tdefault:\n
\t\t\t\t\tif (!ft.test(lines[nexttoken.line - 2])) {\n
\t\t\t\t\t\twarning(\n
\t\t\t\t\t\t\t"Expected a \'break\' statement before \'default\'.",\n
\t\t\t\t\t\t\ttoken);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t\tindentation(-option.indent);\n
\t\t\t\tadvance("default");\n
\t\t\t\tg = true;\n
\t\t\t\tadvance(":");\n
\t\t\t\tbreak;\n
\t\t\tcase "}":\n
\t\t\t\tindent -= option.indent;\n
\t\t\t\tindentation();\n
\t\t\t\tadvance("}", t);\n
\t\t\t\tif (this.cases.length === 1 || this.condition.id === "true" ||\n
\t\t\t\t\t\tthis.condition.id === "false") {\n
\t\t\t\t\tif (!option.onecase)\n
\t\t\t\t\t\twarning("This \'switch\' should be an \'if\'.", this);\n
\t\t\t\t}\n
\t\t\t\tfunct["(breakage)"] -= 1;\n
\t\t\t\tfunct["(verb)"] = undefined;\n
\t\t\t\treturn;\n
\t\t\tcase "(end)":\n
\t\t\t\terror("Missing \'{a}\'.", nexttoken, "}");\n
\t\t\t\treturn;\n
\t\t\tdefault:\n
\t\t\t\tif (g) {\n
\t\t\t\t\tswitch (token.id) {\n
\t\t\t\t\tcase ",":\n
\t\t\t\t\t\terror("Each value should have its own case label.");\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\tcase ":":\n
\t\t\t\t\t\tg = false;\n
\t\t\t\t\t\tstatements();\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\tdefault:\n
\t\t\t\t\t\terror("Missing \':\' on a case clause.", token);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (token.id === ":") {\n
\t\t\t\t\t\tadvance(":");\n
\t\t\t\t\t\terror("Unexpected \'{a}\'.", token, ":");\n
\t\t\t\t\t\tstatements();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\terror("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\t\t\tnexttoken, "case", nexttoken.value);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}).labelled = true;\n
\n
\tstmt("debugger", function () {\n
\t\tif (!option.debug) {\n
\t\t\twarning("All \'debugger\' statements should be removed.");\n
\t\t}\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\t(function () {\n
\t\tvar x = stmt("do", function () {\n
\t\t\tfunct["(breakage)"] += 1;\n
\t\t\tfunct["(loopage)"] += 1;\n
\t\t\tincreaseComplexityCount();\n
\n
\t\t\tthis.first = block(true);\n
\t\t\tadvance("while");\n
\t\t\tvar t = nexttoken;\n
\t\t\tnonadjacent(token, t);\n
\t\t\tadvance("(");\n
\t\t\tnospace();\n
\t\t\texpression(20);\n
\t\t\tif (nexttoken.id === "=") {\n
\t\t\t\tif (!option.boss)\n
\t\t\t\t\twarning("Assignment in conditional expression");\n
\t\t\t\tadvance("=");\n
\t\t\t\texpression(20);\n
\t\t\t}\n
\t\t\tadvance(")", t);\n
\t\t\tnospace(prevtoken, token);\n
\t\t\tfunct["(breakage)"] -= 1;\n
\t\t\tfunct["(loopage)"] -= 1;\n
\t\t\treturn this;\n
\t\t});\n
\t\tx.labelled = true;\n
\t\tx.exps = true;\n
\t}());\n
\n
\tblockstmt("for", function () {\n
\t\tvar s, t = nexttoken;\n
\t\tfunct["(breakage)"] += 1;\n
\t\tfunct["(loopage)"] += 1;\n
\t\tincreaseComplexityCount();\n
\t\tadvance("(");\n
\t\tnonadjacent(this, t);\n
\t\tnospace();\n
\t\tif (peek(nexttoken.id === "var" ? 1 : 0).id === "in") {\n
\t\t\tif (nexttoken.id === "var") {\n
\t\t\t\tadvance("var");\n
\t\t\t\tvarstatement.fud.call(varstatement, true);\n
\t\t\t} else {\n
\t\t\t\tswitch (funct[nexttoken.value]) {\n
\t\t\t\tcase "unused":\n
\t\t\t\t\tfunct[nexttoken.value] = "var";\n
\t\t\t\t\tbreak;\n
\t\t\t\tcase "var":\n
\t\t\t\t\tbreak;\n
\t\t\t\tdefault:\n
\t\t\t\t\twarning("Bad for in variable \'{a}\'.",\n
\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t}\n
\t\t\t\tadvance();\n
\t\t\t}\n
\t\t\tadvance("in");\n
\t\t\texpression(20);\n
\t\t\tadvance(")", t);\n
\t\t\ts = block(true, true);\n
\t\t\tif (option.forin && s && (s.length > 1 || typeof s[0] !== "object" ||\n
\t\t\t\t\ts[0].value !== "if")) {\n
\t\t\t\twarning("The body of a for in should be wrapped in an if statement to filter " +\n
\t\t\t\t\t\t"unwanted properties from the prototype.", this);\n
\t\t\t}\n
\t\t\tfunct["(breakage)"] -= 1;\n
\t\t\tfunct["(loopage)"] -= 1;\n
\t\t\treturn this;\n
\t\t} else {\n
\t\t\tif (nexttoken.id !== ";") {\n
\t\t\t\tif (nexttoken.id === "var") {\n
\t\t\t\t\tadvance("var");\n
\t\t\t\t\tvarstatement.fud.call(varstatement);\n
\t\t\t\t} else {\n
\t\t\t\t\tfor (;;) {\n
\t\t\t\t\t\texpression(0, "for");\n
\t\t\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tcomma();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tnolinebreak(token);\n
\t\t\tadvance(";");\n
\t\t\tif (nexttoken.id !== ";") {\n
\t\t\t\texpression(20);\n
\t\t\t\tif (nexttoken.id === "=") {\n
\t\t\t\t\tif (!option.boss)\n
\t\t\t\t\t\twarning("Assignment in conditional expression");\n
\t\t\t\t\tadvance("=");\n
\t\t\t\t\texpression(20);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tnolinebreak(token);\n
\t\t\tadvance(";");\n
\t\t\tif (nexttoken.id === ";") {\n
\t\t\t\terror("Expected \'{a}\' and instead saw \'{b}\'.",\n
\t\t\t\t\t\tnexttoken, ")", ";");\n
\t\t\t}\n
\t\t\tif (nexttoken.id !== ")") {\n
\t\t\t\tfor (;;) {\n
\t\t\t\t\texpression(0, "for");\n
\t\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t\tcomma();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tadvance(")", t);\n
\t\t\tnospace(prevtoken, token);\n
\t\t\tblock(true, true);\n
\t\t\tfunct["(breakage)"] -= 1;\n
\t\t\tfunct["(loopage)"] -= 1;\n
\t\t\treturn this;\n
\t\t}\n
\t}).labelled = true;\n
\n
\n
\tstmt("break", function () {\n
\t\tvar v = nexttoken.value;\n
\n
\t\tif (funct["(breakage)"] === 0)\n
\t\t\twarning("Unexpected \'{a}\'.", nexttoken, this.value);\n
\n
\t\tif (!option.asi)\n
\t\t\tnolinebreak(this);\n
\n
\t\tif (nexttoken.id !== ";") {\n
\t\t\tif (token.line === nexttoken.line) {\n
\t\t\t\tif (funct[v] !== "label") {\n
\t\t\t\t\twarning("\'{a}\' is not a statement label.", nexttoken, v);\n
\t\t\t\t} else if (scope[v] !== funct) {\n
\t\t\t\t\twarning("\'{a}\' is out of scope.", nexttoken, v);\n
\t\t\t\t}\n
\t\t\t\tthis.first = nexttoken;\n
\t\t\t\tadvance();\n
\t\t\t}\n
\t\t}\n
\t\treachable("break");\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\n
\tstmt("continue", function () {\n
\t\tvar v = nexttoken.value;\n
\n
\t\tif (funct["(breakage)"] === 0)\n
\t\t\twarning("Unexpected \'{a}\'.", nexttoken, this.value);\n
\n
\t\tif (!option.asi)\n
\t\t\tnolinebreak(this);\n
\n
\t\tif (nexttoken.id !== ";") {\n
\t\t\tif (token.line === nexttoken.line) {\n
\t\t\t\tif (funct[v] !== "label") {\n
\t\t\t\t\twarning("\'{a}\' is not a statement label.", nexttoken, v);\n
\t\t\t\t} else if (scope[v] !== funct) {\n
\t\t\t\t\twarning("\'{a}\' is out of scope.", nexttoken, v);\n
\t\t\t\t}\n
\t\t\t\tthis.first = nexttoken;\n
\t\t\t\tadvance();\n
\t\t\t}\n
\t\t} else if (!funct["(loopage)"]) {\n
\t\t\twarning("Unexpected \'{a}\'.", nexttoken, this.value);\n
\t\t}\n
\t\treachable("continue");\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\n
\tstmt("return", function () {\n
\t\tif (this.line === nexttoken.line) {\n
\t\t\tif (nexttoken.id === "(regexp)")\n
\t\t\t\twarning("Wrap the /regexp/ literal in parens to disambiguate the slash operator.");\n
\n
\t\t\tif (nexttoken.id !== ";" && !nexttoken.reach) {\n
\t\t\t\tnonadjacent(token, nexttoken);\n
\t\t\t\tif (peek().value === "=" && !option.boss) {\n
\t\t\t\t\twarningAt("Did you mean to return a conditional instead of an assignment?",\n
\t\t\t\t\t\t\t  token.line, token.character + 1);\n
\t\t\t\t}\n
\t\t\t\tthis.first = expression(0);\n
\t\t\t}\n
\t\t} else if (!option.asi) {\n
\t\t\tnolinebreak(this); // always warn (Line breaking error)\n
\t\t}\n
\t\treachable("return");\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\n
\tstmt("throw", function () {\n
\t\tnolinebreak(this);\n
\t\tnonadjacent(token, nexttoken);\n
\t\tthis.first = expression(20);\n
\t\treachable("throw");\n
\t\treturn this;\n
\t}).exps = true;\n
\n
\treserve("class");\n
\treserve("const");\n
\treserve("enum");\n
\treserve("export");\n
\treserve("extends");\n
\treserve("import");\n
\treserve("super");\n
\n
\treserve("let");\n
\treserve("yield");\n
\treserve("implements");\n
\treserve("interface");\n
\treserve("package");\n
\treserve("private");\n
\treserve("protected");\n
\treserve("public");\n
\treserve("static");\n
\n
\tfunction jsonValue() {\n
\n
\t\tfunction jsonObject() {\n
\t\t\tvar o = {}, t = nexttoken;\n
\t\t\tadvance("{");\n
\t\t\tif (nexttoken.id !== "}") {\n
\t\t\t\tfor (;;) {\n
\t\t\t\t\tif (nexttoken.id === "(end)") {\n
\t\t\t\t\t\terror("Missing \'}\' to match \'{\' from line {a}.",\n
\t\t\t\t\t\t\t\tnexttoken, t.line);\n
\t\t\t\t\t} else if (nexttoken.id === "}") {\n
\t\t\t\t\t\twarning("Unexpected comma.", token);\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t} else if (nexttoken.id === ",") {\n
\t\t\t\t\t\terror("Unexpected comma.", nexttoken);\n
\t\t\t\t\t} else if (nexttoken.id !== "(string)") {\n
\t\t\t\t\t\twarning("Expected a string and instead saw {a}.",\n
\t\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t\t}\n
\t\t\t\t\tif (o[nexttoken.value] === true) {\n
\t\t\t\t\t\twarning("Duplicate key \'{a}\'.",\n
\t\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t\t} else if ((nexttoken.value === "__proto__" &&\n
\t\t\t\t\t\t!option.proto) || (nexttoken.value === "__iterator__" &&\n
\t\t\t\t\t\t!option.iterator)) {\n
\t\t\t\t\t\twarning("The \'{a}\' key may produce unexpected results.",\n
\t\t\t\t\t\t\tnexttoken, nexttoken.value);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\to[nexttoken.value] = true;\n
\t\t\t\t\t}\n
\t\t\t\t\tadvance();\n
\t\t\t\t\tadvance(":");\n
\t\t\t\t\tjsonValue();\n
\t\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t\tadvance(",");\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tadvance("}");\n
\t\t}\n
\n
\t\tfunction jsonArray() {\n
\t\t\tvar t = nexttoken;\n
\t\t\tadvance("[");\n
\t\t\tif (nexttoken.id !== "]") {\n
\t\t\t\tfor (;;) {\n
\t\t\t\t\tif (nexttoken.id === "(end)") {\n
\t\t\t\t\t\terror("Missing \']\' to match \'[\' from line {a}.",\n
\t\t\t\t\t\t\t\tnexttoken, t.line);\n
\t\t\t\t\t} else if (nexttoken.id === "]") {\n
\t\t\t\t\t\twarning("Unexpected comma.", token);\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t} else if (nexttoken.id === ",") {\n
\t\t\t\t\t\terror("Unexpected comma.", nexttoken);\n
\t\t\t\t\t}\n
\t\t\t\t\tjsonValue();\n
\t\t\t\t\tif (nexttoken.id !== ",") {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t\tadvance(",");\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tadvance("]");\n
\t\t}\n
\n
\t\tswitch (nexttoken.id) {\n
\t\tcase "{":\n
\t\t\tjsonObject();\n
\t\t\tbreak;\n
\t\tcase "[":\n
\t\t\tjsonArray();\n
\t\t\tbreak;\n
\t\tcase "true":\n
\t\tcase "false":\n
\t\tcase "null":\n
\t\tcase "(number)":\n
\t\tcase "(string)":\n
\t\t\tadvance();\n
\t\t\tbreak;\n
\t\tcase "-":\n
\t\t\tadvance("-");\n
\t\t\tif (token.character !== nexttoken.from) {\n
\t\t\t\twarning("Unexpected space after \'-\'.", token);\n
\t\t\t}\n
\t\t\tadjacent(token, nexttoken);\n
\t\t\tadvance("(number)");\n
\t\t\tbreak;\n
\t\tdefault:\n
\t\t\terror("Expected a JSON value.", nexttoken);\n
\t\t}\n
\t}\n
\tvar itself = function (s, o, g) {\n
\t\tvar a, i, k, x;\n
\t\tvar optionKeys;\n
\t\tvar newOptionObj = {};\n
\n
\t\tif (o && o.scope) {\n
\t\t\tJSHINT.scope = o.scope;\n
\t\t} else {\n
\t\t\tJSHINT.errors = [];\n
\t\t\tJSHINT.undefs = [];\n
\t\t\tJSHINT.internals = [];\n
\t\t\tJSHINT.blacklist = {};\n
\t\t\tJSHINT.scope = "(main)";\n
\t\t}\n
\n
\t\tpredefined = Object.create(standard);\n
\t\tdeclared = Object.create(null);\n
\t\tcombine(predefined, g || {});\n
\n
\t\tif (o) {\n
\t\t\ta = o.predef;\n
\t\t\tif (a) {\n
\t\t\t\tif (!Array.isArray(a) && typeof a === "object") {\n
\t\t\t\t\ta = Object.keys(a);\n
\t\t\t\t}\n
\t\t\t\ta.forEach(function (item) {\n
\t\t\t\t\tvar slice;\n
\t\t\t\t\tif (item[0] === "-") {\n
\t\t\t\t\t\tslice = item.slice(1);\n
\t\t\t\t\t\tJSHINT.blacklist[slice] = slice;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tpredefined[item] = true;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\toptionKeys = Object.keys(o);\n
\t\t\tfor (x = 0; x < optionKeys.length; x++) {\n
\t\t\t\tnewOptionObj[optionKeys[x]] = o[optionKeys[x]];\n
\n
\t\t\t\tif (optionKeys[x] === "newcap" && o[optionKeys[x]] === false)\n
\t\t\t\t\tnewOptionObj["(explicitNewcap)"] = true;\n
\n
\t\t\t\tif (optionKeys[x] === "indent")\n
\t\t\t\t\tnewOptionObj.white = true;\n
\t\t\t}\n
\t\t}\n
\n
\t\toption = newOptionObj;\n
\n
\t\toption.indent = option.indent || 4;\n
\t\toption.maxerr = option.maxerr || 50;\n
\n
\t\ttab = "";\n
\t\tfor (i = 0; i < option.indent; i += 1) {\n
\t\t\ttab += " ";\n
\t\t}\n
\t\tindent = 1;\n
\t\tglobal = Object.create(predefined);\n
\t\tscope = global;\n
\t\tfunct = {\n
\t\t\t"(global)":   true,\n
\t\t\t"(name)":\t  "(global)",\n
\t\t\t"(scope)":\t  scope,\n
\t\t\t"(breakage)": 0,\n
\t\t\t"(loopage)":  0,\n
\t\t\t"(tokens)":   {},\n
\t\t\t"(metrics)":   createMetrics(nexttoken)\n
\t\t};\n
\t\tfunctions = [funct];\n
\t\turls = [];\n
\t\tstack = null;\n
\t\tmember = {};\n
\t\tmembersOnly = null;\n
\t\timplied = {};\n
\t\tinblock = false;\n
\t\tlookahead = [];\n
\t\tjsonmode = false;\n
\t\twarnings = 0;\n
\t\tlines = [];\n
\t\tunuseds = [];\n
\n
\t\tif (!isString(s) && !Array.isArray(s)) {\n
\t\t\terrorAt("Input is neither a string nor an array of strings.", 0);\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\tif (isString(s) && /^\\s*$/g.test(s)) {\n
\t\t\terrorAt("Input is an empty string.", 0);\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\tif (s.length === 0) {\n
\t\t\terrorAt("Input is an empty array.", 0);\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\tlex.init(s);\n
\n
\t\tprereg = true;\n
\t\tdirective = {};\n
\n
\t\tprevtoken = token = nexttoken = syntax["(begin)"];\n
\t\tfor (var name in o) {\n
\t\t\tif (is_own(o, name)) {\n
\t\t\t\tcheckOption(name, token);\n
\t\t\t}\n
\t\t}\n
\n
\t\tassume();\n
\t\tcombine(predefined, g || {});\n
\t\tcomma.first = true;\n
\t\tquotmark = undefined;\n
\n
\t\ttry {\n
\t\t\tadvance();\n
\t\t\tswitch (nexttoken.id) {\n
\t\t\tcase "{":\n
\t\t\tcase "[":\n
\t\t\t\toption.laxbreak = true;\n
\t\t\t\tjsonmode = true;\n
\t\t\t\tjsonValue();\n
\t\t\t\tbreak;\n
\t\t\tdefault:\n
\t\t\t\tdirectives();\n
\t\t\t\tif (directive["use strict"] && !option.globalstrict) {\n
\t\t\t\t\twarning("Use the function form of \\"use strict\\".", prevtoken);\n
\t\t\t\t}\n
\n
\t\t\t\tstatements();\n
\t\t\t}\n
\t\t\tadvance((nexttoken && nexttoken.value !== ".")\t? "(end)" : undefined);\n
\n
\t\t\tvar markDefined = function (name, context) {\n
\t\t\t\tdo {\n
\t\t\t\t\tif (typeof context[name] === "string") {\n
\n
\t\t\t\t\t\tif (context[name] === "unused")\n
\t\t\t\t\t\t\tcontext[name] = "var";\n
\t\t\t\t\t\telse if (context[name] === "unction")\n
\t\t\t\t\t\t\tcontext[name] = "closure";\n
\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tcontext = context["(context)"];\n
\t\t\t\t} while (context);\n
\n
\t\t\t\treturn false;\n
\t\t\t};\n
\n
\t\t\tvar clearImplied = function (name, line) {\n
\t\t\t\tif (!implied[name])\n
\t\t\t\t\treturn;\n
\n
\t\t\t\tvar newImplied = [];\n
\t\t\t\tfor (var i = 0; i < implied[name].length; i += 1) {\n
\t\t\t\t\tif (implied[name][i] !== line)\n
\t\t\t\t\t\tnewImplied.push(implied[name][i]);\n
\t\t\t\t}\n
\n
\t\t\t\tif (newImplied.length === 0)\n
\t\t\t\t\tdelete implied[name];\n
\t\t\t\telse\n
\t\t\t\t\timplied[name] = newImplied;\n
\t\t\t};\n
\n
\t\t\tvar warnUnused = function (name, token) {\n
\t\t\t\tvar line = token.line;\n
\t\t\t\tvar chr  = token.character;\n
\n
\t\t\t\tif (option.unused)\n
\t\t\t\t\twarningAt("\'{a}\' is defined but never used.", line, chr, name);\n
\n
\t\t\t\tunuseds.push({\n
\t\t\t\t\tname: name,\n
\t\t\t\t\tline: line,\n
\t\t\t\t\tcharacter: chr\n
\t\t\t\t});\n
\t\t\t};\n
\n
\t\t\tvar checkUnused = function (func, key) {\n
\t\t\t\tvar type = func[key];\n
\t\t\t\tvar token = func["(tokens)"][key];\n
\n
\t\t\t\tif (key.charAt(0) === "(")\n
\t\t\t\t\treturn;\n
\n
\t\t\t\tif (type !== "unused" && type !== "unction")\n
\t\t\t\t\treturn;\n
\t\t\t\tif (func["(params)"] && func["(params)"].indexOf(key) !== -1)\n
\t\t\t\t\treturn;\n
\n
\t\t\t\twarnUnused(key, token);\n
\t\t\t};\n
\t\t\tfor (i = 0; i < JSHINT.undefs.length; i += 1) {\n
\t\t\t\tk = JSHINT.undefs[i].slice(0);\n
\n
\t\t\t\tif (markDefined(k[2].value, k[0])) {\n
\t\t\t\t\tclearImplied(k[2].value, k[2].line);\n
\t\t\t\t} else {\n
\t\t\t\t\twarning.apply(warning, k.slice(1));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunctions.forEach(function (func) {\n
\t\t\t\tfor (var key in func) {\n
\t\t\t\t\tif (is_own(func, key)) {\n
\t\t\t\t\t\tcheckUnused(func, key);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (!func["(params)"])\n
\t\t\t\t\treturn;\n
\n
\t\t\t\tvar params = func["(params)"].slice();\n
\t\t\t\tvar param  = params.pop();\n
\t\t\t\tvar type;\n
\n
\t\t\t\twhile (param) {\n
\t\t\t\t\ttype = func[param];\n
\n
\t\t\t\t\tif (param === "undefined")\n
\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\tif (type !== "unused" && type !== "unction")\n
\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\twarnUnused(param, func["(tokens)"][param]);\n
\t\t\t\t\tparam = params.pop();\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tfor (var key in declared) {\n
\t\t\t\tif (is_own(declared, key) && !is_own(global, key)) {\n
\t\t\t\t\twarnUnused(key, declared[key]);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t} catch (e) {\n
\t\t\tif (e) {\n
\t\t\t\tvar nt = nexttoken || {};\n
\t\t\t\tJSHINT.errors.push({\n
\t\t\t\t\traw\t\t  : e.raw,\n
\t\t\t\t\treason\t  : e.message,\n
\t\t\t\t\tline\t  : e.line || nt.line,\n
\t\t\t\t\tcharacter : e.character || nt.from\n
\t\t\t\t}, null);\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (JSHINT.scope === "(main)") {\n
\t\t\to = o || {};\n
\n
\t\t\tfor (i = 0; i < JSHINT.internals.length; i += 1) {\n
\t\t\t\tk = JSHINT.internals[i];\n
\t\t\t\to.scope = k.elem;\n
\t\t\t\titself(k.value, o, g);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn JSHINT.errors.length === 0;\n
\t};\n
\titself.data = function () {\n
\t\tvar data = {\n
\t\t\tfunctions: [],\n
\t\t\toptions: option\n
\t\t};\n
\t\tvar implieds = [];\n
\t\tvar members = [];\n
\t\tvar fu, f, i, j, n, globals;\n
\n
\t\tif (itself.errors.length) {\n
\t\t\tdata.errors = itself.errors;\n
\t\t}\n
\n
\t\tif (jsonmode) {\n
\t\t\tdata.json = true;\n
\t\t}\n
\n
\t\tfor (n in implied) {\n
\t\t\tif (is_own(implied, n)) {\n
\t\t\t\timplieds.push({\n
\t\t\t\t\tname: n,\n
\t\t\t\t\tline: implied[n]\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (implieds.length > 0) {\n
\t\t\tdata.implieds = implieds;\n
\t\t}\n
\n
\t\tif (urls.length > 0) {\n
\t\t\tdata.urls = urls;\n
\t\t}\n
\n
\t\tglobals = Object.keys(scope);\n
\t\tif (globals.length > 0) {\n
\t\t\tdata.globals = globals;\n
\t\t}\n
\n
\t\tfor (i = 1; i < functions.length; i += 1) {\n
\t\t\tf = functions[i];\n
\t\t\tfu = {};\n
\n
\t\t\tfor (j = 0; j < functionicity.length; j += 1) {\n
\t\t\t\tfu[functionicity[j]] = [];\n
\t\t\t}\n
\n
\t\t\tfor (j = 0; j < functionicity.length; j += 1) {\n
\t\t\t\tif (fu[functionicity[j]].length === 0) {\n
\t\t\t\t\tdelete fu[functionicity[j]];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfu.name = f["(name)"];\n
\t\t\tfu.param = f["(params)"];\n
\t\t\tfu.line = f["(line)"];\n
\t\t\tfu.character = f["(character)"];\n
\t\t\tfu.last = f["(last)"];\n
\t\t\tfu.lastcharacter = f["(lastcharacter)"];\n
\t\t\tdata.functions.push(fu);\n
\t\t}\n
\n
\t\tif (unuseds.length > 0) {\n
\t\t\tdata.unused = unuseds;\n
\t\t}\n
\n
\t\tmembers = [];\n
\t\tfor (n in member) {\n
\t\t\tif (typeof member[n] === "number") {\n
\t\t\t\tdata.member = member;\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn data;\n
\t};\n
\n
\titself.jshint = itself;\n
\n
\treturn itself;\n
}());\n
if (typeof exports === "object" && exports) {\n
\texports.JSHINT = JSHINT;\n
}\n
\n
});

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <none/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
