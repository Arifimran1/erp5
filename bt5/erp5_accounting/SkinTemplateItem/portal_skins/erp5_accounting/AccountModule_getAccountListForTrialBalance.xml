<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <tuple>
        <tuple>
          <string>Products.PythonScripts.PythonScript</string>
          <string>PythonScript</string>
        </tuple>
        <none/>
      </tuple>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>Python_magic</string> </key>
            <value> <string encoding="base64">O/INCg==</string> </value>
        </item>
        <item>
            <key> <string>Script_magic</string> </key>
            <value> <int>3</int> </value>
        </item>
        <item>
            <key> <string>__ac_local_roles__</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>_bind_names</string> </key>
            <value>
              <object>
                <klass>
                  <global name="NameAssignments" module="Shared.DC.Scripts.Bindings"/>
                </klass>
                <tuple/>
                <state>
                  <dictionary>
                    <item>
                        <key> <string>_asgns</string> </key>
                        <value>
                          <dictionary>
                            <item>
                                <key> <string>name_container</string> </key>
                                <value> <string>container</string> </value>
                            </item>
                            <item>
                                <key> <string>name_context</string> </key>
                                <value> <string>context</string> </value>
                            </item>
                            <item>
                                <key> <string>name_m_self</string> </key>
                                <value> <string>script</string> </value>
                            </item>
                            <item>
                                <key> <string>name_subpath</string> </key>
                                <value> <string>traverse_subpath</string> </value>
                            </item>
                          </dictionary>
                        </value>
                    </item>
                  </dictionary>
                </state>
              </object>
            </value>
        </item>
        <item>
            <key> <string>_body</string> </key>
            <value> <string encoding="cdata"><![CDATA[

#\n
# This method returns a list of accounts virtually expanded, ie. payable and receivable accounts\n
# are split by \'destination_section\' categories and bank accounts are split by \'source_payment\'\n
#\n
\n
from DateTime import DateTime\n
import math\n
\n
LOG = lambda msg : context.getPortalObject().log(\n
        "AccountModule_getAccountListForTrialBalance", msg)\n
\n
from_date = kw.get(\'from_date\', DateTime(\'1970/01/01\'))\n
simulation_state = kw[\'transaction_simulation_state\']\n
at_date = kw[\'at_date\']\n
\n
# extra arguments for getInventory :\n
extra_kw = {}\n
\n
# get a list of section uids. \n
section_category = kw[\'transaction_section_category\']\n
section_object = context.portal_categories.restrictedTraverse(\n
                        section_category )\n
organisation_list = section_object.getGroupRelatedValueList(\n
                        portal_type=\'Organisation\')\n
section_uid_list = [section_object.getUid()] + [\n
                      x.getUid() for x in organisation_list]\n
extra_kw[\'stock.section_uid\'] = section_uid_list\n
\n
# wether we should or not expand accounts into virtual accounts \n
# (payable & receivable with other parties / bank with bank account)\n
expand_accounts = kw.get("expand_accounts", 1)\n
\n
# the gap tree to use\n
gap_root = kw["gap_root"]\n
\n
# inventory methods\n
getInventory = context.getPortalObject().portal_simulation\\\n
                                        .getInventoryAssetPrice\n
getInventoryList = context.getPortalObject().portal_simulation.getInventoryList\n
\n
# shall we display a summary line for expanded accounts ?\n
display_summary_account_line = 0\n
\n
def formatValues(dict) :\n
  for k, v in dict.items():\n
    if not(same_type(v, "") or same_type(v, u"")) :\n
      if round(v) == 0.00 :\n
        dict[k] = ""\n
      else :\n
        negative = v < 0\n
        if k in (\'opening_balance\', \'closing_balance\') and negative :\n
          v = - v\n
        # FIXME: this part is a copy of Floatfield format_value\n
        value = str(float(v))\n
        value_list = value.split(\'.\')\n
        integer = value_list[0]\n
        i = len(integer)%3\n
        value = integer[:i]\n
        while i != len(integer):\n
          value += \' \' + integer[i:i+3]\n
          i += 3\n
        dict[k] = \'%s.%s\'%(value, str(value_list[1])[:2])\n
        # XXX ohada l10n local hack, we only use integer part !\n
        #dict[k] = \'%s\'%(value)\n
        if k in (\'opening_balance\', \'closing_balance\') :\n
          if negative:\n
            dict[k] = \'%s CR\'%(value)\n
          else :\n
            dict[k] = \'%s   \'%(value)\n
        dict[k]\n
  return dict \n
\n
def getDefaultColumnValues(node_uid = 0, **kw):\n
  """ returns then opening balance, debit movements sum, credit movements\n
  sum and closing balance using defaults categories. """\n
  values = {}\n
  get_inventory_kw = extra_kw.copy()\n
  get_inventory_kw.update(kw)\n
\n
  values[\'opening_balance\']  = getInventory( node_uid = node_uid,\n
               to_date = from_date,\n
               simulation_state = simulation_state,\n
               omit_simulation = 1,\n
               **get_inventory_kw )\n
  \n
  values[\'debit_movement\']  = getInventory( node_uid = node_uid,\n
               from_date = from_date,\n
               at_date = at_date,\n
               simulation_state = simulation_state,\n
               omit_simulation = 1,\n
               omit_output = 1,\n
               **get_inventory_kw )\n
  values[\'credit_movement\']  = - getInventory( node_uid = node_uid,\n
               from_date = from_date,\n
               at_date = at_date,\n
               simulation_state = simulation_state,\n
               omit_simulation = 1,\n
               omit_input = 1,\n
               **get_inventory_kw )\n
  values[\'closing_balance\'] = values[\'opening_balance\'] + \\\n
                              values[\'debit_movement\'] - \\\n
                              values[\'credit_movement\']\n
  return values\n
\n
def expandBankAccountsForAccount(account, **kw) :\n
  tmp_accounts = []\n
  orga_and_banks = []\n
  for orga in organisation_list :\n
     orga_and_banks += [(orga, o.getObject()) for o in \\\n
            orga.searchFolder(portal_type=[ \'Bank Account\',\n
                                            \'Cash Register\',\n
                                            \'Credit Card\'])]\n
  for orga ,bank in orga_and_banks :\n
    this_tmp_account = {\n
         \'uid\'   : account.getUid(),\n
         \'id\'    : \'%s-%s-%s\' % ( account.getGapId(),\n
                                  orga.getTitle().decode(\'utf8\')[:8].upper(),\n
                                  bank.getTitle().decode(\'utf8\')[:8].upper() ),\n
         \'title\' : \'%s (%s / %s)\' % ( account.getTitle(),\n
                                      orga.getTitle(), bank.getTitle()),\n
    }\n
    this_tmp_account.update(\n
              getDefaultColumnValues( node_uid = account.getUid(),\n
                                      payment_uid = bank.getUid() ) )\n
    if ( this_tmp_account[\'opening_balance\'] != 0 or\n
         this_tmp_account[\'credit_movement\'] != 0 or \n
         this_tmp_account[\'debit_movement\'] != 0 or\n
         this_tmp_account[\'closing_balance\'] != 0 ) :\n
      tmp_accounts.append( account.asContext(\n
                              **formatValues(this_tmp_account) ) )\n
  return tmp_accounts\n
\n
def expandThirdPartiesForAccount(account, **kw) :\n
  tmp_accounts = []\n
  # get all entities that are destination section related to this account.\n
  entities = [o.getObject() for o in \\\n
        context.Account_zDistinctSectionList( node_uid = account.getUid(),\n
                                at_date = at_date,\n
                                simulation_state = simulation_state)]\n
  for entity in entities :\n
    this_tmp_account = {\n
         \'uid\' : account.getUid(),\n
         \'id\'  : \'%s-%s\'%(account.getGapId(),\n
                  entity.getTitle().decode(\'utf8\')[:12].upper()),\n
         \'title\' : \'%s (%s)\'%(account.getTitle(),\n
                  entity.getTitle()),\n
    }\n
    this_tmp_account.update(\n
              getDefaultColumnValues( node_uid = account.getUid(),\n
                                      mirror_section_uid = entity.getUid() ) )\n
    if ( this_tmp_account[\'opening_balance\'] != 0 or\n
         this_tmp_account[\'credit_movement\'] != 0 or \n
         this_tmp_account[\'debit_movement\'] != 0 ) :\n
      tmp_accounts.append( account.asContext(\n
                              **formatValues(this_tmp_account) ) )\n
  return tmp_accounts\n
\n
accounts = [ o.getObject() for o in \n
            context.account_module.objectValues(portal_type=\'Account\') ]\n
accounts = filter(lambda account: account.getGapId() is not None, accounts )\n
\n
def gap_sort_func(a, b) :\n
  """ simple function to sort accounts. """\n
  a_gap = a.Account_getGapId()\n
  b_gap = b.Account_getGapId()\n
  while len(a_gap) < 7 :\n
    a_gap += \'0\'\n
  while len(b_gap) < 7 :\n
    b_gap += \'0\'\n
  return cmp(a_gap, b_gap)\n
\n
accounts.sort(gap_sort_func)\n
\n
accounts_to_expand_by_third_parties = context.portal_categories\\\n
        .account_type.asset.receivable.getAccountTypeRelatedValueList(\n
         portal_type=\'Account\', strict_membership=1) + \\\n
    context.portal_categories.account_type.liability.payable\\\n
        .getAccountTypeRelatedValueList(\n
        # we use strict_membership because we do not want VAT\n
         portal_type=\'Account\', strict_membership=1)\n
\n
# use a dict for faster lookup\n
accounts_to_expand_by_third_parties_dict = {}\n
for account in accounts_to_expand_by_third_parties :\n
  accounts_to_expand_by_third_parties_dict[account.getId()] = 1\n
\n
accounts_to_expand_by_bank_accounts = context.portal_categories\\\n
      .account_type.asset.cash.getAccountTypeRelatedValueList(\n
       portal_type=\'Account\')\n
accounts_to_expand_by_bank_accounts_dict = {}\n
for account in accounts_to_expand_by_bank_accounts :\n
  accounts_to_expand_by_bank_accounts_dict[account.getId()] = 1\n
\n
report_items = []\n
results = []\n
for account in accounts :\n
  if expand_accounts and account.getId() \\\n
                          in accounts_to_expand_by_third_parties_dict :\n
    # get all organisations with this account\n
    # and create a "virtual-Account" for each organisation\n
    virtual_accounts = expandThirdPartiesForAccount(account, **kw)\n
    report_items += virtual_accounts\n
    if display_summary_account_line or not len(virtual_accounts) :\n
      # then display the aggregate account\n
      item = { \'title\': account.getTitle(), }\n
      item.update( getDefaultColumnValues( node_uid = account.getUid() ) )\n
\n
      # provide a clearly different display when it is a summary account \n
      # (TODO: it should be in itallic ?).\n
      if len(virtual_accounts) :\n
        item[\'id\'] = "   %s **TOTAL**" % account.getGapId()\n
      else :\n
        item[\'id\'] = account.getGapId()\n
      item[\'closing_balance\'] = item[\'opening_balance\'] + \\\n
                                item[\'debit_movement\'] - \\\n
                                item[\'credit_movement\']\n
\n
      report_items.append( account.asContext( **formatValues(item) ) )\n
\n
  elif expand_accounts and account.getId()\\\n
                            in accounts_to_expand_by_bank_accounts_dict :\n
    virtual_accounts = expandBankAccountsForAccount(account, **kw)\n
    report_items += virtual_accounts\n
    if display_summary_account_line or not len(virtual_accounts)  :\n
      # then display the aggregate account\n
      item = { \'title\': account.getTitle(), }\n
      item.update( getDefaultColumnValues( node_uid = account.getUid() ) )\n
\n
      # provide a clearly different display when it is a summary account \n
      # (TODO: it should be in itallic ?).\n
      if len(virtual_accounts) :\n
        item[\'id\'] = "   %s **TOTAL**" % account.getGapId()\n
      else :\n
        item[\'id\'] = account.getGapId()\n
      item[\'closing_balance\'] = item[\'opening_balance\'] + \\\n
                                item[\'debit_movement\'] - \\\n
                                item[\'credit_movement\']\n
\n
      report_items.append(account.asContext(**formatValues(item)))\n
  else :\n
    item = { \'id\' : account.getGapId(),\n
             \'title\': account.getTitle(), }\n
    item.update( getDefaultColumnValues( node_uid = account.getUid() ) )\n
    report_items.append( account.asContext( **formatValues(item) ) )\n
\n
return report_items\n
# vim: syntax=python\n


]]></string> </value>
        </item>
        <item>
            <key> <string>_code</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>_dav_writelocks</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>_filepath</string> </key>
            <value> <string>Script (Python):/erp5/portal_skins/erp5_accounting/AccountModule_getAccountListForTrialBalance</string> </value>
        </item>
        <item>
            <key> <string>_params</string> </key>
            <value> <string>selection, **kw</string> </value>
        </item>
        <item>
            <key> <string>errors</string> </key>
            <value>
              <tuple/>
            </value>
        </item>
        <item>
            <key> <string>func_code</string> </key>
            <value>
              <object>
                <klass>
                  <global name="FuncCode" module="Shared.DC.Scripts.Signature"/>
                </klass>
                <tuple/>
                <state>
                  <dictionary>
                    <item>
                        <key> <string>co_argcount</string> </key>
                        <value> <int>1</int> </value>
                    </item>
                    <item>
                        <key> <string>co_varnames</string> </key>
                        <value>
                          <tuple>
                            <string>selection</string>
                            <string>kw</string>
                            <string>DateTime</string>
                            <string>math</string>
                            <string>LOG</string>
                            <string>_getattr_</string>
                            <string>from_date</string>
                            <string>_getitem_</string>
                            <string>simulation_state</string>
                            <string>at_date</string>
                            <string>extra_kw</string>
                            <string>section_category</string>
                            <string>context</string>
                            <string>section_object</string>
                            <string>organisation_list</string>
                            <string>append</string>
                            <string>$append0</string>
                            <string>_getiter_</string>
                            <string>x</string>
                            <string>section_uid_list</string>
                            <string>_write_</string>
                            <string>expand_accounts</string>
                            <string>gap_root</string>
                            <string>getInventory</string>
                            <string>getInventoryList</string>
                            <string>display_summary_account_line</string>
                            <string>formatValues</string>
                            <string>getDefaultColumnValues</string>
                            <string>expandBankAccountsForAccount</string>
                            <string>expandThirdPartiesForAccount</string>
                            <string>o</string>
                            <string>accounts</string>
                            <string>filter</string>
                            <string>gap_sort_func</string>
                            <string>accounts_to_expand_by_third_parties</string>
                            <string>accounts_to_expand_by_third_parties_dict</string>
                            <string>account</string>
                            <string>accounts_to_expand_by_bank_accounts</string>
                            <string>accounts_to_expand_by_bank_accounts_dict</string>
                            <string>report_items</string>
                            <string>results</string>
                            <string>_apply_</string>
                            <string>virtual_accounts</string>
                            <string>len</string>
                            <string>item</string>
                          </tuple>
                        </value>
                    </item>
                  </dictionary>
                </state>
              </object>
            </value>
        </item>
        <item>
            <key> <string>func_defaults</string> </key>
            <value>
              <none/>
            </value>
        </item>
        <item>
            <key> <string>id</string> </key>
            <value> <string>AccountModule_getAccountListForTrialBalance</string> </value>
        </item>
        <item>
            <key> <string>warnings</string> </key>
            <value>
              <tuple/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <tuple>
        <tuple>
          <string>Persistence</string>
          <string>PersistentMapping</string>
        </tuple>
        <none/>
      </tuple>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_container</string> </key>
            <value>
              <dictionary/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
