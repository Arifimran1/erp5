<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272511.46</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Core_alterSpec.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

describe(\'Core_alter\', function () {\n
  var id = \'testContainer\';\n
\n
  beforeEach(function () {\n
    this.$container = $(\'<div id="\' + id + \'"></div>\').appendTo(\'body\');\n
  });\n
\n
  afterEach(function () {\n
    if (this.$container) {\n
      destroy();\n
      this.$container.remove();\n
    }\n
  });\n
\n
  var arrayOfNestedObjects = function () {\n
    return [\n
      {id: 1, name: {\n
        first: "Ted",\n
        last: "Right"\n
      }, address: "Street Name", zip: "80410", city: "City Name"},\n
      {id: 2, name: {\n
        first: "Frank",\n
        last: "Honest"\n
      }, address: "Street Name", zip: "80410", city: "City Name"},\n
      {id: 3, name: {\n
        first: "Joan",\n
        last: "Well"\n
      }, address: "Street Name", zip: "80410", city: "City Name"}\n
    ]\n
  };\n
\n
  var arrayOfArrays = function () {\n
    return [\n
      ["", "Kia", "Nissan", "Toyota", "Honda"],\n
      ["2008", 10, 11, 12, 13],\n
      ["2009", 20, 11, 14, 13],\n
      ["2010", 30, 15, 12, 13]\n
    ];\n
  };\n
\n
  describe("remove row", function () {\n
    it(\'should remove row\', function () {\n
      handsontable({\n
        minRows: 5,\n
        data: arrayOfNestedObjects(),\n
        columns: [\n
          {data: "id"},\n
          {data: "name.first"}\n
        ]\n
      });\n
      alter(\'remove_row\', 1);\n
\n
      expect(getDataAtCell(1, 1)).toEqual(\'Joan\'); //Joan should be moved up\n
      expect(getData().length).toEqual(5); //new row should be added by keepEmptyRows\n
    });\n
\n
    it(\'should fire beforeRemoveRow event before removing row\', function () {\n
      var onBeforeRemoveRow = jasmine.createSpy(\'onBeforeRemoveRow\');\n
\n
      var hot = handsontable({\n
        data: arrayOfNestedObjects(),\n
        columns: [\n
          {data: "id"},\n
          {data: "name.first"}\n
        ],\n
        beforeRemoveRow: onBeforeRemoveRow\n
      });\n
      alter(\'remove_row\');\n
\n
      expect(onBeforeRemoveRow).toHaveBeenCalledWith(countRows(), 1, undefined, undefined, undefined, undefined);\n
    });\n
\n
    it(\'should not remove row if removing has been canceled by beforeRemoveRow event handler\', function () {\n
      var onBeforeRemoveRow = jasmine.createSpy(\'onBeforeRemoveRow\');\n
      onBeforeRemoveRow.plan = function () {\n
        return false;\n
      };\n
\n
      var hot = handsontable({\n
        data: arrayOfNestedObjects(),\n
        columns: [\n
          {data: "id"},\n
          {data: "name.first"}\n
        ],\n
        beforeRemoveRow: onBeforeRemoveRow\n
      });\n
\n
      expect(countRows()).toEqual(3);\n
\n
      alter(\'remove_row\');\n
\n
      expect(countRows()).toEqual(3);\n
    });\n
\n
    it(\'should not remove rows below minRows\', function () {\n
      handsontable({\n
        startRows: 5,\n
        minRows: 4\n
      });\n
      alter(\'remove_row\', 1);\n
      alter(\'remove_row\', 1);\n
      alter(\'remove_row\', 1);\n
\n
      expect(countRows()).toEqual(4);\n
    });\n
\n
    it(\'should not remove cols below minCols\', function () {\n
      handsontable({\n
        startCols: 5,\n
        minCols: 4\n
      });\n
      alter(\'remove_col\', 1);\n
      alter(\'remove_col\', 1);\n
      alter(\'remove_col\', 1);\n
\n
      expect(countCols()).toEqual(4);\n
    });\n
\n
    it(\'should remove one row if amount parameter is empty\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'remove_row\', 1);\n
\n
      expect(countRows()).toEqual(4);\n
      expect(this.$container.find(\'tr:eq(0) td:eq(0)\').html()).toEqual(\'a1\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(1)\').html()).toEqual(\'c2\');\n
    });\n
\n
    it(\'should remove as many rows as given in the amount parameter\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'remove_row\', 1, 3);\n
\n
      expect(countRows()).toEqual(2);\n
      expect(this.$container.find(\'tr:eq(0) td:eq(0)\').html()).toEqual(\'a1\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(1)\').html()).toEqual(\'e2\');\n
    });\n
\n
    it(\'should not remove more rows that exist\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'remove_row\', 1, 10);\n
\n
      expect(countRows()).toEqual(1);\n
      expect(getHtCore().find(\'tr:last td:last\').html()).toEqual(\'a3\');\n
    });\n
\n
    it(\'should remove one row from end if no parameters are given\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'remove_row\');\n
\n
      expect(countRows()).toEqual(4);\n
      expect(getHtCore().find(\'tr:last td:eq(0)\').html()).toEqual(\'d1\');\n
    });\n
\n
    it(\'should remove amount of rows from end if index parameter is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'remove_row\', null, 3);\n
\n
      expect(countRows()).toEqual(2);\n
      expect(getHtCore().find(\'tr:last td:eq(0)\').html()).toEqual(\'b1\');\n
    });\n
\n
    it("should remove rows from table with fixedRows", function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"]\n
        ],\n
        fixedRowsTop: 1,\n
        minSpareRows: 0\n
      });\n
\n
      alter(\'remove_row\', 1);\n
\n
      expect(countRows()).toEqual(1);\n
\n
    });\n
\n
    it("should remove all rows from table with fixedRows", function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"]\n
        ],\n
        fixedRowsTop: 1,\n
        minSpareRows: 0\n
      });\n
\n
      alter(\'remove_row\', 1);\n
      alter(\'remove_row\', 1);\n
\n
      expect(countRows()).toEqual(0);\n
\n
    });\n
\n
    it("should remove row\'s cellProperties", function () {\n
      handsontable({\n
        startCols: 1,\n
        startRows: 3\n
      });\n
\n
      getCellMeta(0, 0).someValue = [0, 0];\n
      getCellMeta(1, 0).someValue = [1, 0];\n
      getCellMeta(2, 0).someValue = [2, 0];\n
\n
      alter(\'remove_row\', 0);\n
\n
      expect(getCellMeta(0, 0).someValue).toEqual([1, 0]);\n
      expect(getCellMeta(1, 0).someValue).toEqual([2, 0]);\n
\n
\n
    });\n
\n
    it(\'should fire callback on remove row\', function () {\n
      var output;\n
      handsontable({\n
        minRows: 5,\n
        data: arrayOfNestedObjects(),\n
        columns: [\n
          {data: "id"},\n
          {data: "name.first"}\n
        ],\n
        afterRemoveRow: function (index, amount) {\n
          output = [index, amount];\n
        }\n
      });\n
      alter(\'remove_row\', 1, 2);\n
\n
      expect(output).toEqual([1, 2]);\n
    });\n
\n
    it("should decrement the number of fixed rows, if a fix row is removed", function () {\n
      var hot = handsontable({\n
        startCols: 1,\n
        startRows: 3,\n
        fixedRowsTop: 4\n
      });\n
\n
      alter(\'remove_row\', 1, 1);\n
      expect(hot.getSettings().fixedRowsTop).toEqual(3);\n
      alter(\'remove_row\', 1, 2);\n
      expect(hot.getSettings().fixedRowsTop).toEqual(1);\n
    });\n
\n
  });\n
\n
  describe("remove column", function () {\n
    it(\'should remove one column if amount parameter is empty\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'remove_col\', 1);\n
\n
      expect(countCols()).toEqual(7);\n
      expect(this.$container.find(\'tr:eq(0) td:eq(0)\').html()).toEqual(\'a\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(1)\').html()).toEqual(\'c\');\n
    });\n
\n
    it(\'should remove as many columns as given in the amount parameter\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'remove_col\', 1, 3);\n
\n
      expect(countCols()).toEqual(5);\n
      expect(this.$container.find(\'tr:eq(0) td:eq(0)\').html()).toEqual(\'a\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(1)\').html()).toEqual(\'e\');\n
    });\n
\n
    it(\'should not remove more columns that exist\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'remove_col\', 6, 3);\n
\n
      expect(countCols()).toEqual(6);\n
      expect(this.$container.find(\'tr:eq(1) td:last\').html()).toEqual(\'f\');\n
    });\n
\n
    it(\'should remove one column from end if no parameters are given\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'remove_col\');\n
\n
      expect(countCols()).toEqual(7);\n
      expect(this.$container.find(\'tr:eq(1) td:last\').html()).toEqual(\'g\');\n
    });\n
\n
    it(\'should remove amount of columns from end if index parameter is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'remove_col\', null, 3);\n
\n
      expect(countCols()).toEqual(5);\n
      expect(this.$container.find(\'tr:eq(1) td:last\').html()).toEqual(\'e\');\n
    });\n
\n
    it(\'should fire beforeRemoveCol event before removing col\', function () {\n
      var onBeforeRemoveCol = jasmine.createSpy(\'onBeforeRemoveCol\');\n
\n
      var hot = handsontable({\n
        beforeRemoveCol: onBeforeRemoveCol\n
      });\n
      alter(\'remove_col\');\n
\n
      expect(onBeforeRemoveCol).toHaveBeenCalledWith(countCols(), 1, undefined, undefined, undefined, undefined);\n
    });\n
\n
    it(\'should not remove column if removing has been canceled by beforeRemoveCol event handler\', function () {\n
      var onBeforeRemoveCol = jasmine.createSpy(\'onBeforeRemoveCol\');\n
      onBeforeRemoveCol.plan = function () {\n
        return false;\n
      };\n
\n
      var hot = handsontable({\n
        beforeRemoveCol: onBeforeRemoveCol\n
      });\n
\n
      expect(countCols()).toEqual(5);\n
\n
      alter(\'remove_col\');\n
\n
      expect(countCols()).toEqual(5);\n
    });\n
\n
    it(\'should fire callback on remove col\', function () {\n
      var output;\n
      handsontable({\n
        minRows: 5,\n
        data: arrayOfArrays(),\n
        afterRemoveCol: function (index, amount) {\n
          output = [index, amount];\n
        }\n
      });\n
      alter(\'remove_col\', 1);\n
\n
      expect(output).toEqual([1, 1]);\n
    });\n
\n
    it("should remove column\'s properties", function () {\n
      handsontable({\n
        startCols: 3,\n
        startRows: 1\n
      });\n
\n
      getCellMeta(0, 0).someValue = [0, 0];\n
      getCellMeta(0, 1).someValue = [0, 1];\n
      getCellMeta(0, 2).someValue = [0, 2];\n
\n
      alter(\'remove_col\', 0);\n
\n
      expect(getCellMeta(0, 0).someValue).toEqual([0, 1]);\n
      expect(getCellMeta(0, 1).someValue).toEqual([0, 2]);\n
    });\n
\n
    it("should remove column when not all rows are visible in the viewport", function () {\n
      this.$container.css({\n
        height: \'100\',\n
        overflow: \'auto\'\n
      });\n
\n
      handsontable({\n
        startCols: 3,\n
        startRows: 20\n
      });\n
\n
      expect(getHtCore().find(\'tbody tr\').length).toBeLessThan(20);\n
      expect(countCols()).toEqual(3);\n
\n
      alter(\'remove_col\', 0);\n
\n
      expect(countCols()).toEqual(2);\n
    });\n
\n
    it("should not remove column header together with the column, if headers were NOT specified explicitly", function () {\n
\n
      handsontable({\n
        startCols: 3,\n
        startRows: 2,\n
        colHeaders: true\n
      });\n
\n
      expect(getColHeader()).toEqual([\'A\', \'B\', \'C\']);\n
\n
      expect(countCols()).toEqual(3);\n
\n
      alter(\'remove_col\', 1);\n
\n
      expect(countCols()).toEqual(2);\n
\n
      expect(getColHeader()).toEqual([\'A\', \'B\']);\n
\n
    });\n
\n
    it("should remove column header together with the column, if headers were specified explicitly", function () {\n
\n
      handsontable({\n
        startCols: 3,\n
        startRows: 2,\n
        colHeaders: [\'Header0\', \'Header1\', \'Header2\']\n
      });\n
\n
      expect(getColHeader()).toEqual([\'Header0\', \'Header1\', \'Header2\']);\n
\n
      expect(countCols()).toEqual(3);\n
\n
      alter(\'remove_col\', 1);\n
\n
      expect(countCols()).toEqual(2);\n
\n
      expect(getColHeader()).toEqual([\'Header0\', \'Header2\']);\n
\n
    });\n
\n
    it("should decrement the number of fixed columns, if a fix column is removed", function () {\n
      var hot = handsontable({\n
        startCols: 1,\n
        startRows: 3,\n
        fixedColumnsLeft: 4\n
      });\n
\n
      alter(\'remove_col\', 1, 1);\n
      expect(hot.getSettings().fixedColumnsLeft).toEqual(3);\n
      alter(\'remove_col\', 1, 2);\n
      expect(hot.getSettings().fixedColumnsLeft).toEqual(1);\n
    });\n
\n
  });\n
\n
  describe("insert row", function () {\n
    it(\'should insert row at given index\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'insert_row\', 1);\n
\n
      expect(countRows()).toEqual(6);\n
      expect(this.$container.find(\'tr:eq(2) td:eq(0)\').html()).toEqual(\'b1\');\n
    });\n
\n
    it(\'should insert row at the end if index is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'insert_row\');\n
\n
      expect(countRows()).toEqual(6);\n
      expect(getHtCore().find(\'tr:eq(4) td:eq(0)\').html()).toEqual(\'e1\');\n
\n
      expect(getHtCore().find(\'tr:last td:eq(0)\').html()).toEqual(\'\');\n
    });\n
\n
    it(\'should insert the amount of rows at given index\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'insert_row\', 1, 3);\n
\n
      expect(countRows()).toEqual(8);\n
\n
      expect(this.$container.find(\'tr:eq(1) td:eq(0)\').html()).toEqual(\'\');\n
\n
      expect(this.$container.find(\'tr:eq(4) td:eq(0)\').html()).toEqual(\'b1\');\n
    });\n
\n
    it(\'should insert the amount of rows at the end if index is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ]\n
      });\n
      alter(\'insert_row\', null, 3);\n
\n
      expect(countRows()).toEqual(8);\n
      expect(getHtCore().find(\'tr:eq(4) td:eq(0)\').html()).toEqual(\'e1\');\n
\n
      expect(getHtCore().find(\'tr:eq(5) td:eq(0)\').html()).toEqual(\'\');\n
      expect(getHtCore().find(\'tr:eq(6) td:eq(0)\').html()).toEqual(\'\');\n
      expect(getHtCore().find(\'tr:eq(7) td:eq(0)\').html()).toEqual(\'\');\n
    });\n
\n
    it(\'should insert not more rows than maxRows\', function () {\n
      handsontable({\n
        startRows: 5,\n
        maxRows: 7\n
      });\n
      alter(\'insert_row\', 1);\n
      alter(\'insert_row\', 1);\n
      alter(\'insert_row\', 1);\n
\n
      expect(countRows()).toEqual(7);\n
    });\n
\n
    it(\'when amount parameter is used, should not insert more rows than allowed by maxRows\', function () {\n
      handsontable({\n
        data: [\n
          ["a1", "a2", "a3"],\n
          ["b1", "b2", "b3"],\n
          ["c1", "c2", "c3"],\n
          ["d1", "d2", "d3"],\n
          ["e1", "e2", "e3"]\n
        ],\n
        maxRows: 10\n
      });\n
      alter(\'insert_row\', 1, 10);\n
\n
      expect(countRows()).toEqual(10);\n
      expect(this.$container.find(\'tr:eq(6) td:eq(0)\').html()).toEqual(\'b1\');\n
    });\n
\n
    it(\'should fire callback on create row\', function () {\n
      var output;\n
      handsontable({\n
        minRows: 5,\n
        data: arrayOfNestedObjects(),\n
        columns: [\n
          {data: "id"},\n
          {data: "name.first"}\n
        ],\n
        afterCreateRow: function (index, amount) {\n
          output = index;\n
        }\n
      });\n
      alter(\'insert_row\', 3);\n
\n
      expect(output).toEqual(3);\n
    });\n
\n
    it("should keep the single-cell selection in the same position as before inserting the row", function () {\n
      handsontable({\n
        minRows: 5,\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
\n
      selectCell(2,2);\n
      alter(\'insert_row\', 2);\n
\n
      var selected = getSelected();\n
      expect(selected[0]).toEqual(3);\n
      expect(selected[2]).toEqual(3);\n
    });\n
\n
  });\n
\n
  describe("insert column", function () {\n
    it(\'should insert column at given index\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'insert_col\', 1);\n
\n
      expect(countCols()).toEqual(9);\n
      expect(this.$container.find(\'tr:eq(1) td:eq(2)\').html()).toEqual(\'b\');\n
    });\n
\n
    it(\'should insert column at the end if index is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'insert_col\');\n
\n
      expect(countCols()).toEqual(9);\n
      expect(this.$container.find(\'tr:eq(1) td:eq(7)\').html()).toEqual(\'h\');\n
    });\n
\n
    it(\'should insert the amount of columns at given index\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'insert_col\', 1, 3);\n
\n
      expect(countCols()).toEqual(11);\n
      expect(this.$container.find(\'tr:eq(1) td:eq(4)\').html()).toEqual(\'b\');\n
    });\n
\n
    it(\'should insert the amount of columns at the end if index is not given\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ]\n
      });\n
      alter(\'insert_col\', null, 3);\n
\n
      expect(countCols()).toEqual(11);\n
      expect(this.$container.find(\'tr:eq(1) td:eq(7)\').html()).toEqual(\'h\');\n
\n
      expect(this.$container.find(\'tr:eq(1) td:eq(8)\').html()).toEqual(\'\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(9)\').html()).toEqual(\'\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(10)\').html()).toEqual(\'\');\n
    });\n
\n
    it(\'should insert not more cols than maxCols\', function () {\n
      handsontable({\n
        startCols: 5,\n
        maxCols: 7\n
      });\n
      alter(\'insert_col\', 1);\n
      alter(\'insert_col\', 1);\n
      alter(\'insert_col\', 1);\n
\n
      expect(countCols()).toEqual(7);\n
    });\n
\n
    it(\'should not insert more columns than allowed by maxCols, when amount parameter is used\', function () {\n
      handsontable({\n
        data: [\n
          ["a", "b", "c", "d", "e", "f", "g", "h"],\n
          ["a", "b", "c", "d", "e", "f", "g", "h"]\n
        ],\n
        maxCols: 10\n
      });\n
      alter(\'insert_col\', 1, 10);\n
\n
      expect(countCols()).toEqual(10);\n
      expect(this.$container.find(\'tr:eq(1) td:eq(1)\').html()).toEqual(\'\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(2)\').html()).toEqual(\'\');\n
      expect(this.$container.find(\'tr:eq(1) td:eq(3)\').html()).toEqual(\'b\');\n
    });\n
\n
    it(\'should fire callback on create col\', function () {\n
      var output;\n
      handsontable({\n
        minRows: 5,\n
        data: arrayOfArrays(),\n
        afterCreateCol: function (index) {\n
          output = index;\n
        }\n
      });\n
      alter(\'insert_col\', 2);\n
\n
      expect(output).toEqual(2);\n
    });\n
\n
    it("should not create column header together with the column, if headers were NOT specified explicitly", function () {\n
\n
      handsontable({\n
        startCols: 3,\n
        startRows: 2,\n
        colHeaders: true\n
      });\n
\n
      expect(getColHeader()).toEqual([\'A\', \'B\', \'C\']);\n
\n
      expect(countCols()).toEqual(3);\n
\n
      alter(\'insert_col\', 1);\n
\n
      expect(countCols()).toEqual(4);\n
\n
      expect(getColHeader()).toEqual([\'A\', \'B\', \'C\', \'D\']);\n
\n
    });\n
\n
    it("should create column header together with the column, if headers were specified explicitly", function () {\n
\n
      handsontable({\n
        startCols: 3,\n
        startRows: 2,\n
        colHeaders: [\'Header0\', \'Header1\', \'Header2\']\n
      });\n
\n
      expect(getColHeader()).toEqual([\'Header0\', \'Header1\', \'Header2\']);\n
\n
      expect(countCols()).toEqual(3);\n
\n
      alter(\'insert_col\', 1);\n
\n
      expect(countCols()).toEqual(4);\n
\n
      expect(getColHeader()).toEqual([\'Header0\', \'B\', \'Header1\', \'Header2\']);\n
\n
    });\n
\n
    it("should stretch the table after adding another column (if stretching is set to \'all\')", function () {\n
      this.$container.css({\n
        "width": 500\n
      });\n
\n
      var hot = handsontable({\n
        startCols: 5,\n
        startRows: 10,\n
        stretchH: \'all\'\n
      });\n
\n
      expect(Handsontable.Dom.outerWidth(hot.view.TBODY)).toEqual(500);\n
      alter(\'insert_col\', null, 1);\n
      expect(Handsontable.Dom.outerWidth(hot.view.TBODY)).toEqual(500);\n
      alter(\'insert_col\', null, 1);\n
      expect(Handsontable.Dom.outerWidth(hot.view.TBODY)).toEqual(500);\n
    });\n
\n
  });\n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>21369</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Core_alterSpec.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
