<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272530.36</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>passwordRendererSpec.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

describe(\'passwordRenderer\', function () {\n
\n
  var id = \'testContainer\';\n
\n
  beforeEach(function () {\n
    this.$container = $(\'<div id="\' + id + \'"></div>\').appendTo(\'body\');\n
  });\n
\n
  afterEach(function () {\n
    if (this.$container) {\n
      destroy();\n
      this.$container.remove();\n
    }\n
  });\n
\n
  it("should render strings as a sequence of asterisks", function () {\n
\n
    handsontable({\n
      data: [\n
        [\'Joe\'],\n
        [\'Timothy\'],\n
        [\'Margaret\'],\n
        [\'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          renderer: Handsontable.PasswordRenderer\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(1, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(2, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(3, 0)).toMatch(/^[*]+$/ig);\n
\n
  });\n
\n
  it("should render numbers as a sequence of asterisks ", function () {\n
\n
    handsontable({\n
      data: [\n
        [1],\n
        [1234],\n
        [9090],\n
        [0]\n
      ],\n
      columns: [\n
        {\n
          renderer: Handsontable.PasswordRenderer\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(1, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(2, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(3, 0)).toMatch(/^[*]+$/ig);\n
\n
  });\n
\n
  it("should be possible to set passwordRenderer with column \'type\' parameter", function () {\n
\n
    handsontable({\n
      data: [\n
        [\'Joe\'],\n
        [\'Timothy\'],\n
        [\'Margaret\'],\n
        [\'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          type: \'password\'\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(1, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(2, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(3, 0)).toMatch(/^[*]+$/ig);\n
\n
  });\n
\n
  it("should be possible to set passwordRenderer using alias \'password\'", function () {\n
\n
    handsontable({\n
      data: [\n
        [\'Joe\'],\n
        [\'Timothy\'],\n
        [\'Margaret\'],\n
        [\'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          renderer: \'password\'\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(1, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(2, 0)).toMatch(/^[*]+$/ig);\n
    expect(getRenderedValue(3, 0)).toMatch(/^[*]+$/ig);\n
\n
  });\n
\n
  it("should render strings as a sequence of asterisks, of width matching the original value width", function () {\n
\n
    handsontable({\n
      data: [\n
        [\'Joe\'],\n
        [\'Timothy\'],\n
        [\'Margaret\'],\n
        [\'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          renderer: Handsontable.PasswordRenderer\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0).length).toEqual(getDataAtCell(0, 0).length);\n
    expect(getRenderedValue(1, 0).length).toEqual(getDataAtCell(1, 0).length);\n
    expect(getRenderedValue(2, 0).length).toEqual(getDataAtCell(2, 0).length);\n
    expect(getRenderedValue(3, 0).length).toEqual(getDataAtCell(3, 0).length);\n
\n
  });\n
\n
  it("should render strings as a sequence of asterisks, of fixed width", function () {\n
\n
    handsontable({\n
      data: [\n
        [\'Joe\'],\n
        [\'Timothy\'],\n
        [\'Margaret\'],\n
        [\'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          renderer: Handsontable.PasswordRenderer,\n
          hashLength: 10\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0).length).toEqual(10);\n
    expect(getRenderedValue(1, 0).length).toEqual(10);\n
    expect(getRenderedValue(2, 0).length).toEqual(10);\n
    expect(getRenderedValue(3, 0).length).toEqual(10);\n
\n
  });\n
\n
  it("should render strings as a sequence of custom symbols", function () {\n
\n
    handsontable({\n
      data: [\n
        [1, \'Joe\'],\n
        [2, \'Timothy\'],\n
        [3, \'Margaret\'],\n
        [4, \'Jerry\']\n
      ],\n
      columns: [\n
        {\n
          renderer: Handsontable.PasswordRenderer,\n
          hashSymbol: \'#\'\n
        },\n
        {\n
          renderer: Handsontable.PasswordRenderer,\n
          hashSymbol: \'x\'\n
        }\n
      ]\n
    });\n
\n
    expect(getRenderedValue(0, 0)).toMatch(/^[#]+$/ig);\n
    expect(getRenderedValue(1, 0)).toMatch(/^[#]+$/ig);\n
    expect(getRenderedValue(2, 0)).toMatch(/^[#]+$/ig);\n
    expect(getRenderedValue(3, 0)).toMatch(/^[#]+$/ig);\n
\n
    expect(getRenderedValue(0, 1)).toMatch(/^[x]+$/ig);\n
    expect(getRenderedValue(1, 1)).toMatch(/^[x]+$/ig);\n
    expect(getRenderedValue(2, 1)).toMatch(/^[x]+$/ig);\n
    expect(getRenderedValue(3, 1)).toMatch(/^[x]+$/ig);\n
\n
  });\n
\n
});\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>4515</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>passwordRendererSpec.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
