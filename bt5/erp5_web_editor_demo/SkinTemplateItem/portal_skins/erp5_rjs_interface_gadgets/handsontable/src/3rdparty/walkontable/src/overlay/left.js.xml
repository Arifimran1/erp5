<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272616.02</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>left.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

\n
import {\n
  addClass,\n
  getScrollbarWidth,\n
  getScrollLeft,\n
  getWindowScrollTop,\n
  hasClass,\n
  outerWidth,\n
  removeClass,\n
  setOverlayPosition,\n
    } from \'./../../../../helpers/dom/element\';\n
import {WalkontableOverlay} from \'./_base\';\n
\n
\n
/**\n
 * @class WalkontableLeftOverlay\n
 */\n
class WalkontableLeftOverlay extends WalkontableOverlay {\n
  /**\n
   * @param {Walkontable} wotInstance\n
   */\n
  constructor(wotInstance) {\n
    super(wotInstance);\n
    this.clone = this.makeClone(WalkontableOverlay.CLONE_LEFT);\n
  }\n
\n
  /**\n
   * Checks if overlay should be fully rendered\n
   *\n
   * @returns {Boolean}\n
   */\n
  shouldBeRendered() {\n
    return this.wot.getSetting(\'fixedColumnsLeft\') || this.wot.getSetting(\'rowHeaders\').length ? true : false;\n
  }\n
\n
  /**\n
   * Updates the left overlay position\n
   */\n
  resetFixedPosition() {\n
    if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {\n
      // removed from DOM\n
      return;\n
    }\n
    let overlayRoot = this.clone.wtTable.holder.parentNode;\n
    let headerPosition = 0;\n
\n
    if (this.trimmingContainer === window) {\n
      let box = this.wot.wtTable.hider.getBoundingClientRect();\n
      let left = Math.ceil(box.left);\n
      let right = Math.ceil(box.right);\n
      let finalLeft;\n
      let finalTop;\n
\n
      finalTop = this.wot.wtTable.hider.style.top;\n
      finalTop = finalTop === \'\' ? 0 : finalTop;\n
\n
      if (left < 0 && (right - overlayRoot.offsetWidth) > 0) {\n
        finalLeft = -left;\n
      } else {\n
        finalLeft = 0;\n
      }\n
      headerPosition = finalLeft;\n
      finalLeft = finalLeft + \'px\';\n
\n
      setOverlayPosition(overlayRoot, finalLeft, finalTop);\n
\n
    } else {\n
      headerPosition = this.getScrollPosition();\n
    }\n
    this.adjustHeaderBordersPosition(headerPosition);\n
  }\n
\n
  /**\n
   * Sets the main overlay\'s horizontal scroll position\n
   *\n
   * @param {Number} pos\n
   */\n
  setScrollPosition(pos) {\n
    if (this.mainTableScrollableElement === window) {\n
      window.scrollTo(pos, getWindowScrollTop());\n
\n
    } else {\n
      this.mainTableScrollableElement.scrollLeft = pos;\n
    }\n
  }\n
\n
  /**\n
   * Triggers onScroll hook callback\n
   */\n
  onScroll() {\n
    this.wot.getSetting(\'onScrollHorizontally\');\n
  }\n
\n
  /**\n
   * Calculates total sum cells width\n
   *\n
   * @param {Number} from Column index which calculates started from\n
   * @param {Number} to Column index where calculation is finished\n
   * @returns {Number} Width sum\n
   */\n
  sumCellSizes(from, to) {\n
    let sum = 0;\n
    let defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;\n
\n
    while (from < to) {\n
      sum += this.wot.wtTable.getStretchedColumnWidth(from) || defaultColumnWidth;\n
      from++;\n
    }\n
\n
    return sum;\n
  }\n
\n
  /**\n
   * Adjust overlay root element, childs and master table element sizes (width, height).\n
   *\n
   * @param {Boolean} [force=false]\n
   */\n
  adjustElementsSize(force = false) {\n
    if (this.needFullRender || force) {\n
      this.adjustRootElementSize();\n
      this.adjustRootChildsSize();\n
\n
      if (!force) {\n
        this.isElementSizesAdjusted = true;\n
      }\n
    }\n
  }\n
\n
  /**\n
   * Adjust overlay root element size (width and height).\n
   */\n
  adjustRootElementSize() {\n
    let masterHolder = this.wot.wtTable.holder;\n
    let scrollbarHeight = masterHolder.clientHeight !== masterHolder.offsetHeight ? getScrollbarWidth() : 0;\n
    let overlayRoot = this.clone.wtTable.holder.parentNode;\n
    let overlayRootStyle = overlayRoot.style;\n
    let tableWidth;\n
\n
    if (this.trimmingContainer !== window) {\n
      overlayRootStyle.height = this.wot.wtViewport.getWorkspaceHeight() - scrollbarHeight + \'px\';\n
    }\n
    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n
\n
    tableWidth = outerWidth(this.clone.wtTable.TABLE);\n
    overlayRootStyle.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + \'px\';\n
  }\n
\n
  /**\n
   * Adjust overlay root childs size\n
   */\n
  adjustRootChildsSize() {\n
    let scrollbarWidth = getScrollbarWidth();\n
\n
    this.clone.wtTable.hider.style.height = this.hider.style.height;\n
    this.clone.wtTable.holder.style.height = this.clone.wtTable.holder.parentNode.style.height;\n
\n
    if (scrollbarWidth === 0) {\n
      scrollbarWidth = 30;\n
    }\n
    this.clone.wtTable.holder.style.width = parseInt(this.clone.wtTable.holder.parentNode.style.width, 10) + scrollbarWidth + \'px\';\n
  }\n
\n
  /**\n
   * Adjust the overlay dimensions and position\n
   */\n
  applyToDOM() {\n
    let total = this.wot.getSetting(\'totalColumns\');\n
\n
    if (!this.isElementSizesAdjusted) {\n
      this.adjustElementsSize();\n
    }\n
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === \'number\') {\n
      this.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + \'px\';\n
\n
    } else if (total === 0) {\n
      this.spreader.style.left = \'0\';\n
\n
    } else {\n
      throw new Error(\'Incorrect value of the columnsRenderCalculator\');\n
    }\n
    this.spreader.style.right = \'\';\n
\n
    if (this.needFullRender) {\n
      this.syncOverlayOffset();\n
    }\n
  }\n
\n
  /**\n
   * Synchronize calculated top position to an element\n
   */\n
  syncOverlayOffset() {\n
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === \'number\') {\n
      this.clone.wtTable.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + \'px\';\n
\n
    } else {\n
      this.clone.wtTable.spreader.style.top = \'\';\n
    }\n
  }\n
\n
  /**\n
   * Scrolls horizontally to a column at the left edge of the viewport\n
   *\n
   * @param sourceCol {Number} Column index which you want to scroll to\n
   * @param [beyondRendered=false] {Boolean} if `true`, scrolls according to the bottom edge (top edge is by default)\n
   */\n
  scrollTo(sourceCol, beyondRendered) {\n
    let newX = this.getTableParentOffset();\n
    let sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n
    let mainHolder = sourceInstance.wtTable.holder;\n
    let scrollbarCompensation = 0;\n
\n
    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n
      scrollbarCompensation = getScrollbarWidth();\n
    }\n
    if (beyondRendered) {\n
      newX += this.sumCellSizes(0, sourceCol + 1);\n
      newX -= this.wot.wtViewport.getViewportWidth();\n
\n
    } else {\n
      newX += this.sumCellSizes(this.wot.getSetting(\'fixedColumnsLeft\'), sourceCol);\n
    }\n
    newX += scrollbarCompensation;\n
\n
    this.setScrollPosition(newX);\n
  }\n
\n
  /**\n
   * Gets table parent left position\n
   *\n
   * @returns {Number}\n
   */\n
  getTableParentOffset() {\n
    if (this.trimmingContainer === window) {\n
      return this.wot.wtTable.holderOffset.left;\n
\n
    } else {\n
      return 0;\n
    }\n
  }\n
\n
  /**\n
   * Gets the main overlay\'s horizontal scroll position\n
   *\n
   * @returns {Number} Main table\'s vertical scroll position\n
   */\n
  getScrollPosition() {\n
    return getScrollLeft(this.mainTableScrollableElement);\n
  }\n
\n
  /**\n
   * Adds css classes to hide the header border\'s header (cell-selection border hiding issue)\n
   *\n
   * @param {Number} position Header X position if trimming container is window or scroll top if not\n
   */\n
  adjustHeaderBordersPosition(position) {\n
    let masterParent = this.wot.wtTable.holder.parentNode;\n
    let rowHeaders = this.wot.getSetting(\'rowHeaders\');\n
    let fixedColumnsLeft = this.wot.getSetting(\'fixedColumnsLeft\');\n
\n
    if (fixedColumnsLeft && !rowHeaders.length) {\n
      addClass(masterParent, \'innerBorderLeft\');\n
\n
    } else if (!fixedColumnsLeft && rowHeaders.length) {\n
      let previousState = hasClass(masterParent, \'innerBorderLeft\');\n
\n
      if (position) {\n
        addClass(masterParent, \'innerBorderLeft\');\n
      } else {\n
        removeClass(masterParent, \'innerBorderLeft\');\n
      }\n
      if (!previousState && position || previousState && !position) {\n
        this.wot.wtOverlays.adjustElementsSize();\n
      }\n
    }\n
  }\n
}\n
\n
export {WalkontableLeftOverlay};\n
\n
window.WalkontableLeftOverlay = WalkontableLeftOverlay;\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>7792</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>left.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
