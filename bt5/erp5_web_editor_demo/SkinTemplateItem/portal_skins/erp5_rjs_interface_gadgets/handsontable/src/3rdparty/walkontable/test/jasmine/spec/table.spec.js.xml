<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272589.41</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>table.spec.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

describe(\'WalkontableTable\', function () {\n
  var $table\n
    , $container\n
    , $wrapper\n
    , debug = false;\n
\n
  beforeEach(function () {\n
    $wrapper = $(\'<div></div>\').css({\'overflow\': \'hidden\', \'position\': \'relative\'});\n
    $wrapper.width(100).height(201);\n
    $container = $(\'<div></div>\');\n
    $table = $(\'<table></table>\'); //create a table that is not attached to document\n
    $wrapper.append($container);\n
    $container.append($table);\n
    $wrapper.appendTo(\'body\');\n
    createDataArray();\n
  });\n
\n
  afterEach(function () {\n
    if (!debug) {\n
      $(\'.wtHolder\').remove();\n
    }\n
\n
    $wrapper.remove();\n
  });\n
\n
  it("should create as many rows as fits in height", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr\').length).toBe(9);\n
  });\n
\n
  it("should create as many rows as in `totalRows` if it is smaller than `height`", function () {\n
    this.data.splice(5, this.data.length - 5);\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr\').length).toBe(5);\n
  });\n
\n
  it("first row should have as many columns as in THEAD", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }]\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr:first td\').length).toBe($table.find(\'thead th\').length);\n
  });\n
\n
  it("should put a blank cell in the corner if both rowHeaders and colHeaders are set", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      columnHeaders: [function (col, TH) {\n
        if( col > - 1) {\n
          TH.innerHTML = \'Column\';\n
        }\n
      }],\n
      rowHeaders: [function (row, TH) {\n
        if (row > -1) {\n
          TH.innerHTML = \'Row\';\n
        }\n
      }]\n
    });\n
    wt.draw();\n
    expect($table.find(\'thead tr:first th\').length).toBe(wt.wtTable.getRenderedColumnsCount() + 1); //4 columns in THEAD + 1 empty cell in the corner\n
    expect($table.find(\'thead tr:first th:eq(0)\')[0].innerHTML.replace(/&nbsp;/, \'\')).toBe(\'\'); //corner row is empty (or contains only &nbsp;)\n
    expect($table.find(\'thead tr:first th:eq(1)\')[0].innerHTML).toBe(\'Column\');\n
    expect($table.find(\'tbody tr:first th:eq(0)\')[0].innerHTML).toBe(\'Row\');\n
  });\n
\n
  it("getCell should only return cells from rendered rows", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
\n
    expect(wt.wtTable.getCell(new WalkontableCellCoords(7, 0)) instanceof HTMLElement).toBe(true);\n
    expect($table.find(\'tr:eq(8) td:first-child\').text()).toEqual(this.data[8][0].toString());\n
    expect(wt.wtTable.getCell(new WalkontableCellCoords(20, 0))).toBe(-2); //exit code\n
    expect(wt.wtTable.getCell(new WalkontableCellCoords(25, 0))).toBe(-2); //exit code\n
  });\n
\n
  it("getCoords should return coords of TD", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
\n
    var $td2 = $table.find(\'tbody tr:eq(1) td:eq(1)\');\n
    expect(wt.wtTable.getCoords($td2[0])).toEqual(new WalkontableCellCoords(1, 1));\n
  });\n
\n
  it("getCoords should return coords of TD (with row header)", function () {\n
\n
    $wrapper.width(300);\n
\n
    function plusOne(i) {\n
      return i + 1;\n
    }\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = plusOne(row);\n
      }]\n
    });\n
    wt.draw();\n
\n
    var $td2 = $table.find(\'tbody tr:eq(1) td:eq(1)\');\n
    expect(wt.wtTable.getCoords($td2[0])).toEqual(new WalkontableCellCoords(1, 1));\n
  });\n
\n
  it("getStretchedColumnWidth should return valid column width when stretchH is set as \'all\'", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      stretchH: \'all\'\n
    });\n
    wt.draw();\n
    wt.wtViewport.columnsRenderCalculator.refreshStretching(502);\n
\n
    expect(wt.wtTable.getStretchedColumnWidth(0, 50)).toBe(125);\n
    expect(wt.wtTable.getStretchedColumnWidth(1, 50)).toBe(125);\n
    expect(wt.wtTable.getStretchedColumnWidth(2, 50)).toBe(125);\n
    expect(wt.wtTable.getStretchedColumnWidth(3, 50)).toBe(127);\n
  });\n
\n
  it("getStretchedColumnWidth should return valid column width when stretchH is set as \'last\'", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      stretchH: \'last\'\n
    });\n
    wt.draw();\n
    wt.wtViewport.columnsRenderCalculator.refreshStretching(502);\n
\n
    expect(wt.wtTable.getStretchedColumnWidth(0, 50)).toBe(50);\n
    expect(wt.wtTable.getStretchedColumnWidth(1, 50)).toBe(50);\n
    expect(wt.wtTable.getStretchedColumnWidth(2, 50)).toBe(50);\n
    expect(wt.wtTable.getStretchedColumnWidth(3, 50)).toBe(352);\n
  });\n
\n
  it("should use custom cell renderer if provided", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      cellRenderer: function (row, column, TD) {\n
        var cellData = getData(row, column);\n
        if (cellData !== void 0) {\n
          TD.innerHTML = cellData;\n
        }\n
        else {\n
          TD.innerHTML = \'\';\n
        }\n
        TD.className = \'\';\n
        TD.style.backgroundColor = \'yellow\';\n
      }\n
    });\n
    wt.draw();\n
    expect($table.find(\'td:first\')[0].style.backgroundColor).toBe(\'yellow\');\n
  });\n
\n
  it("should remove rows if they were removed in data source", function () {\n
    this.data.splice(8, this.data.length - 8); //second param is required by IE8\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr\').length).toBe(8);\n
\n
    this.data.splice(7, this.data.length - 7); //second param is required by IE8\n
    wt.draw();\n
    expect($table.find(\'tbody tr\').length).toBe(7);\n
  });\n
\n
  it("should render as much columns as the container width allows, if width is null", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }]\n
    });\n
    wt.draw();\n
    expect($table.find(\'thead tr:first\').children().length).toBe(2);\n
    expect($table.find(\'tbody tr:first\').children().length).toBe(2);\n
\n
    $wrapper.width(200);\n
    wt.draw();\n
    expect($table.find(\'thead tr:first\').children().length).toBe(4);\n
    expect($table.find(\'tbody tr:first\').children().length).toBe(4);\n
  });\n
\n
  it("should render as much columns as the container width allows, if width is null (with row header)", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }]\n
    });\n
    wt.draw();\n
    expect($table.find(\'thead tr:first\').children().length).toBe(2);\n
    expect($table.find(\'tbody tr:first\').children().length).toBe(2);\n
\n
    $wrapper.width(200);\n
    wt.draw();\n
    expect($table.find(\'thead tr:first\').children().length).toBe(4);\n
    expect($table.find(\'tbody tr:first\').children().length).toBe(4);\n
  });\n
\n
  it("should use column width function to get column width", function () {\n
\n
    $wrapper.width(600);\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }],\n
      columnWidth: function (column) {\n
        return (column + 1) * 50\n
      }\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr:first td:eq(0)\').outerWidth()).toBe(50);\n
    expect($table.find(\'tbody tr:first td:eq(1)\').outerWidth()).toBe(100);\n
    expect($table.find(\'tbody tr:first td:eq(2)\').outerWidth()).toBe(150);\n
    expect($table.find(\'tbody tr:first td:eq(3)\').outerWidth()).toBe(200);\n
  });\n
\n
  it("should use column width array to get column width", function () {\n
\n
    $wrapper.width(600);\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }],\n
      columnWidth: [50, 100, 150, 201]\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr:first td:eq(0)\').outerWidth()).toBe(50);\n
    expect($table.find(\'tbody tr:first td:eq(1)\').outerWidth()).toBe(100);\n
    expect($table.find(\'tbody tr:first td:eq(2)\').outerWidth()).toBe(150);\n
    expect($table.find(\'tbody tr:first td:eq(3)\').outerWidth()).toBe(201);\n
  });\n
\n
  it("should use column width integer to get column width", function () {\n
\n
    $wrapper.width(600);\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }],\n
      columnWidth: 100\n
    });\n
    wt.draw();\n
    expect($table.find(\'tbody tr:first td:eq(0)\').outerWidth()).toBe(100);\n
    expect($table.find(\'tbody tr:first td:eq(1)\').outerWidth()).toBe(100);\n
    expect($table.find(\'tbody tr:first td:eq(2)\').outerWidth()).toBe(100);\n
    expect($table.find(\'tbody tr:first td:eq(3)\').outerWidth()).toBe(100);\n
  });\n
\n
  it("should use column width also when there are no rows", function () {\n
    this.data.length = 0;\n
\n
    $wrapper.width(600);\n
\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: 4,\n
      rowHeaders: [function (row, TH) {\n
        TH.innerHTML = row + 1;\n
      }],\n
      columnHeaders: [function (col, TH) {\n
        TH.innerHTML = col + 1;\n
      }],\n
      columnWidth: 100\n
    });\n
    wt.draw();\n
    //start from eq(1) because eq(0) is corner header\n
    expect($table.find(\'thead tr:first th:eq(1)\').outerWidth()).toBe(100);\n
    expect($table.find(\'thead tr:first th:eq(2)\').outerWidth()).toBe(100);\n
    expect($table.find(\'thead tr:first th:eq(3)\').outerWidth()).toBe(100);\n
    expect($table.find(\'thead tr:first th:eq(4)\').outerWidth()).toBe(100);\n
  });\n
\n
  it("should render a cell that is outside of the viewport horizontally", function () {\n
    var wt = new Walkontable({\n
      table: $table[0],\n
      data: getData,\n
      totalRows: getTotalRows,\n
      totalColumns: getTotalColumns\n
    });\n
    wt.draw();\n
    $table.find(\'tbody td\').html(\'\');\n
    wt.draw();\n
    expect($table.find(\'tbody tr:first td\').length).toBe(2);\n
  });\n
\n
  it("should not render a cell when fastDraw == true", function () {\n
    var count = 0\n
      , wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns,\n
        cellRenderer: function (row, column, TD) {\n
          count++;\n
          return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n
        }\n
      });\n
    wt.draw();\n
    var oldCount = count;\n
    wt.draw(true);\n
    expect(count).toBe(oldCount);\n
  });\n
\n
  it("should not ignore fastDraw == true when grid was scrolled by amount of rows that doesn\'t exceed endRow", function () {\n
    var count = 0\n
      , wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns,\n
        cellRenderer: function (row, column, TD) {\n
          count++;\n
          return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n
        },\n
        viewportRowCalculatorOverride: function(calc) {\n
          calc.endRow += 10;\n
        }\n
      });\n
    wt.draw();\n
    var oldCount = count;\n
\n
    wt.scrollVertical(8);\n
    wt.draw(true);\n
    expect(count).not.toBeGreaterThan(oldCount);\n
  });\n
\n
  it("should ignore fastDraw == true when grid was scrolled by amount of rows that exceeds endRow", function () {\n
    var count = 0\n
      , wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns,\n
        cellRenderer: function (row, column, TD) {\n
          count++;\n
          return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n
        },\n
        viewportRowCalculatorOverride: function(calc) {\n
          calc.endRow += 10;\n
        }\n
      });\n
    wt.draw();\n
    var oldCount = count;\n
\n
    wt.scrollVertical(10);\n
    wt.draw(true);\n
    expect(count).not.toBeGreaterThan(oldCount);\n
\n
    wt.scrollVertical(11);\n
    wt.draw(true);\n
    expect(count).toBeGreaterThan(oldCount);\n
  });\n
\n
  it("should not ignore fastDraw == true when grid was scrolled by amount of columns that doesn\'t exceed endColumn", function () {\n
    createDataArray(50, 50);\n
    var count = 0\n
      , wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns,\n
        cellRenderer: function (row, column, TD) {\n
          count++;\n
          return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n
        },\n
        viewportColumnCalculatorOverride: function(calc) {\n
          calc.endColumn += 10;\n
        }\n
      });\n
    wt.draw();\n
    var oldCount = count;\n
\n
    wt.scrollHorizontal(8);\n
    wt.draw(true);\n
\n
    expect(count).not.toBeGreaterThan(oldCount);\n
  });\n
\n
  it("should ignore fastDraw == true when grid was scrolled by amount of columns that exceeds endColumn", function () {\n
    createDataArray(50, 50);\n
    var count = 0\n
      , wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns,\n
        cellRenderer: function (row, column, TD) {\n
          count++;\n
          return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n
        },\n
        viewportColumnCalculatorOverride: function(calc) {\n
          calc.endColumn += 10;\n
        }\n
      });\n
    wt.draw();\n
    var oldCount = count;\n
\n
    wt.scrollHorizontal(10);\n
    wt.draw(true);\n
    expect(count).not.toBeGreaterThan(oldCount);\n
\n
    wt.scrollHorizontal(11);\n
    wt.draw(true);\n
    expect(count).toBeGreaterThan(oldCount);\n
  });\n
\n
  describe(\'cell header border\', function () {\n
    it("should be correct visible in fixedColumns and without row header", function () {\n
      createDataArray(50, 50);\n
      $wrapper.width(500).height(400);\n
\n
      var count = 0,\n
        wt = new Walkontable({\n
          table: $table[0],\n
          data: getData,\n
          totalRows: getTotalRows,\n
          totalColumns: getTotalColumns,\n
          columnWidth: 70,\n
          fixedColumnsLeft: 2,\n
          columnHeaders: [function (col, TH) {}]\n
        });\n
      wt.draw();\n
\n
      expect($(\'.ht_clone_corner thead tr th\').eq(0).css(\'border-left-width\')).toBe(\'1px\');\n
      expect($(\'.ht_clone_corner thead tr th\').eq(0).css(\'border-right-width\')).toBe(\'1px\');\n
      expect($(\'.ht_clone_corner thead tr th\').eq(1).css(\'border-left-width\')).toBe(\'0px\');\n
      expect($(\'.ht_clone_corner thead tr th\').eq(1).css(\'border-right-width\')).toBe(\'1px\');\n
    });\n
  });\n
\n
\n
  describe(\'isLastRowFullyVisible\', function () {\n
    it(\'should be false because it is only partially visible\', function () {\n
      createDataArray(8, 4);\n
\n
      $wrapper.width(185).height(175);\n
\n
      var wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns\n
      });\n
      wt.draw();\n
\n
      expect(wt.wtTable.isLastRowFullyVisible()).toEqual(false);\n
    });\n
\n
    it(\'should be true because it is fully visible\', function () {\n
      createDataArray(8, 4);\n
\n
      $wrapper.width(185).height(185);\n
\n
      var wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns\n
      });\n
      wt.draw();\n
      wt.scrollVertical(7);\n
      wt.draw();\n
\n
      expect(wt.wtTable.isLastRowFullyVisible()).toEqual(true);\n
    });\n
  });\n
\n
  xdescribe(\'isLastColumnFullyVisible\', function () {\n
    it(\'should be false because it is only partially visible\', function () {\n
      createDataArray(18, 4);\n
\n
      $wrapper.width(209).height(185);\n
\n
      var wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns\n
      });\n
      wt.draw();\n
\n
      expect(wt.wtTable.isLastColumnFullyVisible()).toEqual(false); //few pixels are obstacled by scrollbar\n
    });\n
\n
    it(\'should be true because it is fully visible\', function () {\n
      createDataArray(18, 4);\n
\n
      $wrapper.width(180).height(185);\n
\n
      var wt = new Walkontable({\n
        table: $table[0],\n
        data: getData,\n
        totalRows: getTotalRows,\n
        totalColumns: getTotalColumns\n
      });\n
      wt.draw();\n
      wt.scrollHorizontal(1);\n
\n
      expect(wt.wtTable.isLastColumnFullyVisible()).toEqual(true);\n
    });\n
  });\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>18088</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>table.spec.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
