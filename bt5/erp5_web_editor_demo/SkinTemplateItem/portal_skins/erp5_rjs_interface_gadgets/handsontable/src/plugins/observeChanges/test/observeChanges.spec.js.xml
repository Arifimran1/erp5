<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272672.77</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>observeChanges.spec.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

describe(\'HandsontableObserveChanges\', function () {\n
  var id = \'testContainer\';\n
\n
  beforeEach(function () {\n
    this.$container = $(\'<div id="\' + id + \'"></div>\').appendTo(\'body\');\n
  });\n
\n
  afterEach(function () {\n
    if (this.$container) {\n
      destroy();\n
      this.$container.remove();\n
    }\n
  });\n
\n
  function createHOT(data, observeChanges) {\n
    return handsontable({\n
      data: data,\n
      width: 200,\n
      height: 200,\n
      observeChanges: observeChanges\n
    });\n
  }\n
\n
  describe("refreshing table after changes have been detected", function () {\n
    describe("array data", function () {\n
      it(\'should render newly added row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.push(["A3", "B3"]);\n
\n
        var htCore = getHtCore();\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(3);\n
          expect(htCore.find(\'col\').length).toEqual(2);\n
        });\n
      });\n
\n
      it(\'should render newly added column\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data[0].push("C1");\n
        data[1].push("C2");\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(2);\n
          expect(htCore.find(\'col\').length).toEqual(3);\n
        });\n
      });\n
\n
      it(\'should render removed row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.splice(0, 1); //removes one row at index 0\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(1);\n
          expect(htCore.find(\'col\').length).toEqual(2);\n
        });\n
      });\n
\n
      it(\'should render removed column\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data[0].splice(0, 1); //removes one column at index 0 in first row\n
        data[1].splice(0, 1); //removes one column at index 0 in second row\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(2);\n
          expect(htCore.find(\'col\').length).toEqual(1);\n
        });\n
      });\n
\n
      it(\'should render cell change from string to string\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data[0][0] = \'new string\';\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'td:eq(0)\').html()).toEqual(\'new string\');\n
        });\n
      });\n
\n
      it(\'should render cell change in a new row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.push(["A3", "B3"]);\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1500);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr:eq(2) td:eq(0)\').html()).toEqual(\'A3\');\n
          afterRenderSpy.reset();\n
          data[2][0] = \'new string\';\n
        });\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1500);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr:eq(2) td:eq(0)\').html()).toEqual(\'new string\');\n
        });\n
      });\n
\n
      it(\'should not render cell change when turned off (`observeChanges: false`)\', function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        createHOT(data, false);\n
        var htCore = getHtCore();\n
\n
        data[0][0] = \'new string\';\n
\n
        waits(100); //Object.observe is async\n
\n
        runs(function () {\n
          expect(htCore.find(\'td:eq(0)\').html()).toEqual(\'A1\');\n
        });\n
      });\n
    });\n
    describe("object data", function () {\n
      it(\'should render newly added row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.push({prop0: "A3", prop1: "B3"});\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1500);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(3);\n
          expect(htCore.find(\'col\').length).toEqual(2);\n
        });\n
      });\n
\n
      it(\'should render removed row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.splice(0, 1); //removes one row at index 0\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr\').length).toEqual(1);\n
          expect(htCore.find(\'col\').length).toEqual(2);\n
        });\n
      });\n
\n
      it(\'should render cell change from string to string\', function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data[0][\'prop0\'] = \'new string\';\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'td:eq(0)\').html()).toEqual(\'new string\');\n
        });\n
      });\n
\n
      it(\'should render cell change in a new row\', function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data.push({prop0: "A3", prop1: "B3"});\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1500);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr:eq(2) td:eq(0)\').html()).toEqual(\'A3\');\n
          afterRenderSpy.reset();\n
          data[2][\'prop0\'] = \'new string\';\n
        });\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1500);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr:eq(2) td:eq(0)\').html()).toEqual(\'new string\');\n
        });\n
      });\n
\n
      it(\'should not render cell change when turned off (`observeChanges: false`)\', function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        createHOT(data, false);\n
        var htCore = getHtCore();\n
\n
        data[0][\'prop0\'] = \'new string\';\n
\n
        waits(100); //Object.observe is async\n
\n
        runs(function () {\n
          expect(htCore.find(\'td:eq(0)\').html()).toEqual(\'A1\');\n
        });\n
      });\n
    });\n
  });\n
\n
  describe("enabling/disabling plugin", function () {\n
    it("should be possible to enable plugin using updateSettings", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, false);\n
      var htCore = getHtCore();\n
\n
      data[0][0] = \'new string\';\n
\n
      waits(100); //Object.observe is async\n
\n
      runs(function () {\n
        expect(htCore.find(\'td:eq(0)\').html()).toEqual(\'A1\');\n
\n
        updateSettings({\n
          observeChanges: true\n
        });\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        data[1][0] = \'another new string\';\n
\n
        waitsFor(function () {\n
          return afterRenderSpy.callCount > 0;\n
        }, \'Table render\', 1000);\n
\n
        runs(function () {\n
          expect(htCore.find(\'tr:eq(1) td:eq(0)\').html()).toEqual(\'another new string\');\n
        });\n
\n
      });\n
    });\n
\n
    it("should be possible to disable plugin using updateSettings", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, true);\n
      var htCore = getHtCore();\n
\n
      var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
      hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
      data[0][0] = \'new string\';\n
\n
      waitsFor(function () {\n
        return afterRenderSpy.callCount > 0;\n
      }, \'Table render\', 1000);\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'A2\');\n
      });\n
\n
      runs(function () {\n
        updateSettings({\n
          observeChanges: false\n
        });\n
\n
        data[1][0] = \'another new string\';\n
      });\n
\n
      waits(100);\n
\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'A2\');\n
      });\n
\n
\n
      runs(function () {\n
        hot.render();\n
\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'another new string\');\n
      });\n
\n
    });\n
\n
    it("should be possible to pause observing changes without disabling the plugin", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, true);\n
      var htCore = getHtCore();\n
\n
      var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
      hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
      data[0][0] = \'new string\';\n
\n
      waitsFor(function () {\n
        return afterRenderSpy.callCount > 0;\n
      }, \'Table render\', 1000);\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'A2\');\n
      });\n
\n
      runs(function () {\n
        hot.pauseObservingChanges();\n
\n
        data[1][0] = \'another new string\';\n
      });\n
\n
      waits(100);\n
\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'A2\');\n
      });\n
\n
\n
      runs(function () {\n
        hot.render();\n
\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'another new string\');\n
      });\n
\n
    });\n
\n
    it("should be possible to resume observing changes after it was paused", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, true);\n
      var htCore = getHtCore();\n
\n
      var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
      hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
      hot.pauseObservingChanges();\n
\n
      data[0][0] = \'new string\';\n
\n
      waits(100);\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'A1\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'A2\');\n
      });\n
\n
      runs(function () {\n
        hot.resumeObservingChanges();\n
        data[1][0] = \'another new string\';\n
        afterRenderSpy.reset();\n
      });\n
\n
      waitsFor(function () {\n
        return afterRenderSpy.calls.length > 0;\n
      }, \'Table render\', 1000);\n
\n
\n
      runs(function () {\n
        expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').html()).toEqual(\'new string\');\n
        expect(htCore.find(\'tbody tr:eq(1) td:eq(0)\').html()).toEqual(\'another new string\');\n
      });\n
    });\n
  });\n
\n
  describe(\'observeChanges fires appropriate events when changes are detected\', function () {\n
    describe("array data", function () {\n
      it("should fire afterChangesObserved event after changes has been noticed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        data[0][0] = \'new string\';\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should fire afterCreateRow event after detecting that new row has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterCreateRowCallback = jasmine.createSpy(\'afterCreateRowCallback\');\n
        hot.addHook(\'afterCreateRow\', afterCreateRowCallback);\n
\n
        data.push([\'A2\', \'B2\']);\n
\n
        waitsFor(function () {\n
          return afterCreateRowCallback.calls.length > 0;\n
        }, \'afterCreateRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterCreateRowCallback.calls.length).toEqual(1);\n
          expect(afterCreateRowCallback).toHaveBeenCalledWith(2, undefined, undefined, undefined, undefined, undefined);\n
        });\n
      });\n
\n
      it("should fire afterRemoveRow event after detecting that row has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveRowCallback = jasmine.createSpy(\'afterRemoveRowCallback\');\n
        hot.addHook(\'afterRemoveRow\', afterRemoveRowCallback);\n
\n
        data.pop();\n
\n
        waitsFor(function () {\n
          return afterRemoveRowCallback.calls.length > 0;\n
        }, \'afterCreateRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveRowCallback.calls.length).toEqual(1);\n
          expect(afterRemoveRowCallback).toHaveBeenCalledWith(1, 1, undefined, undefined, undefined, undefined);\n
        });\n
      });\n
\n
      it("should fire afterRemoveRow event after detecting that multiple rows have been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveRowCallback = jasmine.createSpy(\'afterRemoveRowCallback\');\n
        hot.addHook(\'afterRemoveRow\', afterRemoveRowCallback);\n
\n
        data.splice(0, 2);\n
\n
        waitsFor(function () {\n
          return afterRemoveRowCallback.calls.length > 0;\n
        }, \'afterRemoveRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveRowCallback.calls.length).toEqual(2);\n
\n
          //The order of run hooks depends on whether objectObserve uses native Object.observe or a shim\n
          var args = [];\n
          args.push(afterRemoveRowCallback.calls[0].args);\n
          args.push(afterRemoveRowCallback.calls[1].args);\n
          expect(args).toContain([1, 1, undefined, undefined, undefined, undefined]);\n
          expect(args).toContain([0, 1, undefined, undefined, undefined, undefined]);\n
        });\n
      });\n
\n
      it("should fire afterCreateCol event after detecting that new col has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterCreateColCallback = jasmine.createSpy(\'afterCreateColCallback\');\n
        hot.addHook(\'afterCreateCol\', afterCreateColCallback);\n
\n
        data[0].push("C1");\n
        data[1].push("C2");\n
\n
        waitsFor(function () {\n
          return afterCreateColCallback.calls.length > 0;\n
        }, \'afterCreateCol event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterCreateColCallback.calls.length).toEqual(1);\n
          expect(afterCreateColCallback.calls[0].args).toEqual([2, undefined, undefined, undefined, undefined, undefined]);\n
        });\n
      });\n
\n
      it("should fire afterRemoveCol event after detecting that col has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveColCallback = jasmine.createSpy(\'afterRemoveColCallback\');\n
        hot.addHook(\'afterRemoveCol\', afterRemoveColCallback);\n
\n
        data[0].pop();\n
        data[1].pop();\n
\n
        waitsFor(function () {\n
          return afterRemoveColCallback.calls.length > 0;\n
        }, \'afterRemoveCol event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveColCallback.calls.length).toEqual(1);\n
          expect(afterRemoveColCallback.calls[0].args).toEqual([1, 1, undefined, undefined, undefined, undefined]);\n
        });\n
      });\n
\n
      it("should fire afterRemoveCol event after detecting that multiple cols have been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveColCallback = jasmine.createSpy(\'afterRemoveColCallback\');\n
        hot.addHook(\'afterRemoveCol\', afterRemoveColCallback);\n
\n
        data[0].pop();\n
        data[0].pop();\n
        data[1].pop();\n
        data[1].pop();\n
\n
        waitsFor(function () {\n
          return afterRemoveColCallback.calls.length > 0;\n
        }, \'afterRemoveCol event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveColCallback.calls.length).toEqual(2);\n
\n
          //The order of run hooks depends on whether objectObserve uses native Object.observe or a shim\n
          var args = [];\n
          args.push(afterRemoveColCallback.calls[0].args);\n
          args.push(afterRemoveColCallback.calls[1].args);\n
          expect(args).toContain([1, 1, undefined, undefined, undefined, undefined]);\n
          expect(args).toContain([0, 1, undefined, undefined, undefined, undefined]);\n
        });\n
      });\n
\n
      it("should fire afterChange event after detecting that table data has changed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterChangeCallback = jasmine.createSpy(\'afterChangeCallback\');\n
        hot.addHook(\'afterChange\', afterChangeCallback);\n
\n
        data[0][0] = "new string";\n
\n
        waitsFor(function () {\n
          return afterChangeCallback.calls.length > 0;\n
        }, \'afterChange event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterChangeCallback.calls.length).toEqual(1);\n
          expect(afterChangeCallback).toHaveBeenCalledWith([0, 0, null, "new string"], \'external\', undefined, undefined, undefined, undefined);\n
        });\n
      });\n
    });\n
    describe("object data", function () {\n
      it("should fire afterChangesObserved event after changes has been noticed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        data[0][\'prop0\'] = \'new string\';\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should fire afterCreateRow event after detecting that new row has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterCreateRowCallback = jasmine.createSpy(\'afterCreateRowCallback\');\n
        hot.addHook(\'afterCreateRow\', afterCreateRowCallback);\n
\n
        data.push({prop0: \'A2\', prop1: \'B2\'});\n
\n
        waitsFor(function () {\n
          return afterCreateRowCallback.calls.length > 0;\n
        }, \'afterCreateRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterCreateRowCallback.calls.length).toEqual(1);\n
          expect(afterCreateRowCallback).toHaveBeenCalledWith(2, undefined, undefined, undefined, undefined, undefined);\n
        });\n
      });\n
\n
      it("should fire afterRemoveRow event after detecting that row has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveRowCallback = jasmine.createSpy(\'afterRemoveRowCallback\');\n
        hot.addHook(\'afterRemoveRow\', afterRemoveRowCallback);\n
\n
        data.pop();\n
\n
        waitsFor(function () {\n
          return afterRemoveRowCallback.calls.length > 0;\n
        }, \'afterCreateRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveRowCallback.calls.length).toEqual(1);\n
          expect(afterRemoveRowCallback).toHaveBeenCalledWith(1, 1, undefined, undefined, undefined, undefined);\n
        });\n
      });\n
\n
      it("should fire afterRemoveRow event after detecting that multiple rows have been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRemoveRowCallback = jasmine.createSpy(\'afterRemoveRowCallback\');\n
        hot.addHook(\'afterRemoveRow\', afterRemoveRowCallback);\n
\n
        data.splice(0, 2);\n
\n
        waitsFor(function () {\n
          return afterRemoveRowCallback.calls.length > 0;\n
        }, \'afterRemoveRow event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterRemoveRowCallback.calls.length).toEqual(2);\n
\n
          //The order of run hooks depends on whether objectObserve uses native Object.observe or a shim\n
          var args = [];\n
          args.push(afterRemoveRowCallback.calls[0].args);\n
          args.push(afterRemoveRowCallback.calls[1].args);\n
          expect(args).toContain([1, 1, undefined, undefined, undefined, undefined]);\n
          expect(args).toContain([0, 1, undefined, undefined, undefined, undefined]);\n
        });\n
      });\n
\n
      it("should fire afterChange event after detecting that table data has changed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterChangeCallback = jasmine.createSpy(\'afterChangeCallback\');\n
        hot.addHook(\'afterChange\', afterChangeCallback);\n
\n
        data[0][\'prop0\'] = "new string";\n
\n
        waitsFor(function () {\n
          return afterChangeCallback.calls.length > 0;\n
        }, \'afterChange event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(afterChangeCallback.calls.length).toEqual(1);\n
          expect(afterChangeCallback).toHaveBeenCalledWith([0, \'prop0\', null, "new string"], \'external\', undefined, undefined, undefined, undefined);\n
        });\n
      });\n
    });\n
  });\n
\n
  describe("using HOT data manipulation methods, when observeChanges plugin is enabled", function () {\n
    describe("array data", function () {\n
      it("should run render ONCE after detecting that new row has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'insert_row\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
        runs(function () {\n
          expect(countRows()).toEqual(3);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that row has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'remove_row\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(countRows()).toEqual(1);\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that new column has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'insert_col\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
        runs(function () {\n
          expect(countCols()).toEqual(3);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that column has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'remove_col\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(countCols()).toEqual(1);\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that table data has changed", function () {\n
        var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
        var hot = createHOT(data, true);\n
        var htCore = getHtCore();\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        setDataAtCell(0, 0, \'new value\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(htCore.find(\'tbody tr:eq(0) td:eq(0)\').text()).toEqual(\'new value\');\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
    });\n
    describe("object data", function () {\n
      it("should run render ONCE after detecting that new row has been added", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'insert_row\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
        runs(function () {\n
          expect(countRows()).toEqual(3);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that row has been removed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        alter(\'remove_row\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(countRows()).toEqual(1);\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
\n
      it("should run render ONCE after detecting that table data has changed", function () {\n
        var data = Handsontable.helper.createSpreadsheetObjectData(2, 2);\n
        var hot = createHOT(data, true);\n
\n
        var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
        hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
        var afterChangesObservedCallback = jasmine.createSpy(\'afterChangesObservedCallback\');\n
        hot.addHook(\'afterChangesObserved\', afterChangesObservedCallback);\n
\n
        setDataAtRowProp(0, \'prop0\', \'new value\');\n
\n
        waitsFor(function () {\n
          return afterChangesObservedCallback.calls.length > 0;\n
        }, \'afterChangesObserved event fire\', 1000);\n
\n
\n
        runs(function () {\n
          expect(this.$container.find(\'tbody tr:eq(0) td:eq(0)\').text()).toEqual(\'new value\');\n
          expect(afterChangesObservedCallback.calls.length).toEqual(1);\n
          expect(afterRenderSpy.calls.length).toEqual(1);\n
        });\n
      });\n
    });\n
  });\n
\n
  describe("refreshing table after changes have been detected", function () {\n
    it("should observe changes to new data bound using loadData", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var newData = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, true);\n
      var htCore = getHtCore();\n
      hot.loadData(newData);\n
\n
      var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
      hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
      newData.push(["A3", "B3"]);\n
\n
      waitsFor(function () {\n
        return afterRenderSpy.callCount > 0;\n
      }, \'Table render\', 1000);\n
\n
      runs(function () {\n
        expect(afterRenderSpy.callCount).toBe(1);\n
        expect(htCore.find(\'tr\').length).toEqual(3);\n
        expect(htCore.find(\'col\').length).toEqual(2);\n
      });\n
    });\n
\n
    it("should not observe changes to old data after it was replaced using loadData", function () {\n
      var data = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var newData = Handsontable.helper.createSpreadsheetData(2, 2);\n
      var hot = createHOT(data, true);\n
      var htCore = getHtCore();\n
      hot.loadData(newData);\n
\n
      var afterRenderSpy = jasmine.createSpy(\'afterRenderSpy\');\n
      hot.addHook(\'afterRender\', afterRenderSpy);\n
\n
      data.push(["A3", "B3"]);\n
\n
      waits(1000);\n
\n
      runs(function () {\n
        expect(afterRenderSpy.callCount).toBe(0);\n
        expect(htCore.find(\'tr\').length).toEqual(2);\n
        expect(htCore.find(\'col\').length).toEqual(2);\n
      });\n
    });\n
  });\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>33098</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>observeChanges.spec.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
