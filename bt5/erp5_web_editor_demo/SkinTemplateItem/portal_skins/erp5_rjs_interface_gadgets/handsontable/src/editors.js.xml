<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41272720.88</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>editors.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string>/**\n
 * Utility to register editors and common namespace for keeping reference to all editor classes\n
 */\n
\n
import {toUpperCaseFirst} from \'./helpers/string\';\n
\n
export {registerEditor, getEditor, hasEditor, getEditorConstructor};\n
\n
var\n
  registeredEditorNames = {},\n
  registeredEditorClasses = new WeakMap();\n
\n
// support for older versions of Handsontable\n
Handsontable.editors = Handsontable.editors || {};\n
Handsontable.editors.registerEditor = registerEditor;\n
Handsontable.editors.getEditor = getEditor;\n
\n
function RegisteredEditor(editorClass) {\n
  var Clazz, instances;\n
\n
  instances = {};\n
  Clazz = editorClass;\n
\n
  this.getConstructor = function() {\n
    return editorClass;\n
  };\n
\n
  this.getInstance = function (hotInstance) {\n
    if (!(hotInstance.guid in instances)) {\n
      instances[hotInstance.guid] = new Clazz(hotInstance);\n
    }\n
\n
    return instances[hotInstance.guid];\n
  };\n
}\n
\n
/**\n
 * Registers editor under given name\n
 * @param {String} editorName\n
 * @param {Function} editorClass\n
 */\n
function registerEditor(editorName, editorClass) {\n
  var editor = new RegisteredEditor(editorClass);\n
\n
  if (typeof editorName === \'string\') {\n
    registeredEditorNames[editorName] = editor;\n
    Handsontable.editors[toUpperCaseFirst(editorName) + \'Editor\'] = editorClass;\n
  }\n
  registeredEditorClasses.set(editorClass, editor);\n
}\n
\n
/**\n
 * Returns instance (singleton) of editor class\n
 *\n
 * @param {String} editorName\n
 * @param {Object} hotInstance\n
 * @returns {Function} editorClass\n
 */\n
function getEditor(editorName, hotInstance) {\n
  var editor;\n
\n
  if (typeof editorName == \'function\') {\n
    if (!(registeredEditorClasses.get(editorName))) {\n
      registerEditor(null, editorName);\n
    }\n
    editor = registeredEditorClasses.get(editorName);\n
  }\n
  else if (typeof editorName == \'string\') {\n
    editor = registeredEditorNames[editorName];\n
  }\n
  else {\n
    throw Error(\'Only strings and functions can be passed as "editor" parameter \');\n
  }\n
\n
  if (!editor) {\n
    throw Error(\'No editor registered under name "\' + editorName + \'"\');\n
  }\n
\n
  return editor.getInstance(hotInstance);\n
}\n
\n
/**\n
 * Get editor constructor class\n
 *\n
 * @param {String} editorName\n
 * @returns {Function}\n
 */\n
function getEditorConstructor(editorName) {\n
  var editor;\n
\n
  if (typeof editorName == \'string\') {\n
    editor = registeredEditorNames[editorName];\n
  }\n
  else {\n
    throw Error(\'Only strings and functions can be passed as "editor" parameter \');\n
  }\n
\n
  if (!editor) {\n
    throw Error(\'No editor registered under name "\' + editorName + \'"\');\n
  }\n
\n
  return editor.getConstructor();\n
}\n
\n
/**\n
 * @param editorName\n
 * @returns {Boolean}\n
 */\n
function hasEditor(editorName) {\n
  return registeredEditorNames[editorName] ? true : false;\n
}\n
</string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>2689</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>editors.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
