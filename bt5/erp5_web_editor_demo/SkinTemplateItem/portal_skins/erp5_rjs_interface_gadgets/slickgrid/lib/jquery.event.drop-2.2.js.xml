<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41271254.19</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>jquery.event.drop-2.2.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/*! \n
 * jquery.event.drop - v 2.2\n
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n
 * Open Source MIT License - http://threedubmedia.com/code/license\n
 */\n
// Created: 2008-06-04 \n
// Updated: 2012-05-21\n
// REQUIRES: jquery 1.7.x, event.drag 2.2\n
\n
;(function($){ // secure $ jQuery alias\n
\n
// Events: drop, dropstart, dropend\n
\n
// add the jquery instance method\n
$.fn.drop = function( str, arg, opts ){\n
\t// figure out the event type\n
\tvar type = typeof str == "string" ? str : "",\n
\t// figure out the event handler...\n
\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n
\t// fix the event type\n
\tif ( type.indexOf("drop") !== 0 ) \n
\t\ttype = "drop"+ type;\n
\t// were options passed\n
\topts = ( str == fn ? arg : opts ) || {};\n
\t// trigger or bind event handler\n
\treturn fn ? this.bind( type, opts, fn ) : this.trigger( type );\n
};\n
\n
// DROP MANAGEMENT UTILITY\n
// returns filtered drop target elements, caches their positions\n
$.drop = function( opts ){ \n
\topts = opts || {};\n
\t// safely set new options...\n
\tdrop.multi = opts.multi === true ? Infinity : \n
\t\topts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;\n
\tdrop.delay = opts.delay || drop.delay;\n
\tdrop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance : \n
\t\topts.tolerance === null ? null : drop.tolerance;\n
\tdrop.mode = opts.mode || drop.mode || \'intersect\';\n
};\n
\n
// local refs (increase compression)\n
var $event = $.event, \n
$special = $event.special,\n
// configure the drop special event\n
drop = $.event.special.drop = {\n
\n
\t// these are the default settings\n
\tmulti: 1, // allow multiple drop winners per dragged element\n
\tdelay: 20, // async timeout delay\n
\tmode: \'overlap\', // drop tolerance mode\n
\t\t\n
\t// internal cache\n
\ttargets: [], \n
\t\n
\t// the key name for stored drop data\n
\tdatakey: "dropdata",\n
\t\t\n
\t// prevent bubbling for better performance\n
\tnoBubble: true,\n
\t\n
\t// count bound related events\n
\tadd: function( obj ){ \n
\t\t// read the interaction data\n
\t\tvar data = $.data( this, drop.datakey );\n
\t\t// count another realted event\n
\t\tdata.related += 1;\n
\t},\n
\t\n
\t// forget unbound related events\n
\tremove: function(){\n
\t\t$.data( this, drop.datakey ).related -= 1;\n
\t},\n
\t\n
\t// configure the interactions\n
\tsetup: function(){\n
\t\t// check for related events\n
\t\tif ( $.data( this, drop.datakey ) ) \n
\t\t\treturn;\n
\t\t// initialize the drop element data\n
\t\tvar data = { \n
\t\t\trelated: 0,\n
\t\t\tactive: [],\n
\t\t\tanyactive: 0,\n
\t\t\twinner: 0,\n
\t\t\tlocation: {}\n
\t\t};\n
\t\t// store the drop data on the element\n
\t\t$.data( this, drop.datakey, data );\n
\t\t// store the drop target in internal cache\n
\t\tdrop.targets.push( this );\n
\t},\n
\t\n
\t// destroy the configure interaction\t\n
\tteardown: function(){ \n
\t\tvar data = $.data( this, drop.datakey ) || {};\n
\t\t// check for related events\n
\t\tif ( data.related ) \n
\t\t\treturn;\n
\t\t// remove the stored data\n
\t\t$.removeData( this, drop.datakey );\n
\t\t// reference the targeted element\n
\t\tvar element = this;\n
\t\t// remove from the internal cache\n
\t\tdrop.targets = $.grep( drop.targets, function( target ){ \n
\t\t\treturn ( target !== element ); \n
\t\t});\n
\t},\n
\t\n
\t// shared event handler\n
\thandler: function( event, dd ){ \n
\t\t// local vars\n
\t\tvar results, $targets;\n
\t\t// make sure the right data is available\n
\t\tif ( !dd ) \n
\t\t\treturn;\n
\t\t// handle various events\n
\t\tswitch ( event.type ){\n
\t\t\t// draginit, from $.event.special.drag\n
\t\t\tcase \'mousedown\': // DROPINIT >>\n
\t\t\tcase \'touchstart\': // DROPINIT >>\n
\t\t\t\t// collect and assign the drop targets\n
\t\t\t\t$targets =  $( drop.targets );\n
\t\t\t\tif ( typeof dd.drop == "string" )\n
\t\t\t\t\t$targets = $targets.filter( dd.drop );\n
\t\t\t\t// reset drop data winner properties\n
\t\t\t\t$targets.each(function(){\n
\t\t\t\t\tvar data = $.data( this, drop.datakey );\n
\t\t\t\t\tdata.active = [];\n
\t\t\t\t\tdata.anyactive = 0;\n
\t\t\t\t\tdata.winner = 0;\n
\t\t\t\t});\n
\t\t\t\t// set available target elements\n
\t\t\t\tdd.droppable = $targets;\n
\t\t\t\t// activate drop targets for the initial element being dragged\n
\t\t\t\t$special.drag.hijack( event, "dropinit", dd ); \n
\t\t\t\tbreak;\n
\t\t\t// drag, from $.event.special.drag\n
\t\t\tcase \'mousemove\': // TOLERATE >>\n
\t\t\tcase \'touchmove\': // TOLERATE >>\n
\t\t\t\tdrop.event = event; // store the mousemove event\n
\t\t\t\tif ( !drop.timer )\n
\t\t\t\t\t// monitor drop targets\n
\t\t\t\t\tdrop.tolerate( dd ); \n
\t\t\t\tbreak;\n
\t\t\t// dragend, from $.event.special.drag\n
\t\t\tcase \'mouseup\': // DROP >> DROPEND >>\n
\t\t\tcase \'touchend\': // DROP >> DROPEND >>\n
\t\t\t\tdrop.timer = clearTimeout( drop.timer ); // delete timer\t\n
\t\t\t\tif ( dd.propagates ){\n
\t\t\t\t\t$special.drag.hijack( event, "drop", dd ); \n
\t\t\t\t\t$special.drag.hijack( event, "dropend", dd ); \n
\t\t\t\t}\n
\t\t\t\tbreak;\n
\t\t\t\t\n
\t\t}\n
\t},\n
\t\t\n
\t// returns the location positions of an element\n
\tlocate: function( elem, index ){ \n
\t\tvar data = $.data( elem, drop.datakey ),\n
\t\t$elem = $( elem ), \n
\t\tposi = $elem.offset() || {}, \n
\t\theight = $elem.outerHeight(), \n
\t\twidth = $elem.outerWidth(),\n
\t\tlocation = { \n
\t\t\telem: elem, \n
\t\t\twidth: width, \n
\t\t\theight: height,\n
\t\t\ttop: posi.top, \n
\t\t\tleft: posi.left, \n
\t\t\tright: posi.left + width, \n
\t\t\tbottom: posi.top + height\n
\t\t};\n
\t\t// drag elements might not have dropdata\n
\t\tif ( data ){\n
\t\t\tdata.location = location;\n
\t\t\tdata.index = index;\n
\t\t\tdata.elem = elem;\n
\t\t}\n
\t\treturn location;\n
\t},\n
\t\n
\t// test the location positions of an element against another OR an X,Y coord\n
\tcontains: function( target, test ){ // target { location } contains test [x,y] or { location }\n
\t\treturn ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right\n
\t\t\t&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom ); \n
\t},\n
\t\n
\t// stored tolerance modes\n
\tmodes: { // fn scope: "$.event.special.drop" object \n
\t\t// target with mouse wins, else target with most overlap wins\n
\t\t\'intersect\': function( event, proxy, target ){\n
\t\t\treturn this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor\n
\t\t\t\t1e9 : this.modes.overlap.apply( this, arguments ); // check overlap\n
\t\t},\n
\t\t// target with most overlap wins\t\n
\t\t\'overlap\': function( event, proxy, target ){\n
\t\t\t// calculate the area of overlap...\n
\t\t\treturn Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )\n
\t\t\t\t* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );\n
\t\t},\n
\t\t// proxy is completely contained within target bounds\t\n
\t\t\'fit\': function( event, proxy, target ){\n
\t\t\treturn this.contains( target, proxy ) ? 1 : 0;\n
\t\t},\n
\t\t// center of the proxy is contained within target bounds\t\n
\t\t\'middle\': function( event, proxy, target ){\n
\t\t\treturn this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;\n
\t\t}\n
\t},\t\n
\t\n
\t// sort drop target cache by by winner (dsc), then index (asc)\n
\tsort: function( a, b ){\n
\t\treturn ( b.winner - a.winner ) || ( a.index - b.index );\n
\t},\n
\t\t\n
\t// async, recursive tolerance execution\n
\ttolerate: function( dd ){\t\t\n
\t\t// declare local refs\n
\t\tvar i, drp, drg, data, arr, len, elem,\n
\t\t// interaction iteration variables\n
\t\tx = 0, ia, end = dd.interactions.length,\n
\t\t// determine the mouse coords\n
\t\txy = [ drop.event.pageX, drop.event.pageY ],\n
\t\t// custom or stored tolerance fn\n
\t\ttolerance = drop.tolerance || drop.modes[ drop.mode ];\n
\t\t// go through each passed interaction...\n
\t\tdo if ( ia = dd.interactions[x] ){\n
\t\t\t// check valid interaction\n
\t\t\tif ( !ia )\n
\t\t\t\treturn; \n
\t\t\t// initialize or clear the drop data\n
\t\t\tia.drop = [];\n
\t\t\t// holds the drop elements\n
\t\t\tarr = []; \n
\t\t\tlen = ia.droppable.length;\n
\t\t\t// determine the proxy location, if needed\n
\t\t\tif ( tolerance )\n
\t\t\t\tdrg = drop.locate( ia.proxy ); \n
\t\t\t// reset the loop\n
\t\t\ti = 0;\n
\t\t\t// loop each stored drop target\n
\t\t\tdo if ( elem = ia.droppable[i] ){ \n
\t\t\t\tdata = $.data( elem, drop.datakey );\n
\t\t\t\tdrp = data.location;\n
\t\t\t\tif ( !drp ) continue;\n
\t\t\t\t// find a winner: tolerance function is defined, call it\n
\t\t\t\tdata.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp ) \n
\t\t\t\t\t// mouse position is always the fallback\n
\t\t\t\t\t: drop.contains( drp, xy ) ? 1 : 0; \n
\t\t\t\tarr.push( data );\t\n
\t\t\t} while ( ++i < len ); // loop \n
\t\t\t// sort the drop targets\n
\t\t\tarr.sort( drop.sort );\t\t\t\n
\t\t\t// reset the loop\n
\t\t\ti = 0;\n
\t\t\t// loop through all of the targets again\n
\t\t\tdo if ( data = arr[ i ] ){\n
\t\t\t\t// winners...\n
\t\t\t\tif ( data.winner && ia.drop.length < drop.multi ){\n
\t\t\t\t\t// new winner... dropstart\n
\t\t\t\t\tif ( !data.active[x] && !data.anyactive ){\n
\t\t\t\t\t\t// check to make sure that this is not prevented\n
\t\t\t\t\t\tif ( $special.drag.hijack( drop.event, "dropstart", dd, x, data.elem )[0] !== false ){ \t\n
\t\t\t\t\t\t\tdata.active[x] = 1;\n
\t\t\t\t\t\t\tdata.anyactive += 1;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\t// if false, it is not a winner\n
\t\t\t\t\t\telse\n
\t\t\t\t\t\t\tdata.winner = 0;\n
\t\t\t\t\t}\n
\t\t\t\t\t// if it is still a winner\n
\t\t\t\t\tif ( data.winner )\n
\t\t\t\t\t\tia.drop.push( data.elem );\n
\t\t\t\t}\n
\t\t\t\t// losers... \n
\t\t\t\telse if ( data.active[x] && data.anyactive == 1 ){\n
\t\t\t\t\t// former winner... dropend\n
\t\t\t\t\t$special.drag.hijack( drop.event, "dropend", dd, x, data.elem ); \n
\t\t\t\t\tdata.active[x] = 0;\n
\t\t\t\t\tdata.anyactive -= 1;\n
\t\t\t\t}\n
\t\t\t} while ( ++i < len ); // loop \t\t\n
\t\t} while ( ++x < end ) // loop\n
\t\t// check if the mouse is still moving or is idle\n
\t\tif ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY ) \n
\t\t\tdelete drop.timer; // idle, don\'t recurse\n
\t\telse  // recurse\n
\t\t\tdrop.timer = setTimeout(function(){ \n
\t\t\t\tdrop.tolerate( dd ); \n
\t\t\t}, drop.delay );\n
\t\t// remember event, to compare idleness\n
\t\tdrop.last = drop.event; \n
\t}\n
\t\n
};\n
\n
// share the same special event configuration with related events...\n
$special.dropinit = $special.dropstart = $special.dropend = drop;\n
\n
})(jQuery); // confine scope\t

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>9420</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>jquery.event.drop-2.2.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
