<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268283.16</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Serializer.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Serializer.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to serialize down the DOM tree into a string using a Writer instance.\n
 *\n
 *\n
 * @example\n
 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse(\'<p>text</p>\'));\n
 * @class tinymce.html.Serializer\n
 * @version 3.4\n
 */\n
define("tinymce/html/Serializer", [\n
\t"tinymce/html/Writer",\n
\t"tinymce/html/Schema"\n
], function(Writer, Schema) {\n
\t/**\n
\t * Constructs a new Serializer instance.\n
\t *\n
\t * @constructor\n
\t * @method Serializer\n
\t * @param {Object} settings Name/value settings object.\n
\t * @param {tinymce.html.Schema} schema Schema instance to use.\n
\t */\n
\treturn function(settings, schema) {\n
\t\tvar self = this, writer = new Writer(settings);\n
\n
\t\tsettings = settings || {};\n
\t\tsettings.validate = "validate" in settings ? settings.validate : true;\n
\n
\t\tself.schema = schema = schema || new Schema();\n
\t\tself.writer = writer;\n
\n
\t\t/**\n
\t\t * Serializes the specified node into a string.\n
\t\t *\n
\t\t * @example\n
\t\t * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse(\'<p>text</p>\'));\n
\t\t * @method serialize\n
\t\t * @param {tinymce.html.Node} node Node instance to serialize.\n
\t\t * @return {String} String with HTML based on DOM tree.\n
\t\t */\n
\t\tself.serialize = function(node) {\n
\t\t\tvar handlers, validate;\n
\n
\t\t\tvalidate = settings.validate;\n
\n
\t\t\thandlers = {\n
\t\t\t\t// #text\n
\t\t\t\t3: function(node) {\n
\t\t\t\t\twriter.text(node.value, node.raw);\n
\t\t\t\t},\n
\n
\t\t\t\t// #comment\n
\t\t\t\t8: function(node) {\n
\t\t\t\t\twriter.comment(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Processing instruction\n
\t\t\t\t7: function(node) {\n
\t\t\t\t\twriter.pi(node.name, node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Doctype\n
\t\t\t\t10: function(node) {\n
\t\t\t\t\twriter.doctype(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// CDATA\n
\t\t\t\t4: function(node) {\n
\t\t\t\t\twriter.cdata(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Document fragment\n
\t\t\t\t11: function(node) {\n
\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\twalk(node);\n
\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\twriter.reset();\n
\n
\t\t\tfunction walk(node) {\n
\t\t\t\tvar handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;\n
\n
\t\t\t\tif (!handler) {\n
\t\t\t\t\tname = node.name;\n
\t\t\t\t\tisEmpty = node.shortEnded;\n
\t\t\t\t\tattrs = node.attributes;\n
\n
\t\t\t\t\t// Sort attributes\n
\t\t\t\t\tif (validate && attrs && attrs.length > 1) {\n
\t\t\t\t\t\tsortedAttrs = [];\n
\t\t\t\t\t\tsortedAttrs.map = {};\n
\n
\t\t\t\t\t\telementRule = schema.getElementRule(node.name);\n
\t\t\t\t\t\tfor (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n
\t\t\t\t\t\t\tattrName = elementRule.attributesOrder[i];\n
\n
\t\t\t\t\t\t\tif (attrName in attrs.map) {\n
\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\n
\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\n
\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tfor (i = 0, l = attrs.length; i < l; i++) {\n
\t\t\t\t\t\t\tattrName = attrs[i].name;\n
\n
\t\t\t\t\t\t\tif (!(attrName in sortedAttrs.map)) {\n
\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\n
\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\n
\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tattrs = sortedAttrs;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\twriter.start(node.name, attrs, isEmpty);\n
\n
\t\t\t\t\tif (!isEmpty) {\n
\t\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\t\twalk(node);\n
\t\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\twriter.end(name);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\thandler(node);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Serialize element and treat all non elements as fragments\n
\t\t\tif (node.type == 1 && !settings.inner) {\n
\t\t\t\twalk(node);\n
\t\t\t} else {\n
\t\t\t\thandlers[11](node);\n
\t\t\t}\n
\n
\t\t\treturn writer.getContent();\n
\t\t};\n
\t};\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>3688</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Serializer.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
