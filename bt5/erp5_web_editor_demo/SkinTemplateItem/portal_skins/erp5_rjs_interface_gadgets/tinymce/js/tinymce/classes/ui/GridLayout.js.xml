<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268321.62</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>GridLayout.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * GridLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout manager places controls in a grid.\n
 *\n
 * @setting {Number} spacing Spacing between controls.\n
 * @setting {Number} spacingH Horizontal spacing between controls.\n
 * @setting {Number} spacingV Vertical spacing between controls.\n
 * @setting {Number} columns Number of columns to use.\n
 * @setting {String/Array} alignH start|end|center|stretch or array of values for each column.\n
 * @setting {String/Array} alignV start|end|center|stretch or array of values for each column.\n
 * @setting {String} pack start|end\n
 *\n
 * @class tinymce.ui.GridLayout\n
 * @extends tinymce.ui.AbsoluteLayout\n
 */\n
define("tinymce/ui/GridLayout", [\n
\t"tinymce/ui/AbsoluteLayout"\n
], function(AbsoluteLayout) {\n
\t"use strict";\n
\n
\treturn AbsoluteLayout.extend({\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\tvar settings = container.settings, rows, cols, items, contLayoutRect, width, height, rect,\n
\t\t\t\tctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY,\n
\t\t\t\tcolWidths = [], rowHeights = [], ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;\n
\n
\t\t\t// Get layout settings\n
\t\t\tsettings = container.settings;\n
\t\t\titems = container.items().filter(\':visible\');\n
\t\t\tcontLayoutRect = container.layoutRect();\n
\t\t\tcols = settings.columns || Math.ceil(Math.sqrt(items.length));\n
\t\t\trows = Math.ceil(items.length / cols);\n
\t\t\tspacingH = settings.spacingH || settings.spacing || 0;\n
\t\t\tspacingV = settings.spacingV || settings.spacing || 0;\n
\t\t\talignH = settings.alignH || settings.align;\n
\t\t\talignV = settings.alignV || settings.align;\n
\t\t\tcontPaddingBox = container.paddingBox;\n
\t\t\treverseRows = \'reverseRows\' in settings ? settings.reverseRows : container.isRtl();\n
\n
\t\t\tif (alignH && typeof alignH == "string") {\n
\t\t\t\talignH = [alignH];\n
\t\t\t}\n
\n
\t\t\tif (alignV && typeof alignV == "string") {\n
\t\t\t\talignV = [alignV];\n
\t\t\t}\n
\n
\t\t\t// Zero padd columnWidths\n
\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\tcolWidths.push(0);\n
\t\t\t}\n
\n
\t\t\t// Zero padd rowHeights\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\trowHeights.push(0);\n
\t\t\t}\n
\n
\t\t\t// Calculate columnWidths and rowHeights\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\t\tctrl = items[y * cols + x];\n
\n
\t\t\t\t\t// Out of bounds\n
\t\t\t\t\tif (!ctrl) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\t\tctrlMinWidth = ctrlLayoutRect.minW;\n
\t\t\t\t\tctrlMinHeight = ctrlLayoutRect.minH;\n
\n
\t\t\t\t\tcolWidths[x] = ctrlMinWidth > colWidths[x] ? ctrlMinWidth : colWidths[x];\n
\t\t\t\t\trowHeights[y] = ctrlMinHeight > rowHeights[y] ? ctrlMinHeight : rowHeights[y];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Calculate maxX\n
\t\t\tavailableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;\n
\t\t\tfor (maxX = 0, x = 0; x < cols; x++) {\n
\t\t\t\tmaxX += colWidths[x] + (x > 0 ? spacingH : 0);\n
\t\t\t\tavailableWidth -= (x > 0 ? spacingH : 0) + colWidths[x];\n
\t\t\t}\n
\n
\t\t\t// Calculate maxY\n
\t\t\tavailableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;\n
\t\t\tfor (maxY = 0, y = 0; y < rows; y++) {\n
\t\t\t\tmaxY += rowHeights[y] + (y > 0 ? spacingV : 0);\n
\t\t\t\tavailableHeight -= (y > 0 ? spacingV : 0) + rowHeights[y];\n
\t\t\t}\n
\n
\t\t\tmaxX += contPaddingBox.left + contPaddingBox.right;\n
\t\t\tmaxY += contPaddingBox.top + contPaddingBox.bottom;\n
\n
\t\t\t// Calculate minW/minH\n
\t\t\trect = {};\n
\t\t\trect.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);\n
\t\t\trect.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);\n
\n
\t\t\trect.contentW = rect.minW - contLayoutRect.deltaW;\n
\t\t\trect.contentH = rect.minH - contLayoutRect.deltaH;\n
\t\t\trect.minW = Math.min(rect.minW, contLayoutRect.maxW);\n
\t\t\trect.minH = Math.min(rect.minH, contLayoutRect.maxH);\n
\t\t\trect.minW = Math.max(rect.minW, contLayoutRect.startMinWidth);\n
\t\t\trect.minH = Math.max(rect.minH, contLayoutRect.startMinHeight);\n
\n
\t\t\t// Resize container container if minSize was changed\n
\t\t\tif (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {\n
\t\t\t\trect.w = rect.minW;\n
\t\t\t\trect.h = rect.minH;\n
\n
\t\t\t\tcontainer.layoutRect(rect);\n
\t\t\t\tthis.recalc(container);\n
\n
\t\t\t\t// Forced recalc for example if items are hidden/shown\n
\t\t\t\tif (container._lastRect === null) {\n
\t\t\t\t\tvar parentCtrl = container.parent();\n
\t\t\t\t\tif (parentCtrl) {\n
\t\t\t\t\t\tparentCtrl._lastRect = null;\n
\t\t\t\t\t\tparentCtrl.recalc();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Update contentW/contentH so absEnd moves correctly\n
\t\t\tif (contLayoutRect.autoResize) {\n
\t\t\t\trect = container.layoutRect(rect);\n
\t\t\t\trect.contentW = rect.minW - contLayoutRect.deltaW;\n
\t\t\t\trect.contentH = rect.minH - contLayoutRect.deltaH;\n
\t\t\t}\n
\n
\t\t\tvar flexV;\n
\n
\t\t\tif (settings.packV == \'start\') {\n
\t\t\t\tflexV = 0;\n
\t\t\t} else {\n
\t\t\t\tflexV = availableHeight > 0 ? Math.floor(availableHeight / rows) : 0;\n
\t\t\t}\n
\n
\t\t\t// Calculate totalFlex\n
\t\t\tvar totalFlex = 0;\n
\t\t\tvar flexWidths = settings.flexWidths;\n
\t\t\tif (flexWidths) {\n
\t\t\t\tfor (x = 0; x < flexWidths.length; x++) {\n
\t\t\t\t\ttotalFlex += flexWidths[x];\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\ttotalFlex = cols;\n
\t\t\t}\n
\n
\t\t\t// Calculate new column widths based on flex values\n
\t\t\tvar ratio = availableWidth / totalFlex;\n
\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\tcolWidths[x] += flexWidths ? flexWidths[x] * ratio : ratio;\n
\t\t\t}\n
\n
\t\t\t// Move/resize controls\n
\t\t\tposY = contPaddingBox.top;\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\tposX = contPaddingBox.left;\n
\t\t\t\theight = rowHeights[y] + flexV;\n
\n
\t\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\t\tif (reverseRows) {\n
\t\t\t\t\t\tidx = y * cols + cols - 1 - x;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tidx = y * cols + x;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrl = items[idx];\n
\n
\t\t\t\t\t// No more controls to render then break\n
\t\t\t\t\tif (!ctrl) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Get control settings and calculate x, y\n
\t\t\t\t\tctrlSettings = ctrl.settings;\n
\t\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\t\twidth = Math.max(colWidths[x], ctrlLayoutRect.startMinWidth);\n
\t\t\t\t\tctrlLayoutRect.x = posX;\n
\t\t\t\t\tctrlLayoutRect.y = posY;\n
\n
\t\t\t\t\t// Align control horizontal\n
\t\t\t\t\talign = ctrlSettings.alignH || (alignH ? (alignH[x] || alignH[0]) : null);\n
\t\t\t\t\tif (align == "center") {\n
\t\t\t\t\t\tctrlLayoutRect.x = posX + (width / 2) - (ctrlLayoutRect.w / 2);\n
\t\t\t\t\t} else if (align == "right") {\n
\t\t\t\t\t\tctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;\n
\t\t\t\t\t} else if (align == "stretch") {\n
\t\t\t\t\t\tctrlLayoutRect.w = width;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Align control vertical\n
\t\t\t\t\talign = ctrlSettings.alignV || (alignV ? (alignV[x] || alignV[0]) : null);\n
\t\t\t\t\tif (align == "center") {\n
\t\t\t\t\t\tctrlLayoutRect.y = posY + (height / 2) - (ctrlLayoutRect.h / 2);\n
\t\t\t\t\t} else if (align == "bottom") {\n
\t\t\t\t\t\tctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;\n
\t\t\t\t\t} else if (align == "stretch") {\n
\t\t\t\t\t\tctrlLayoutRect.h = height;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrl.layoutRect(ctrlLayoutRect);\n
\n
\t\t\t\t\tposX += width + spacingH;\n
\n
\t\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\t\tctrl.recalc();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tposY += height + spacingV;\n
\t\t\t}\n
\t\t}\n
\t});\n
});

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>7126</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>GridLayout.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
