<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268380.12</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>RangeUtils.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * RangeUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains a few utility methods for ranges.\n
 *\n
 * @class tinymce.dom.RangeUtils\n
 */\n
define("tinymce/dom/RangeUtils", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/TreeWalker"\n
], function(Tools, TreeWalker) {\n
\tvar each = Tools.each;\n
\n
\tfunction getEndChild(container, index) {\n
\t\tvar childNodes = container.childNodes;\n
\n
\t\tindex--;\n
\n
\t\tif (index > childNodes.length - 1) {\n
\t\t\tindex = childNodes.length - 1;\n
\t\t} else if (index < 0) {\n
\t\t\tindex = 0;\n
\t\t}\n
\n
\t\treturn childNodes[index] || container;\n
\t}\n
\n
\tfunction RangeUtils(dom) {\n
\t\t/**\n
\t\t * Walks the specified range like object and executes the callback for each sibling collection it finds.\n
\t\t *\n
\t\t * @private\n
\t\t * @method walk\n
\t\t * @param {Object} rng Range like object.\n
\t\t * @param {function} callback Callback function to execute for each sibling collection.\n
\t\t */\n
\t\tthis.walk = function(rng, callback) {\n
\t\t\tvar startContainer = rng.startContainer,\n
\t\t\t\tstartOffset = rng.startOffset,\n
\t\t\t\tendContainer = rng.endContainer,\n
\t\t\t\tendOffset = rng.endOffset,\n
\t\t\t\tancestor, startPoint,\n
\t\t\t\tendPoint, node, parent, siblings, nodes;\n
\n
\t\t\t// Handle table cell selection the table plugin enables\n
\t\t\t// you to fake select table cells and perform formatting actions on them\n
\t\t\tnodes = dom.select(\'td.mce-item-selected,th.mce-item-selected\');\n
\t\t\tif (nodes.length > 0) {\n
\t\t\t\teach(nodes, function(node) {\n
\t\t\t\t\tcallback([node]);\n
\t\t\t\t});\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Excludes start/end text node if they are out side the range\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Array} nodes Nodes to exclude items from.\n
\t\t\t * @return {Array} Array with nodes excluding the start/end container if needed.\n
\t\t\t */\n
\t\t\tfunction exclude(nodes) {\n
\t\t\t\tvar node;\n
\n
\t\t\t\t// First node is excluded\n
\t\t\t\tnode = nodes[0];\n
\t\t\t\tif (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {\n
\t\t\t\t\tnodes.splice(0, 1);\n
\t\t\t\t}\n
\n
\t\t\t\t// Last node is excluded\n
\t\t\t\tnode = nodes[nodes.length - 1];\n
\t\t\t\tif (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {\n
\t\t\t\t\tnodes.splice(nodes.length - 1, 1);\n
\t\t\t\t}\n
\n
\t\t\t\treturn nodes;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Collects siblings\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Node} node Node to collect siblings from.\n
\t\t\t * @param {String} name Name of the sibling to check for.\n
\t\t\t * @return {Array} Array of collected siblings.\n
\t\t\t */\n
\t\t\tfunction collectSiblings(node, name, end_node) {\n
\t\t\t\tvar siblings = [];\n
\n
\t\t\t\tfor (; node && node != end_node; node = node[name]) {\n
\t\t\t\t\tsiblings.push(node);\n
\t\t\t\t}\n
\n
\t\t\t\treturn siblings;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Find an end point this is the node just before the common ancestor root.\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Node} node Node to start at.\n
\t\t\t * @param {Node} root Root/ancestor element to stop just before.\n
\t\t\t * @return {Node} Node just before the root element.\n
\t\t\t */\n
\t\t\tfunction findEndPoint(node, root) {\n
\t\t\t\tdo {\n
\t\t\t\t\tif (node.parentNode == root) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t} while (node);\n
\t\t\t}\n
\n
\t\t\tfunction walkBoundary(start_node, end_node, next) {\n
\t\t\t\tvar siblingName = next ? \'nextSibling\' : \'previousSibling\';\n
\n
\t\t\t\tfor (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {\n
\t\t\t\t\tparent = node.parentNode;\n
\t\t\t\t\tsiblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);\n
\n
\t\t\t\t\tif (siblings.length) {\n
\t\t\t\t\t\tif (!next) {\n
\t\t\t\t\t\t\tsiblings.reverse();\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tcallback(exclude(siblings));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// If index based start position then resolve it\n
\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {\n
\t\t\t\tstartContainer = startContainer.childNodes[startOffset];\n
\t\t\t}\n
\n
\t\t\t// If index based end position then resolve it\n
\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {\n
\t\t\t\tendContainer = getEndChild(endContainer, endOffset);\n
\t\t\t}\n
\n
\t\t\t// Same container\n
\t\t\tif (startContainer == endContainer) {\n
\t\t\t\treturn callback(exclude([startContainer]));\n
\t\t\t}\n
\n
\t\t\t// Find common ancestor and end points\n
\t\t\tancestor = dom.findCommonAncestor(startContainer, endContainer);\n
\n
\t\t\t// Process left side\n
\t\t\tfor (node = startContainer; node; node = node.parentNode) {\n
\t\t\t\tif (node === endContainer) {\n
\t\t\t\t\treturn walkBoundary(startContainer, ancestor, true);\n
\t\t\t\t}\n
\n
\t\t\t\tif (node === ancestor) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Process right side\n
\t\t\tfor (node = endContainer; node; node = node.parentNode) {\n
\t\t\t\tif (node === startContainer) {\n
\t\t\t\t\treturn walkBoundary(endContainer, ancestor);\n
\t\t\t\t}\n
\n
\t\t\t\tif (node === ancestor) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Find start/end point\n
\t\t\tstartPoint = findEndPoint(startContainer, ancestor) || startContainer;\n
\t\t\tendPoint = findEndPoint(endContainer, ancestor) || endContainer;\n
\n
\t\t\t// Walk left leaf\n
\t\t\twalkBoundary(startContainer, startPoint, true);\n
\n
\t\t\t// Walk the middle from start to end point\n
\t\t\tsiblings = collectSiblings(\n
\t\t\t\tstartPoint == startContainer ? startPoint : startPoint.nextSibling,\n
\t\t\t\t\'nextSibling\',\n
\t\t\t\tendPoint == endContainer ? endPoint.nextSibling : endPoint\n
\t\t\t);\n
\n
\t\t\tif (siblings.length) {\n
\t\t\t\tcallback(exclude(siblings));\n
\t\t\t}\n
\n
\t\t\t// Walk right leaf\n
\t\t\twalkBoundary(endContainer, endPoint);\n
\t\t};\n
\n
\t\t/**\n
\t\t * Splits the specified range at it\'s start/end points.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Range/RangeObject} rng Range to split.\n
\t\t * @return {Object} Range position object.\n
\t\t */\n
\t\tthis.split = function(rng) {\n
\t\t\tvar startContainer = rng.startContainer,\n
\t\t\t\tstartOffset = rng.startOffset,\n
\t\t\t\tendContainer = rng.endContainer,\n
\t\t\t\tendOffset = rng.endOffset;\n
\n
\t\t\tfunction splitText(node, offset) {\n
\t\t\t\treturn node.splitText(offset);\n
\t\t\t}\n
\n
\t\t\t// Handle single text node\n
\t\t\tif (startContainer == endContainer && startContainer.nodeType == 3) {\n
\t\t\t\tif (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n
\t\t\t\t\tendContainer = splitText(startContainer, startOffset);\n
\t\t\t\t\tstartContainer = endContainer.previousSibling;\n
\n
\t\t\t\t\tif (endOffset > startOffset) {\n
\t\t\t\t\t\tendOffset = endOffset - startOffset;\n
\t\t\t\t\t\tstartContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\n
\t\t\t\t\t\tendOffset = endContainer.nodeValue.length;\n
\t\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tendOffset = 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Split startContainer text node if needed\n
\t\t\t\tif (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n
\t\t\t\t\tstartContainer = splitText(startContainer, startOffset);\n
\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t}\n
\n
\t\t\t\t// Split endContainer text node if needed\n
\t\t\t\tif (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\n
\t\t\t\t\tendContainer = splitText(endContainer, endOffset).previousSibling;\n
\t\t\t\t\tendOffset = endContainer.nodeValue.length;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn {\n
\t\t\t\tstartContainer: startContainer,\n
\t\t\t\tstartOffset: startOffset,\n
\t\t\t\tendContainer: endContainer,\n
\t\t\t\tendOffset: endOffset\n
\t\t\t};\n
\t\t};\n
\n
\t\t/**\n
\t\t * Normalizes the specified range by finding the closest best suitable caret location.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Range} rng Range to normalize.\n
\t\t * @return {Boolean} True/false if the specified range was normalized or not.\n
\t\t */\n
\t\tthis.normalize = function(rng) {\n
\t\t\tvar normalized, collapsed;\n
\n
\t\t\tfunction normalizeEndPoint(start) {\n
\t\t\t\tvar container, offset, walker, body = dom.getRoot(), node, nonEmptyElementsMap;\n
\t\t\t\tvar directionLeft, isAfterNode;\n
\n
\t\t\t\tfunction hasBrBeforeAfter(node, left) {\n
\t\t\t\t\tvar walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);\n
\n
\t\t\t\t\twhile ((node = walker[left ? \'prev\' : \'next\']())) {\n
\t\t\t\t\t\tif (node.nodeName === "BR") {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction isPrevNode(node, name) {\n
\t\t\t\t\treturn node.previousSibling && node.previousSibling.nodeName == name;\n
\t\t\t\t}\n
\n
\t\t\t\t// Walks the dom left/right to find a suitable text node to move the endpoint into\n
\t\t\t\t// It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG\n
\t\t\t\tfunction findTextNodeRelative(left, startNode) {\n
\t\t\t\t\tvar walker, lastInlineElement, parentBlockContainer;\n
\n
\t\t\t\t\tstartNode = startNode || container;\n
\t\t\t\t\tparentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\n
\n
\t\t\t\t\t// Lean left before the BR element if it\'s the only BR within a block element. Gecko bug: #6680\n
\t\t\t\t\t// This: <p><br>|</p> becomes <p>|<br></p>\n
\t\t\t\t\tif (left && startNode.nodeName == \'BR\' && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n
\t\t\t\t\t\tcontainer = startNode.parentNode;\n
\t\t\t\t\t\toffset = dom.nodeIndex(startNode);\n
\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Walk left until we hit a text node we can move to or a block/br/img\n
\t\t\t\t\twalker = new TreeWalker(startNode, parentBlockContainer);\n
\t\t\t\t\twhile ((node = walker[left ? \'prev\' : \'next\']())) {\n
\t\t\t\t\t\t// Break if we hit a non content editable node\n
\t\t\t\t\t\tif (dom.getContentEditableParent(node) === "false") {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Found text node that has a length\n
\t\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length > 0) {\n
\t\t\t\t\t\t\tcontainer = node;\n
\t\t\t\t\t\t\toffset = left ? node.nodeValue.length : 0;\n
\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Break if we find a block or a BR/IMG/INPUT etc\n
\t\t\t\t\t\tif (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tlastInlineElement = node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Only fetch the last inline element when in caret mode for now\n
\t\t\t\t\tif (collapsed && lastInlineElement) {\n
\t\t\t\t\t\tcontainer = lastInlineElement;\n
\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\toffset = 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tcontainer = rng[(start ? \'start\' : \'end\') + \'Container\'];\n
\t\t\t\toffset = rng[(start ? \'start\' : \'end\') + \'Offset\'];\n
\t\t\t\tisAfterNode = container.nodeType == 1 && offset === container.childNodes.length;\n
\t\t\t\tnonEmptyElementsMap = dom.schema.getNonEmptyElements();\n
\t\t\t\tdirectionLeft = start;\n
\n
\t\t\t\tif (container.nodeType == 1 && offset > container.childNodes.length - 1) {\n
\t\t\t\t\tdirectionLeft = false;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the container is a document move it to the body element\n
\t\t\t\tif (container.nodeType === 9) {\n
\t\t\t\t\tcontainer = dom.getRoot();\n
\t\t\t\t\toffset = 0;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the container is body try move it into the closest text node or position\n
\t\t\t\tif (container === body) {\n
\t\t\t\t\t// If start is before/after a image, table etc\n
\t\t\t\t\tif (directionLeft) {\n
\t\t\t\t\t\tnode = container.childNodes[offset > 0 ? offset - 1 : 0];\n
\t\t\t\t\t\tif (node) {\n
\t\t\t\t\t\t\tif (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Resolve the index\n
\t\t\t\t\tif (container.hasChildNodes()) {\n
\t\t\t\t\t\toffset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n
\t\t\t\t\t\tcontainer = container.childNodes[offset];\n
\t\t\t\t\t\toffset = 0;\n
\n
\t\t\t\t\t\t// Don\'t walk into elements that doesn\'t have any child nodes like a IMG\n
\t\t\t\t\t\tif (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {\n
\t\t\t\t\t\t\t// Walk the DOM to find a text node to place the caret at or a BR\n
\t\t\t\t\t\t\tnode = container;\n
\t\t\t\t\t\t\twalker = new TreeWalker(container, body);\n
\n
\t\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\t\t// Found a text node use that position\n
\t\t\t\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length > 0) {\n
\t\t\t\t\t\t\t\t\toffset = directionLeft ? 0 : node.nodeValue.length;\n
\t\t\t\t\t\t\t\t\tcontainer = node;\n
\t\t\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t// Found a BR/IMG element that we can place the caret before\n
\t\t\t\t\t\t\t\tif (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\t\t\t\toffset = dom.nodeIndex(node);\n
\t\t\t\t\t\t\t\t\tcontainer = node.parentNode;\n
\n
\t\t\t\t\t\t\t\t\t// Put caret after image when moving the end point\n
\t\t\t\t\t\t\t\t\tif (node.nodeName == "IMG" && !directionLeft) {\n
\t\t\t\t\t\t\t\t\t\toffset++;\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t} while ((node = (directionLeft ? walker.next() : walker.prev())));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Lean the caret to the left if possible\n
\t\t\t\tif (collapsed) {\n
\t\t\t\t\t// So this: <b>x</b><i>|x</i>\n
\t\t\t\t\t// Becomes: <b>x|</b><i>x</i>\n
\t\t\t\t\t// Seems that only gecko has issues with this\n
\t\t\t\t\tif (container.nodeType === 3 && offset === 0) {\n
\t\t\t\t\t\tfindTextNodeRelative(true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Lean left into empty inline elements when the caret is before a BR\n
\t\t\t\t\t// So this: <i><b></b><i>|<br></i>\n
\t\t\t\t\t// Becomes: <i><b>|</b><i><br></i>\n
\t\t\t\t\t// Seems that only gecko has issues with this.\n
\t\t\t\t\t// Special edge case for <p><a>x</a>|<br></p> since we don\'t want <p><a>x|</a><br></p>\n
\t\t\t\t\tif (container.nodeType === 1) {\n
\t\t\t\t\t\tnode = container.childNodes[offset];\n
\n
\t\t\t\t\t\t// Offset is after the containers last child\n
\t\t\t\t\t\t// then use the previous child for normalization\n
\t\t\t\t\t\tif (!node) {\n
\t\t\t\t\t\t\tnode = container.childNodes[offset - 1];\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (node && node.nodeName === \'BR\' && !isPrevNode(node, \'A\') &&\n
\t\t\t\t\t\t\t!hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {\n
\t\t\t\t\t\t\tfindTextNodeRelative(true, node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Lean the start of the selection right if possible\n
\t\t\t\t// So this: x[<b>x]</b>\n
\t\t\t\t// Becomes: x<b>[x]</b>\n
\t\t\t\tif (directionLeft && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {\n
\t\t\t\t\tfindTextNodeRelative(false);\n
\t\t\t\t}\n
\n
\t\t\t\t// Set endpoint if it was normalized\n
\t\t\t\tif (normalized) {\n
\t\t\t\t\trng[\'set\' + (start ? \'Start\' : \'End\')](container, offset);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tcollapsed = rng.collapsed;\n
\n
\t\t\tnormalizeEndPoint(true);\n
\n
\t\t\tif (!collapsed) {\n
\t\t\t\tnormalizeEndPoint();\n
\t\t\t}\n
\n
\t\t\t// If it was collapsed then make sure it still is\n
\t\t\tif (normalized && collapsed) {\n
\t\t\t\trng.collapse(true);\n
\t\t\t}\n
\n
\t\t\treturn normalized;\n
\t\t};\n
\t}\n
\n
\t/**\n
\t * Compares two ranges and checks if they are equal.\n
\t *\n
\t * @static\n
\t * @method compareRanges\n
\t * @param {DOMRange} rng1 First range to compare.\n
\t * @param {DOMRange} rng2 First range to compare.\n
\t * @return {Boolean} true/false if the ranges are equal.\n
\t */\n
\tRangeUtils.compareRanges = function(rng1, rng2) {\n
\t\tif (rng1 && rng2) {\n
\t\t\t// Compare native IE ranges\n
\t\t\tif (rng1.item || rng1.duplicate) {\n
\t\t\t\t// Both are control ranges and the selected element matches\n
\t\t\t\tif (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Both are text ranges and the range matches\n
\t\t\t\tif (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Compare w3c ranges\n
\t\t\t\treturn rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn false;\n
\t};\n
\n
\t/**\n
\t * Gets the caret range for the given x/y location.\n
\t *\n
\t * @static\n
\t * @method getCaretRangeFromPoint\n
\t * @param {Number} x X coordinate for range\n
\t * @param {Number} y Y coordinate for range\n
\t * @param {Document} doc Document that x/y are relative to\n
\t * @returns {Range} caret range\n
\t */\n
\tRangeUtils.getCaretRangeFromPoint = function(x, y, doc) {\n
\t\tvar rng, point;\n
\n
\t\tif (doc.caretPositionFromPoint) {\n
\t\t\tpoint = doc.caretPositionFromPoint(x, y);\n
\t\t\trng = doc.createRange();\n
\t\t\trng.setStart(point.offsetNode, point.offset);\n
\t\t\trng.collapse(true);\n
\t\t} else if (doc.caretRangeFromPoint) {\n
\t\t\trng = doc.caretRangeFromPoint(x, y);\n
\t\t} else if (doc.body.createTextRange) {\n
\t\t\trng = doc.body.createTextRange();\n
\n
\t\t\ttry {\n
\t\t\t\trng.moveToPoint(x, y);\n
\t\t\t\trng.collapse(true);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Append to top or bottom depending on drop location\n
\t\t\t\trng.collapse(y < doc.body.clientHeight);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn rng;\n
\t};\n
\n
\tRangeUtils.getNode = function(container, offset) {\n
\t\tif (container.nodeType == 1 && container.hasChildNodes()) {\n
\t\t\tif (offset >= container.childNodes.length) {\n
\t\t\t\toffset = container.childNodes.length - 1;\n
\t\t\t}\n
\n
\t\t\tcontainer = container.childNodes[offset];\n
\t\t}\n
\n
\t\treturn container;\n
\t};\n
\n
\treturn RangeUtils;\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>15781</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>RangeUtils.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
