<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268634.23</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>tinymce.jquery.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>1013526</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>tinymce.jquery.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// 4.2.4 (2015-08-17)\n
\n
/**\n
 * Compiled inline version. (Library mode)\n
 */\n
\n
/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */\n
/*globals $code */\n
\n
(function(exports, undefined) {\n
\t"use strict";\n
\n
\tvar modules = {};\n
\n
\tfunction require(ids, callback) {\n
\t\tvar module, defs = [];\n
\n
\t\tfor (var i = 0; i < ids.length; ++i) {\n
\t\t\tmodule = modules[ids[i]] || resolve(ids[i]);\n
\t\t\tif (!module) {\n
\t\t\t\tthrow \'module definition dependecy not found: \' + ids[i];\n
\t\t\t}\n
\n
\t\t\tdefs.push(module);\n
\t\t}\n
\n
\t\tcallback.apply(null, defs);\n
\t}\n
\n
\tfunction define(id, dependencies, definition) {\n
\t\tif (typeof id !== \'string\') {\n
\t\t\tthrow \'invalid module definition, module id must be defined and be a string\';\n
\t\t}\n
\n
\t\tif (dependencies === undefined) {\n
\t\t\tthrow \'invalid module definition, dependencies must be specified\';\n
\t\t}\n
\n
\t\tif (definition === undefined) {\n
\t\t\tthrow \'invalid module definition, definition function must be specified\';\n
\t\t}\n
\n
\t\trequire(dependencies, function() {\n
\t\t\tmodules[id] = definition.apply(null, arguments);\n
\t\t});\n
\t}\n
\n
\tfunction defined(id) {\n
\t\treturn !!modules[id];\n
\t}\n
\n
\tfunction resolve(id) {\n
\t\tvar target = exports;\n
\t\tvar fragments = id.split(/[.\\/]/);\n
\n
\t\tfor (var fi = 0; fi < fragments.length; ++fi) {\n
\t\t\tif (!target[fragments[fi]]) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\ttarget = target[fragments[fi]];\n
\t\t}\n
\n
\t\treturn target;\n
\t}\n
\n
\tfunction expose(ids) {\n
\t\tfor (var i = 0; i < ids.length; i++) {\n
\t\t\tvar target = exports;\n
\t\t\tvar id = ids[i];\n
\t\t\tvar fragments = id.split(/[.\\/]/);\n
\n
\t\t\tfor (var fi = 0; fi < fragments.length - 1; ++fi) {\n
\t\t\t\tif (target[fragments[fi]] === undefined) {\n
\t\t\t\t\ttarget[fragments[fi]] = {};\n
\t\t\t\t}\n
\n
\t\t\t\ttarget = target[fragments[fi]];\n
\t\t\t}\n
\n
\t\t\ttarget[fragments[fragments.length - 1]] = modules[id];\n
\t\t}\n
\t}\n
\n
// Included from: js/tinymce/classes/dom/EventUtils.js\n
\n
/**\n
 * EventUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*jshint loopfunc:true*/\n
/*eslint no-loop-func:0 */\n
\n
/**\n
 * This class wraps the browsers native event logic with more convenient methods.\n
 *\n
 * @class tinymce.dom.EventUtils\n
 */\n
define("tinymce/dom/EventUtils", [], function() {\n
\t"use strict";\n
\n
\tvar eventExpandoPrefix = "mce-data-";\n
\tvar mouseEventRe = /^(?:mouse|contextmenu)|click/;\n
\tvar deprecated = {keyLocation: 1, layerX: 1, layerY: 1, returnValue: 1, webkitMovementX: 1, webkitMovementY: 1};\n
\n
\t/**\n
\t * Binds a native event to a callback on the speified target.\n
\t */\n
\tfunction addEvent(target, name, callback, capture) {\n
\t\tif (target.addEventListener) {\n
\t\t\ttarget.addEventListener(name, callback, capture || false);\n
\t\t} else if (target.attachEvent) {\n
\t\t\ttarget.attachEvent(\'on\' + name, callback);\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Unbinds a native event callback on the specified target.\n
\t */\n
\tfunction removeEvent(target, name, callback, capture) {\n
\t\tif (target.removeEventListener) {\n
\t\t\ttarget.removeEventListener(name, callback, capture || false);\n
\t\t} else if (target.detachEvent) {\n
\t\t\ttarget.detachEvent(\'on\' + name, callback);\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Normalizes a native event object or just adds the event specific methods on a custom event.\n
\t */\n
\tfunction fix(originalEvent, data) {\n
\t\tvar name, event = data || {}, undef;\n
\n
\t\t// Dummy function that gets replaced on the delegation state functions\n
\t\tfunction returnFalse() {\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\t// Dummy function that gets replaced on the delegation state functions\n
\t\tfunction returnTrue() {\n
\t\t\treturn true;\n
\t\t}\n
\n
\t\t// Copy all properties from the original event\n
\t\tfor (name in originalEvent) {\n
\t\t\t// layerX/layerY is deprecated in Chrome and produces a warning\n
\t\t\tif (!deprecated[name]) {\n
\t\t\t\tevent[name] = originalEvent[name];\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Normalize target IE uses srcElement\n
\t\tif (!event.target) {\n
\t\t\tevent.target = event.srcElement || document;\n
\t\t}\n
\n
\t\t// Calculate pageX/Y if missing and clientX/Y available\n
\t\tif (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === undef && originalEvent.clientX !== undef) {\n
\t\t\tvar eventDoc = event.target.ownerDocument || document;\n
\t\t\tvar doc = eventDoc.documentElement;\n
\t\t\tvar body = eventDoc.body;\n
\n
\t\t\tevent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -\n
\t\t\t\t(doc && doc.clientLeft || body && body.clientLeft || 0);\n
\n
\t\t\tevent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -\n
\t\t\t\t(doc && doc.clientTop || body && body.clientTop || 0);\n
\t\t}\n
\n
\t\t// Add preventDefault method\n
\t\tevent.preventDefault = function() {\n
\t\t\tevent.isDefaultPrevented = returnTrue;\n
\n
\t\t\t// Execute preventDefault on the original event object\n
\t\t\tif (originalEvent) {\n
\t\t\t\tif (originalEvent.preventDefault) {\n
\t\t\t\t\toriginalEvent.preventDefault();\n
\t\t\t\t} else {\n
\t\t\t\t\toriginalEvent.returnValue = false; // IE\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\n
\t\t// Add stopPropagation\n
\t\tevent.stopPropagation = function() {\n
\t\t\tevent.isPropagationStopped = returnTrue;\n
\n
\t\t\t// Execute stopPropagation on the original event object\n
\t\t\tif (originalEvent) {\n
\t\t\t\tif (originalEvent.stopPropagation) {\n
\t\t\t\t\toriginalEvent.stopPropagation();\n
\t\t\t\t} else {\n
\t\t\t\t\toriginalEvent.cancelBubble = true; // IE\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\n
\t\t// Add stopImmediatePropagation\n
\t\tevent.stopImmediatePropagation = function() {\n
\t\t\tevent.isImmediatePropagationStopped = returnTrue;\n
\t\t\tevent.stopPropagation();\n
\t\t};\n
\n
\t\t// Add event delegation states\n
\t\tif (!event.isDefaultPrevented) {\n
\t\t\tevent.isDefaultPrevented = returnFalse;\n
\t\t\tevent.isPropagationStopped = returnFalse;\n
\t\t\tevent.isImmediatePropagationStopped = returnFalse;\n
\t\t}\n
\n
\t\t// Add missing metaKey for IE 8\n
\t\tif (typeof event.metaKey == \'undefined\') {\n
\t\t\tevent.metaKey = false;\n
\t\t}\n
\n
\t\treturn event;\n
\t}\n
\n
\t/**\n
\t * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.\n
\t * It will also set/check the domLoaded state of the event_utils instance so ready isn\'t called multiple times.\n
\t */\n
\tfunction bindOnReady(win, callback, eventUtils) {\n
\t\tvar doc = win.document, event = {type: \'ready\'};\n
\n
\t\tif (eventUtils.domLoaded) {\n
\t\t\tcallback(event);\n
\t\t\treturn;\n
\t\t}\n
\n
\t\t// Gets called when the DOM is ready\n
\t\tfunction readyHandler() {\n
\t\t\tif (!eventUtils.domLoaded) {\n
\t\t\t\teventUtils.domLoaded = true;\n
\t\t\t\tcallback(event);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction waitForDomLoaded() {\n
\t\t\t// Check complete or interactive state if there is a body\n
\t\t\t// element on some iframes IE 8 will produce a null body\n
\t\t\tif (doc.readyState === "complete" || (doc.readyState === "interactive" && doc.body)) {\n
\t\t\t\tremoveEvent(doc, "readystatechange", waitForDomLoaded);\n
\t\t\t\treadyHandler();\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction tryScroll() {\n
\t\t\ttry {\n
\t\t\t\t// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.\n
\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n
\t\t\t\tdoc.documentElement.doScroll("left");\n
\t\t\t} catch (ex) {\n
\t\t\t\tsetTimeout(tryScroll, 0);\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\treadyHandler();\n
\t\t}\n
\n
\t\t// Use W3C method\n
\t\tif (doc.addEventListener) {\n
\t\t\tif (doc.readyState === "complete") {\n
\t\t\t\treadyHandler();\n
\t\t\t} else {\n
\t\t\t\taddEvent(win, \'DOMContentLoaded\', readyHandler);\n
\t\t\t}\n
\t\t} else {\n
\t\t\t// Use IE method\n
\t\t\taddEvent(doc, "readystatechange", waitForDomLoaded);\n
\n
\t\t\t// Wait until we can scroll, when we can the DOM is initialized\n
\t\t\tif (doc.documentElement.doScroll && win.self === win.top) {\n
\t\t\t\ttryScroll();\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Fallback if any of the above methods should fail for some odd reason\n
\t\taddEvent(win, \'load\', readyHandler);\n
\t}\n
\n
\t/**\n
\t * This class enables you to bind/unbind native events to elements and normalize it\'s behavior across browsers.\n
\t */\n
\tfunction EventUtils() {\n
\t\tvar self = this, events = {}, count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;\n
\n
\t\texpando = eventExpandoPrefix + (+new Date()).toString(32);\n
\t\thasMouseEnterLeave = "onmouseenter" in document.documentElement;\n
\t\thasFocusIn = "onfocusin" in document.documentElement;\n
\t\tmouseEnterLeave = {mouseenter: \'mouseover\', mouseleave: \'mouseout\'};\n
\t\tcount = 1;\n
\n
\t\t// State if the DOMContentLoaded was executed or not\n
\t\tself.domLoaded = false;\n
\t\tself.events = events;\n
\n
\t\t/**\n
\t\t * Executes all event handler callbacks for a specific event.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Event} evt Event object.\n
\t\t * @param {String} id Expando id value to look for.\n
\t\t */\n
\t\tfunction executeHandlers(evt, id) {\n
\t\t\tvar callbackList, i, l, callback, container = events[id];\n
\n
\t\t\tcallbackList = container && container[evt.type];\n
\t\t\tif (callbackList) {\n
\t\t\t\tfor (i = 0, l = callbackList.length; i < l; i++) {\n
\t\t\t\t\tcallback = callbackList[i];\n
\n
\t\t\t\t\t// Check if callback exists might be removed if a unbind is called inside the callback\n
\t\t\t\t\tif (callback && callback.func.call(callback.scope, evt) === false) {\n
\t\t\t\t\t\tevt.preventDefault();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Should we stop propagation to immediate listeners\n
\t\t\t\t\tif (evt.isImmediatePropagationStopped()) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Binds a callback to an event on the specified target.\n
\t\t *\n
\t\t * @method bind\n
\t\t * @param {Object} target Target node/window or custom object.\n
\t\t * @param {String} names Name of the event to bind.\n
\t\t * @param {function} callback Callback function to execute when the event occurs.\n
\t\t * @param {Object} scope Scope to call the callback function on, defaults to target.\n
\t\t * @return {function} Callback function that got bound.\n
\t\t */\n
\t\tself.bind = function(target, names, callback, scope) {\n
\t\t\tvar id, callbackList, i, name, fakeName, nativeHandler, capture, win = window;\n
\n
\t\t\t// Native event handler function patches the event and executes the callbacks for the expando\n
\t\t\tfunction defaultNativeHandler(evt) {\n
\t\t\t\texecuteHandlers(fix(evt || win.event), id);\n
\t\t\t}\n
\n
\t\t\t// Don\'t bind to text nodes or comments\n
\t\t\tif (!target || target.nodeType === 3 || target.nodeType === 8) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Create or get events id for the target\n
\t\t\tif (!target[expando]) {\n
\t\t\t\tid = count++;\n
\t\t\t\ttarget[expando] = id;\n
\t\t\t\tevents[id] = {};\n
\t\t\t} else {\n
\t\t\t\tid = target[expando];\n
\t\t\t}\n
\n
\t\t\t// Setup the specified scope or use the target as a default\n
\t\t\tscope = scope || target;\n
\n
\t\t\t// Split names and bind each event, enables you to bind multiple events with one call\n
\t\t\tnames = names.split(\' \');\n
\t\t\ti = names.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tname = names[i];\n
\t\t\t\tnativeHandler = defaultNativeHandler;\n
\t\t\t\tfakeName = capture = false;\n
\n
\t\t\t\t// Use ready instead of DOMContentLoaded\n
\t\t\t\tif (name === "DOMContentLoaded") {\n
\t\t\t\t\tname = "ready";\n
\t\t\t\t}\n
\n
\t\t\t\t// DOM is already ready\n
\t\t\t\tif (self.domLoaded && name === "ready" && target.readyState == \'complete\') {\n
\t\t\t\t\tcallback.call(scope, fix({type: name}));\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// Handle mouseenter/mouseleaver\n
\t\t\t\tif (!hasMouseEnterLeave) {\n
\t\t\t\t\tfakeName = mouseEnterLeave[name];\n
\n
\t\t\t\t\tif (fakeName) {\n
\t\t\t\t\t\tnativeHandler = function(evt) {\n
\t\t\t\t\t\t\tvar current, related;\n
\n
\t\t\t\t\t\t\tcurrent = evt.currentTarget;\n
\t\t\t\t\t\t\trelated = evt.relatedTarget;\n
\n
\t\t\t\t\t\t\t// Check if related is inside the current target if it\'s not then the event should\n
\t\t\t\t\t\t\t// be ignored since it\'s a mouseover/mouseout inside the element\n
\t\t\t\t\t\t\tif (related && current.contains) {\n
\t\t\t\t\t\t\t\t// Use contains for performance\n
\t\t\t\t\t\t\t\trelated = current.contains(related);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\twhile (related && related !== current) {\n
\t\t\t\t\t\t\t\t\trelated = related.parentNode;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Fire fake event\n
\t\t\t\t\t\t\tif (!related) {\n
\t\t\t\t\t\t\t\tevt = fix(evt || win.event);\n
\t\t\t\t\t\t\t\tevt.type = evt.type === \'mouseout\' ? \'mouseleave\' : \'mouseenter\';\n
\t\t\t\t\t\t\t\tevt.target = current;\n
\t\t\t\t\t\t\t\texecuteHandlers(evt, id);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t};\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Fake bubbeling of focusin/focusout\n
\t\t\t\tif (!hasFocusIn && (name === "focusin" || name === "focusout")) {\n
\t\t\t\t\tcapture = true;\n
\t\t\t\t\tfakeName = name === "focusin" ? "focus" : "blur";\n
\t\t\t\t\tnativeHandler = function(evt) {\n
\t\t\t\t\t\tevt = fix(evt || win.event);\n
\t\t\t\t\t\tevt.type = evt.type === \'focus\' ? \'focusin\' : \'focusout\';\n
\t\t\t\t\t\texecuteHandlers(evt, id);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\t// Setup callback list and bind native event\n
\t\t\t\tcallbackList = events[id][name];\n
\t\t\t\tif (!callbackList) {\n
\t\t\t\t\tevents[id][name] = callbackList = [{func: callback, scope: scope}];\n
\t\t\t\t\tcallbackList.fakeName = fakeName;\n
\t\t\t\t\tcallbackList.capture = capture;\n
\t\t\t\t\t//callbackList.callback = callback;\n
\n
\t\t\t\t\t// Add the nativeHandler to the callback list so that we can later unbind it\n
\t\t\t\t\tcallbackList.nativeHandler = nativeHandler;\n
\n
\t\t\t\t\t// Check if the target has native events support\n
\n
\t\t\t\t\tif (name === "ready") {\n
\t\t\t\t\t\tbindOnReady(target, nativeHandler, self);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\taddEvent(target, fakeName || name, nativeHandler, capture);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (name === "ready" && self.domLoaded) {\n
\t\t\t\t\t\tcallback({type: name});\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// If it already has an native handler then just push the callback\n
\t\t\t\t\t\tcallbackList.push({func: callback, scope: scope});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\ttarget = callbackList = 0; // Clean memory for IE\n
\n
\t\t\treturn callback;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Unbinds the specified event by name, name and callback or all events on the target.\n
\t\t *\n
\t\t * @method unbind\n
\t\t * @param {Object} target Target node/window or custom object.\n
\t\t * @param {String} names Optional event name to unbind.\n
\t\t * @param {function} callback Optional callback function to unbind.\n
\t\t * @return {EventUtils} Event utils instance.\n
\t\t */\n
\t\tself.unbind = function(target, names, callback) {\n
\t\t\tvar id, callbackList, i, ci, name, eventMap;\n
\n
\t\t\t// Don\'t bind to text nodes or comments\n
\t\t\tif (!target || target.nodeType === 3 || target.nodeType === 8) {\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\t// Unbind event or events if the target has the expando\n
\t\t\tid = target[expando];\n
\t\t\tif (id) {\n
\t\t\t\teventMap = events[id];\n
\n
\t\t\t\t// Specific callback\n
\t\t\t\tif (names) {\n
\t\t\t\t\tnames = names.split(\' \');\n
\t\t\t\t\ti = names.length;\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tname = names[i];\n
\t\t\t\t\t\tcallbackList = eventMap[name];\n
\n
\t\t\t\t\t\t// Unbind the event if it exists in the map\n
\t\t\t\t\t\tif (callbackList) {\n
\t\t\t\t\t\t\t// Remove specified callback\n
\t\t\t\t\t\t\tif (callback) {\n
\t\t\t\t\t\t\t\tci = callbackList.length;\n
\t\t\t\t\t\t\t\twhile (ci--) {\n
\t\t\t\t\t\t\t\t\tif (callbackList[ci].func === callback) {\n
\t\t\t\t\t\t\t\t\t\tvar nativeHandler = callbackList.nativeHandler;\n
\t\t\t\t\t\t\t\t\t\tvar fakeName = callbackList.fakeName, capture = callbackList.capture;\n
\n
\t\t\t\t\t\t\t\t\t\t// Clone callbackList since unbind inside a callback would otherwise break the handlers loop\n
\t\t\t\t\t\t\t\t\t\tcallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n
\t\t\t\t\t\t\t\t\t\tcallbackList.nativeHandler = nativeHandler;\n
\t\t\t\t\t\t\t\t\t\tcallbackList.fakeName = fakeName;\n
\t\t\t\t\t\t\t\t\t\tcallbackList.capture = capture;\n
\n
\t\t\t\t\t\t\t\t\t\teventMap[name] = callbackList;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Remove all callbacks if there isn\'t a specified callback or there is no callbacks left\n
\t\t\t\t\t\t\tif (!callback || callbackList.length === 0) {\n
\t\t\t\t\t\t\t\tdelete eventMap[name];\n
\t\t\t\t\t\t\t\tremoveEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// All events for a specific element\n
\t\t\t\t\tfor (name in eventMap) {\n
\t\t\t\t\t\tcallbackList = eventMap[name];\n
\t\t\t\t\t\tremoveEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teventMap = {};\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if object is empty, if it isn\'t then we won\'t remove the expando map\n
\t\t\t\tfor (name in eventMap) {\n
\t\t\t\t\treturn self;\n
\t\t\t\t}\n
\n
\t\t\t\t// Delete event object\n
\t\t\t\tdelete events[id];\n
\n
\t\t\t\t// Remove expando from target\n
\t\t\t\ttry {\n
\t\t\t\t\t// IE will fail here since it can\'t delete properties from window\n
\t\t\t\t\tdelete target[expando];\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// IE will set it to null\n
\t\t\t\t\ttarget[expando] = null;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Fires the specified event on the specified target.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {Object} target Target node/window or custom object.\n
\t\t * @param {String} name Event name to fire.\n
\t\t * @param {Object} args Optional arguments to send to the observers.\n
\t\t * @return {EventUtils} Event utils instance.\n
\t\t */\n
\t\tself.fire = function(target, name, args) {\n
\t\t\tvar id;\n
\n
\t\t\t// Don\'t bind to text nodes or comments\n
\t\t\tif (!target || target.nodeType === 3 || target.nodeType === 8) {\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\t// Build event object by patching the args\n
\t\t\targs = fix(null, args);\n
\t\t\targs.type = name;\n
\t\t\targs.target = target;\n
\n
\t\t\tdo {\n
\t\t\t\t// Found an expando that means there is listeners to execute\n
\t\t\t\tid = target[expando];\n
\t\t\t\tif (id) {\n
\t\t\t\t\texecuteHandlers(args, id);\n
\t\t\t\t}\n
\n
\t\t\t\t// Walk up the DOM\n
\t\t\t\ttarget = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n
\t\t\t} while (target && !args.isPropagationStopped());\n
\n
\t\t\treturn self;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Removes all bound event listeners for the specified target. This will also remove any bound\n
\t\t * listeners to child nodes within that target.\n
\t\t *\n
\t\t * @method clean\n
\t\t * @param {Object} target Target node/window object.\n
\t\t * @return {EventUtils} Event utils instance.\n
\t\t */\n
\t\tself.clean = function(target) {\n
\t\t\tvar i, children, unbind = self.unbind;\n
\n
\t\t\t// Don\'t bind to text nodes or comments\n
\t\t\tif (!target || target.nodeType === 3 || target.nodeType === 8) {\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\t// Unbind any element on the specificed target\n
\t\t\tif (target[expando]) {\n
\t\t\t\tunbind(target);\n
\t\t\t}\n
\n
\t\t\t// Target doesn\'t have getElementsByTagName it\'s probably a window object then use it\'s document to find the children\n
\t\t\tif (!target.getElementsByTagName) {\n
\t\t\t\ttarget = target.document;\n
\t\t\t}\n
\n
\t\t\t// Remove events from each child element\n
\t\t\tif (target && target.getElementsByTagName) {\n
\t\t\t\tunbind(target);\n
\n
\t\t\t\tchildren = target.getElementsByTagName(\'*\');\n
\t\t\t\ti = children.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\ttarget = children[i];\n
\n
\t\t\t\t\tif (target[expando]) {\n
\t\t\t\t\t\tunbind(target);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Destroys the event object. Call this on IE to remove memory leaks.\n
\t\t */\n
\t\tself.destroy = function() {\n
\t\t\tevents = {};\n
\t\t};\n
\n
\t\t// Legacy function for canceling events\n
\t\tself.cancel = function(e) {\n
\t\t\tif (e) {\n
\t\t\t\te.preventDefault();\n
\t\t\t\te.stopImmediatePropagation();\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t};\n
\t}\n
\n
\tEventUtils.Event = new EventUtils();\n
\tEventUtils.Event.bind(window, \'ready\', function() {});\n
\n
\treturn EventUtils;\n
});\n
\n
// Included from: js/tinymce/classes/dom/Sizzle.jQuery.js\n
\n
/**\n
 * Sizzle.jQuery.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*global jQuery:true */\n
\n
/*\n
 * Fake Sizzle using jQuery.\n
 */\n
define("tinymce/dom/Sizzle", [], function() {\n
\t// Detect if jQuery is loaded\n
\tif (!window.jQuery) {\n
\t\tthrow new Error("Load jQuery first");\n
\t}\n
\n
\treturn jQuery.find;\n
});\n
\n
// Included from: js/tinymce/classes/Env.js\n
\n
/**\n
 * Env.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains various environment constants like browser versions etc.\n
 * Normally you don\'t want to sniff specific browser versions but sometimes you have\n
 * to when it\'s impossible to feature detect. So use this with care.\n
 *\n
 * @class tinymce.Env\n
 * @static\n
 */\n
define("tinymce/Env", [], function() {\n
\tvar nav = navigator, userAgent = nav.userAgent;\n
\tvar opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi;\n
\n
\topera = window.opera && window.opera.buildNumber;\n
\tandroid = /Android/.test(userAgent);\n
\twebkit = /WebKit/.test(userAgent);\n
\tie = !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName);\n
\tie = ie && /MSIE (\\w+)\\./.exec(userAgent)[1];\n
\tie11 = userAgent.indexOf(\'Trident/\') != -1 && (userAgent.indexOf(\'rv:\') != -1 || nav.appName.indexOf(\'Netscape\') != -1) ? 11 : false;\n
\tie12 = (userAgent.indexOf(\'Edge/\') != -1 && !ie && !ie11) ? 12 : false;\n
\tie = ie || ie11 || ie12;\n
\tgecko = !webkit && !ie11 && /Gecko/.test(userAgent);\n
\tmac = userAgent.indexOf(\'Mac\') != -1;\n
\tiDevice = /(iPad|iPhone)/.test(userAgent);\n
\tfileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;\n
\n
\tif (ie12) {\n
\t\twebkit = false;\n
\t}\n
\n
\t// Is a iPad/iPhone and not on iOS5 sniff the WebKit version since older iOS WebKit versions\n
\t// says it has contentEditable support but there is no visible caret.\n
\tvar contentEditable = !iDevice || fileApi || userAgent.match(/AppleWebKit\\/(\\d*)/)[1] >= 534;\n
\n
\treturn {\n
\t\t/**\n
\t\t * Constant that is true if the browser is Opera.\n
\t\t *\n
\t\t * @property opera\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\topera: opera,\n
\n
\t\t/**\n
\t\t * Constant that is true if the browser is WebKit (Safari/Chrome).\n
\t\t *\n
\t\t * @property webKit\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\twebkit: webkit,\n
\n
\t\t/**\n
\t\t * Constant that is more than zero if the browser is IE.\n
\t\t *\n
\t\t * @property ie\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tie: ie,\n
\n
\t\t/**\n
\t\t * Constant that is true if the browser is Gecko.\n
\t\t *\n
\t\t * @property gecko\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tgecko: gecko,\n
\n
\t\t/**\n
\t\t * Constant that is true if the os is Mac OS.\n
\t\t *\n
\t\t * @property mac\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tmac: mac,\n
\n
\t\t/**\n
\t\t * Constant that is true if the os is iOS.\n
\t\t *\n
\t\t * @property iOS\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tiOS: iDevice,\n
\n
\t\t/**\n
\t\t * Constant that is true if the os is android.\n
\t\t *\n
\t\t * @property android\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tandroid: android,\n
\n
\t\t/**\n
\t\t * Constant that is true if the browser supports editing.\n
\t\t *\n
\t\t * @property contentEditable\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tcontentEditable: contentEditable,\n
\n
\t\t/**\n
\t\t * Transparent image data url.\n
\t\t *\n
\t\t * @property transparentSrc\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\ttransparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",\n
\n
\t\t/**\n
\t\t * Returns true/false if the browser can or can\'t place the caret after a inline block like an image.\n
\t\t *\n
\t\t * @property noCaretAfter\n
\t\t * @type Boolean\n
\t\t * @final\n
\t\t */\n
\t\tcaretAfter: ie != 8,\n
\n
\t\t/**\n
\t\t * Constant that is true if the browser supports native DOM Ranges. IE 9+.\n
\t\t *\n
\t\t * @property range\n
\t\t * @type Boolean\n
\t\t */\n
\t\trange: window.getSelection && "Range" in window,\n
\n
\t\t/**\n
\t\t * Returns the IE document mode for non IE browsers this will fake IE 10.\n
\t\t *\n
\t\t * @property documentMode\n
\t\t * @type Number\n
\t\t */\n
\t\tdocumentMode: ie && !ie12 ? (document.documentMode || 7) : 10,\n
\n
\t\t/**\n
\t\t * Constant that is true if the browser has a modern file api.\n
\t\t *\n
\t\t * @property fileApi\n
\t\t * @type Boolean\n
\t\t */\n
\t\tfileApi: fileApi\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/Tools.js\n
\n
/**\n
 * Tools.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains various utlity functions. These are also exposed\n
 * directly on the tinymce namespace.\n
 *\n
 * @class tinymce.util.Tools\n
 */\n
define("tinymce/util/Tools", [\n
\t"tinymce/Env"\n
], function(Env) {\n
\t/**\n
\t * Removes whitespace from the beginning and end of a string.\n
\t *\n
\t * @method trim\n
\t * @param {String} s String to remove whitespace from.\n
\t * @return {String} New string with removed whitespace.\n
\t */\n
\tvar whiteSpaceRegExp = /^\\s*|\\s*$/g;\n
\n
\tfunction trim(str) {\n
\t\treturn (str === null || str === undefined) ? \'\' : ("" + str).replace(whiteSpaceRegExp, \'\');\n
\t}\n
\n
\t/**\n
\t * Returns true/false if the object is an array or not.\n
\t *\n
\t * @method isArray\n
\t * @param {Object} obj Object to check.\n
\t * @return {boolean} true/false state if the object is an array or not.\n
\t */\n
\tvar isArray = Array.isArray || function(obj) {\n
\t\treturn Object.prototype.toString.call(obj) === "[object Array]";\n
\t};\n
\n
\t/**\n
\t * Checks if a object is of a specific type for example an array.\n
\t *\n
\t * @method is\n
\t * @param {Object} obj Object to check type of.\n
\t * @param {string} type Optional type to check for.\n
\t * @return {Boolean} true/false if the object is of the specified type.\n
\t */\n
\tfunction is(obj, type) {\n
\t\tif (!type) {\n
\t\t\treturn obj !== undefined;\n
\t\t}\n
\n
\t\tif (type == \'array\' && isArray(obj)) {\n
\t\t\treturn true;\n
\t\t}\n
\n
\t\treturn typeof obj == type;\n
\t}\n
\n
\t/**\n
\t * Converts the specified object into a real JavaScript array.\n
\t *\n
\t * @method toArray\n
\t * @param {Object} obj Object to convert into array.\n
\t * @return {Array} Array object based in input.\n
\t */\n
\tfunction toArray(obj) {\n
\t\tvar array = obj, i, l;\n
\n
\t\tif (!isArray(obj)) {\n
\t\t\tarray = [];\n
\t\t\tfor (i = 0, l = obj.length; i < l; i++) {\n
\t\t\t\tarray[i] = obj[i];\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn array;\n
\t}\n
\n
\t/**\n
\t * Makes a name/object map out of an array with names.\n
\t *\n
\t * @method makeMap\n
\t * @param {Array/String} items Items to make map out of.\n
\t * @param {String} delim Optional delimiter to split string by.\n
\t * @param {Object} map Optional map to add items to.\n
\t * @return {Object} Name/value map of items.\n
\t */\n
\tfunction makeMap(items, delim, map) {\n
\t\tvar i;\n
\n
\t\titems = items || [];\n
\t\tdelim = delim || \',\';\n
\n
\t\tif (typeof items == "string") {\n
\t\t\titems = items.split(delim);\n
\t\t}\n
\n
\t\tmap = map || {};\n
\n
\t\ti = items.length;\n
\t\twhile (i--) {\n
\t\t\tmap[items[i]] = {};\n
\t\t}\n
\n
\t\treturn map;\n
\t}\n
\n
\t/**\n
\t * Performs an iteration of all items in a collection such as an object or array. This method will execure the\n
\t * callback function for each item in the collection, if the callback returns false the iteration will terminate.\n
\t * The callback has the following format: cb(value, key_or_index).\n
\t *\n
\t * @method each\n
\t * @param {Object} o Collection to iterate.\n
\t * @param {function} cb Callback function to execute for each item.\n
\t * @param {Object} s Optional scope to execute the callback in.\n
\t * @example\n
\t * // Iterate an array\n
\t * tinymce.each([1,2,3], function(v, i) {\n
\t *     console.debug("Value: " + v + ", Index: " + i);\n
\t * });\n
\t *\n
\t * // Iterate an object\n
\t * tinymce.each({a: 1, b: 2, c: 3], function(v, k) {\n
\t *     console.debug("Value: " + v + ", Key: " + k);\n
\t * });\n
\t */\n
\tfunction each(o, cb, s) {\n
\t\tvar n, l;\n
\n
\t\tif (!o) {\n
\t\t\treturn 0;\n
\t\t}\n
\n
\t\ts = s || o;\n
\n
\t\tif (o.length !== undefined) {\n
\t\t\t// Indexed arrays, needed for Safari\n
\t\t\tfor (n = 0, l = o.length; n < l; n++) {\n
\t\t\t\tif (cb.call(s, o[n], n, o) === false) {\n
\t\t\t\t\treturn 0;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t} else {\n
\t\t\t// Hashtables\n
\t\t\tfor (n in o) {\n
\t\t\t\tif (o.hasOwnProperty(n)) {\n
\t\t\t\t\tif (cb.call(s, o[n], n, o) === false) {\n
\t\t\t\t\t\treturn 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn 1;\n
\t}\n
\n
\t/**\n
\t * Creates a new array by the return value of each iteration function call. This enables you to convert\n
\t * one array list into another.\n
\t *\n
\t * @method map\n
\t * @param {Array} array Array of items to iterate.\n
\t * @param {function} callback Function to call for each item. It\'s return value will be the new value.\n
\t * @return {Array} Array with new values based on function return values.\n
\t */\n
\tfunction map(array, callback) {\n
\t\tvar out = [];\n
\n
\t\teach(array, function(item) {\n
\t\t\tout.push(callback(item));\n
\t\t});\n
\n
\t\treturn out;\n
\t}\n
\n
\t/**\n
\t * Filters out items from the input array by calling the specified function for each item.\n
\t * If the function returns false the item will be excluded if it returns true it will be included.\n
\t *\n
\t * @method grep\n
\t * @param {Array} a Array of items to loop though.\n
\t * @param {function} f Function to call for each item. Include/exclude depends on it\'s return value.\n
\t * @return {Array} New array with values imported and filtered based in input.\n
\t * @example\n
\t * // Filter out some items, this will return an array with 4 and 5\n
\t * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});\n
\t */\n
\tfunction grep(a, f) {\n
\t\tvar o = [];\n
\n
\t\teach(a, function(v) {\n
\t\t\tif (!f || f(v)) {\n
\t\t\t\to.push(v);\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn o;\n
\t}\n
\n
\t/**\n
\t * Creates a class, subclass or static singleton.\n
\t * More details on this method can be found in the Wiki.\n
\t *\n
\t * @method create\n
\t * @param {String} s Class name, inheritage and prefix.\n
\t * @param {Object} p Collection of methods to add to the class.\n
\t * @param {Object} root Optional root object defaults to the global window object.\n
\t * @example\n
\t * // Creates a basic class\n
\t * tinymce.create(\'tinymce.somepackage.SomeClass\', {\n
\t *     SomeClass: function() {\n
\t *         // Class constructor\n
\t *     },\n
\t *\n
\t *     method: function() {\n
\t *         // Some method\n
\t *     }\n
\t * });\n
\t *\n
\t * // Creates a basic subclass class\n
\t * tinymce.create(\'tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass\', {\n
\t *     SomeSubClass: function() {\n
\t *         // Class constructor\n
\t *         this.parent(); // Call parent constructor\n
\t *     },\n
\t *\n
\t *     method: function() {\n
\t *         // Some method\n
\t *         this.parent(); // Call parent method\n
\t *     },\n
\t *\n
\t *     \'static\': {\n
\t *         staticMethod: function() {\n
\t *             // Static method\n
\t *         }\n
\t *     }\n
\t * });\n
\t *\n
\t * // Creates a singleton/static class\n
\t * tinymce.create(\'static tinymce.somepackage.SomeSingletonClass\', {\n
\t *     method: function() {\n
\t *         // Some method\n
\t *     }\n
\t * });\n
\t */\n
\tfunction create(s, p, root) {\n
\t\tvar self = this, sp, ns, cn, scn, c, de = 0;\n
\n
\t\t// Parse : <prefix> <class>:<super class>\n
\t\ts = /^((static) )?([\\w.]+)(:([\\w.]+))?/.exec(s);\n
\t\tcn = s[3].match(/(^|\\.)(\\w+)$/i)[2]; // Class name\n
\n
\t\t// Create namespace for new class\n
\t\tns = self.createNS(s[3].replace(/\\.\\w+$/, \'\'), root);\n
\n
\t\t// Class already exists\n
\t\tif (ns[cn]) {\n
\t\t\treturn;\n
\t\t}\n
\n
\t\t// Make pure static class\n
\t\tif (s[2] == \'static\') {\n
\t\t\tns[cn] = p;\n
\n
\t\t\tif (this.onCreate) {\n
\t\t\t\tthis.onCreate(s[2], s[3], ns[cn]);\n
\t\t\t}\n
\n
\t\t\treturn;\n
\t\t}\n
\n
\t\t// Create default constructor\n
\t\tif (!p[cn]) {\n
\t\t\tp[cn] = function() {};\n
\t\t\tde = 1;\n
\t\t}\n
\n
\t\t// Add constructor and methods\n
\t\tns[cn] = p[cn];\n
\t\tself.extend(ns[cn].prototype, p);\n
\n
\t\t// Extend\n
\t\tif (s[5]) {\n
\t\t\tsp = self.resolve(s[5]).prototype;\n
\t\t\tscn = s[5].match(/\\.(\\w+)$/i)[1]; // Class name\n
\n
\t\t\t// Extend constructor\n
\t\t\tc = ns[cn];\n
\t\t\tif (de) {\n
\t\t\t\t// Add passthrough constructor\n
\t\t\t\tns[cn] = function() {\n
\t\t\t\t\treturn sp[scn].apply(this, arguments);\n
\t\t\t\t};\n
\t\t\t} else {\n
\t\t\t\t// Add inherit constructor\n
\t\t\t\tns[cn] = function() {\n
\t\t\t\t\tthis.parent = sp[scn];\n
\t\t\t\t\treturn c.apply(this, arguments);\n
\t\t\t\t};\n
\t\t\t}\n
\t\t\tns[cn].prototype[cn] = ns[cn];\n
\n
\t\t\t// Add super methods\n
\t\t\tself.each(sp, function(f, n) {\n
\t\t\t\tns[cn].prototype[n] = sp[n];\n
\t\t\t});\n
\n
\t\t\t// Add overridden methods\n
\t\t\tself.each(p, function(f, n) {\n
\t\t\t\t// Extend methods if needed\n
\t\t\t\tif (sp[n]) {\n
\t\t\t\t\tns[cn].prototype[n] = function() {\n
\t\t\t\t\t\tthis.parent = sp[n];\n
\t\t\t\t\t\treturn f.apply(this, arguments);\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\tif (n != cn) {\n
\t\t\t\t\t\tns[cn].prototype[n] = f;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Add static methods\n
\t\t/*jshint sub:true*/\n
\t\t/*eslint dot-notation:0*/\n
\t\tself.each(p[\'static\'], function(f, n) {\n
\t\t\tns[cn][n] = f;\n
\t\t});\n
\t}\n
\n
\t/**\n
\t * Returns the index of a value in an array, this method will return -1 if the item wasn\'t found.\n
\t *\n
\t * @method inArray\n
\t * @param {Array} a Array/Object to search for value in.\n
\t * @param {Object} v Value to check for inside the array.\n
\t * @return {Number/String} Index of item inside the array inside an object. Or -1 if it wasn\'t found.\n
\t * @example\n
\t * // Get index of value in array this will alert 1 since 2 is at that index\n
\t * alert(tinymce.inArray([1,2,3], 2));\n
\t */\n
\tfunction inArray(a, v) {\n
\t\tvar i, l;\n
\n
\t\tif (a) {\n
\t\t\tfor (i = 0, l = a.length; i < l; i++) {\n
\t\t\t\tif (a[i] === v) {\n
\t\t\t\t\treturn i;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn -1;\n
\t}\n
\n
\tfunction extend(obj, ext) {\n
\t\tvar i, l, name, args = arguments, value;\n
\n
\t\tfor (i = 1, l = args.length; i < l; i++) {\n
\t\t\text = args[i];\n
\t\t\tfor (name in ext) {\n
\t\t\t\tif (ext.hasOwnProperty(name)) {\n
\t\t\t\t\tvalue = ext[name];\n
\n
\t\t\t\t\tif (value !== undefined) {\n
\t\t\t\t\t\tobj[name] = value;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn obj;\n
\t}\n
\n
\t/**\n
\t * Executed the specified function for each item in a object tree.\n
\t *\n
\t * @method walk\n
\t * @param {Object} o Object tree to walk though.\n
\t * @param {function} f Function to call for each item.\n
\t * @param {String} n Optional name of collection inside the objects to walk for example childNodes.\n
\t * @param {String} s Optional scope to execute the function in.\n
\t */\n
\tfunction walk(o, f, n, s) {\n
\t\ts = s || this;\n
\n
\t\tif (o) {\n
\t\t\tif (n) {\n
\t\t\t\to = o[n];\n
\t\t\t}\n
\n
\t\t\teach(o, function(o, i) {\n
\t\t\t\tif (f.call(s, o, i, n) === false) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\twalk(o, f, n, s);\n
\t\t\t});\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Creates a namespace on a specific object.\n
\t *\n
\t * @method createNS\n
\t * @param {String} n Namespace to create for example a.b.c.d.\n
\t * @param {Object} o Optional object to add namespace to, defaults to window.\n
\t * @return {Object} New namespace object the last item in path.\n
\t * @example\n
\t * // Create some namespace\n
\t * tinymce.createNS(\'tinymce.somepackage.subpackage\');\n
\t *\n
\t * // Add a singleton\n
\t * var tinymce.somepackage.subpackage.SomeSingleton = {\n
\t *     method: function() {\n
\t *         // Some method\n
\t *     }\n
\t * };\n
\t */\n
\tfunction createNS(n, o) {\n
\t\tvar i, v;\n
\n
\t\to = o || window;\n
\n
\t\tn = n.split(\'.\');\n
\t\tfor (i = 0; i < n.length; i++) {\n
\t\t\tv = n[i];\n
\n
\t\t\tif (!o[v]) {\n
\t\t\t\to[v] = {};\n
\t\t\t}\n
\n
\t\t\to = o[v];\n
\t\t}\n
\n
\t\treturn o;\n
\t}\n
\n
\t/**\n
\t * Resolves a string and returns the object from a specific structure.\n
\t *\n
\t * @method resolve\n
\t * @param {String} n Path to resolve for example a.b.c.d.\n
\t * @param {Object} o Optional object to search though, defaults to window.\n
\t * @return {Object} Last object in path or null if it couldn\'t be resolved.\n
\t * @example\n
\t * // Resolve a path into an object reference\n
\t * var obj = tinymce.resolve(\'a.b.c.d\');\n
\t */\n
\tfunction resolve(n, o) {\n
\t\tvar i, l;\n
\n
\t\to = o || window;\n
\n
\t\tn = n.split(\'.\');\n
\t\tfor (i = 0, l = n.length; i < l; i++) {\n
\t\t\to = o[n[i]];\n
\n
\t\t\tif (!o) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn o;\n
\t}\n
\n
\t/**\n
\t * Splits a string but removes the whitespace before and after each value.\n
\t *\n
\t * @method explode\n
\t * @param {string} s String to split.\n
\t * @param {string} d Delimiter to split by.\n
\t * @example\n
\t * // Split a string into an array with a,b,c\n
\t * var arr = tinymce.explode(\'a, b,   c\');\n
\t */\n
\tfunction explode(s, d) {\n
\t\tif (!s || is(s, \'array\')) {\n
\t\t\treturn s;\n
\t\t}\n
\n
\t\treturn map(s.split(d || \',\'), trim);\n
\t}\n
\n
\tfunction constant(value) {\n
\t\treturn function() {\n
\t\t\treturn value;\n
\t\t};\n
\t}\n
\n
\tfunction reduce(collection, iteratee, accumulator, thisArg) {\n
\t\tvar i = 0;\n
\n
\t\tif (arguments.length < 3) {\n
\t\t\taccumulator = collection[0];\n
\t\t\ti = 1;\n
\t\t}\n
\n
\t\tfor (; i < collection.length; i++) {\n
\t\t\taccumulator = iteratee.call(thisArg, accumulator, collection[i], i);\n
\t\t}\n
\n
\t\treturn accumulator;\n
\t}\n
\n
\tfunction _addCacheSuffix(url) {\n
\t\tvar cacheSuffix = Env.cacheSuffix;\n
\n
\t\tif (cacheSuffix) {\n
\t\t\turl += (url.indexOf(\'?\') === -1 ? \'?\' : \'&\') + cacheSuffix;\n
\t\t}\n
\n
\t\treturn url;\n
\t}\n
\n
\treturn {\n
\t\ttrim: trim,\n
\t\tisArray: isArray,\n
\t\tis: is,\n
\t\ttoArray: toArray,\n
\t\tmakeMap: makeMap,\n
\t\teach: each,\n
\t\tmap: map,\n
\t\tgrep: grep,\n
\t\tfilter: grep,\n
\t\tinArray: inArray,\n
\t\textend: extend,\n
\t\tcreate: create,\n
\t\twalk: walk,\n
\t\tcreateNS: createNS,\n
\t\tresolve: resolve,\n
\t\texplode: explode,\n
\t\tconstant: constant,\n
\t\treduce: reduce,\n
\t\t_addCacheSuffix: _addCacheSuffix\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/DomQuery.js\n
\n
/**\n
 * DomQuery.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class mimics most of the jQuery API:\n
 *\n
 * This is whats currently implemented:\n
 * - Utility functions\n
 * - DOM traversial\n
 * - DOM manipulation\n
 * - Event binding\n
 *\n
 * This is not currently implemented:\n
 * - Dimension\n
 * - Ajax\n
 * - Animation\n
 * - Advanced chaining\n
 *\n
 * @example\n
 * var $ = tinymce.dom.DomQuery;\n
 * $(\'p\').attr(\'attr\', \'value\').addClass(\'class\');\n
 *\n
 * @class tinymce.dom.DomQuery\n
 */\n
define("tinymce/dom/DomQuery", [\n
\t"tinymce/dom/EventUtils",\n
\t"tinymce/dom/Sizzle",\n
\t"tinymce/util/Tools",\n
\t"tinymce/Env"\n
], function(EventUtils, Sizzle, Tools, Env) {\n
\tvar doc = document, push = Array.prototype.push, slice = Array.prototype.slice;\n
\tvar rquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/;\n
\tvar Event = EventUtils.Event, undef;\n
\n
\tfunction isDefined(obj) {\n
\t\treturn typeof obj !== \'undefined\';\n
\t}\n
\n
\tfunction isString(obj) {\n
\t\treturn typeof obj === \'string\';\n
\t}\n
\n
\tfunction isWindow(obj) {\n
\t\treturn obj && obj == obj.window;\n
\t}\n
\n
\tfunction createFragment(html, fragDoc) {\n
\t\tvar frag, node, container;\n
\n
\t\tfragDoc = fragDoc || doc;\n
\t\tcontainer = fragDoc.createElement(\'div\');\n
\t\tfrag = fragDoc.createDocumentFragment();\n
\t\tcontainer.innerHTML = html;\n
\n
\t\twhile ((node = container.firstChild)) {\n
\t\t\tfrag.appendChild(node);\n
\t\t}\n
\n
\t\treturn frag;\n
\t}\n
\n
\tfunction domManipulate(targetNodes, sourceItem, callback, reverse) {\n
\t\tvar i;\n
\n
\t\tif (isString(sourceItem)) {\n
\t\t\tsourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));\n
\t\t} else if (sourceItem.length && !sourceItem.nodeType) {\n
\t\t\tsourceItem = DomQuery.makeArray(sourceItem);\n
\n
\t\t\tif (reverse) {\n
\t\t\t\tfor (i = sourceItem.length - 1; i >= 0; i--) {\n
\t\t\t\t\tdomManipulate(targetNodes, sourceItem[i], callback, reverse);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tfor (i = 0; i < sourceItem.length; i++) {\n
\t\t\t\t\tdomManipulate(targetNodes, sourceItem[i], callback, reverse);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn targetNodes;\n
\t\t}\n
\n
\t\tif (sourceItem.nodeType) {\n
\t\t\ti = targetNodes.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tcallback.call(targetNodes[i], sourceItem);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn targetNodes;\n
\t}\n
\n
\tfunction hasClass(node, className) {\n
\t\treturn node && className && (\' \' + node.className + \' \').indexOf(\' \' + className + \' \') !== -1;\n
\t}\n
\n
\tfunction wrap(elements, wrapper, all) {\n
\t\tvar lastParent, newWrapper;\n
\n
\t\twrapper = DomQuery(wrapper)[0];\n
\n
\t\telements.each(function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!all || lastParent != self.parentNode) {\n
\t\t\t\tlastParent = self.parentNode;\n
\t\t\t\tnewWrapper = wrapper.cloneNode(false);\n
\t\t\t\tself.parentNode.insertBefore(newWrapper, self);\n
\t\t\t\tnewWrapper.appendChild(self);\n
\t\t\t} else {\n
\t\t\t\tnewWrapper.appendChild(self);\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn elements;\n
\t}\n
\n
\tvar numericCssMap = Tools.makeMap(\'fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom\', \' \');\n
\tvar booleanMap = Tools.makeMap(\'checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected\', \' \');\n
\tvar propFix = {\n
\t\t\'for\': \'htmlFor\',\n
\t\t\'class\': \'className\',\n
\t\t\'readonly\': \'readOnly\'\n
\t};\n
\tvar cssFix = {\n
\t\t\'float\': \'cssFloat\'\n
\t};\n
\n
\tvar attrHooks = {}, cssHooks = {};\n
\n
\tfunction DomQuery(selector, context) {\n
\t\t/*eslint new-cap:0 */\n
\t\treturn new DomQuery.fn.init(selector, context);\n
\t}\n
\n
\tfunction inArray(item, array) {\n
\t\tvar i;\n
\n
\t\tif (array.indexOf) {\n
\t\t\treturn array.indexOf(item);\n
\t\t}\n
\n
\t\ti = array.length;\n
\t\twhile (i--) {\n
\t\t\tif (array[i] === item) {\n
\t\t\t\treturn i;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn -1;\n
\t}\n
\n
\tvar whiteSpaceRegExp = /^\\s*|\\s*$/g;\n
\n
\tfunction trim(str) {\n
\t\treturn (str === null || str === undef) ? \'\' : ("" + str).replace(whiteSpaceRegExp, \'\');\n
\t}\n
\n
\tfunction each(obj, callback) {\n
\t\tvar length, key, i, undef, value;\n
\n
\t\tif (obj) {\n
\t\t\tlength = obj.length;\n
\n
\t\t\tif (length === undef) {\n
\t\t\t\t// Loop object items\n
\t\t\t\tfor (key in obj) {\n
\t\t\t\t\tif (obj.hasOwnProperty(key)) {\n
\t\t\t\t\t\tvalue = obj[key];\n
\t\t\t\t\t\tif (callback.call(value, key, value) === false) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Loop array items\n
\t\t\t\tfor (i = 0; i < length; i++) {\n
\t\t\t\t\tvalue = obj[i];\n
\t\t\t\t\tif (callback.call(value, i, value) === false) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn obj;\n
\t}\n
\n
\tfunction grep(array, callback) {\n
\t\tvar out = [];\n
\n
\t\teach(array, function(i, item) {\n
\t\t\tif (callback(item, i)) {\n
\t\t\t\tout.push(item);\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn out;\n
\t}\n
\n
\tfunction getElementDocument(element) {\n
\t\tif (!element) {\n
\t\t\treturn doc;\n
\t\t}\n
\n
\t\tif (element.nodeType == 9) {\n
\t\t\treturn element;\n
\t\t}\n
\n
\t\treturn element.ownerDocument;\n
\t}\n
\n
\tDomQuery.fn = DomQuery.prototype = {\n
\t\tconstructor: DomQuery,\n
\n
\t\t/**\n
\t\t * Selector for the current set.\n
\t\t *\n
\t\t * @property selector\n
\t\t * @type String\n
\t\t */\n
\t\tselector: "",\n
\n
\t\t/**\n
\t\t * Context used to create the set.\n
\t\t *\n
\t\t * @property context\n
\t\t * @type Element\n
\t\t */\n
\t\tcontext: null,\n
\n
\t\t/**\n
\t\t * Number of items in the current set.\n
\t\t *\n
\t\t * @property length\n
\t\t * @type Number\n
\t\t */\n
\t\tlength: 0,\n
\n
\t\t/**\n
\t\t * Constructs a new DomQuery instance with the specified selector or context.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @method init\n
\t\t * @param {String/Array/DomQuery} selector Optional CSS selector/Array or array like object or HTML string.\n
\t\t * @param {Document/Element} context Optional context to search in.\n
\t\t */\n
\t\tinit: function(selector, context) {\n
\t\t\tvar self = this, match, node;\n
\n
\t\t\tif (!selector) {\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\tif (selector.nodeType) {\n
\t\t\t\tself.context = self[0] = selector;\n
\t\t\t\tself.length = 1;\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\tif (context && context.nodeType) {\n
\t\t\t\tself.context = context;\n
\t\t\t} else {\n
\t\t\t\tif (context) {\n
\t\t\t\t\treturn DomQuery(selector).attr(context);\n
\t\t\t\t}\n
\n
\t\t\t\tself.context = context = document;\n
\t\t\t}\n
\n
\t\t\tif (isString(selector)) {\n
\t\t\t\tself.selector = selector;\n
\n
\t\t\t\tif (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {\n
\t\t\t\t\tmatch = [null, selector, null];\n
\t\t\t\t} else {\n
\t\t\t\t\tmatch = rquickExpr.exec(selector);\n
\t\t\t\t}\n
\n
\t\t\t\tif (match) {\n
\t\t\t\t\tif (match[1]) {\n
\t\t\t\t\t\tnode = createFragment(selector, getElementDocument(context)).firstChild;\n
\n
\t\t\t\t\t\twhile (node) {\n
\t\t\t\t\t\t\tpush.call(self, node);\n
\t\t\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tnode = getElementDocument(context).getElementById(match[2]);\n
\n
\t\t\t\t\t\tif (!node) {\n
\t\t\t\t\t\t\treturn self;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (node.id !== match[2]) {\n
\t\t\t\t\t\t\treturn self.find(selector);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tself.length = 1;\n
\t\t\t\t\t\tself[0] = node;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\treturn DomQuery(context).find(selector);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tthis.add(selector, false);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Converts the current set to an array.\n
\t\t *\n
\t\t * @method toArray\n
\t\t * @param {Array} Array of all nodes in set.\n
\t\t */\n
\t\ttoArray: function() {\n
\t\t\treturn Tools.toArray(this);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds new nodes to the set.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {Array/tinymce.dom.DomQuery} items Array of all nodes to add to set.\n
\t\t * @return {tinymce.dom.DomQuery} New instance with nodes added.\n
\t\t */\n
\t\tadd: function(items, sort) {\n
\t\t\tvar self = this, nodes, i;\n
\n
\t\t\tif (isString(items)) {\n
\t\t\t\treturn self.add(DomQuery(items));\n
\t\t\t}\n
\n
\t\t\tif (sort !== false) {\n
\t\t\t\tnodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));\n
\t\t\t\tself.length = nodes.length;\n
\t\t\t\tfor (i = 0; i < nodes.length; i++) {\n
\t\t\t\t\tself[i] = nodes[i];\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tpush.apply(self, DomQuery.makeArray(items));\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets attributes on the elements in the current set.\n
\t\t *\n
\t\t * @method attr\n
\t\t * @param {String/Object} name Name of attribute to get or an object with attributes to set.\n
\t\t * @param {String} value Optional value to set.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set or the specified attribute when only the name is specified.\n
\t\t */\n
\t\tattr: function(name, value) {\n
\t\t\tvar self = this, hook;\n
\n
\t\t\tif (typeof name === "object") {\n
\t\t\t\teach(name, function(name, value) {\n
\t\t\t\t\tself.attr(name, value);\n
\t\t\t\t});\n
\t\t\t} else if (isDefined(value)) {\n
\t\t\t\tthis.each(function() {\n
\t\t\t\t\tvar hook;\n
\n
\t\t\t\t\tif (this.nodeType === 1) {\n
\t\t\t\t\t\thook = attrHooks[name];\n
\t\t\t\t\t\tif (hook && hook.set) {\n
\t\t\t\t\t\t\thook.set(this, value);\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (value === null) {\n
\t\t\t\t\t\t\tthis.removeAttribute(name, 2);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tthis.setAttribute(name, value, 2);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\tif (self[0] && self[0].nodeType === 1) {\n
\t\t\t\t\thook = attrHooks[name];\n
\t\t\t\t\tif (hook && hook.get) {\n
\t\t\t\t\t\treturn hook.get(self[0], name);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (booleanMap[name]) {\n
\t\t\t\t\t\treturn self.prop(name) ? name : undef;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tvalue = self[0].getAttribute(name, 2);\n
\n
\t\t\t\t\tif (value === null) {\n
\t\t\t\t\t\tvalue = undef;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes attributse on the elements in the current set.\n
\t\t *\n
\t\t * @method removeAttr\n
\t\t * @param {String/Object} name Name of attribute to remove.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set.\n
\t\t */\n
\t\tremoveAttr: function(name) {\n
\t\t\treturn this.attr(name, null);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets properties on the elements in the current set.\n
\t\t *\n
\t\t * @method attr\n
\t\t * @param {String/Object} name Name of property to get or an object with properties to set.\n
\t\t * @param {String} value Optional value to set.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set or the specified property when only the name is specified.\n
\t\t */\n
\t\tprop: function(name, value) {\n
\t\t\tvar self = this;\n
\n
\t\t\tname = propFix[name] || name;\n
\n
\t\t\tif (typeof name === "object") {\n
\t\t\t\teach(name, function(name, value) {\n
\t\t\t\t\tself.prop(name, value);\n
\t\t\t\t});\n
\t\t\t} else if (isDefined(value)) {\n
\t\t\t\tthis.each(function() {\n
\t\t\t\t\tif (this.nodeType == 1) {\n
\t\t\t\t\t\tthis[name] = value;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\tif (self[0] && self[0].nodeType && name in self[0]) {\n
\t\t\t\t\treturn self[0][name];\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets styles on the elements in the current set.\n
\t\t *\n
\t\t * @method css\n
\t\t * @param {String/Object} name Name of style to get or an object with styles to set.\n
\t\t * @param {String} value Optional value to set.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set or the specified style when only the name is specified.\n
\t\t */\n
\t\tcss: function(name, value) {\n
\t\t\tvar self = this, elm, hook;\n
\n
\t\t\tfunction camel(name) {\n
\t\t\t\treturn name.replace(/-(\\D)/g, function(a, b) {\n
\t\t\t\t\treturn b.toUpperCase();\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tfunction dashed(name) {\n
\t\t\t\treturn name.replace(/[A-Z]/g, function(a) {\n
\t\t\t\t\treturn \'-\' + a;\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (typeof name === "object") {\n
\t\t\t\teach(name, function(name, value) {\n
\t\t\t\t\tself.css(name, value);\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\tif (isDefined(value)) {\n
\t\t\t\t\tname = camel(name);\n
\n
\t\t\t\t\t// Default px suffix on these\n
\t\t\t\t\tif (typeof value === \'number\' && !numericCssMap[name]) {\n
\t\t\t\t\t\tvalue += \'px\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.each(function() {\n
\t\t\t\t\t\tvar style = this.style;\n
\n
\t\t\t\t\t\thook = cssHooks[name];\n
\t\t\t\t\t\tif (hook && hook.set) {\n
\t\t\t\t\t\t\thook.set(this, value);\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\ttry {\n
\t\t\t\t\t\t\tthis.style[cssFix[name] || name] = value;\n
\t\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t\t// Ignore\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (value === null || value === \'\') {\n
\t\t\t\t\t\t\tif (style.removeProperty) {\n
\t\t\t\t\t\t\t\tstyle.removeProperty(dashed(name));\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tstyle.removeAttribute(name);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\telm = self[0];\n
\n
\t\t\t\t\thook = cssHooks[name];\n
\t\t\t\t\tif (hook && hook.get) {\n
\t\t\t\t\t\treturn hook.get(elm);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (elm.ownerDocument.defaultView) {\n
\t\t\t\t\t\ttry {\n
\t\t\t\t\t\t\treturn elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));\n
\t\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t\treturn undef;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else if (elm.currentStyle) {\n
\t\t\t\t\t\treturn elm.currentStyle[camel(name)];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes all nodes in set from the document.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.dom.DomQuery} Current set with the removed nodes.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this, node, i = this.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = self[i];\n
\t\t\t\tEvent.clean(node);\n
\n
\t\t\t\tif (node.parentNode) {\n
\t\t\t\t\tnode.parentNode.removeChild(node);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Empties all elements in set.\n
\t\t *\n
\t\t * @method empty\n
\t\t * @return {tinymce.dom.DomQuery} Current set with the empty nodes.\n
\t\t */\n
\t\tempty: function() {\n
\t\t\tvar self = this, node, i = this.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = self[i];\n
\t\t\t\twhile (node.firstChild) {\n
\t\t\t\t\tnode.removeChild(node.firstChild);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets or gets the HTML of the current set or first set node.\n
\t\t *\n
\t\t * @method html\n
\t\t * @param {String} value Optional innerHTML value to set on each element.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set or the innerHTML of the first element.\n
\t\t */\n
\t\thtml: function(value) {\n
\t\t\tvar self = this, i;\n
\n
\t\t\tif (isDefined(value)) {\n
\t\t\t\ti = self.length;\n
\n
\t\t\t\ttry {\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tself[i].innerHTML = value;\n
\t\t\t\t\t}\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Workaround for "Unknown runtime error" when DIV is added to P on IE\n
\t\t\t\t\tDomQuery(self[i]).empty().append(value);\n
\t\t\t\t}\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\treturn self[0] ? self[0].innerHTML : \'\';\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets or gets the text of the current set or first set node.\n
\t\t *\n
\t\t * @method text\n
\t\t * @param {String} value Optional innerText value to set on each element.\n
\t\t * @return {tinymce.dom.DomQuery/String} Current set or the innerText of the first element.\n
\t\t */\n
\t\ttext: function(value) {\n
\t\t\tvar self = this, i;\n
\n
\t\t\tif (isDefined(value)) {\n
\t\t\t\ti = self.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tif ("innerText" in self[i]) {\n
\t\t\t\t\t\tself[i].innerText = value;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself[0].textContent = value;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\treturn self[0] ? (self[0].innerText || self[0].textContent) : \'\';\n
\t\t},\n
\n
\t\t/**\n
\t\t * Appends the specified node/html or node set to the current set nodes.\n
\t\t *\n
\t\t * @method append\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to append to each element in set.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tappend: function() {\n
\t\t\treturn domManipulate(this, arguments, function(node) {\n
\t\t\t\tif (this.nodeType === 1) {\n
\t\t\t\t\tthis.appendChild(node);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Prepends the specified node/html or node set to the current set nodes.\n
\t\t *\n
\t\t * @method prepend\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to prepend to each element in set.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tprepend: function() {\n
\t\t\treturn domManipulate(this, arguments, function(node) {\n
\t\t\t\tif (this.nodeType === 1) {\n
\t\t\t\t\tthis.insertBefore(node, this.firstChild);\n
\t\t\t\t}\n
\t\t\t}, true);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds the specified elements before current set nodes.\n
\t\t *\n
\t\t * @method before\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add before to each element in set.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tbefore: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self[0] && self[0].parentNode) {\n
\t\t\t\treturn domManipulate(self, arguments, function(node) {\n
\t\t\t\t\tthis.parentNode.insertBefore(node, this);\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds the specified elements after current set nodes.\n
\t\t *\n
\t\t * @method after\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add after to each element in set.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tafter: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self[0] && self[0].parentNode) {\n
\t\t\t\treturn domManipulate(self, arguments, function(node) {\n
\t\t\t\t\tthis.parentNode.insertBefore(node, this.nextSibling);\n
\t\t\t\t}, true);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Appends the specified set nodes to the specified selector/instance.\n
\t\t *\n
\t\t * @method appendTo\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to append the current set to.\n
\t\t * @return {tinymce.dom.DomQuery} Current set with the appended nodes.\n
\t\t */\n
\t\tappendTo: function(val) {\n
\t\t\tDomQuery(val).append(this);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Prepends the specified set nodes to the specified selector/instance.\n
\t\t *\n
\t\t * @method prependTo\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to prepend the current set to.\n
\t\t * @return {tinymce.dom.DomQuery} Current set with the prepended nodes.\n
\t\t */\n
\t\tprependTo: function(val) {\n
\t\t\tDomQuery(val).prepend(this);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Replaces the nodes in set with the specified content.\n
\t\t *\n
\t\t * @method replaceWith\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to replace nodes with.\n
\t\t * @return {tinymce.dom.DomQuery} Set with replaced nodes.\n
\t\t */\n
\t\treplaceWith: function(content) {\n
\t\t\treturn this.before(content).remove();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Wraps all elements in set with the specified wrapper.\n
\t\t *\n
\t\t * @method wrap\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.\n
\t\t * @return {tinymce.dom.DomQuery} Set with wrapped nodes.\n
\t\t */\n
\t\twrap: function(wrapper) {\n
\t\t\treturn wrap(this, wrapper);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Wraps all nodes in set with the specified wrapper. If the nodes are siblings all of them\n
\t\t * will be wrapped in the same wrapper.\n
\t\t *\n
\t\t * @method wrapAll\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.\n
\t\t * @return {tinymce.dom.DomQuery} Set with wrapped nodes.\n
\t\t */\n
\t\twrapAll: function(wrapper) {\n
\t\t\treturn wrap(this, wrapper, true);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Wraps all elements inner contents in set with the specified wrapper.\n
\t\t *\n
\t\t * @method wrapInner\n
\t\t * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.\n
\t\t * @return {tinymce.dom.DomQuery} Set with wrapped nodes.\n
\t\t */\n
\t\twrapInner: function(wrapper) {\n
\t\t\tthis.each(function() {\n
\t\t\t\tDomQuery(this).contents().wrapAll(wrapper);\n
\t\t\t});\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unwraps all elements by removing the parent element of each item in set.\n
\t\t *\n
\t\t * @method unwrap\n
\t\t * @return {tinymce.dom.DomQuery} Set with unwrapped nodes.\n
\t\t */\n
\t\tunwrap: function() {\n
\t\t\treturn this.parent().each(function() {\n
\t\t\t\tDomQuery(this).replaceWith(this.childNodes);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Clones all nodes in set.\n
\t\t *\n
\t\t * @method clone\n
\t\t * @return {tinymce.dom.DomQuery} Set with cloned nodes.\n
\t\t */\n
\t\tclone: function() {\n
\t\t\tvar result = [];\n
\n
\t\t\tthis.each(function() {\n
\t\t\t\tresult.push(this.cloneNode(true));\n
\t\t\t});\n
\n
\t\t\treturn DomQuery(result);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds the specified class name to the current set elements.\n
\t\t *\n
\t\t * @method addClass\n
\t\t * @param {String} className Class name to add.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\taddClass: function(className) {\n
\t\t\treturn this.toggleClass(className, true);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified class name to the current set elements.\n
\t\t *\n
\t\t * @method removeClass\n
\t\t * @param {String} className Class name to remove.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tremoveClass: function(className) {\n
\t\t\treturn this.toggleClass(className, false);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Toggles the specified class name on the current set elements.\n
\t\t *\n
\t\t * @method toggleClass\n
\t\t * @param {String} className Class name to add/remove.\n
\t\t * @param {Boolean} state Optional state to toggle on/off.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\ttoggleClass: function(className, state) {\n
\t\t\tvar self = this;\n
\n
\t\t\t// Functions are not supported\n
\t\t\tif (typeof className != \'string\') {\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\tif (className.indexOf(\' \') !== -1) {\n
\t\t\t\teach(className.split(\' \'), function() {\n
\t\t\t\t\tself.toggleClass(this, state);\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\tself.each(function(index, node) {\n
\t\t\t\t\tvar existingClassName, classState;\n
\n
\t\t\t\t\tclassState = hasClass(node, className);\n
\t\t\t\t\tif (classState !== state) {\n
\t\t\t\t\t\texistingClassName = node.className;\n
\n
\t\t\t\t\t\tif (classState) {\n
\t\t\t\t\t\t\tnode.className = trim((" " + existingClassName + " ").replace(\' \' + className + \' \', \' \'));\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode.className += existingClassName ? \' \' + className : className;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the first item in set has the specified class.\n
\t\t *\n
\t\t * @method hasClass\n
\t\t * @param {String} className Class name to check for.\n
\t\t * @return {Boolean} True/false if the set has the specified class.\n
\t\t */\n
\t\thasClass: function(className) {\n
\t\t\treturn hasClass(this[0], className);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes the callback function for each item DomQuery collection. If you return false in the\n
\t\t * callback it will break the loop.\n
\t\t *\n
\t\t * @method each\n
\t\t * @param {function} callback Callback function to execute for each item.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\teach: function(callback) {\n
\t\t\treturn each(this, callback);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Binds an event with callback function to the elements in set.\n
\t\t *\n
\t\t * @method on\n
\t\t * @param {String} name Name of the event to bind.\n
\t\t * @param {function} callback Callback function to execute when the event occurs.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\ton: function(name, callback) {\n
\t\t\treturn this.each(function() {\n
\t\t\t\tEvent.bind(this, name, callback);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unbinds an event with callback function to the elements in set.\n
\t\t *\n
\t\t * @method off\n
\t\t * @param {String} name Optional name of the event to bind.\n
\t\t * @param {function} callback Optional callback function to execute when the event occurs.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\toff: function(name, callback) {\n
\t\t\treturn this.each(function() {\n
\t\t\t\tEvent.unbind(this, name, callback);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Triggers the specified event by name or event object.\n
\t\t *\n
\t\t * @method trigger\n
\t\t * @param {String/Object} name Name of the event to trigger or event object.\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\ttrigger: function(name) {\n
\t\t\treturn this.each(function() {\n
\t\t\t\tif (typeof name == \'object\') {\n
\t\t\t\t\tEvent.fire(this, name.type, name);\n
\t\t\t\t} else {\n
\t\t\t\t\tEvent.fire(this, name);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows all elements in set.\n
\t\t *\n
\t\t * @method show\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\tshow: function() {\n
\t\t\treturn this.css(\'display\', \'\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides all elements in set.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @return {tinymce.dom.DomQuery} Current set.\n
\t\t */\n
\t\thide: function() {\n
\t\t\treturn this.css(\'display\', \'none\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Slices the current set.\n
\t\t *\n
\t\t * @method slice\n
\t\t * @param {Number} start Start index to slice at.\n
\t\t * @param {Number} end Optional ened index to end slice at.\n
\t\t * @return {tinymce.dom.DomQuery} Sliced set.\n
\t\t */\n
\t\tslice: function() {\n
\t\t\treturn new DomQuery(slice.apply(this, arguments));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Makes the set equal to the specified index.\n
\t\t *\n
\t\t * @method eq\n
\t\t * @param {Number} index Index to set it equal to.\n
\t\t * @return {tinymce.dom.DomQuery} Single item set.\n
\t\t */\n
\t\teq: function(index) {\n
\t\t\treturn index === -1 ? this.slice(index) : this.slice(index, +index + 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Makes the set equal to first element in set.\n
\t\t *\n
\t\t * @method first\n
\t\t * @return {tinymce.dom.DomQuery} Single item set.\n
\t\t */\n
\t\tfirst: function() {\n
\t\t\treturn this.eq(0);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Makes the set equal to last element in set.\n
\t\t *\n
\t\t * @method last\n
\t\t * @return {tinymce.dom.DomQuery} Single item set.\n
\t\t */\n
\t\tlast: function() {\n
\t\t\treturn this.eq(-1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Finds elements by the specified selector for each element in set.\n
\t\t *\n
\t\t * @method find\n
\t\t * @param {String} selector Selector to find elements by.\n
\t\t * @return {tinymce.dom.DomQuery} Set with matches elements.\n
\t\t */\n
\t\tfind: function(selector) {\n
\t\t\tvar i, l, ret = [];\n
\n
\t\t\tfor (i = 0, l = this.length; i < l; i++) {\n
\t\t\t\tDomQuery.find(selector, this[i], ret);\n
\t\t\t}\n
\n
\t\t\treturn DomQuery(ret);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Filters the current set with the specified selector.\n
\t\t *\n
\t\t * @method filter\n
\t\t * @param {String/function} selector Selector to filter elements by.\n
\t\t * @return {tinymce.dom.DomQuery} Set with filtered elements.\n
\t\t */\n
\t\tfilter: function(selector) {\n
\t\t\tif (typeof selector == \'function\') {\n
\t\t\t\treturn DomQuery(grep(this.toArray(), function(item, i) {\n
\t\t\t\t\treturn selector(i, item);\n
\t\t\t\t}));\n
\t\t\t}\n
\n
\t\t\treturn DomQuery(DomQuery.filter(selector, this.toArray()));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets the current node or any partent matching the specified selector.\n
\t\t *\n
\t\t * @method closest\n
\t\t * @param {String/Element/tinymce.dom.DomQuery} selector Selector or element to find.\n
\t\t * @return {tinymce.dom.DomQuery} Set with closest elements.\n
\t\t */\n
\t\tclosest: function(selector) {\n
\t\t\tvar result = [];\n
\n
\t\t\tif (selector instanceof DomQuery) {\n
\t\t\t\tselector = selector[0];\n
\t\t\t}\n
\n
\t\t\tthis.each(function(i, node) {\n
\t\t\t\twhile (node) {\n
\t\t\t\t\tif (typeof selector == \'string\' && DomQuery(node).is(selector)) {\n
\t\t\t\t\t\tresult.push(node);\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t} else if (node == selector) {\n
\t\t\t\t\t\tresult.push(node);\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn DomQuery(result);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the offset of the first element in set or sets the top/left css properties of all elements in set.\n
\t\t *\n
\t\t * @method offset\n
\t\t * @param {Object} offset Optional offset object to set on each item.\n
\t\t * @return {Object/tinymce.dom.DomQuery} Returns the first element offset or the current set if you specified an offset.\n
\t\t */\n
\t\toffset: function(offset) {\n
\t\t\tvar elm, doc, docElm;\n
\t\t\tvar x = 0, y = 0, pos;\n
\n
\t\t\tif (!offset) {\n
\t\t\t\telm = this[0];\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\tdoc = elm.ownerDocument;\n
\t\t\t\t\tdocElm = doc.documentElement;\n
\n
\t\t\t\t\tif (elm.getBoundingClientRect) {\n
\t\t\t\t\t\tpos = elm.getBoundingClientRect();\n
\t\t\t\t\t\tx = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;\n
\t\t\t\t\t\ty = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn {\n
\t\t\t\t\tleft: x,\n
\t\t\t\t\ttop: y\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\treturn this.css(offset);\n
\t\t},\n
\n
\t\tpush: push,\n
\t\tsort: [].sort,\n
\t\tsplice: [].splice\n
\t};\n
\n
\t// Static members\n
\tTools.extend(DomQuery, {\n
\t\t/**\n
\t\t * Extends the specified object with one or more objects.\n
\t\t *\n
\t\t * @static\n
\t\t * @method extend\n
\t\t * @param {Object} target Target object to extend with new items.\n
\t\t * @param {Object..} object Object to extend the target with.\n
\t\t * @return {Object} Extended input object.\n
\t\t */\n
\t\textend: Tools.extend,\n
\n
\t\t/**\n
\t\t * Creates an array out of an array like object.\n
\t\t *\n
\t\t * @static\n
\t\t * @method makeArray\n
\t\t * @param {Object} object Object to convert to array.\n
\t\t * @return {Arrau} Array produced from object.\n
\t\t */\n
\t\tmakeArray: function(array) {\n
\t\t\tif (isWindow(array) || array.nodeType) {\n
\t\t\t\treturn [array];\n
\t\t\t}\n
\n
\t\t\treturn Tools.toArray(array);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the index of the specified item inside the array.\n
\t\t *\n
\t\t * @static\n
\t\t * @method inArray\n
\t\t * @param {Object} item Item to look for.\n
\t\t * @param {Array} array Array to look for item in.\n
\t\t * @return {Number} Index of the item or -1.\n
\t\t */\n
\t\tinArray: inArray,\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified object is an array or not.\n
\t\t *\n
\t\t * @static\n
\t\t * @method isArray\n
\t\t * @param {Object} array Object to check if it\'s an array or not.\n
\t\t * @return {Boolean} True/false if the object is an array.\n
\t\t */\n
\t\tisArray: Tools.isArray,\n
\n
\t\t/**\n
\t\t * Executes the callback function for each item in array/object. If you return false in the\n
\t\t * callback it will break the loop.\n
\t\t *\n
\t\t * @static\n
\t\t * @method each\n
\t\t * @param {Object} obj Object to iterate.\n
\t\t * @param {function} callback Callback function to execute for each item.\n
\t\t */\n
\t\teach: each,\n
\n
\t\t/**\n
\t\t * Removes whitespace from the beginning and end of a string.\n
\t\t *\n
\t\t * @static\n
\t\t * @method trim\n
\t\t * @param {String} str String to remove whitespace from.\n
\t\t * @return {String} New string with removed whitespace.\n
\t\t */\n
\t\ttrim: trim,\n
\n
\t\t/**\n
\t\t * Filters out items from the input array by calling the specified function for each item.\n
\t\t * If the function returns false the item will be excluded if it returns true it will be included.\n
\t\t *\n
\t\t * @static\n
\t\t * @method grep\n
\t\t * @param {Array} array Array of items to loop though.\n
\t\t * @param {function} callback Function to call for each item. Include/exclude depends on it\'s return value.\n
\t\t * @return {Array} New array with values imported and filtered based in input.\n
\t\t * @example\n
\t\t * // Filter out some items, this will return an array with 4 and 5\n
\t\t * var items = DomQuery.grep([1, 2, 3, 4, 5], function(v) {return v > 3;});\n
\t\t */\n
\t\tgrep: grep,\n
\n
\t\t// Sizzle\n
\t\tfind: Sizzle,\n
\t\texpr: Sizzle.selectors,\n
\t\tunique: Sizzle.uniqueSort,\n
\t\ttext: Sizzle.getText,\n
\t\tcontains: Sizzle.contains,\n
\t\tfilter: function(expr, elems, not) {\n
\t\t\tvar i = elems.length;\n
\n
\t\t\tif (not) {\n
\t\t\t\texpr = ":not(" + expr + ")";\n
\t\t\t}\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tif (elems[i].nodeType != 1) {\n
\t\t\t\t\telems.splice(i, 1);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (elems.length === 1) {\n
\t\t\t\telems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];\n
\t\t\t} else {\n
\t\t\t\telems = DomQuery.find.matches(expr, elems);\n
\t\t\t}\n
\n
\t\t\treturn elems;\n
\t\t}\n
\t});\n
\n
\tfunction dir(el, prop, until) {\n
\t\tvar matched = [], cur = el[prop];\n
\n
\t\tif (typeof until != \'string\' && until instanceof DomQuery) {\n
\t\t\tuntil = until[0];\n
\t\t}\n
\n
\t\twhile (cur && cur.nodeType !== 9) {\n
\t\t\tif (until !== undefined) {\n
\t\t\t\tif (cur === until) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tif (typeof until == \'string\' && DomQuery(cur).is(until)) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (cur.nodeType === 1) {\n
\t\t\t\tmatched.push(cur);\n
\t\t\t}\n
\n
\t\t\tcur = cur[prop];\n
\t\t}\n
\n
\t\treturn matched;\n
\t}\n
\n
\tfunction sibling(node, siblingName, nodeType, until) {\n
\t\tvar result = [];\n
\n
\t\tif (until instanceof DomQuery) {\n
\t\t\tuntil = until[0];\n
\t\t}\n
\n
\t\tfor (; node; node = node[siblingName]) {\n
\t\t\tif (nodeType && node.nodeType !== nodeType) {\n
\t\t\t\tcontinue;\n
\t\t\t}\n
\n
\t\t\tif (until !== undefined) {\n
\t\t\t\tif (node === until) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tif (typeof until == \'string\' && DomQuery(node).is(until)) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tresult.push(node);\n
\t\t}\n
\n
\t\treturn result;\n
\t}\n
\n
\tfunction firstSibling(node, siblingName, nodeType) {\n
\t\tfor (node = node[siblingName]; node; node = node[siblingName]) {\n
\t\t\tif (node.nodeType == nodeType) {\n
\t\t\t\treturn node;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn null;\n
\t}\n
\n
\teach({\n
\t\t/**\n
\t\t * Returns a new collection with the parent of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method parent\n
\t\t * @param {String} selector Selector to match parents agains.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.\n
\t\t */\n
\t\tparent: function(node) {\n
\t\t\tvar parent = node.parentNode;\n
\n
\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection with the all the parents of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method parents\n
\t\t * @param {String} selector Selector to match parents agains.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.\n
\t\t */\n
\t\tparents: function(node) {\n
\t\t\treturn dir(node, "parentNode");\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection with next sibling of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method next\n
\t\t * @param {String} selector Selector to match the next element against.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tnext: function(node) {\n
\t\t\treturn firstSibling(node, \'nextSibling\', 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection with previous sibling of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method prev\n
\t\t * @param {String} selector Selector to match the previous element against.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tprev: function(node) {\n
\t\t\treturn firstSibling(node, \'previousSibling\', 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns all child elements matching the optional selector.\n
\t\t *\n
\t\t * @method children\n
\t\t * @param {String} selector Selector to match the elements against.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tchildren: function(node) {\n
\t\t\treturn sibling(node.firstChild, \'nextSibling\', 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns all child nodes matching the optional selector.\n
\t\t *\n
\t\t * @method contents\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tcontents: function(node) {\n
\t\t\treturn Tools.toArray((node.nodeName === "iframe" ? node.contentDocument || node.contentWindow.document : node).childNodes);\n
\t\t}\n
\t}, function(name, fn) {\n
\t\tDomQuery.fn[name] = function(selector) {\n
\t\t\tvar self = this, result = [];\n
\n
\t\t\tself.each(function() {\n
\t\t\t\tvar nodes = fn.call(result, this, selector, result);\n
\n
\t\t\t\tif (nodes) {\n
\t\t\t\t\tif (DomQuery.isArray(nodes)) {\n
\t\t\t\t\t\tresult.push.apply(result, nodes);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tresult.push(nodes);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// If traversing on multiple elements we might get the same elements twice\n
\t\t\tif (this.length > 1) {\n
\t\t\t\tresult = DomQuery.unique(result);\n
\n
\t\t\t\tif (name.indexOf(\'parents\') === 0) {\n
\t\t\t\t\tresult = result.reverse();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tresult = DomQuery(result);\n
\n
\t\t\tif (selector) {\n
\t\t\t\treturn result.filter(selector);\n
\t\t\t}\n
\n
\t\t\treturn result;\n
\t\t};\n
\t});\n
\n
\teach({\n
\t\t/**\n
\t\t * Returns a new collection with the all the parents until the matching selector/element\n
\t\t * of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method parentsUntil\n
\t\t * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.\n
\t\t */\n
\t\tparentsUntil: function(node, until) {\n
\t\t\treturn dir(node, "parentNode", until);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection with all next siblings of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method nextUntil\n
\t\t * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tnextUntil: function(node, until) {\n
\t\t\treturn sibling(node, \'nextSibling\', 1, until).slice(1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection with all previous siblings of each item in current collection matching the optional selector.\n
\t\t *\n
\t\t * @method prevUntil\n
\t\t * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.\n
\t\t * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.\n
\t\t */\n
\t\tprevUntil: function(node, until) {\n
\t\t\treturn sibling(node, \'previousSibling\', 1, until).slice(1);\n
\t\t}\n
\t}, function(name, fn) {\n
\t\tDomQuery.fn[name] = function(selector, filter) {\n
\t\t\tvar self = this, result = [];\n
\n
\t\t\tself.each(function() {\n
\t\t\t\tvar nodes = fn.call(result, this, selector, result);\n
\n
\t\t\t\tif (nodes) {\n
\t\t\t\t\tif (DomQuery.isArray(nodes)) {\n
\t\t\t\t\t\tresult.push.apply(result, nodes);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tresult.push(nodes);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// If traversing on multiple elements we might get the same elements twice\n
\t\t\tif (this.length > 1) {\n
\t\t\t\tresult = DomQuery.unique(result);\n
\n
\t\t\t\tif (name.indexOf(\'parents\') === 0 || name === \'prevUntil\') {\n
\t\t\t\t\tresult = result.reverse();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tresult = DomQuery(result);\n
\n
\t\t\tif (filter) {\n
\t\t\t\treturn result.filter(filter);\n
\t\t\t}\n
\n
\t\t\treturn result;\n
\t\t};\n
\t});\n
\n
\t/**\n
\t * Returns true/false if the current set items matches the selector.\n
\t *\n
\t * @method is\n
\t * @param {String} selector Selector to match the elements against.\n
\t * @return {Boolean} True/false if the current set matches the selector.\n
\t */\n
\tDomQuery.fn.is = function(selector) {\n
\t\treturn !!selector && this.filter(selector).length > 0;\n
\t};\n
\n
\tDomQuery.fn.init.prototype = DomQuery.fn;\n
\n
\tDomQuery.overrideDefaults = function(callback) {\n
\t\tvar defaults;\n
\n
\t\tfunction sub(selector, context) {\n
\t\t\tdefaults = defaults || callback();\n
\n
\t\t\tif (arguments.length === 0) {\n
\t\t\t\tselector = defaults.element;\n
\t\t\t}\n
\n
\t\t\tif (!context) {\n
\t\t\t\tcontext = defaults.context;\n
\t\t\t}\n
\n
\t\t\treturn new sub.fn.init(selector, context);\n
\t\t}\n
\n
\t\tDomQuery.extend(sub, this);\n
\n
\t\treturn sub;\n
\t};\n
\n
\tfunction appendHooks(targetHooks, prop, hooks) {\n
\t\teach(hooks, function(name, func) {\n
\t\t\ttargetHooks[name] = targetHooks[name] || {};\n
\t\t\ttargetHooks[name][prop] = func;\n
\t\t});\n
\t}\n
\n
\tif (Env.ie && Env.ie < 8) {\n
\t\tappendHooks(attrHooks, \'get\', {\n
\t\t\tmaxlength: function(elm) {\n
\t\t\t\tvar value = elm.maxLength;\n
\n
\t\t\t\tif (value === 0x7fffffff) {\n
\t\t\t\t\treturn undef;\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t},\n
\n
\t\t\tsize: function(elm) {\n
\t\t\t\tvar value = elm.size;\n
\n
\t\t\t\tif (value === 20) {\n
\t\t\t\t\treturn undef;\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t},\n
\n
\t\t\t\'class\': function(elm) {\n
\t\t\t\treturn elm.className;\n
\t\t\t},\n
\n
\t\t\tstyle: function(elm) {\n
\t\t\t\tvar value = elm.style.cssText;\n
\n
\t\t\t\tif (value.length === 0) {\n
\t\t\t\t\treturn undef;\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t}\n
\t\t});\n
\n
\t\tappendHooks(attrHooks, \'set\', {\n
\t\t\t\'class\': function(elm, value) {\n
\t\t\t\telm.className = value;\n
\t\t\t},\n
\n
\t\t\tstyle: function(elm, value) {\n
\t\t\t\telm.style.cssText = value;\n
\t\t\t}\n
\t\t});\n
\t}\n
\n
\tif (Env.ie && Env.ie < 9) {\n
\t\t/*jshint sub:true */\n
\t\t/*eslint dot-notation: 0*/\n
\t\tcssFix[\'float\'] = \'styleFloat\';\n
\n
\t\tappendHooks(cssHooks, \'set\', {\n
\t\t\topacity: function(elm, value) {\n
\t\t\t\tvar style = elm.style;\n
\n
\t\t\t\tif (value === null || value === \'\') {\n
\t\t\t\t\tstyle.removeAttribute(\'filter\');\n
\t\t\t\t} else {\n
\t\t\t\t\tstyle.zoom = 1;\n
\t\t\t\t\tstyle.filter = \'alpha(opacity=\' + (value * 100) + \')\';\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\t}\n
\n
\tDomQuery.attrHooks = attrHooks;\n
\tDomQuery.cssHooks = cssHooks;\n
\n
\treturn DomQuery;\n
});\n
\n
// Included from: js/tinymce/classes/html/Styles.js\n
\n
/**\n
 * Styles.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to parse CSS styles it also compresses styles to reduce the output size.\n
 *\n
 * @example\n
 * var Styles = new tinymce.html.Styles({\n
 *    url_converter: function(url) {\n
 *       return url;\n
 *    }\n
 * });\n
 *\n
 * styles = Styles.parse(\'border: 1px solid red\');\n
 * styles.color = \'red\';\n
 *\n
 * console.log(new tinymce.html.StyleSerializer().serialize(styles));\n
 *\n
 * @class tinymce.html.Styles\n
 * @version 3.4\n
 */\n
define("tinymce/html/Styles", [], function() {\n
\treturn function(settings, schema) {\n
\t\t/*jshint maxlen:255 */\n
\t\t/*eslint max-len:0 */\n
\t\tvar rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi,\n
\t\t\turlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\"([^\\"]+)\\"\\s*\\))|(?:\\(\\s*\\\'([^\\\']+)\\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\\'([^\\\']+)\\\')|(?:\\"([^\\"]+)\\")/gi,\n
\t\t\tstyleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g,\n
\t\t\ttrimRightRegExp = /\\s+$/,\n
\t\t\tundef, i, encodingLookup = {}, encodingItems, validStyles, invalidStyles, invisibleChar = \'\\uFEFF\';\n
\n
\t\tsettings = settings || {};\n
\n
\t\tif (schema) {\n
\t\t\tvalidStyles = schema.getValidStyles();\n
\t\t\tinvalidStyles = schema.getInvalidStyles();\n
\t\t}\n
\n
\t\tencodingItems = (\'\\\\" \\\\\\\' \\\\; \\\\: ; : \' + invisibleChar).split(\' \');\n
\t\tfor (i = 0; i < encodingItems.length; i++) {\n
\t\t\tencodingLookup[encodingItems[i]] = invisibleChar + i;\n
\t\t\tencodingLookup[invisibleChar + i] = encodingItems[i];\n
\t\t}\n
\n
\t\tfunction toHex(match, r, g, b) {\n
\t\t\tfunction hex(val) {\n
\t\t\t\tval = parseInt(val, 10).toString(16);\n
\n
\t\t\t\treturn val.length > 1 ? val : \'0\' + val; // 0 -> 00\n
\t\t\t}\n
\n
\t\t\treturn \'#\' + hex(r) + hex(g) + hex(b);\n
\t\t}\n
\n
\t\treturn {\n
\t\t\t/**\n
\t\t\t * Parses the specified RGB color value and returns a hex version of that color.\n
\t\t\t *\n
\t\t\t * @method toHex\n
\t\t\t * @param {String} color RGB string value like rgb(1,2,3)\n
\t\t\t * @return {String} Hex version of that RGB value like #FF00FF.\n
\t\t\t */\n
\t\t\ttoHex: function(color) {\n
\t\t\t\treturn color.replace(rgbRegExp, toHex);\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Parses the specified style value into an object collection. This parser will also\n
\t\t\t * merge and remove any redundant items that browsers might have added. It will also convert non hex\n
\t\t\t * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.\n
\t\t\t *\n
\t\t\t * @method parse\n
\t\t\t * @param {String} css Style value to parse for example: border:1px solid red;.\n
\t\t\t * @return {Object} Object representation of that style like {border: \'1px solid red\'}\n
\t\t\t */\n
\t\t\tparse: function(css) {\n
\t\t\t\tvar styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter;\n
\t\t\t\tvar urlConverterScope = settings.url_converter_scope || this;\n
\n
\t\t\t\tfunction compress(prefix, suffix, noJoin) {\n
\t\t\t\t\tvar top, right, bottom, left;\n
\n
\t\t\t\t\ttop = styles[prefix + \'-top\' + suffix];\n
\t\t\t\t\tif (!top) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tright = styles[prefix + \'-right\' + suffix];\n
\t\t\t\t\tif (!right) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tbottom = styles[prefix + \'-bottom\' + suffix];\n
\t\t\t\t\tif (!bottom) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tleft = styles[prefix + \'-left\' + suffix];\n
\t\t\t\t\tif (!left) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tvar box = [top, right, bottom, left];\n
\t\t\t\t\ti = box.length - 1;\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tif (box[i] !== box[i + 1]) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (i > -1 && noJoin) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstyles[prefix + suffix] = i == -1 ? box[0] : box.join(\' \');\n
\t\t\t\t\tdelete styles[prefix + \'-top\' + suffix];\n
\t\t\t\t\tdelete styles[prefix + \'-right\' + suffix];\n
\t\t\t\t\tdelete styles[prefix + \'-bottom\' + suffix];\n
\t\t\t\t\tdelete styles[prefix + \'-left\' + suffix];\n
\t\t\t\t}\n
\n
\t\t\t\t/**\n
\t\t\t\t * Checks if the specific style can be compressed in other words if all border-width are equal.\n
\t\t\t\t */\n
\t\t\t\tfunction canCompress(key) {\n
\t\t\t\t\tvar value = styles[key], i;\n
\n
\t\t\t\t\tif (!value) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tvalue = value.split(\' \');\n
\t\t\t\t\ti = value.length;\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tif (value[i] !== value[0]) {\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstyles[key] = value[0];\n
\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t/**\n
\t\t\t\t * Compresses multiple styles into one style.\n
\t\t\t\t */\n
\t\t\t\tfunction compress2(target, a, b, c) {\n
\t\t\t\t\tif (!canCompress(a)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!canCompress(b)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!canCompress(c)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Compress\n
\t\t\t\t\tstyles[target] = styles[a] + \' \' + styles[b] + \' \' + styles[c];\n
\t\t\t\t\tdelete styles[a];\n
\t\t\t\t\tdelete styles[b];\n
\t\t\t\t\tdelete styles[c];\n
\t\t\t\t}\n
\n
\t\t\t\t// Encodes the specified string by replacing all \\" \\\' ; : with _<num>\n
\t\t\t\tfunction encode(str) {\n
\t\t\t\t\tisEncoded = true;\n
\n
\t\t\t\t\treturn encodingLookup[str];\n
\t\t\t\t}\n
\n
\t\t\t\t// Decodes the specified string by replacing all _<num> with it\'s original value \\" \\\' etc\n
\t\t\t\t// It will also decode the \\" \\\' if keep_slashes is set to fale or omitted\n
\t\t\t\tfunction decode(str, keep_slashes) {\n
\t\t\t\t\tif (isEncoded) {\n
\t\t\t\t\t\tstr = str.replace(/\\uFEFF[0-9]/g, function(str) {\n
\t\t\t\t\t\t\treturn encodingLookup[str];\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!keep_slashes) {\n
\t\t\t\t\t\tstr = str.replace(/\\\\([\\\'\\";:])/g, "$1");\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn str;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction processUrl(match, url, url2, url3, str, str2) {\n
\t\t\t\t\tstr = str || str2;\n
\n
\t\t\t\t\tif (str) {\n
\t\t\t\t\t\tstr = decode(str);\n
\n
\t\t\t\t\t\t// Force strings into single quote format\n
\t\t\t\t\t\treturn "\'" + str.replace(/\\\'/g, "\\\\\'") + "\'";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\turl = decode(url || url2 || url3);\n
\n
\t\t\t\t\tif (!settings.allow_script_urls) {\n
\t\t\t\t\t\tvar scriptUrl = url.replace(/[\\s\\r\\n]+/, \'\');\n
\n
\t\t\t\t\t\tif (/(java|vb)script:/i.test(scriptUrl)) {\n
\t\t\t\t\t\t\treturn "";\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n
\t\t\t\t\t\t\treturn "";\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Convert the URL to relative/absolute depending on config\n
\t\t\t\t\tif (urlConverter) {\n
\t\t\t\t\t\turl = urlConverter.call(urlConverterScope, url, \'style\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Output new URL format\n
\t\t\t\t\treturn "url(\'" + url.replace(/\\\'/g, "\\\\\'") + "\')";\n
\t\t\t\t}\n
\n
\t\t\t\tif (css) {\n
\t\t\t\t\tcss = css.replace(/[\\u0000-\\u001F]/g, \'\');\n
\n
\t\t\t\t\t// Encode \\" \\\' % and ; and : inside strings so they don\'t interfere with the style parsing\n
\t\t\t\t\tcss = css.replace(/\\\\[\\"\\\';:\\uFEFF]/g, encode).replace(/\\"[^\\"]+\\"|\\\'[^\\\']+\\\'/g, function(str) {\n
\t\t\t\t\t\treturn str.replace(/[;:]/g, encode);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Parse styles\n
\t\t\t\t\twhile ((matches = styleRegExp.exec(css))) {\n
\t\t\t\t\t\tname = matches[1].replace(trimRightRegExp, \'\').toLowerCase();\n
\t\t\t\t\t\tvalue = matches[2].replace(trimRightRegExp, \'\');\n
\n
\t\t\t\t\t\t// Decode escaped sequences like \\65 -> e\n
\t\t\t\t\t\t/*jshint loopfunc:true*/\n
\t\t\t\t\t\t/*eslint no-loop-func:0 */\n
\t\t\t\t\t\tvalue = value.replace(/\\\\[0-9a-f]+/g, function(e) {\n
\t\t\t\t\t\t\treturn String.fromCharCode(parseInt(e.substr(1), 16));\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\tif (name && value.length > 0) {\n
\t\t\t\t\t\t\t// Don\'t allow behavior name or expression/comments within the values\n
\t\t\t\t\t\t\tif (!settings.allow_script_urls && (name == "behavior" || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n
\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Opera will produce 700 instead of bold in their style values\n
\t\t\t\t\t\t\tif (name === \'font-weight\' && value === \'700\') {\n
\t\t\t\t\t\t\t\tvalue = \'bold\';\n
\t\t\t\t\t\t\t} else if (name === \'color\' || name === \'background-color\') { // Lowercase colors like RED\n
\t\t\t\t\t\t\t\tvalue = value.toLowerCase();\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Convert RGB colors to HEX\n
\t\t\t\t\t\t\tvalue = value.replace(rgbRegExp, toHex);\n
\n
\t\t\t\t\t\t\t// Convert URLs and force them into url(\'value\') format\n
\t\t\t\t\t\t\tvalue = value.replace(urlOrStrRegExp, processUrl);\n
\t\t\t\t\t\t\tstyles[name] = isEncoded ? decode(value, true) : value;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tstyleRegExp.lastIndex = matches.index + matches[0].length;\n
\t\t\t\t\t}\n
\t\t\t\t\t// Compress the styles to reduce it\'s size for example IE will expand styles\n
\t\t\t\t\tcompress("border", "", true);\n
\t\t\t\t\tcompress("border", "-width");\n
\t\t\t\t\tcompress("border", "-color");\n
\t\t\t\t\tcompress("border", "-style");\n
\t\t\t\t\tcompress("padding", "");\n
\t\t\t\t\tcompress("margin", "");\n
\t\t\t\t\tcompress2(\'border\', \'border-width\', \'border-style\', \'border-color\');\n
\n
\t\t\t\t\t// Remove pointless border, IE produces these\n
\t\t\t\t\tif (styles.border === \'medium none\') {\n
\t\t\t\t\t\tdelete styles.border;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>\n
\t\t\t\t\t// So lets asume it shouldn\'t be there\n
\t\t\t\t\tif (styles[\'border-image\'] === \'none\') {\n
\t\t\t\t\t\tdelete styles[\'border-image\'];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn styles;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Serializes the specified style object into a string.\n
\t\t\t *\n
\t\t\t * @method serialize\n
\t\t\t * @param {Object} styles Object to serialize as string for example: {border: \'1px solid red\'}\n
\t\t\t * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.\n
\t\t\t * @return {String} String representation of the style object for example: border: 1px solid red.\n
\t\t\t */\n
\t\t\tserialize: function(styles, elementName) {\n
\t\t\t\tvar css = \'\', name, value;\n
\n
\t\t\t\tfunction serializeStyles(name) {\n
\t\t\t\t\tvar styleList, i, l, value;\n
\n
\t\t\t\t\tstyleList = validStyles[name];\n
\t\t\t\t\tif (styleList) {\n
\t\t\t\t\t\tfor (i = 0, l = styleList.length; i < l; i++) {\n
\t\t\t\t\t\t\tname = styleList[i];\n
\t\t\t\t\t\t\tvalue = styles[name];\n
\n
\t\t\t\t\t\t\tif (value !== undef && value.length > 0) {\n
\t\t\t\t\t\t\t\tcss += (css.length > 0 ? \' \' : \'\') + name + \': \' + value + \';\';\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction isValid(name, elementName) {\n
\t\t\t\t\tvar styleMap;\n
\n
\t\t\t\t\tstyleMap = invalidStyles[\'*\'];\n
\t\t\t\t\tif (styleMap && styleMap[name]) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstyleMap = invalidStyles[elementName];\n
\t\t\t\t\tif (styleMap && styleMap[name]) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Serialize styles according to schema\n
\t\t\t\tif (elementName && validStyles) {\n
\t\t\t\t\t// Serialize global styles and element specific styles\n
\t\t\t\t\tserializeStyles(\'*\');\n
\t\t\t\t\tserializeStyles(elementName);\n
\t\t\t\t} else {\n
\t\t\t\t\t// Output the styles in the order they are inside the object\n
\t\t\t\t\tfor (name in styles) {\n
\t\t\t\t\t\tvalue = styles[name];\n
\n
\t\t\t\t\t\tif (value !== undef && value.length > 0) {\n
\t\t\t\t\t\t\tif (!invalidStyles || isValid(name, elementName)) {\n
\t\t\t\t\t\t\t\tcss += (css.length > 0 ? \' \' : \'\') + name + \': \' + value + \';\';\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn css;\n
\t\t\t}\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/TreeWalker.js\n
\n
/**\n
 * TreeWalker.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * TreeWalker class enables you to walk the DOM in a linear manner.\n
 *\n
 * @class tinymce.dom.TreeWalker\n
 * @example\n
 * var walker = new tinymce.dom.TreeWalker(startNode);\n
 *\n
 * do {\n
 *     console.log(walker.current());\n
 * } while (walker.next());\n
 */\n
define("tinymce/dom/TreeWalker", [], function() {\n
\t/**\n
\t * Constructs a new TreeWalker instance.\n
\t *\n
\t * @constructor\n
\t * @method TreeWalker\n
\t * @param {Node} startNode Node to start walking from.\n
\t * @param {node} rootNode Optional root node to never walk out of.\n
\t */\n
\treturn function(startNode, rootNode) {\n
\t\tvar node = startNode;\n
\n
\t\tfunction findSibling(node, startName, siblingName, shallow) {\n
\t\t\tvar sibling, parent;\n
\n
\t\t\tif (node) {\n
\t\t\t\t// Walk into nodes if it has a start\n
\t\t\t\tif (!shallow && node[startName]) {\n
\t\t\t\t\treturn node[startName];\n
\t\t\t\t}\n
\n
\t\t\t\t// Return the sibling if it has one\n
\t\t\t\tif (node != rootNode) {\n
\t\t\t\t\tsibling = node[siblingName];\n
\t\t\t\t\tif (sibling) {\n
\t\t\t\t\t\treturn sibling;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Walk up the parents to look for siblings\n
\t\t\t\t\tfor (parent = node.parentNode; parent && parent != rootNode; parent = parent.parentNode) {\n
\t\t\t\t\t\tsibling = parent[siblingName];\n
\t\t\t\t\t\tif (sibling) {\n
\t\t\t\t\t\t\treturn sibling;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the current node.\n
\t\t *\n
\t\t * @method current\n
\t\t * @return {Node} Current node where the walker is.\n
\t\t */\n
\t\tthis.current = function() {\n
\t\t\treturn node;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Walks to the next node in tree.\n
\t\t *\n
\t\t * @method next\n
\t\t * @return {Node} Current node where the walker is after moving to the next node.\n
\t\t */\n
\t\tthis.next = function(shallow) {\n
\t\t\tnode = findSibling(node, \'firstChild\', \'nextSibling\', shallow);\n
\t\t\treturn node;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Walks to the previous node in tree.\n
\t\t *\n
\t\t * @method prev\n
\t\t * @return {Node} Current node where the walker is after moving to the previous node.\n
\t\t */\n
\t\tthis.prev = function(shallow) {\n
\t\t\tnode = findSibling(node, \'lastChild\', \'previousSibling\', shallow);\n
\t\t\treturn node;\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/Range.js\n
\n
/**\n
 * Range.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
define("tinymce/dom/Range", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\t// Range constructor\n
\tfunction Range(dom) {\n
\t\tvar self = this,\n
\t\t\tdoc = dom.doc,\n
\t\t\tEXTRACT = 0,\n
\t\t\tCLONE = 1,\n
\t\t\tDELETE = 2,\n
\t\t\tTRUE = true,\n
\t\t\tFALSE = false,\n
\t\t\tSTART_OFFSET = \'startOffset\',\n
\t\t\tSTART_CONTAINER = \'startContainer\',\n
\t\t\tEND_CONTAINER = \'endContainer\',\n
\t\t\tEND_OFFSET = \'endOffset\',\n
\t\t\textend = Tools.extend,\n
\t\t\tnodeIndex = dom.nodeIndex;\n
\n
\t\tfunction createDocumentFragment() {\n
\t\t\treturn doc.createDocumentFragment();\n
\t\t}\n
\n
\t\tfunction setStart(n, o) {\n
\t\t\t_setEndPoint(TRUE, n, o);\n
\t\t}\n
\n
\t\tfunction setEnd(n, o) {\n
\t\t\t_setEndPoint(FALSE, n, o);\n
\t\t}\n
\n
\t\tfunction setStartBefore(n) {\n
\t\t\tsetStart(n.parentNode, nodeIndex(n));\n
\t\t}\n
\n
\t\tfunction setStartAfter(n) {\n
\t\t\tsetStart(n.parentNode, nodeIndex(n) + 1);\n
\t\t}\n
\n
\t\tfunction setEndBefore(n) {\n
\t\t\tsetEnd(n.parentNode, nodeIndex(n));\n
\t\t}\n
\n
\t\tfunction setEndAfter(n) {\n
\t\t\tsetEnd(n.parentNode, nodeIndex(n) + 1);\n
\t\t}\n
\n
\t\tfunction collapse(ts) {\n
\t\t\tif (ts) {\n
\t\t\t\tself[END_CONTAINER] = self[START_CONTAINER];\n
\t\t\t\tself[END_OFFSET] = self[START_OFFSET];\n
\t\t\t} else {\n
\t\t\t\tself[START_CONTAINER] = self[END_CONTAINER];\n
\t\t\t\tself[START_OFFSET] = self[END_OFFSET];\n
\t\t\t}\n
\n
\t\t\tself.collapsed = TRUE;\n
\t\t}\n
\n
\t\tfunction selectNode(n) {\n
\t\t\tsetStartBefore(n);\n
\t\t\tsetEndAfter(n);\n
\t\t}\n
\n
\t\tfunction selectNodeContents(n) {\n
\t\t\tsetStart(n, 0);\n
\t\t\tsetEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);\n
\t\t}\n
\n
\t\tfunction compareBoundaryPoints(h, r) {\n
\t\t\tvar sc = self[START_CONTAINER], so = self[START_OFFSET], ec = self[END_CONTAINER], eo = self[END_OFFSET],\n
\t\t\trsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;\n
\n
\t\t\t// Check START_TO_START\n
\t\t\tif (h === 0) {\n
\t\t\t\treturn _compareBoundaryPoints(sc, so, rsc, rso);\n
\t\t\t}\n
\n
\t\t\t// Check START_TO_END\n
\t\t\tif (h === 1) {\n
\t\t\t\treturn _compareBoundaryPoints(ec, eo, rsc, rso);\n
\t\t\t}\n
\n
\t\t\t// Check END_TO_END\n
\t\t\tif (h === 2) {\n
\t\t\t\treturn _compareBoundaryPoints(ec, eo, rec, reo);\n
\t\t\t}\n
\n
\t\t\t// Check END_TO_START\n
\t\t\tif (h === 3) {\n
\t\t\t\treturn _compareBoundaryPoints(sc, so, rec, reo);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction deleteContents() {\n
\t\t\t_traverse(DELETE);\n
\t\t}\n
\n
\t\tfunction extractContents() {\n
\t\t\treturn _traverse(EXTRACT);\n
\t\t}\n
\n
\t\tfunction cloneContents() {\n
\t\t\treturn _traverse(CLONE);\n
\t\t}\n
\n
\t\tfunction insertNode(n) {\n
\t\t\tvar startContainer = this[START_CONTAINER],\n
\t\t\t\tstartOffset = this[START_OFFSET], nn, o;\n
\n
\t\t\t// Node is TEXT_NODE or CDATA\n
\t\t\tif ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {\n
\t\t\t\tif (!startOffset) {\n
\t\t\t\t\t// At the start of text\n
\t\t\t\t\tstartContainer.parentNode.insertBefore(n, startContainer);\n
\t\t\t\t} else if (startOffset >= startContainer.nodeValue.length) {\n
\t\t\t\t\t// At the end of text\n
\t\t\t\t\tdom.insertAfter(n, startContainer);\n
\t\t\t\t} else {\n
\t\t\t\t\t// Middle, need to split\n
\t\t\t\t\tnn = startContainer.splitText(startOffset);\n
\t\t\t\t\tstartContainer.parentNode.insertBefore(n, nn);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Insert element node\n
\t\t\t\tif (startContainer.childNodes.length > 0) {\n
\t\t\t\t\to = startContainer.childNodes[startOffset];\n
\t\t\t\t}\n
\n
\t\t\t\tif (o) {\n
\t\t\t\t\tstartContainer.insertBefore(n, o);\n
\t\t\t\t} else {\n
\t\t\t\t\tif (startContainer.nodeType == 3) {\n
\t\t\t\t\t\tdom.insertAfter(n, startContainer);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tstartContainer.appendChild(n);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction surroundContents(n) {\n
\t\t\tvar f = self.extractContents();\n
\n
\t\t\tself.insertNode(n);\n
\t\t\tn.appendChild(f);\n
\t\t\tself.selectNode(n);\n
\t\t}\n
\n
\t\tfunction cloneRange() {\n
\t\t\treturn extend(new Range(dom), {\n
\t\t\t\tstartContainer: self[START_CONTAINER],\n
\t\t\t\tstartOffset: self[START_OFFSET],\n
\t\t\t\tendContainer: self[END_CONTAINER],\n
\t\t\t\tendOffset: self[END_OFFSET],\n
\t\t\t\tcollapsed: self.collapsed,\n
\t\t\t\tcommonAncestorContainer: self.commonAncestorContainer\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Private methods\n
\n
\t\tfunction _getSelectedNode(container, offset) {\n
\t\t\tvar child;\n
\n
\t\t\tif (container.nodeType == 3 /* TEXT_NODE */) {\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\tif (offset < 0) {\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\tchild = container.firstChild;\n
\t\t\twhile (child && offset > 0) {\n
\t\t\t\t--offset;\n
\t\t\t\tchild = child.nextSibling;\n
\t\t\t}\n
\n
\t\t\tif (child) {\n
\t\t\t\treturn child;\n
\t\t\t}\n
\n
\t\t\treturn container;\n
\t\t}\n
\n
\t\tfunction _isCollapsed() {\n
\t\t\treturn (self[START_CONTAINER] == self[END_CONTAINER] && self[START_OFFSET] == self[END_OFFSET]);\n
\t\t}\n
\n
\t\tfunction _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {\n
\t\t\tvar c, offsetC, n, cmnRoot, childA, childB;\n
\n
\t\t\t// In the first case the boundary-points have the same container. A is before B\n
\t\t\t// if its offset is less than the offset of B, A is equal to B if its offset is\n
\t\t\t// equal to the offset of B, and A is after B if its offset is greater than the\n
\t\t\t// offset of B.\n
\t\t\tif (containerA == containerB) {\n
\t\t\t\tif (offsetA == offsetB) {\n
\t\t\t\t\treturn 0; // equal\n
\t\t\t\t}\n
\n
\t\t\t\tif (offsetA < offsetB) {\n
\t\t\t\t\treturn -1; // before\n
\t\t\t\t}\n
\n
\t\t\t\treturn 1; // after\n
\t\t\t}\n
\n
\t\t\t// In the second case a child node C of the container of A is an ancestor\n
\t\t\t// container of B. In this case, A is before B if the offset of A is less than or\n
\t\t\t// equal to the index of the child node C and A is after B otherwise.\n
\t\t\tc = containerB;\n
\t\t\twhile (c && c.parentNode != containerA) {\n
\t\t\t\tc = c.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (c) {\n
\t\t\t\toffsetC = 0;\n
\t\t\t\tn = containerA.firstChild;\n
\n
\t\t\t\twhile (n != c && offsetC < offsetA) {\n
\t\t\t\t\toffsetC++;\n
\t\t\t\t\tn = n.nextSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tif (offsetA <= offsetC) {\n
\t\t\t\t\treturn -1; // before\n
\t\t\t\t}\n
\n
\t\t\t\treturn 1; // after\n
\t\t\t}\n
\n
\t\t\t// In the third case a child node C of the container of B is an ancestor container\n
\t\t\t// of A. In this case, A is before B if the index of the child node C is less than\n
\t\t\t// the offset of B and A is after B otherwise.\n
\t\t\tc = containerA;\n
\t\t\twhile (c && c.parentNode != containerB) {\n
\t\t\t\tc = c.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (c) {\n
\t\t\t\toffsetC = 0;\n
\t\t\t\tn = containerB.firstChild;\n
\n
\t\t\t\twhile (n != c && offsetC < offsetB) {\n
\t\t\t\t\toffsetC++;\n
\t\t\t\t\tn = n.nextSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tif (offsetC < offsetB) {\n
\t\t\t\t\treturn -1; // before\n
\t\t\t\t}\n
\n
\t\t\t\treturn 1; // after\n
\t\t\t}\n
\n
\t\t\t// In the fourth case, none of three other cases hold: the containers of A and B\n
\t\t\t// are siblings or descendants of sibling nodes. In this case, A is before B if\n
\t\t\t// the container of A is before the container of B in a pre-order traversal of the\n
\t\t\t// Ranges\' context tree and A is after B otherwise.\n
\t\t\tcmnRoot = dom.findCommonAncestor(containerA, containerB);\n
\t\t\tchildA = containerA;\n
\n
\t\t\twhile (childA && childA.parentNode != cmnRoot) {\n
\t\t\t\tchildA = childA.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (!childA) {\n
\t\t\t\tchildA = cmnRoot;\n
\t\t\t}\n
\n
\t\t\tchildB = containerB;\n
\t\t\twhile (childB && childB.parentNode != cmnRoot) {\n
\t\t\t\tchildB = childB.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (!childB) {\n
\t\t\t\tchildB = cmnRoot;\n
\t\t\t}\n
\n
\t\t\tif (childA == childB) {\n
\t\t\t\treturn 0; // equal\n
\t\t\t}\n
\n
\t\t\tn = cmnRoot.firstChild;\n
\t\t\twhile (n) {\n
\t\t\t\tif (n == childA) {\n
\t\t\t\t\treturn -1; // before\n
\t\t\t\t}\n
\n
\t\t\t\tif (n == childB) {\n
\t\t\t\t\treturn 1; // after\n
\t\t\t\t}\n
\n
\t\t\t\tn = n.nextSibling;\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction _setEndPoint(st, n, o) {\n
\t\t\tvar ec, sc;\n
\n
\t\t\tif (st) {\n
\t\t\t\tself[START_CONTAINER] = n;\n
\t\t\t\tself[START_OFFSET] = o;\n
\t\t\t} else {\n
\t\t\t\tself[END_CONTAINER] = n;\n
\t\t\t\tself[END_OFFSET] = o;\n
\t\t\t}\n
\n
\t\t\t// If one boundary-point of a Range is set to have a root container\n
\t\t\t// other than the current one for the Range, the Range is collapsed to\n
\t\t\t// the new position. This enforces the restriction that both boundary-\n
\t\t\t// points of a Range must have the same root container.\n
\t\t\tec = self[END_CONTAINER];\n
\t\t\twhile (ec.parentNode) {\n
\t\t\t\tec = ec.parentNode;\n
\t\t\t}\n
\n
\t\t\tsc = self[START_CONTAINER];\n
\t\t\twhile (sc.parentNode) {\n
\t\t\t\tsc = sc.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (sc == ec) {\n
\t\t\t\t// The start position of a Range is guaranteed to never be after the\n
\t\t\t\t// end position. To enforce this restriction, if the start is set to\n
\t\t\t\t// be at a position after the end, the Range is collapsed to that\n
\t\t\t\t// position.\n
\t\t\t\tif (_compareBoundaryPoints(self[START_CONTAINER], self[START_OFFSET], self[END_CONTAINER], self[END_OFFSET]) > 0) {\n
\t\t\t\t\tself.collapse(st);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tself.collapse(st);\n
\t\t\t}\n
\n
\t\t\tself.collapsed = _isCollapsed();\n
\t\t\tself.commonAncestorContainer = dom.findCommonAncestor(self[START_CONTAINER], self[END_CONTAINER]);\n
\t\t}\n
\n
\t\tfunction _traverse(how) {\n
\t\t\tvar c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;\n
\n
\t\t\tif (self[START_CONTAINER] == self[END_CONTAINER]) {\n
\t\t\t\treturn _traverseSameContainer(how);\n
\t\t\t}\n
\n
\t\t\tfor (c = self[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\n
\t\t\t\tif (p == self[START_CONTAINER]) {\n
\t\t\t\t\treturn _traverseCommonStartContainer(c, how);\n
\t\t\t\t}\n
\n
\t\t\t\t++endContainerDepth;\n
\t\t\t}\n
\n
\t\t\tfor (c = self[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {\n
\t\t\t\tif (p == self[END_CONTAINER]) {\n
\t\t\t\t\treturn _traverseCommonEndContainer(c, how);\n
\t\t\t\t}\n
\n
\t\t\t\t++startContainerDepth;\n
\t\t\t}\n
\n
\t\t\tdepthDiff = startContainerDepth - endContainerDepth;\n
\n
\t\t\tstartNode = self[START_CONTAINER];\n
\t\t\twhile (depthDiff > 0) {\n
\t\t\t\tstartNode = startNode.parentNode;\n
\t\t\t\tdepthDiff--;\n
\t\t\t}\n
\n
\t\t\tendNode = self[END_CONTAINER];\n
\t\t\twhile (depthDiff < 0) {\n
\t\t\t\tendNode = endNode.parentNode;\n
\t\t\t\tdepthDiff++;\n
\t\t\t}\n
\n
\t\t\t// ascend the ancestor hierarchy until we have a common parent.\n
\t\t\tfor (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {\n
\t\t\t\tstartNode = sp;\n
\t\t\t\tendNode = ep;\n
\t\t\t}\n
\n
\t\t\treturn _traverseCommonAncestors(startNode, endNode, how);\n
\t\t}\n
\n
\t\tfunction _traverseSameContainer(how) {\n
\t\t\tvar frag, s, sub, n, cnt, sibling, xferNode, start, len;\n
\n
\t\t\tif (how != DELETE) {\n
\t\t\t\tfrag = createDocumentFragment();\n
\t\t\t}\n
\n
\t\t\t// If selection is empty, just return the fragment\n
\t\t\tif (self[START_OFFSET] == self[END_OFFSET]) {\n
\t\t\t\treturn frag;\n
\t\t\t}\n
\n
\t\t\t// Text node needs special case handling\n
\t\t\tif (self[START_CONTAINER].nodeType == 3 /* TEXT_NODE */) {\n
\t\t\t\t// get the substring\n
\t\t\t\ts = self[START_CONTAINER].nodeValue;\n
\t\t\t\tsub = s.substring(self[START_OFFSET], self[END_OFFSET]);\n
\n
\t\t\t\t// set the original text node to its new value\n
\t\t\t\tif (how != CLONE) {\n
\t\t\t\t\tn = self[START_CONTAINER];\n
\t\t\t\t\tstart = self[START_OFFSET];\n
\t\t\t\t\tlen = self[END_OFFSET] - self[START_OFFSET];\n
\n
\t\t\t\t\tif (start === 0 && len >= n.nodeValue.length - 1) {\n
\t\t\t\t\t\tn.parentNode.removeChild(n);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tn.deleteData(start, len);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Nothing is partially selected, so collapse to start point\n
\t\t\t\t\tself.collapse(TRUE);\n
\t\t\t\t}\n
\n
\t\t\t\tif (how == DELETE) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (sub.length > 0) {\n
\t\t\t\t\tfrag.appendChild(doc.createTextNode(sub));\n
\t\t\t\t}\n
\n
\t\t\t\treturn frag;\n
\t\t\t}\n
\n
\t\t\t// Copy nodes between the start/end offsets.\n
\t\t\tn = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]);\n
\t\t\tcnt = self[END_OFFSET] - self[START_OFFSET];\n
\n
\t\t\twhile (n && cnt > 0) {\n
\t\t\t\tsibling = n.nextSibling;\n
\t\t\t\txferNode = _traverseFullySelected(n, how);\n
\n
\t\t\t\tif (frag) {\n
\t\t\t\t\tfrag.appendChild(xferNode);\n
\t\t\t\t}\n
\n
\t\t\t\t--cnt;\n
\t\t\t\tn = sibling;\n
\t\t\t}\n
\n
\t\t\t// Nothing is partially selected, so collapse to start point\n
\t\t\tif (how != CLONE) {\n
\t\t\t\tself.collapse(TRUE);\n
\t\t\t}\n
\n
\t\t\treturn frag;\n
\t\t}\n
\n
\t\tfunction _traverseCommonStartContainer(endAncestor, how) {\n
\t\t\tvar frag, n, endIdx, cnt, sibling, xferNode;\n
\n
\t\t\tif (how != DELETE) {\n
\t\t\t\tfrag = cr

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAM=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="3" aka="AAAAAAAAAAM=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

eateDocumentFragment();\n
\t\t\t}\n
\n
\t\t\tn = _traverseRightBoundary(endAncestor, how);\n
\n
\t\t\tif (frag) {\n
\t\t\t\tfrag.appendChild(n);\n
\t\t\t}\n
\n
\t\t\tendIdx = nodeIndex(endAncestor);\n
\t\t\tcnt = endIdx - self[START_OFFSET];\n
\n
\t\t\tif (cnt <= 0) {\n
\t\t\t\t// Collapse to just before the endAncestor, which\n
\t\t\t\t// is partially selected.\n
\t\t\t\tif (how != CLONE) {\n
\t\t\t\t\tself.setEndBefore(endAncestor);\n
\t\t\t\t\tself.collapse(FALSE);\n
\t\t\t\t}\n
\n
\t\t\t\treturn frag;\n
\t\t\t}\n
\n
\t\t\tn = endAncestor.previousSibling;\n
\t\t\twhile (cnt > 0) {\n
\t\t\t\tsibling = n.previousSibling;\n
\t\t\t\txferNode = _traverseFullySelected(n, how);\n
\n
\t\t\t\tif (frag) {\n
\t\t\t\t\tfrag.insertBefore(xferNode, frag.firstChild);\n
\t\t\t\t}\n
\n
\t\t\t\t--cnt;\n
\t\t\t\tn = sibling;\n
\t\t\t}\n
\n
\t\t\t// Collapse to just before the endAncestor, which\n
\t\t\t// is partially selected.\n
\t\t\tif (how != CLONE) {\n
\t\t\t\tself.setEndBefore(endAncestor);\n
\t\t\t\tself.collapse(FALSE);\n
\t\t\t}\n
\n
\t\t\treturn frag;\n
\t\t}\n
\n
\t\tfunction _traverseCommonEndContainer(startAncestor, how) {\n
\t\t\tvar frag, startIdx, n, cnt, sibling, xferNode;\n
\n
\t\t\tif (how != DELETE) {\n
\t\t\t\tfrag = createDocumentFragment();\n
\t\t\t}\n
\n
\t\t\tn = _traverseLeftBoundary(startAncestor, how);\n
\t\t\tif (frag) {\n
\t\t\t\tfrag.appendChild(n);\n
\t\t\t}\n
\n
\t\t\tstartIdx = nodeIndex(startAncestor);\n
\t\t\t++startIdx; // Because we already traversed it\n
\n
\t\t\tcnt = self[END_OFFSET] - startIdx;\n
\t\t\tn = startAncestor.nextSibling;\n
\t\t\twhile (n && cnt > 0) {\n
\t\t\t\tsibling = n.nextSibling;\n
\t\t\t\txferNode = _traverseFullySelected(n, how);\n
\n
\t\t\t\tif (frag) {\n
\t\t\t\t\tfrag.appendChild(xferNode);\n
\t\t\t\t}\n
\n
\t\t\t\t--cnt;\n
\t\t\t\tn = sibling;\n
\t\t\t}\n
\n
\t\t\tif (how != CLONE) {\n
\t\t\t\tself.setStartAfter(startAncestor);\n
\t\t\t\tself.collapse(TRUE);\n
\t\t\t}\n
\n
\t\t\treturn frag;\n
\t\t}\n
\n
\t\tfunction _traverseCommonAncestors(startAncestor, endAncestor, how) {\n
\t\t\tvar n, frag, startOffset, endOffset, cnt, sibling, nextSibling;\n
\n
\t\t\tif (how != DELETE) {\n
\t\t\t\tfrag = createDocumentFragment();\n
\t\t\t}\n
\n
\t\t\tn = _traverseLeftBoundary(startAncestor, how);\n
\t\t\tif (frag) {\n
\t\t\t\tfrag.appendChild(n);\n
\t\t\t}\n
\n
\t\t\tstartOffset = nodeIndex(startAncestor);\n
\t\t\tendOffset = nodeIndex(endAncestor);\n
\t\t\t++startOffset;\n
\n
\t\t\tcnt = endOffset - startOffset;\n
\t\t\tsibling = startAncestor.nextSibling;\n
\n
\t\t\twhile (cnt > 0) {\n
\t\t\t\tnextSibling = sibling.nextSibling;\n
\t\t\t\tn = _traverseFullySelected(sibling, how);\n
\n
\t\t\t\tif (frag) {\n
\t\t\t\t\tfrag.appendChild(n);\n
\t\t\t\t}\n
\n
\t\t\t\tsibling = nextSibling;\n
\t\t\t\t--cnt;\n
\t\t\t}\n
\n
\t\t\tn = _traverseRightBoundary(endAncestor, how);\n
\n
\t\t\tif (frag) {\n
\t\t\t\tfrag.appendChild(n);\n
\t\t\t}\n
\n
\t\t\tif (how != CLONE) {\n
\t\t\t\tself.setStartAfter(startAncestor);\n
\t\t\t\tself.collapse(TRUE);\n
\t\t\t}\n
\n
\t\t\treturn frag;\n
\t\t}\n
\n
\t\tfunction _traverseRightBoundary(root, how) {\n
\t\t\tvar next = _getSelectedNode(self[END_CONTAINER], self[END_OFFSET] - 1), parent, clonedParent;\n
\t\t\tvar prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != self[END_CONTAINER];\n
\n
\t\t\tif (next == root) {\n
\t\t\t\treturn _traverseNode(next, isFullySelected, FALSE, how);\n
\t\t\t}\n
\n
\t\t\tparent = next.parentNode;\n
\t\t\tclonedParent = _traverseNode(parent, FALSE, FALSE, how);\n
\n
\t\t\twhile (parent) {\n
\t\t\t\twhile (next) {\n
\t\t\t\t\tprevSibling = next.previousSibling;\n
\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, FALSE, how);\n
\n
\t\t\t\t\tif (how != DELETE) {\n
\t\t\t\t\t\tclonedParent.insertBefore(clonedChild, clonedParent.firstChild);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tisFullySelected = TRUE;\n
\t\t\t\t\tnext = prevSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tif (parent == root) {\n
\t\t\t\t\treturn clonedParent;\n
\t\t\t\t}\n
\n
\t\t\t\tnext = parent.previousSibling;\n
\t\t\t\tparent = parent.parentNode;\n
\n
\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);\n
\n
\t\t\t\tif (how != DELETE) {\n
\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\n
\t\t\t\t}\n
\n
\t\t\t\tclonedParent = clonedGrandParent;\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction _traverseLeftBoundary(root, how) {\n
\t\t\tvar next = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]), isFullySelected = next != self[START_CONTAINER];\n
\t\t\tvar parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;\n
\n
\t\t\tif (next == root) {\n
\t\t\t\treturn _traverseNode(next, isFullySelected, TRUE, how);\n
\t\t\t}\n
\n
\t\t\tparent = next.parentNode;\n
\t\t\tclonedParent = _traverseNode(parent, FALSE, TRUE, how);\n
\n
\t\t\twhile (parent) {\n
\t\t\t\twhile (next) {\n
\t\t\t\t\tnextSibling = next.nextSibling;\n
\t\t\t\t\tclonedChild = _traverseNode(next, isFullySelected, TRUE, how);\n
\n
\t\t\t\t\tif (how != DELETE) {\n
\t\t\t\t\t\tclonedParent.appendChild(clonedChild);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tisFullySelected = TRUE;\n
\t\t\t\t\tnext = nextSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tif (parent == root) {\n
\t\t\t\t\treturn clonedParent;\n
\t\t\t\t}\n
\n
\t\t\t\tnext = parent.nextSibling;\n
\t\t\t\tparent = parent.parentNode;\n
\n
\t\t\t\tclonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);\n
\n
\t\t\t\tif (how != DELETE) {\n
\t\t\t\t\tclonedGrandParent.appendChild(clonedParent);\n
\t\t\t\t}\n
\n
\t\t\t\tclonedParent = clonedGrandParent;\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction _traverseNode(n, isFullySelected, isLeft, how) {\n
\t\t\tvar txtValue, newNodeValue, oldNodeValue, offset, newNode;\n
\n
\t\t\tif (isFullySelected) {\n
\t\t\t\treturn _traverseFullySelected(n, how);\n
\t\t\t}\n
\n
\t\t\tif (n.nodeType == 3 /* TEXT_NODE */) {\n
\t\t\t\ttxtValue = n.nodeValue;\n
\n
\t\t\t\tif (isLeft) {\n
\t\t\t\t\toffset = self[START_OFFSET];\n
\t\t\t\t\tnewNodeValue = txtValue.substring(offset);\n
\t\t\t\t\toldNodeValue = txtValue.substring(0, offset);\n
\t\t\t\t} else {\n
\t\t\t\t\toffset = self[END_OFFSET];\n
\t\t\t\t\tnewNodeValue = txtValue.substring(0, offset);\n
\t\t\t\t\toldNodeValue = txtValue.substring(offset);\n
\t\t\t\t}\n
\n
\t\t\t\tif (how != CLONE) {\n
\t\t\t\t\tn.nodeValue = oldNodeValue;\n
\t\t\t\t}\n
\n
\t\t\t\tif (how == DELETE) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tnewNode = dom.clone(n, FALSE);\n
\t\t\t\tnewNode.nodeValue = newNodeValue;\n
\n
\t\t\t\treturn newNode;\n
\t\t\t}\n
\n
\t\t\tif (how == DELETE) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\treturn dom.clone(n, FALSE);\n
\t\t}\n
\n
\t\tfunction _traverseFullySelected(n, how) {\n
\t\t\tif (how != DELETE) {\n
\t\t\t\treturn how == CLONE ? dom.clone(n, TRUE) : n;\n
\t\t\t}\n
\n
\t\t\tn.parentNode.removeChild(n);\n
\t\t}\n
\n
\t\tfunction toStringIE() {\n
\t\t\treturn dom.create(\'body\', null, cloneContents()).outerText;\n
\t\t}\n
\n
\t\textend(self, {\n
\t\t\t// Inital states\n
\t\t\tstartContainer: doc,\n
\t\t\tstartOffset: 0,\n
\t\t\tendContainer: doc,\n
\t\t\tendOffset: 0,\n
\t\t\tcollapsed: TRUE,\n
\t\t\tcommonAncestorContainer: doc,\n
\n
\t\t\t// Range constants\n
\t\t\tSTART_TO_START: 0,\n
\t\t\tSTART_TO_END: 1,\n
\t\t\tEND_TO_END: 2,\n
\t\t\tEND_TO_START: 3,\n
\n
\t\t\t// Public methods\n
\t\t\tsetStart: setStart,\n
\t\t\tsetEnd: setEnd,\n
\t\t\tsetStartBefore: setStartBefore,\n
\t\t\tsetStartAfter: setStartAfter,\n
\t\t\tsetEndBefore: setEndBefore,\n
\t\t\tsetEndAfter: setEndAfter,\n
\t\t\tcollapse: collapse,\n
\t\t\tselectNode: selectNode,\n
\t\t\tselectNodeContents: selectNodeContents,\n
\t\t\tcompareBoundaryPoints: compareBoundaryPoints,\n
\t\t\tdeleteContents: deleteContents,\n
\t\t\textractContents: extractContents,\n
\t\t\tcloneContents: cloneContents,\n
\t\t\tinsertNode: insertNode,\n
\t\t\tsurroundContents: surroundContents,\n
\t\t\tcloneRange: cloneRange,\n
\t\t\ttoStringIE: toStringIE\n
\t\t});\n
\n
\t\treturn self;\n
\t}\n
\n
\t// Older IE versions doesn\'t let you override toString by it\'s constructor so we have to stick it in the prototype\n
\tRange.prototype.toString = function() {\n
\t\treturn this.toStringIE();\n
\t};\n
\n
\treturn Range;\n
});\n
\n
// Included from: js/tinymce/classes/html/Entities.js\n
\n
/**\n
 * Entities.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*jshint bitwise:false */\n
/*eslint no-bitwise:0 */\n
\n
/**\n
 * Entity encoder class.\n
 *\n
 * @class tinymce.html.Entities\n
 * @static\n
 * @version 3.4\n
 */\n
define("tinymce/html/Entities", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar makeMap = Tools.makeMap;\n
\n
\tvar namedEntities, baseEntities, reverseEntities,\n
\t\tattrsCharsRegExp = /[&<>\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n
\t\ttextCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n
\t\trawCharsRegExp = /[<>&\\"\\\']/g,\n
\t\tentityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,\n
\t\tasciiMap = {\n
\t\t\t128: "\\u20AC", 130: "\\u201A", 131: "\\u0192", 132: "\\u201E", 133: "\\u2026", 134: "\\u2020",\n
\t\t\t135: "\\u2021", 136: "\\u02C6", 137: "\\u2030", 138: "\\u0160", 139: "\\u2039", 140: "\\u0152",\n
\t\t\t142: "\\u017D", 145: "\\u2018", 146: "\\u2019", 147: "\\u201C", 148: "\\u201D", 149: "\\u2022",\n
\t\t\t150: "\\u2013", 151: "\\u2014", 152: "\\u02DC", 153: "\\u2122", 154: "\\u0161", 155: "\\u203A",\n
\t\t\t156: "\\u0153", 158: "\\u017E", 159: "\\u0178"\n
\t\t};\n
\n
\t// Raw entities\n
\tbaseEntities = {\n
\t\t\'\\"\': \'&quot;\', // Needs to be escaped since the YUI compressor would otherwise break the code\n
\t\t"\'": \'&#39;\',\n
\t\t\'<\': \'&lt;\',\n
\t\t\'>\': \'&gt;\',\n
\t\t\'&\': \'&amp;\',\n
\t\t\'\\u0060\': \'&#96;\'\n
\t};\n
\n
\t// Reverse lookup table for raw entities\n
\treverseEntities = {\n
\t\t\'&lt;\': \'<\',\n
\t\t\'&gt;\': \'>\',\n
\t\t\'&amp;\': \'&\',\n
\t\t\'&quot;\': \'"\',\n
\t\t\'&apos;\': "\'"\n
\t};\n
\n
\t// Decodes text by using the browser\n
\tfunction nativeDecode(text) {\n
\t\tvar elm;\n
\n
\t\telm = document.createElement("div");\n
\t\telm.innerHTML = text;\n
\n
\t\treturn elm.textContent || elm.innerText || text;\n
\t}\n
\n
\t// Build a two way lookup table for the entities\n
\tfunction buildEntitiesLookup(items, radix) {\n
\t\tvar i, chr, entity, lookup = {};\n
\n
\t\tif (items) {\n
\t\t\titems = items.split(\',\');\n
\t\t\tradix = radix || 10;\n
\n
\t\t\t// Build entities lookup table\n
\t\t\tfor (i = 0; i < items.length; i += 2) {\n
\t\t\t\tchr = String.fromCharCode(parseInt(items[i], radix));\n
\n
\t\t\t\t// Only add non base entities\n
\t\t\t\tif (!baseEntities[chr]) {\n
\t\t\t\t\tentity = \'&\' + items[i + 1] + \';\';\n
\t\t\t\t\tlookup[chr] = entity;\n
\t\t\t\t\tlookup[entity] = chr;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn lookup;\n
\t\t}\n
\t}\n
\n
\t// Unpack entities lookup where the numbers are in radix 32 to reduce the size\n
\tnamedEntities = buildEntitiesLookup(\n
\t\t\'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,\' +\n
\t\t\'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,\' +\n
\t\t\'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,\' +\n
\t\t\'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,\' +\n
\t\t\'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,\' +\n
\t\t\'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,\' +\n
\t\t\'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,\' +\n
\t\t\'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,\' +\n
\t\t\'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,\' +\n
\t\t\'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,\' +\n
\t\t\'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,\' +\n
\t\t\'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,\' +\n
\t\t\'t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,\' +\n
\t\t\'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,\' +\n
\t\t\'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,\' +\n
\t\t\'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,\' +\n
\t\t\'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,\' +\n
\t\t\'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,\' +\n
\t\t\'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,\' +\n
\t\t\'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,\' +\n
\t\t\'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,\' +\n
\t\t\'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,\' +\n
\t\t\'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,\' +\n
\t\t\'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,\' +\n
\t\t\'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro\', 32);\n
\n
\tvar Entities = {\n
\t\t/**\n
\t\t * Encodes the specified string using raw entities. This means only the required XML base entities will be endoded.\n
\t\t *\n
\t\t * @method encodeRaw\n
\t\t * @param {String} text Text to encode.\n
\t\t * @param {Boolean} attr Optional flag to specify if the text is attribute contents.\n
\t\t * @return {String} Entity encoded text.\n
\t\t */\n
\t\tencodeRaw: function(text, attr) {\n
\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\n
\t\t\t\treturn baseEntities[chr] || chr;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents\n
\t\t * since it doesn\'t know if the context is within a attribute or text node. This was added for compatibility\n
\t\t * and is exposed as the DOMUtils.encode function.\n
\t\t *\n
\t\t * @method encodeAllRaw\n
\t\t * @param {String} text Text to encode.\n
\t\t * @return {String} Entity encoded text.\n
\t\t */\n
\t\tencodeAllRaw: function(text) {\n
\t\t\treturn (\'\' + text).replace(rawCharsRegExp, function(chr) {\n
\t\t\t\treturn baseEntities[chr] || chr;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Encodes the specified string using numeric entities. The core entities will be\n
\t\t * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.\n
\t\t *\n
\t\t * @method encodeNumeric\n
\t\t * @param {String} text Text to encode.\n
\t\t * @param {Boolean} attr Optional flag to specify if the text is attribute contents.\n
\t\t * @return {String} Entity encoded text.\n
\t\t */\n
\t\tencodeNumeric: function(text, attr) {\n
\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\n
\t\t\t\t// Multi byte sequence convert it to a single entity\n
\t\t\t\tif (chr.length > 1) {\n
\t\t\t\t\treturn \'&#\' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + \';\';\n
\t\t\t\t}\n
\n
\t\t\t\treturn baseEntities[chr] || \'&#\' + chr.charCodeAt(0) + \';\';\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Encodes the specified string using named entities. The core entities will be encoded\n
\t\t * as named ones but all non lower ascii characters will be encoded into named entities.\n
\t\t *\n
\t\t * @method encodeNamed\n
\t\t * @param {String} text Text to encode.\n
\t\t * @param {Boolean} attr Optional flag to specify if the text is attribute contents.\n
\t\t * @param {Object} entities Optional parameter with entities to use.\n
\t\t * @return {String} Entity encoded text.\n
\t\t */\n
\t\tencodeNamed: function(text, attr, entities) {\n
\t\t\tentities = entities || namedEntities;\n
\n
\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\n
\t\t\t\treturn baseEntities[chr] || entities[chr] || chr;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns an encode function based on the name(s) and it\'s optional entities.\n
\t\t *\n
\t\t * @method getEncodeFunc\n
\t\t * @param {String} name Comma separated list of encoders for example named,numeric.\n
\t\t * @param {String} entities Optional parameter with entities to use instead of the built in set.\n
\t\t * @return {function} Encode function to be used.\n
\t\t */\n
\t\tgetEncodeFunc: function(name, entities) {\n
\t\t\tentities = buildEntitiesLookup(entities) || namedEntities;\n
\n
\t\t\tfunction encodeNamedAndNumeric(text, attr) {\n
\t\t\t\treturn text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {\n
\t\t\t\t\treturn baseEntities[chr] || entities[chr] || \'&#\' + chr.charCodeAt(0) + \';\' || chr;\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tfunction encodeCustomNamed(text, attr) {\n
\t\t\t\treturn Entities.encodeNamed(text, attr, entities);\n
\t\t\t}\n
\n
\t\t\t// Replace + with , to be compatible with previous TinyMCE versions\n
\t\t\tname = makeMap(name.replace(/\\+/g, \',\'));\n
\n
\t\t\t// Named and numeric encoder\n
\t\t\tif (name.named && name.numeric) {\n
\t\t\t\treturn encodeNamedAndNumeric;\n
\t\t\t}\n
\n
\t\t\t// Named encoder\n
\t\t\tif (name.named) {\n
\t\t\t\t// Custom names\n
\t\t\t\tif (entities) {\n
\t\t\t\t\treturn encodeCustomNamed;\n
\t\t\t\t}\n
\n
\t\t\t\treturn Entities.encodeNamed;\n
\t\t\t}\n
\n
\t\t\t// Numeric\n
\t\t\tif (name.numeric) {\n
\t\t\t\treturn Entities.encodeNumeric;\n
\t\t\t}\n
\n
\t\t\t// Raw encoder\n
\t\t\treturn Entities.encodeRaw;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Decodes the specified string, this will replace entities with raw UTF characters.\n
\t\t *\n
\t\t * @method decode\n
\t\t * @param {String} text Text to entity decode.\n
\t\t * @return {String} Entity decoded string.\n
\t\t */\n
\t\tdecode: function(text) {\n
\t\t\treturn text.replace(entityRegExp, function(all, numeric) {\n
\t\t\t\tif (numeric) {\n
\t\t\t\t\tif (numeric.charAt(0).toLowerCase() === \'x\') {\n
\t\t\t\t\t\tnumeric = parseInt(numeric.substr(1), 16);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tnumeric = parseInt(numeric, 10);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Support upper UTF\n
\t\t\t\t\tif (numeric > 0xFFFF) {\n
\t\t\t\t\t\tnumeric -= 0x10000;\n
\n
\t\t\t\t\t\treturn String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn asciiMap[numeric] || String.fromCharCode(numeric);\n
\t\t\t\t}\n
\n
\t\t\t\treturn reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n
\t\t\t});\n
\t\t}\n
\t};\n
\n
\treturn Entities;\n
});\n
\n
// Included from: js/tinymce/classes/dom/StyleSheetLoader.js\n
\n
/**\n
 * StyleSheetLoader.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles loading of external stylesheets and fires events when these are loaded.\n
 *\n
 * @class tinymce.dom.StyleSheetLoader\n
 * @private\n
 */\n
define("tinymce/dom/StyleSheetLoader", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\t"use strict";\n
\n
\treturn function(document, settings) {\n
\t\tvar idCount = 0, loadedStates = {}, maxLoadTime;\n
\n
\t\tsettings = settings || {};\n
\t\tmaxLoadTime = settings.maxLoadTime || 5000;\n
\n
\t\tfunction appendToHead(node) {\n
\t\t\tdocument.getElementsByTagName(\'head\')[0].appendChild(node);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Loads the specified css style sheet file and call the loadedCallback once it\'s finished loading.\n
\t\t *\n
\t\t * @method load\n
\t\t * @param {String} url Url to be loaded.\n
\t\t * @param {Function} loadedCallback Callback to be executed when loaded.\n
\t\t * @param {Function} errorCallback Callback to be executed when failed loading.\n
\t\t */\n
\t\tfunction load(url, loadedCallback, errorCallback) {\n
\t\t\tvar link, style, startTime, state;\n
\n
\t\t\tfunction passed() {\n
\t\t\t\tvar callbacks = state.passed, i = callbacks.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tcallbacks[i]();\n
\t\t\t\t}\n
\n
\t\t\t\tstate.status = 2;\n
\t\t\t\tstate.passed = [];\n
\t\t\t\tstate.failed = [];\n
\t\t\t}\n
\n
\t\t\tfunction failed() {\n
\t\t\t\tvar callbacks = state.failed, i = callbacks.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tcallbacks[i]();\n
\t\t\t\t}\n
\n
\t\t\t\tstate.status = 3;\n
\t\t\t\tstate.passed = [];\n
\t\t\t\tstate.failed = [];\n
\t\t\t}\n
\n
\t\t\t// Sniffs for older WebKit versions that have the link.onload but a broken one\n
\t\t\tfunction isOldWebKit() {\n
\t\t\t\tvar webKitChunks = navigator.userAgent.match(/WebKit\\/(\\d*)/);\n
\t\t\t\treturn !!(webKitChunks && webKitChunks[1] < 536);\n
\t\t\t}\n
\n
\t\t\t// Calls the waitCallback until the test returns true or the timeout occurs\n
\t\t\tfunction wait(testCallback, waitCallback) {\n
\t\t\t\tif (!testCallback()) {\n
\t\t\t\t\t// Wait for timeout\n
\t\t\t\t\tif ((new Date().getTime()) - startTime < maxLoadTime) {\n
\t\t\t\t\t\twindow.setTimeout(waitCallback, 0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tfailed();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Workaround for WebKit that doesn\'t properly support the onload event for link elements\n
\t\t\t// Or WebKit that fires the onload event before the StyleSheet is added to the document\n
\t\t\tfunction waitForWebKitLinkLoaded() {\n
\t\t\t\twait(function() {\n
\t\t\t\t\tvar styleSheets = document.styleSheets, styleSheet, i = styleSheets.length, owner;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tstyleSheet = styleSheets[i];\n
\t\t\t\t\t\towner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;\n
\t\t\t\t\t\tif (owner && owner.id === link.id) {\n
\t\t\t\t\t\t\tpassed();\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}, waitForWebKitLinkLoaded);\n
\t\t\t}\n
\n
\t\t\t// Workaround for older Geckos that doesn\'t have any onload event for StyleSheets\n
\t\t\tfunction waitForGeckoLinkLoaded() {\n
\t\t\t\twait(function() {\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\t// Accessing the cssRules will throw an exception until the CSS file is loaded\n
\t\t\t\t\t\tvar cssRules = style.sheet.cssRules;\n
\t\t\t\t\t\tpassed();\n
\t\t\t\t\t\treturn !!cssRules;\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Ignore\n
\t\t\t\t\t}\n
\t\t\t\t}, waitForGeckoLinkLoaded);\n
\t\t\t}\n
\n
\t\t\turl = Tools._addCacheSuffix(url);\n
\n
\t\t\tif (!loadedStates[url]) {\n
\t\t\t\tstate = {\n
\t\t\t\t\tpassed: [],\n
\t\t\t\t\tfailed: []\n
\t\t\t\t};\n
\n
\t\t\t\tloadedStates[url] = state;\n
\t\t\t} else {\n
\t\t\t\tstate = loadedStates[url];\n
\t\t\t}\n
\n
\t\t\tif (loadedCallback) {\n
\t\t\t\tstate.passed.push(loadedCallback);\n
\t\t\t}\n
\n
\t\t\tif (errorCallback) {\n
\t\t\t\tstate.failed.push(errorCallback);\n
\t\t\t}\n
\n
\t\t\t// Is loading wait for it to pass\n
\t\t\tif (state.status == 1) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Has finished loading and was success\n
\t\t\tif (state.status == 2) {\n
\t\t\t\tpassed();\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Has finished loading and was a failure\n
\t\t\tif (state.status == 3) {\n
\t\t\t\tfailed();\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Start loading\n
\t\t\tstate.status = 1;\n
\t\t\tlink = document.createElement(\'link\');\n
\t\t\tlink.rel = \'stylesheet\';\n
\t\t\tlink.type = \'text/css\';\n
\t\t\tlink.id = \'u\' + (idCount++);\n
\t\t\tlink.async = false;\n
\t\t\tlink.defer = false;\n
\t\t\tstartTime = new Date().getTime();\n
\n
\t\t\t// Feature detect onload on link element and sniff older webkits since it has an broken onload event\n
\t\t\tif ("onload" in link && !isOldWebKit()) {\n
\t\t\t\tlink.onload = waitForWebKitLinkLoaded;\n
\t\t\t\tlink.onerror = failed;\n
\t\t\t} else {\n
\t\t\t\t// Sniff for old Firefox that doesn\'t support the onload event on link elements\n
\t\t\t\t// TODO: Remove this in the future when everyone uses modern browsers\n
\t\t\t\tif (navigator.userAgent.indexOf("Firefox") > 0) {\n
\t\t\t\t\tstyle = document.createElement(\'style\');\n
\t\t\t\t\tstyle.textContent = \'@import "\' + url + \'"\';\n
\t\t\t\t\twaitForGeckoLinkLoaded();\n
\t\t\t\t\tappendToHead(style);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Use the id owner on older webkits\n
\t\t\t\twaitForWebKitLinkLoaded();\n
\t\t\t}\n
\n
\t\t\tappendToHead(link);\n
\t\t\tlink.href = url;\n
\t\t}\n
\n
\t\tthis.load = load;\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/DOMUtils.js\n
\n
/**\n
 * DOMUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Utility class for various DOM manipulation and retrieval functions.\n
 *\n
 * @class tinymce.dom.DOMUtils\n
 * @example\n
 * // Add a class to an element by id in the page\n
 * tinymce.DOM.addClass(\'someid\', \'someclass\');\n
 *\n
 * // Add a class to an element by id inside the editor\n
 * tinymce.activeEditor.dom.addClass(\'someid\', \'someclass\');\n
 */\n
define("tinymce/dom/DOMUtils", [\n
\t"tinymce/dom/Sizzle",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/html/Styles",\n
\t"tinymce/dom/EventUtils",\n
\t"tinymce/dom/TreeWalker",\n
\t"tinymce/dom/Range",\n
\t"tinymce/html/Entities",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/StyleSheetLoader"\n
], function(Sizzle, $, Styles, EventUtils, TreeWalker, Range, Entities, Env, Tools, StyleSheetLoader) {\n
\t// Shorten names\n
\tvar each = Tools.each, is = Tools.is, grep = Tools.grep, trim = Tools.trim;\n
\tvar isIE = Env.ie;\n
\tvar simpleSelectorRe = /^([a-z0-9],?)+$/i;\n
\tvar whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n
\n
\tfunction setupAttrHooks(domUtils, settings) {\n
\t\tvar attrHooks = {}, keepValues = settings.keep_values, keepUrlHook;\n
\n
\t\tkeepUrlHook = {\n
\t\t\tset: function($elm, value, name) {\n
\t\t\t\tif (settings.url_converter) {\n
\t\t\t\t\tvalue = settings.url_converter.call(settings.url_converter_scope || domUtils, value, name, $elm[0]);\n
\t\t\t\t}\n
\n
\t\t\t\t$elm.attr(\'data-mce-\' + name, value).attr(name, value);\n
\t\t\t},\n
\n
\t\t\tget: function($elm, name) {\n
\t\t\t\treturn $elm.attr(\'data-mce-\' + name) || $elm.attr(name);\n
\t\t\t}\n
\t\t};\n
\n
\t\tattrHooks = {\n
\t\t\tstyle: {\n
\t\t\t\tset: function($elm, value) {\n
\t\t\t\t\tif (value !== null && typeof value === \'object\') {\n
\t\t\t\t\t\t$elm.css(value);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (keepValues) {\n
\t\t\t\t\t\t$elm.attr(\'data-mce-style\', value);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t$elm.attr(\'style\', value);\n
\t\t\t\t},\n
\n
\t\t\t\tget: function($elm) {\n
\t\t\t\t\tvar value = $elm.attr(\'data-mce-style\') || $elm.attr(\'style\');\n
\n
\t\t\t\t\tvalue = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[0].nodeName);\n
\n
\t\t\t\t\treturn value;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\n
\t\tif (keepValues) {\n
\t\t\tattrHooks.href = attrHooks.src = keepUrlHook;\n
\t\t}\n
\n
\t\treturn attrHooks;\n
\t}\n
\n
\t/**\n
\t * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.\n
\t *\n
\t * @constructor\n
\t * @method DOMUtils\n
\t * @param {Document} d Document reference to bind the utility class to.\n
\t * @param {settings} s Optional settings collection.\n
\t */\n
\tfunction DOMUtils(doc, settings) {\n
\t\tvar self = this, blockElementsMap;\n
\n
\t\tself.doc = doc;\n
\t\tself.win = window;\n
\t\tself.files = {};\n
\t\tself.counter = 0;\n
\t\tself.stdMode = !isIE || doc.documentMode >= 8;\n
\t\tself.boxModel = !isIE || doc.compatMode == "CSS1Compat" || self.stdMode;\n
\t\tself.styleSheetLoader = new StyleSheetLoader(doc);\n
\t\tself.boundEvents = [];\n
\t\tself.settings = settings = settings || {};\n
\t\tself.schema = settings.schema;\n
\t\tself.styles = new Styles({\n
\t\t\turl_converter: settings.url_converter,\n
\t\t\turl_converter_scope: settings.url_converter_scope\n
\t\t}, settings.schema);\n
\n
\t\tself.fixDoc(doc);\n
\t\tself.events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;\n
\t\tself.attrHooks = setupAttrHooks(self, settings);\n
\t\tblockElementsMap = settings.schema ? settings.schema.getBlockElements() : {};\n
\t\tself.$ = $.overrideDefaults(function() {\n
\t\t\treturn {\n
\t\t\t\tcontext: doc,\n
\t\t\t\telement: self.getRoot()\n
\t\t\t};\n
\t\t});\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element is a block element or not.\n
\t\t *\n
\t\t * @method isBlock\n
\t\t * @param {Node/String} node Element/Node to check.\n
\t\t * @return {Boolean} True/False state if the node is a block element or not.\n
\t\t */\n
\t\tself.isBlock = function(node) {\n
\t\t\t// Fix for #5446\n
\t\t\tif (!node) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\t// This function is called in module pattern style since it might be executed with the wrong this scope\n
\t\t\tvar type = node.nodeType;\n
\n
\t\t\t// If it\'s a node then check the type and use the nodeName\n
\t\t\tif (type) {\n
\t\t\t\treturn !!(type === 1 && blockElementsMap[node.nodeName]);\n
\t\t\t}\n
\n
\t\t\treturn !!blockElementsMap[node];\n
\t\t};\n
\t}\n
\n
\tDOMUtils.prototype = {\n
\t\t$$: function(elm) {\n
\t\t\tif (typeof elm == \'string\') {\n
\t\t\t\telm = this.get(elm);\n
\t\t\t}\n
\n
\t\t\treturn this.$(elm);\n
\t\t},\n
\n
\t\troot: null,\n
\n
\t\tfixDoc: function(doc) {\n
\t\t\tvar settings = this.settings, name;\n
\n
\t\t\tif (isIE && settings.schema) {\n
\t\t\t\t// Add missing HTML 4/5 elements to IE\n
\t\t\t\t(\'abbr article aside audio canvas \' +\n
\t\t\t\t\'details figcaption figure footer \' +\n
\t\t\t\t\'header hgroup mark menu meter nav \' +\n
\t\t\t\t\'output progress section summary \' +\n
\t\t\t\t\'time video\').replace(/\\w+/g, function(name) {\n
\t\t\t\t\tdoc.createElement(name);\n
\t\t\t\t});\n
\n
\t\t\t\t// Create all custom elements\n
\t\t\t\tfor (name in settings.schema.getCustomElements()) {\n
\t\t\t\t\tdoc.createElement(name);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\tclone: function(node, deep) {\n
\t\t\tvar self = this, clone, doc;\n
\n
\t\t\t// TODO: Add feature detection here in the future\n
\t\t\tif (!isIE || node.nodeType !== 1 || deep) {\n
\t\t\t\treturn node.cloneNode(deep);\n
\t\t\t}\n
\n
\t\t\tdoc = self.doc;\n
\n
\t\t\t// Make a HTML5 safe shallow copy\n
\t\t\tif (!deep) {\n
\t\t\t\tclone = doc.createElement(node.nodeName);\n
\n
\t\t\t\t// Copy attribs\n
\t\t\t\teach(self.getAttribs(node), function(attr) {\n
\t\t\t\t\tself.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));\n
\t\t\t\t});\n
\n
\t\t\t\treturn clone;\n
\t\t\t}\n
\n
\t\t\treturn clone.firstChild;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not\n
\t\t * go above the point of this root node.\n
\t\t *\n
\t\t * @method getRoot\n
\t\t * @return {Element} Root element for the utility class.\n
\t\t */\n
\t\tgetRoot: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\treturn self.settings.root_element || self.doc.body;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the viewport of the window.\n
\t\t *\n
\t\t * @method getViewPort\n
\t\t * @param {Window} win Optional window to get viewport of.\n
\t\t * @return {Object} Viewport object with fields x, y, w and h.\n
\t\t */\n
\t\tgetViewPort: function(win) {\n
\t\t\tvar doc, rootElm;\n
\n
\t\t\twin = !win ? this.win : win;\n
\t\t\tdoc = win.document;\n
\t\t\trootElm = this.boxModel ? doc.documentElement : doc.body;\n
\n
\t\t\t// Returns viewport size excluding scrollbars\n
\t\t\treturn {\n
\t\t\t\tx: win.pageXOffset || rootElm.scrollLeft,\n
\t\t\t\ty: win.pageYOffset || rootElm.scrollTop,\n
\t\t\t\tw: win.innerWidth || rootElm.clientWidth,\n
\t\t\t\th: win.innerHeight || rootElm.clientHeight\n
\t\t\t};\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the rectangle for a specific element.\n
\t\t *\n
\t\t * @method getRect\n
\t\t * @param {Element/String} elm Element object or element ID to get rectangle from.\n
\t\t * @return {object} Rectangle for specified element object with x, y, w, h fields.\n
\t\t */\n
\t\tgetRect: function(elm) {\n
\t\t\tvar self = this, pos, size;\n
\n
\t\t\telm = self.get(elm);\n
\t\t\tpos = self.getPos(elm);\n
\t\t\tsize = self.getSize(elm);\n
\n
\t\t\treturn {\n
\t\t\t\tx: pos.x, y: pos.y,\n
\t\t\t\tw: size.w, h: size.h\n
\t\t\t};\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the size dimensions of the specified element.\n
\t\t *\n
\t\t * @method getSize\n
\t\t * @param {Element/String} elm Element object or element ID to get rectangle from.\n
\t\t * @return {object} Rectangle for specified element object with w, h fields.\n
\t\t */\n
\t\tgetSize: function(elm) {\n
\t\t\tvar self = this, w, h;\n
\n
\t\t\telm = self.get(elm);\n
\t\t\tw = self.getStyle(elm, \'width\');\n
\t\t\th = self.getStyle(elm, \'height\');\n
\n
\t\t\t// Non pixel value, then force offset/clientWidth\n
\t\t\tif (w.indexOf(\'px\') === -1) {\n
\t\t\t\tw = 0;\n
\t\t\t}\n
\n
\t\t\t// Non pixel value, then force offset/clientWidth\n
\t\t\tif (h.indexOf(\'px\') === -1) {\n
\t\t\t\th = 0;\n
\t\t\t}\n
\n
\t\t\treturn {\n
\t\t\t\tw: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,\n
\t\t\t\th: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight\n
\t\t\t};\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a node by the specified selector function. This function will\n
\t\t * loop through all parent nodes and call the specified function for each node.\n
\t\t * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end\n
\t\t * and the node it found will be returned.\n
\t\t *\n
\t\t * @method getParent\n
\t\t * @param {Node/String} node DOM node to search parents on or ID string.\n
\t\t * @param {function} selector Selection function or CSS selector to execute on each node.\n
\t\t * @param {Node} root Optional root element, never go below this point.\n
\t\t * @return {Node} DOM Node or null if it wasn\'t found.\n
\t\t */\n
\t\tgetParent: function(node, selector, root) {\n
\t\t\treturn this.getParents(node, selector, root, false);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a node list of all parents matching the specified selector function or pattern.\n
\t\t * If the function then returns true indicating that it has found what it was looking for and that node will be collected.\n
\t\t *\n
\t\t * @method getParents\n
\t\t * @param {Node/String} node DOM node to search parents on or ID string.\n
\t\t * @param {function} selector Selection function to execute on each node or CSS pattern.\n
\t\t * @param {Node} root Optional root element, never go below this point.\n
\t\t * @return {Array} Array of nodes or null if it wasn\'t found.\n
\t\t */\n
\t\tgetParents: function(node, selector, root, collect) {\n
\t\t\tvar self = this, selectorVal, result = [];\n
\n
\t\t\tnode = self.get(node);\n
\t\t\tcollect = collect === undefined;\n
\n
\t\t\t// Default root on inline mode\n
\t\t\troot = root || (self.getRoot().nodeName != \'BODY\' ? self.getRoot().parentNode : null);\n
\n
\t\t\t// Wrap node name as func\n
\t\t\tif (is(selector, \'string\')) {\n
\t\t\t\tselectorVal = selector;\n
\n
\t\t\t\tif (selector === \'*\') {\n
\t\t\t\t\tselector = function(node) {\n
\t\t\t\t\t\treturn node.nodeType == 1;\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\tselector = function(node) {\n
\t\t\t\t\t\treturn self.is(node, selectorVal);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\twhile (node) {\n
\t\t\t\tif (node == root || !node.nodeType || node.nodeType === 9) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!selector || selector(node)) {\n
\t\t\t\t\tif (collect) {\n
\t\t\t\t\t\tresult.push(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tnode = node.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn collect ? result : null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the specified element by ID or the input element if it isn\'t a string.\n
\t\t *\n
\t\t * @method get\n
\t\t * @param {String/Element} n Element id to look for or element to just pass though.\n
\t\t * @return {Element} Element matching the specified id or null if it wasn\'t found.\n
\t\t */\n
\t\tget: function(elm) {\n
\t\t\tvar name;\n
\n
\t\t\tif (elm && this.doc && typeof elm == \'string\') {\n
\t\t\t\tname = elm;\n
\t\t\t\telm = this.doc.getElementById(elm);\n
\n
\t\t\t\t// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick\n
\t\t\t\tif (elm && elm.id !== name) {\n
\t\t\t\t\treturn this.doc.getElementsByName(name)[1];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn elm;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the next node that matches selector or function\n
\t\t *\n
\t\t * @method getNext\n
\t\t * @param {Node} node Node to find siblings from.\n
\t\t * @param {String/function} selector Selector CSS expression or function.\n
\t\t * @return {Node} Next node item matching the selector or null if it wasn\'t found.\n
\t\t */\n
\t\tgetNext: function(node, selector) {\n
\t\t\treturn this._findSib(node, selector, \'nextSibling\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the previous node that matches selector or function\n
\t\t *\n
\t\t * @method getPrev\n
\t\t * @param {Node} node Node to find siblings from.\n
\t\t * @param {String/function} selector Selector CSS expression or function.\n
\t\t * @return {Node} Previous node item matching the selector or null if it wasn\'t found.\n
\t\t */\n
\t\tgetPrev: function(node, selector) {\n
\t\t\treturn this._findSib(node, selector, \'previousSibling\');\n
\t\t},\n
\n
\t\t// #ifndef jquery\n
\n
\t\t/**\n
\t\t * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".\n
\t\t * This function is optimized for the most common patterns needed in TinyMCE but it also performs well enough\n
\t\t * on more complex patterns.\n
\t\t *\n
\t\t * @method select\n
\t\t * @param {String} selector CSS level 3 pattern to select/find elements by.\n
\t\t * @param {Object} scope Optional root element/scope element to search in.\n
\t\t * @return {Array} Array with all matched elements.\n
\t\t * @example\n
\t\t * // Adds a class to all paragraphs in the currently active editor\n
\t\t * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'someclass\');\n
\t\t *\n
\t\t * // Adds a class to all spans that have the test class in the currently active editor\n
\t\t * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'span.test\'), \'someclass\')\n
\t\t */\n
\t\tselect: function(selector, scope) {\n
\t\t\tvar self = this;\n
\n
\t\t\t/*eslint new-cap:0 */\n
\t\t\treturn Sizzle(selector, self.get(scope) || self.settings.root_element || self.doc, []);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element matches the specified css pattern.\n
\t\t *\n
\t\t * @method is\n
\t\t * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.\n
\t\t * @param {String} selector CSS pattern to match the element against.\n
\t\t */\n
\t\tis: function(elm, selector) {\n
\t\t\tvar i;\n
\n
\t\t\t// If it isn\'t an array then try to do some simple selectors instead of Sizzle for to boost performance\n
\t\t\tif (elm.length === undefined) {\n
\t\t\t\t// Simple all selector\n
\t\t\t\tif (selector === \'*\') {\n
\t\t\t\t\treturn elm.nodeType == 1;\n
\t\t\t\t}\n
\n
\t\t\t\t// Simple selector just elements\n
\t\t\t\tif (simpleSelectorRe.test(selector)) {\n
\t\t\t\t\tselector = selector.toLowerCase().split(/,/);\n
\t\t\t\t\telm = elm.nodeName.toLowerCase();\n
\n
\t\t\t\t\tfor (i = selector.length - 1; i >= 0; i--) {\n
\t\t\t\t\t\tif (selector[i] == elm) {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Is non element\n
\t\t\tif (elm.nodeType && elm.nodeType != 1) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tvar elms = elm.nodeType ? [elm] : elm;\n
\n
\t\t\t/*eslint new-cap:0 */\n
\t\t\treturn Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;\n
\t\t},\n
\n
\t\t// #endif\n
\n
\t\t/**\n
\t\t * Adds the specified element to another element or elements.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.\n
\t\t * @param {String/Element} name Name of new element to add or existing element to add.\n
\t\t * @param {Object} attrs Optional object collection with arguments to add to the new element(s).\n
\t\t * @param {String} html Optional inner HTML contents to add for each element.\n
\t\t * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements\n
\t\t * were passed in.\n
\t\t * @example\n
\t\t * // Adds a new paragraph to the end of the active editor\n
\t\t * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), \'p\', {title: \'my title\'}, \'Some content\');\n
\t\t */\n
\t\tadd: function(parentElm, name, attrs, html, create) {\n
\t\t\tvar self = this;\n
\n
\t\t\treturn this.run(parentElm, function(parentElm) {\n
\t\t\t\tvar newElm;\n
\n
\t\t\t\tnewElm = is(name, \'string\') ? self.doc.createElement(name) : name;\n
\t\t\t\tself.setAttribs(newElm, attrs);\n
\n
\t\t\t\tif (html) {\n
\t\t\t\t\tif (html.nodeType) {\n
\t\t\t\t\t\tnewElm.appendChild(html);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself.setHTML(newElm, html);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn !create ? parentElm.appendChild(newElm) : newElm;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates a new element.\n
\t\t *\n
\t\t * @method create\n
\t\t * @param {String} name Name of new element.\n
\t\t * @param {Object} attrs Optional object name/value collection with element attributes.\n
\t\t * @param {String} html Optional HTML string to set as inner HTML of the element.\n
\t\t * @return {Element} HTML DOM node element that got created.\n
\t\t * @example\n
\t\t * // Adds an element where the caret/selection is in the active editor\n
\t\t * var el = tinymce.activeEditor.dom.create(\'div\', {id: \'test\', \'class\': \'myclass\'}, \'some content\');\n
\t\t * tinymce.activeEditor.selection.setNode(el);\n
\t\t */\n
\t\tcreate: function(name, attrs, html) {\n
\t\t\treturn this.add(this.doc.createElement(name), name, attrs, html, 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.\n
\t\t *\n
\t\t * @method createHTML\n
\t\t * @param {String} name Name of new element.\n
\t\t * @param {Object} attrs Optional object name/value collection with element attributes.\n
\t\t * @param {String} html Optional HTML string to set as inner HTML of the element.\n
\t\t * @return {String} String with new HTML element, for example: <a href="#">test</a>.\n
\t\t * @example\n
\t\t * // Creates a html chunk and inserts it at the current selection/caret location\n
\t\t * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML(\'a\', {href: \'test.html\'}, \'some line\'));\n
\t\t */\n
\t\tcreateHTML: function(name, attrs, html) {\n
\t\t\tvar outHtml = \'\', key;\n
\n
\t\t\toutHtml += \'<\' + name;\n
\n
\t\t\tfor (key in attrs) {\n
\t\t\t\tif (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] != \'undefined\') {\n
\t\t\t\t\toutHtml += \' \' + key + \'="\' + this.encode(attrs[key]) + \'"\';\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// A call to tinymce.is doesn\'t work for some odd reason on IE9 possible bug inside their JS runtime\n
\t\t\tif (typeof html != "undefined") {\n
\t\t\t\treturn outHtml + \'>\' + html + \'</\' + name + \'>\';\n
\t\t\t}\n
\n
\t\t\treturn outHtml + \' />\';\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates a document fragment out of the specified HTML string.\n
\t\t *\n
\t\t * @method createFragment\n
\t\t * @param {String} html Html string to create fragment from.\n
\t\t * @return {DocumentFragment} Document fragment node.\n
\t\t */\n
\t\tcreateFragment: function(html) {\n
\t\t\tvar frag, node, doc = this.doc, container;\n
\n
\t\t\tcontainer = doc.createElement("div");\n
\t\t\tfrag = doc.createDocumentFragment();\n
\n
\t\t\tif (html) {\n
\t\t\t\tcontainer.innerHTML = html;\n
\t\t\t}\n
\n
\t\t\twhile ((node = container.firstChild)) {\n
\t\t\t\tfrag.appendChild(node);\n
\t\t\t}\n
\n
\t\t\treturn frag;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes/deletes the specified element(s) from the DOM.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.\n
\t\t * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be\n
\t\t * placed at the location of the removed element.\n
\t\t * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements\n
\t\t * were passed in.\n
\t\t * @example\n
\t\t * // Removes all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select(\'p\'));\n
\t\t *\n
\t\t * // Removes an element by id in the document\n
\t\t * tinymce.DOM.remove(\'mydiv\');\n
\t\t */\n
\t\tremove: function(node, keepChildren) {\n
\t\t\tnode = this.$$(node);\n
\n
\t\t\tif (keepChildren) {\n
\t\t\t\tnode.each(function() {\n
\t\t\t\t\tvar child;\n
\n
\t\t\t\t\twhile ((child = this.firstChild)) {\n
\t\t\t\t\t\tif (child.nodeType == 3 && child.data.length === 0) {\n
\t\t\t\t\t\t\tthis.removeChild(child);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tthis.parentNode.insertBefore(child, this);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}).remove();\n
\t\t\t} else {\n
\t\t\t\tnode.remove();\n
\t\t\t}\n
\n
\t\t\treturn node.length > 1 ? node.toArray() : node[0];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the CSS style value on a HTML element. The name can be a camelcase string\n
\t\t * or the CSS style name like background-color.\n
\t\t *\n
\t\t * @method setStyle\n
\t\t * @param {String/Element/Array} n HTML element/Element ID or Array of elements/ids to set CSS style value on.\n
\t\t * @param {String} na Name of the style value to set.\n
\t\t * @param {String} v Value to set on the style.\n
\t\t * @example\n
\t\t * // Sets a style value on all paragraphs in the currently active editor\n
\t\t * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select(\'p\'), \'background-color\', \'red\');\n
\t\t *\n
\t\t * // Sets a style value to an element by id in the current document\n
\t\t * tinymce.DOM.setStyle(\'mydiv\', \'background-color\', \'red\');\n
\t\t */\n
\t\tsetStyle: function(elm, name, value) {\n
\t\t\telm = this.$$(elm).css(name, value);\n
\n
\t\t\tif (this.settings.update_styles) {\n
\t\t\t\telm.attr(\'data-mce-style\', null);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the current style or runtime/computed value of an element.\n
\t\t *\n
\t\t * @method getStyle\n
\t\t * @param {String/Element} elm HTML element or element id string to get style from.\n
\t\t * @param {String} name Style name to return.\n
\t\t * @param {Boolean} computed Computed style.\n
\t\t * @return {String} Current style or computed style value of an element.\n
\t\t */\n
\t\tgetStyle: function(elm, name, computed) {\n
\t\t\telm = this.$$(elm);\n
\n
\t\t\tif (computed) {\n
\t\t\t\treturn elm.css(name);\n
\t\t\t}\n
\n
\t\t\t// Camelcase it, if needed\n
\t\t\tname = name.replace(/-(\\D)/g, function(a, b) {\n
\t\t\t\treturn b.toUpperCase();\n
\t\t\t});\n
\n
\t\t\tif (name == \'float\') {\n
\t\t\t\tname = Env.ie && Env.ie < 12 ? \'styleFloat\' : \'cssFloat\';\n
\t\t\t}\n
\n
\t\t\treturn elm[0] && elm[0].style ? elm[0].style[name] : undefined;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets multiple styles on the specified element(s).\n
\t\t *\n
\t\t * @method setStyles\n
\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set styles on.\n
\t\t * @param {Object} o Name/Value collection of style items to add to the element(s).\n
\t\t * @example\n
\t\t * // Sets styles on all paragraphs in the currently active editor\n
\t\t * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select(\'p\'), {\'background-color\': \'red\', \'color\': \'green\'});\n
\t\t *\n
\t\t * // Sets styles to an element by id in the current document\n
\t\t * tinymce.DOM.setStyles(\'mydiv\', {\'background-color\': \'red\', \'color\': \'green\'});\n
\t\t */\n
\t\tsetStyles: function(elm, styles) {\n
\t\t\telm = this.$$(elm).css(styles);\n
\n
\t\t\tif (this.settings.update_styles) {\n
\t\t\t\telm.attr(\'data-mce-style\', null);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes all attributes from an element or elements.\n
\t\t *\n
\t\t * @method removeAllAttribs\n
\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.\n
\t\t */\n
\t\tremoveAllAttribs: function(e) {\n
\t\t\treturn this.run(e, function(e) {\n
\t\t\t\tvar i, attrs = e.attributes;\n
\t\t\t\tfor (i = attrs.length - 1; i >= 0; i--) {\n
\t\t\t\t\te.removeAttributeNode(attrs.item(i));\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified attribute of an element or elements.\n
\t\t *\n
\t\t * @method setAttrib\n
\t\t * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attribute on.\n
\t\t * @param {String} n Name of attribute to set.\n
\t\t * @param {String} v Value to set on the attribute - if this value is falsy like null, 0 or \'\' it will remove the attribute instead.\n
\t\t * @example\n
\t\t * // Sets class attribute on all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select(\'p\'), \'class\', \'myclass\');\n
\t\t *\n
\t\t * // Sets class attribute on a specific element in the current page\n
\t\t * tinymce.dom.setAttrib(\'mydiv\', \'class\', \'myclass\');\n
\t\t */\n
\t\tsetAttrib: function(elm, name, value) {\n
\t\t\tvar self = this, originalValue, hook, settings = self.settings;\n
\n
\t\t\tif (value === \'\') {\n
\t\t\t\tvalue = null;\n
\t\t\t}\n
\n
\t\t\telm = self.$$(elm);\n
\t\t\toriginalValue = elm.attr(name);\n
\n
\t\t\tif (!elm.length) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\thook = self.attrHooks[name];\n
\t\t\tif (hook && hook.set) {\n
\t\t\t\thook.set(elm, value, name);\n
\t\t\t} else {\n
\t\t\t\telm.attr(name, value);\n
\t\t\t}\n
\n
\t\t\tif (originalValue != value && settings.onSetAttrib) {\n
\t\t\t\tsettings.onSetAttrib({\n
\t\t\t\t\tattrElm: elm,\n
\t\t\t\t\tattrName: name,\n
\t\t\t\t\tattrValue: value\n
\t\t\t\t});\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets two or more specified attributes of an element or elements.\n
\t\t *\n
\t\t * @method setAttribs\n
\t\t * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.\n
\t\t * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).\n
\t\t * @example\n
\t\t * // Sets class and title attributes on all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select(\'p\'), {\'class\': \'myclass\', title: \'some title\'});\n
\t\t *\n
\t\t * // Sets class and title attributes on a specific element in the current page\n
\t\t * tinymce.DOM.setAttribs(\'mydiv\', {\'class\': \'myclass\', title: \'some title\'});\n
\t\t */\n
\t\tsetAttribs: function(elm, attrs) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.$$(elm).each(function(i, node) {\n
\t\t\t\teach(attrs, function(value, name) {\n
\t\t\t\t\tself.setAttrib(node, name, value);\n
\t\t\t\t});\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the specified attribute by name.\n
\t\t *\n
\t\t * @method getAttrib\n
\t\t * @param {String/Element} elm Element string id or DOM element to get attribute from.\n
\t\t * @param {String} name Name of attribute to get.\n
\t\t * @param {String} defaultVal Optional default value to return if the attribute didn\'t exist.\n
\t\t * @return {String} Attribute value string, default value or null if the attribute wasn\'t found.\n
\t\t */\n
\t\tgetAttrib: function(elm, name, defaultVal) {\n
\t\t\tvar self = this, hook, value;\n
\n
\t\t\telm = self.$$(elm);\n
\n
\t\t\tif (elm.length) {\n
\t\t\t\thook = self.attrHooks[name];\n
\n
\t\t\t\tif (hook && hook.get) {\n
\t\t\t\t\tvalue = hook.get(elm, name);\n
\t\t\t\t} else {\n
\t\t\t\t\tvalue = elm.attr(name);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (typeof value == \'undefined\') {\n
\t\t\t\tvalue = defaultVal || \'\';\n
\t\t\t}\n
\n
\t\t\treturn value;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.\n
\t\t *\n
\t\t * @method getPos\n
\t\t * @param {Element/String} elm HTML element or element id to get x, y position from.\n
\t\t * @param {Element} rootElm Optional root element to stop calculations at.\n
\t\t * @return {object} Absolute position of the specified element object with x, y fields.\n
\t\t */\n
\t\tgetPos: function(elm, rootElm) {\n
\t\t\tvar self = this, x = 0, y = 0, offsetParent, doc = self.doc, body = doc.body, pos;\n
\n
\t\t\telm = self.get(elm);\n
\t\t\trootElm = rootElm || body;\n
\n
\t\t\tif (elm) {\n
\t\t\t\t// Use getBoundingClientRect if it exists since it\'s faster than looping offset nodes\n
\t\t\t\t// Fallback to offsetParent calculations if the body isn\'t static better since it stops at the body root\n
\t\t\t\tif (rootElm === body && elm.getBoundingClientRect && $(body).css(\'position\') === \'static\') {\n
\t\t\t\t\tpos = elm.getBoundingClientRect();\n
\t\t\t\t\trootElm = self.boxModel ? doc.documentElement : body;\n
\n
\t\t\t\t\t// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit\n
\t\t\t\t\t// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position\n
\t\t\t\t\tx = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - rootElm.clientLeft;\n
\t\t\t\t\ty = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - rootElm.clientTop;\n
\n
\t\t\t\t\treturn {x: x, y: y};\n
\t\t\t\t}\n
\n
\t\t\t\toffsetParent = elm;\n
\t\t\t\twhile (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {\n
\t\t\t\t\tx += offsetParent.offsetLeft || 0;\n
\t\t\t\t\ty += offsetParent.offsetTop || 0;\n
\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n
\t\t\t\t}\n
\n
\t\t\t\toffsetParent = elm.parentNode;\n
\t\t\t\twhile (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {\n
\t\t\t\t\tx -= offsetParent.scrollLeft || 0;\n
\t\t\t\t\ty -= offsetParent.scrollTop || 0;\n
\t\t\t\t\toffsetParent = offsetParent.parentNode;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn {x: x, y: y};\n
\t\t},\n
\n
\t\t/**\n
\t\t * Parses the specified style value into an object collection. This parser will also\n
\t\t * merge and remove any redundant items that browsers might have added. It will also convert non-hex\n
\t\t * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.\n
\t\t *\n
\t\t * @method parseStyle\n
\t\t * @param {String} cssText Style value to parse, for example: border:1px solid red;.\n
\t\t * @return {Object} Object representation of that style, for example: {border: \'1px solid red\'}\n
\t\t */\n
\t\tparseStyle: function(cssText) {\n
\t\t\treturn this.styles.parse(cssText);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Serializes the specified style object into a string.\n
\t\t *\n
\t\t * @method serializeStyle\n
\t\t * @param {Object} styles Object to serialize as string, for example: {border: \'1px solid red\'}\n
\t\t * @param {String} name Optional element name.\n
\t\t * @return {String} String representation of the style object, for example: border: 1px solid red.\n
\t\t */\n
\t\tserializeStyle: function(styles, name) {\n
\t\t\treturn this.styles.serialize(styles, name);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a style element at the top of the document with the specified cssText content.\n
\t\t *\n
\t\t * @method addStyle\n
\t\t * @param {String} cssText CSS Text style to add to top of head of document.\n
\t\t */\n
\t\taddStyle: function(cssText) {\n
\t\t\tvar self = this, doc = self.doc, head, styleElm;\n
\n
\t\t\t// Prevent inline from loading the same styles twice\n
\t\t\tif (self !== DOMUtils.DOM && doc === document) {\n
\t\t\t\tvar addedStyles = DOMUtils.DOM.addedStyles;\n
\n
\t\t\t\taddedStyles = addedStyles || [];\n
\t\t\t\tif (addedStyles[cssText]) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\taddedStyles[cssText] = true;\n
\t\t\t\tDOMUtils.DOM.addedStyles = addedStyles;\n
\t\t\t}\n
\n
\t\t\t// Create style element if needed\n
\t\t\tstyleElm = doc.getElementById(\'mceDefaultStyles\');\n
\t\t\tif (!styleElm) {\n
\t\t\t\tstyleElm = doc.createElement(\'style\');\n
\t\t\t\tstyleElm.id = \'mceDefaultStyles\';\n
\t\t\t\tstyleElm.type = \'text/css\';\n
\n
\t\t\t\thead = doc.getElementsByTagName(\'head\')[0];\n
\t\t\t\tif (head.firstChild) {\n
\t\t\t\t\thead.insertBefore(styleElm, head.firstChild);\n
\t\t\t\t} else {\n
\t\t\t\t\thead.appendChild(styleElm);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Append style data to old or new style element\n
\t\t\tif (styleElm.styleSheet) {\n
\t\t\t\tstyleElm.styleSheet.cssText += cssText;\n
\t\t\t} else {\n
\t\t\t\tstyleElm.appendChild(doc.createTextNode(cssText));\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Imports/loads the specified CSS file into the document bound to the class.\n
\t\t *\n
\t\t * @method loadCSS\n
\t\t * @param {String} u URL to CSS file to load.\n
\t\t * @example\n
\t\t * // Loads a CSS file dynamically into the current document\n
\t\t * tinymce.DOM.loadCSS(\'somepath/some.css\');\n
\t\t *\n
\t\t * // Loads a CSS file into the currently active editor instance\n
\t\t * tinymce.activeEditor.dom.loadCSS(\'somepath/some.css\');\n
\t\t *\n
\t\t * // Loads a CSS file into an editor instance by id\n
\t\t * tinymce.get(\'someid\').dom.loadCSS(\'somepath/some.css\');\n
\t\t *\n
\t\t * // Loads multiple CSS files into the current document\n
\t\t * tinymce.DOM.loadCSS(\'somepath/some.css,somepath/someother.css\');\n
\t\t */\n
\t\tloadCSS: function(url) {\n
\t\t\tvar self = this, doc = self.doc, head;\n
\n
\t\t\t// Prevent inline from loading the same CSS file twice\n
\t\t\tif (self !== DOMUtils.DOM && doc === document) {\n
\t\t\t\tDOMUtils.DOM.loadCSS(url);\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!url) {\n
\t\t\t\turl = \'\';\n
\t\t\t}\n
\n
\t\t\thead = doc.getElementsByTagName(\'head\')[0];\n
\n
\t\t\teach(url.split(\',\'), function(url) {\n
\t\t\t\tvar link;\n
\n
\t\t\t\turl = Tools._addCacheSuffix(url);\n
\n
\t\t\t\tif (self.files[url]) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tself.files[url] = true;\n
\t\t\t\tlink = self.create(\'link\', {rel: \'stylesheet\', href: url});\n
\n
\t\t\t\t// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug\n
\t\t\t\t// This fix seems to resolve that issue by recalcing the document once a stylesheet finishes loading\n
\t\t\t\t// It\'s ugly but it seems to work fine.\n
\t\t\t\tif (isIE && doc.documentMode && doc.recalc) {\n
\t\t\t\t\tlink.onload = function() {\n
\t\t\t\t\t\tif (doc.recalc) {\n
\t\t\t\t\t\t\tdoc.recalc();\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tlink.onload = null;\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\thead.appendChild(link);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a class to the specified element or elements.\n
\t\t *\n
\t\t * @method addClass\n
\t\t * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.\n
\t\t * @param {String} cls Class name to add to each element.\n
\t\t * @return {String/Array} String with new class value or array with new class values for all elements.\n
\t\t * @example\n
\t\t * // Adds a class to all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'myclass\');\n
\t\t *\n
\t\t * // Adds a class to a specific element in the current page\n
\t\t * tinymce.DOM.addClass(\'mydiv\', \'myclass\');\n
\t\t */\n
\t\taddClass: function(elm, cls) {\n
\t\t\tthis.$$(elm).addClass(cls);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes a class from the specified element or elements.\n
\t\t *\n
\t\t * @method removeClass\n
\t\t * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.\n
\t\t * @param {String} cls Class name to remove from each element.\n
\t\t * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements\n
\t\t * were passed in.\n
\t\t * @example\n
\t\t * // Removes a class from all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select(\'p\'), \'myclass\');\n
\t\t *\n
\t\t * // Removes a class from a specific element in the current page\n
\t\t * tinymce.DOM.removeClass(\'mydiv\', \'myclass\');\n
\t\t */\n
\t\tremoveClass: function(elm, cls) {\n
\t\t\tthis.toggleClass(elm, cls, false);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true if the specified element has the specified class.\n
\t\t *\n
\t\t * @method hasClass\n
\t\t * @param {String/Element} n HTML element or element id string to check CSS class on.\n
\t\t * @param {String} c CSS class to check for.\n
\t\t * @return {Boolean} true/false if the specified element has the specified class.\n
\t\t */\n
\t\thasClass: function(elm, cls) {\n
\t\t\treturn this.$$(elm).hasClass(cls);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Toggles the specified class on/off.\n
\t\t *\n
\t\t * @method toggleClass\n
\t\t * @param {Element} elm Element to toggle class on.\n
\t\t * @param {[type]} cls Class to toggle on/off.\n
\t\t * @param {[type]} state Optional state to set.\n
\t\t */\n
\t\ttoggleClass: function(elm, cls, state) {\n
\t\t\tthis.$$(elm).toggleClass(cls, state).each(function() {\n
\t\t\t\tif (this.className === \'\') {\n
\t\t\t\t\t$(this).attr(\'class\', null);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the specified element(s) by ID by setting the "display" style.\n
\t\t *\n
\t\t * @method show\n
\t\t * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.\n
\t\t */\n
\t\tshow: function(elm) {\n
\t\t\tthis.$$(elm).show();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the specified element(s) by ID by setting the "display" style.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to hide.\n
\t\t * @example\n
\t\t * // Hides an element by id in the document\n
\t\t * tinymce.DOM.hide(\'myid\');\n
\t\t */\n
\t\thide: function(elm) {\n
\t\t\tthis.$$(elm).hide();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the element is hidden or not by checking the "display" style.\n
\t\t *\n
\t\t * @method isHidden\n
\t\t * @param {String/Element} e Id or element to check display state on.\n
\t\t * @return {Boolean} true/false if the element is hidden or not.\n
\t\t */\n
\t\tisHidden: function(elm) {\n
\t\t\treturn this.$$(elm).css(\'display\') == \'none\';\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a unique id. This can be useful when generating elements on the fly.\n
\t\t * This method will not check if the element already exists.\n
\t\t *\n
\t\t * @method uniqueId\n
\t\t * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".\n
\t\t * @return {String} Unique id.\n
\t\t */\n
\t\tuniqueId: function(prefix) {\n
\t\t\treturn (!prefix ? \'mce_\' : prefix) + (this.counter++);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means\n
\t\t * URLs will get converted, hex color values fixed etc. Check processHTML for details.\n
\t\t *\n
\t\t * @method setHTML\n
\t\t * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.\n
\t\t * @param {String} h HTML content to set as inner HTML of the element.\n
\t\t * @example\n
\t\t * // Sets the inner HTML of all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select(\'p\'), \'some inner html\');\n
\t\t *\n
\t\t * // Sets the inner HTML of an element by id in the document\n
\t\t * tinymce.DOM.setHTML(\'mydiv\', \'some inner html\');\n
\t\t */\n
\t\tsetHTML: function(elm, html) {\n
\t\t\telm = this.$$(elm);\n
\n
\t\t\tif (isIE) {\n
\t\t\t\telm.each(function(i, target) {\n
\t\t\t\t\tif (target.canHaveHTML === false) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Remove all child nodes, IE keeps empty text nodes in DOM\n
\t\t\t\t\twhile (target.firstChild) {\n
\t\t\t\t\t\ttarget.removeChild(target.firstChild);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\t// IE will remove comments from the beginning\n
\t\t\t\t\t\t// unless you padd the contents with something\n
\t\t\t\t\t\ttarget.innerHTML = \'<br>\' + html;\n
\t\t\t\t\t\ttarget.removeChild(target.firstChild);\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// IE sometimes produces an unknown runtime error on innerHTML if it\'s a div inside a p\n
\t\t\t\t\t\t$(\'<div>\').html(\'<br>\' + html).contents().slice(1).appendTo(target);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn html;\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\telm.html(html);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the outer HTML of an element.\n
\t\t *\n
\t\t * @method getOuterHTML\n
\t\t * @param {String/Element} elm Element ID or element object to get outer HTML from.\n
\t\t * @return {String} Outer HTML string.\n
\t\t * @example\n
\t\t * tinymce.DOM.getOuterHTML(editorElement);\n
\t\t * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());\n
\t\t */\n
\t\tgetOuterHTML: function(elm) {\n
\t\t\telm = this.get(elm);\n
\n
\t\t\t// Older FF doesn\'t have outerHTML 3.6 is still used by some orgaizations\n
\t\t\treturn elm.nodeType == 1 && "outerHTML" in elm ? elm.outerHTML : $(\'<div>\').append($(elm).clone()).html();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified outer HTML on an element or elements.\n
\t\t *\n
\t\t * @method setOuterHTML\n
\t\t * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.\n
\t\t * @param {Object} html HTML code to set as outer value for the element.\n
\t\t * @param {Document} doc Optional document scope to use in this process - defaults to the document of the DOM class.\n
\t\t * @example\n
\t\t * // Sets the outer HTML of all paragraphs in the active editor\n
\t\t * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select(\'p\'), \'<div>some html</div>\');\n
\t\t *\n
\t\t * // Sets the outer HTML of an element by id in the document\n
\t\t * tinymce.DOM.setOuterHTML(\'mydiv\', \'<div>some html</div>\');\n
\t\t */\n
\t\tsetOuterHTML: function(elm, html) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.$$(elm).each(function() {\n
\t\t\t\ttry {\n
\t\t\t\t\t// Older FF doesn\'t have outerHTML 3.6 is still used by some orgaizations\n
\t\t\t\t\tif ("outerHTML" in this) {\n
\t\t\t\t\t\tthis.outerHTML = html;\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Ignore\n
\t\t\t\t}\n
\n
\t\t\t\t// OuterHTML for IE it sometimes produces an "unknown runtime error"\n
\t\t\t\tself.remove($(this).html(html), true);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Entity decodes a string. This method decodes any HTML entities, such as &aring;.\n
\t\t *\n
\t\t * @method decode\n
\t\t * @param {String} s String to decode entities on.\n
\t\t * @return {String} Entity decoded string.\n
\t\t */\n
\t\tdecode: Entities.decode,\n
\n
\t\t/**\n
\t\t * Entity encodes a string. This method encodes the most common entities, such as <>"&.\n
\t\t *\n
\t\t * @method encode\n
\t\t * @param {String} text String to encode with entities.\n
\t\t * @return {String} Entity encoded string.\n
\t\t */\n
\t\tencode: Entities.encodeAllRaw,\n
\n
\t\t/**\n
\t\t * Inserts an element after the reference element.\n
\t\t *\n
\t\t * @method insertAfter\n
\t\t * @param {Element} node Element to insert after the reference.\n
\t\t * @param {Element/String/Array} reference_node Reference element, element id or array of elements to insert after.\n
\t\t * @return {Element/Array} Element that got added or an array with elements.\n
\t\t */\n
\t\tinsertAfter: function(node, referenceNode) {\n
\t\t\treferenceNode = this.get(referenceNode);\n
\n
\t\t\treturn this.run(node, function(node) {\n
\t\t\t\tvar parent, nextSibling;\n
\n
\t\t\t\tparent = referenceNode.parentNode;\n
\t\t\t\tnextSibling = referenceNode.nextSibling;\n
\n
\t\t\t\tif (nextSibling) {\n
\t\t\t\t\tparent.insertBefore(node, nextSibling);\n
\t\t\t\t} else {\n
\t\t\t\t\tparent.appendChild(node);\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Replaces the specified element or elements with the new element specified. The new element will\n
\t\t * be cloned if multiple input elements are passed in.\n
\t\t *\n
\t\t * @method replace\n
\t\t * @param {Element} newElm New element to replace old ones with.\n
\t\t * @param {Element/String/Array} oldELm Element DOM node, element id or array of elements or ids to replace.\n
\t\t * @param {Boolean} k Optional keep children state, if set to true child nodes from the old object will be added to new ones.\n
\t\t */\n
\t\treplace: function(newElm, oldElm, keepChildren) {\n
\t\t\tvar self = this;\n
\n
\t\t\treturn self.run(oldElm, function(oldElm) {\n
\t\t\t\tif (is(oldElm, \'array\')) {\n
\t\t\t\t\tnewElm = newElm.cloneNode(true);\n
\t\t\t\t}\n
\n
\t\t\t\tif (keepChildren) {\n
\t\t\t\t\teach(grep(oldElm.childNodes), function(node) {\n
\t\t\t\t\t\tnewElm.appendChild(node);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\treturn oldElm.parentNode.replaceChild(newElm, oldElm);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renames the specified element and keeps its attributes and children.\n
\t\t *\n
\t\t * @method rename\n
\t\t * @param {Element} elm Element to rename.\n
\t\t * @param {String} name Name of the new element.\n
\t\t * @return {Element} New element or the old element if it needed renaming.\n
\t\t */\n
\t\trename: function(elm, name) {\n
\t\t\tvar self = this, newElm;\n
\n
\t\t\tif (elm.nodeName != name.toUpperCase()) {\n
\t\t\t\t// Rename block element\n
\t\t\t\tnewElm = self.create(name);\n
\n
\t\t\t\t// Copy attribs to new block\n
\t\t\t\teach(self.getAttribs(elm), function(attrNode) {\n
\t\t\t\t\tself.setAttrib(newElm, attrNode.nodeName, self.getAttrib(elm, attrNode.nodeName));\n
\t\t\t\t});\n
\n
\t\t\t\t// Replace block\n
\t\t\t\tself.replace(newElm, elm, 1);\n
\t\t\t}\n
\n
\t\t\treturn newElm || elm;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.\n
\t\t *\n
\t\t * @method findCommonAncestor\n
\t\t * @param {Element} a Element to find common ancestor of.\n
\t\t * @param {Element} b Element to find common ancestor of.\n
\t\t * @return {Element} Common ancestor element of the two input elements.\n
\t\t */\n
\t\tfindCommonAncestor: function(a, b) {\n
\t\t\tvar ps = a, pe;\n
\n
\t\t\twhile (ps) {\n
\t\t\t\tpe = b;\n
\n
\t\t\t\twhile (pe && ps != pe) {\n
\t\t\t\t\tpe = pe.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\tif (ps == pe) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tps = ps.parentNode;\n
\t\t\t}\n
\n
\t\t\tif (!ps && a.ownerDocument) {\n
\t\t\t\treturn a.ownerDocument.documentElement;\n
\t\t\t}\n
\n
\t\t\treturn ps;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Parses the specified RGB color value and returns a hex version of that color.\n
\t\t *\n
\t\t * @method toHex\n
\t\t * @param {String} rgbVal RGB string value like rgb(1,2,3)\n
\t\t * @return {String} Hex version of that RGB value like #FF00FF.\n
\t\t */\n
\t\ttoHex: function(rgbVal) {\n
\t\t\treturn this.styles.toHex(Tools.trim(rgbVal));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes the specified function on the element by id or dom element node or array of elements/id.\n
\t\t *\n
\t\t * @method run\n
\t\t * @param {String/Element/Array} Element ID or DOM element object or array with ids or elements.\n
\t\t * @param {function} f Function to execute for each item.\n
\t\t * @param {Object} s Optional scope to execute the function in.\n
\t\t * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.\n
\t\t */\n
\t\trun: function(elm, func, scope) {\n
\t\t\tvar self = this, result;\n
\n
\t\t\tif (typeof elm === \'string\') {\n
\t\t\t\telm = self.get(elm);\n
\t\t\t}\n
\n
\t\t\tif (!elm) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tscope = scope || this;\n
\t\t\tif (!elm.nodeType && (elm.length || elm.length === 0)) {\n
\t\t\t\tresult = [];\n
\n
\t\t\t\teach(elm, function(elm, i) {\n
\t\t\t\t\tif (elm) {\n
\t\t\t\t\t\tif (typeof elm == \'string\') {\n
\t\t\t\t\t\t\telm = self.get(elm);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tresult.push(func.call(scope, elm, i));\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn result;\n
\t\t\t}\n
\n
\t\t\treturn func.call(scope, elm);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a NodeList with attributes for the element.\n
\t\t *\n
\t\t * @method getAttribs\n
\t\t * @param {HTMLElement/string} elm Element node or string id to get attributes from.\n
\t\t * @return {NodeList} NodeList with attributes.\n
\t\t */\n
\t\tgetAttribs: function(elm) {\n
\t\t\tvar attrs;\n
\n
\t\t\telm = this.get(elm);\n
\n
\t\t\tif (!elm) {\n
\t\t\t\treturn [];\n
\t\t\t}\n
\n
\t\t\tif (isIE) {\n
\t\t\t\tattrs = [];\n
\n
\t\t\t\t// Object will throw exception in IE\n
\t\t\t\tif (elm.nodeName == \'OBJECT\') {\n
\t\t\t\t\treturn elm.attributes;\n
\t\t\t\t}\n
\n
\t\t\t\t// IE doesn\'t keep the selected attribute if you clone option elements\n
\t\t\t\tif (elm.nodeName === \'OPTION\' && this.getAttrib(elm, \'selected\')) {\n
\t\t\t\t\tattrs.push({specified: 1, nodeName: \'selected\'});\n
\t\t\t\t}\n
\n
\t\t\t\t// It\'s crazy that this is faster in IE but it\'s because it returns all attributes all the time\n
\t\t\t\tvar attrRegExp = /<\\/?[\\w:\\-]+ ?|=[\\"][^\\"]+\\"|=\\\'[^\\\']+\\\'|=[\\w\\-]+|>/gi;\n
\t\t\t\telm.cloneNode(false).outerHTML.replace(attrRegExp, \'\').replace(/[\\w:\\-]+/gi, function(a) {\n
\t\t\t\t\tattrs.push({specified: 1, nodeName: a});\n
\t\t\t\t});\n
\n
\t\t\t\treturn attrs;\n
\t\t\t}\n
\n
\t\t\treturn elm.attributes;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified node is to be considered empty or not.\n
\t\t *\n
\t\t * @example\n
\t\t * tinymce.DOM.isEmpty(node, {img: true});\n
\t\t * @method isEmpty\n
\t\t * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.\n
\t\t * @return {Boolean} true/false if the node is empty or not.\n
\t\t */\n
\t\tisEmpty: function(node, elements) {\n
\t\t\tvar self = this, i, attributes, type, walker, name, brCount = 0;\n
\n
\t\t\tnode = node.firstChild;\n
\t\t\tif (node) {\n
\t\t\t\twalker = new TreeWalker(node, node.parentNode);\n
\t\t\t\telements = elements || (self.schema ? self.schema.getNonEmptyElements() : null);\n
\n
\t\t\t\tdo {\n
\t\t\t\t\ttype = node.nodeType;\n
\n
\t\t\t\t\tif (type === 1) {\n
\t\t\t\t\t\t// Ignore bogus elements\n
\t\t\t\t\t\tif (node.getAttribute(\'data-mce-bogus\')) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Keep empty elements like <img />\n
\t\t\t\t\t\tname = node.nodeName.toLowerCase();\n
\t\t\t\t\t\tif (elements && elements[name]) {\n


]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAQ=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="4" aka="AAAAAAAAAAQ=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

\t\t\t\t\t\t\t// Ignore single BR elements in blocks like <p><br /></p> or <p><span><br /></span></p>\n
\t\t\t\t\t\t\tif (name === \'br\') {\n
\t\t\t\t\t\t\t\tbrCount++;\n
\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Keep elements with data-bookmark attributes or name attribute like <a name="1"></a>\n
\t\t\t\t\t\tattributes = self.getAttribs(node);\n
\t\t\t\t\t\ti = attributes.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tname = attributes[i].nodeName;\n
\t\t\t\t\t\t\tif (name === "name" || name === \'data-mce-bookmark\') {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Keep comment nodes\n
\t\t\t\t\tif (type == 8) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Keep non whitespace text nodes\n
\t\t\t\t\tif ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue))) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t} while ((node = walker.next()));\n
\t\t\t}\n
\n
\t\t\treturn brCount <= 1;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates a new DOM Range object. This will use the native DOM Range API if it\'s\n
\t\t * available. If it\'s not, it will fall back to the custom TinyMCE implementation.\n
\t\t *\n
\t\t * @method createRng\n
\t\t * @return {DOMRange} DOM Range object.\n
\t\t * @example\n
\t\t * var rng = tinymce.DOM.createRng();\n
\t\t * alert(rng.startContainer + "," + rng.startOffset);\n
\t\t */\n
\t\tcreateRng: function() {\n
\t\t\tvar doc = this.doc;\n
\n
\t\t\treturn doc.createRange ? doc.createRange() : new Range(this);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the index of the specified node within its parent.\n
\t\t *\n
\t\t * @method nodeIndex\n
\t\t * @param {Node} node Node to look for.\n
\t\t * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.\n
\t\t * @return {Number} Index of the specified node.\n
\t\t */\n
\t\tnodeIndex: function(node, normalized) {\n
\t\t\tvar idx = 0, lastNodeType, nodeType;\n
\n
\t\t\tif (node) {\n
\t\t\t\tfor (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {\n
\t\t\t\t\tnodeType = node.nodeType;\n
\n
\t\t\t\t\t// Normalize text nodes\n
\t\t\t\t\tif (normalized && nodeType == 3) {\n
\t\t\t\t\t\tif (nodeType == lastNodeType || !node.nodeValue.length) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t\tidx++;\n
\t\t\t\t\tlastNodeType = nodeType;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn idx;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Splits an element into two new elements and places the specified split\n
\t\t * element or elements between the new ones. For example splitting the paragraph at the bold element in\n
\t\t * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>.\n
\t\t *\n
\t\t * @method split\n
\t\t * @param {Element} parentElm Parent element to split.\n
\t\t * @param {Element} splitElm Element to split at.\n
\t\t * @param {Element} replacementElm Optional replacement element to replace the split element with.\n
\t\t * @return {Element} Returns the split element or the replacement element if that is specified.\n
\t\t */\n
\t\tsplit: function(parentElm, splitElm, replacementElm) {\n
\t\t\tvar self = this, r = self.createRng(), bef, aft, pa;\n
\n
\t\t\t// W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense\n
\t\t\t// but we don\'t want that in our code since it serves no purpose for the end user\n
\t\t\t// For example splitting this html at the bold element:\n
\t\t\t//   <p>text 1<span><b>CHOP</b></span>text 2</p>\n
\t\t\t// would produce:\n
\t\t\t//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>\n
\t\t\t// this function will then trim off empty edges and produce:\n
\t\t\t//   <p>text 1</p><b>CHOP</b><p>text 2</p>\n
\t\t\tfunction trimNode(node) {\n
\t\t\t\tvar i, children = node.childNodes, type = node.nodeType;\n
\n
\t\t\t\tfunction surroundedBySpans(node) {\n
\t\t\t\t\tvar previousIsSpan = node.previousSibling && node.previousSibling.nodeName == \'SPAN\';\n
\t\t\t\t\tvar nextIsSpan = node.nextSibling && node.nextSibling.nodeName == \'SPAN\';\n
\t\t\t\t\treturn previousIsSpan && nextIsSpan;\n
\t\t\t\t}\n
\n
\t\t\t\tif (type == 1 && node.getAttribute(\'data-mce-type\') == \'bookmark\') {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tfor (i = children.length - 1; i >= 0; i--) {\n
\t\t\t\t\ttrimNode(children[i]);\n
\t\t\t\t}\n
\n
\t\t\t\tif (type != 9) {\n
\t\t\t\t\t// Keep non whitespace text nodes\n
\t\t\t\t\tif (type == 3 && node.nodeValue.length > 0) {\n
\t\t\t\t\t\t// If parent element isn\'t a block or there isn\'t any useful contents for example "<p>   </p>"\n
\t\t\t\t\t\t// Also keep text nodes with only spaces if surrounded by spans.\n
\t\t\t\t\t\t// eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b\n
\t\t\t\t\t\tvar trimmedLength = trim(node.nodeValue).length;\n
\t\t\t\t\t\tif (!self.isBlock(node.parentNode) || trimmedLength > 0 || trimmedLength === 0 && surroundedBySpans(node)) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else if (type == 1) {\n
\t\t\t\t\t\t// If the only child is a bookmark then move it up\n
\t\t\t\t\t\tchildren = node.childNodes;\n
\n
\t\t\t\t\t\t// TODO fix this complex if\n
\t\t\t\t\t\tif (children.length == 1 && children[0] && children[0].nodeType == 1 &&\n
\t\t\t\t\t\t\tchildren[0].getAttribute(\'data-mce-type\') == \'bookmark\') {\n
\t\t\t\t\t\t\tnode.parentNode.insertBefore(children[0], node);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Keep non empty elements or img, hr etc\n
\t\t\t\t\t\tif (children.length || /^(br|hr|input|img)$/i.test(node.nodeName)) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.remove(node);\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\tif (parentElm && splitElm) {\n
\t\t\t\t// Get before chunk\n
\t\t\t\tr.setStart(parentElm.parentNode, self.nodeIndex(parentElm));\n
\t\t\t\tr.setEnd(splitElm.parentNode, self.nodeIndex(splitElm));\n
\t\t\t\tbef = r.extractContents();\n
\n
\t\t\t\t// Get after chunk\n
\t\t\t\tr = self.createRng();\n
\t\t\t\tr.setStart(splitElm.parentNode, self.nodeIndex(splitElm) + 1);\n
\t\t\t\tr.setEnd(parentElm.parentNode, self.nodeIndex(parentElm) + 1);\n
\t\t\t\taft = r.extractContents();\n
\n
\t\t\t\t// Insert before chunk\n
\t\t\t\tpa = parentElm.parentNode;\n
\t\t\t\tpa.insertBefore(trimNode(bef), parentElm);\n
\n
\t\t\t\t// Insert middle chunk\n
\t\t\t\tif (replacementElm) {\n
\t\t\t\t\tpa.replaceChild(replacementElm, splitElm);\n
\t\t\t\t} else {\n
\t\t\t\t\tpa.insertBefore(splitElm, parentElm);\n
\t\t\t\t}\n
\n
\t\t\t\t// Insert after chunk\n
\t\t\t\tpa.insertBefore(trimNode(aft), parentElm);\n
\t\t\t\tself.remove(parentElm);\n
\n
\t\t\t\treturn replacementElm || splitElm;\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds an event handler to the specified object.\n
\t\t *\n
\t\t * @method bind\n
\t\t * @param {Element/Document/Window/Array} target Target element to bind events to.\n
\t\t * handler to or an array of elements/ids/documents.\n
\t\t * @param {String} name Name of event handler to add, for example: click.\n
\t\t * @param {function} func Function to execute when the event occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t * @return {function} Function callback handler the same as the one passed in.\n
\t\t */\n
\t\tbind: function(target, name, func, scope) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (Tools.isArray(target)) {\n
\t\t\t\tvar i = target.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\ttarget[i] = self.bind(target[i], name, func, scope);\n
\t\t\t\t}\n
\n
\t\t\t\treturn target;\n
\t\t\t}\n
\n
\t\t\t// Collect all window/document events bound by editor instance\n
\t\t\tif (self.settings.collect && (target === self.doc || target === self.win)) {\n
\t\t\t\tself.boundEvents.push([target, name, func, scope]);\n
\t\t\t}\n
\n
\t\t\treturn self.events.bind(target, name, func, scope || self);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified event handler by name and function from an element or collection of elements.\n
\t\t *\n
\t\t * @method unbind\n
\t\t * @param {Element/Document/Window/Array} target Target element to unbind events on.\n
\t\t * @param {String} name Event handler name, for example: "click"\n
\t\t * @param {function} func Function to remove.\n
\t\t * @return {bool/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements\n
\t\t * were passed in.\n
\t\t */\n
\t\tunbind: function(target, name, func) {\n
\t\t\tvar self = this, i;\n
\n
\t\t\tif (Tools.isArray(target)) {\n
\t\t\t\ti = target.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\ttarget[i] = self.unbind(target[i], name, func);\n
\t\t\t\t}\n
\n
\t\t\t\treturn target;\n
\t\t\t}\n
\n
\t\t\t// Remove any bound events matching the input\n
\t\t\tif (self.boundEvents && (target === self.doc || target === self.win)) {\n
\t\t\t\ti = self.boundEvents.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tvar item = self.boundEvents[i];\n
\n
\t\t\t\t\tif (target == item[0] && (!name || name == item[1]) && (!func || func == item[2])) {\n
\t\t\t\t\t\tthis.events.unbind(item[0], item[1], item[2]);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn this.events.unbind(target, name, func);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Fires the specified event name with object on target.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {Node/Document/Window} target Target element or object to fire event on.\n
\t\t * @param {String} name Name of the event to fire.\n
\t\t * @param {Object} evt Event object to send.\n
\t\t * @return {Event} Event object.\n
\t\t */\n
\t\tfire: function(target, name, evt) {\n
\t\t\treturn this.events.fire(target, name, evt);\n
\t\t},\n
\n
\t\t// Returns the content editable state of a node\n
\t\tgetContentEditable: function(node) {\n
\t\t\tvar contentEditable;\n
\n
\t\t\t// Check type\n
\t\t\tif (!node || node.nodeType != 1) {\n
\t\t\t\treturn null;\n
\t\t\t}\n
\n
\t\t\t// Check for fake content editable\n
\t\t\tcontentEditable = node.getAttribute("data-mce-contenteditable");\n
\t\t\tif (contentEditable && contentEditable !== "inherit") {\n
\t\t\t\treturn contentEditable;\n
\t\t\t}\n
\n
\t\t\t// Check for real content editable\n
\t\t\treturn node.contentEditable !== "inherit" ? node.contentEditable : null;\n
\t\t},\n
\n
\t\tgetContentEditableParent: function(node) {\n
\t\t\tvar root = this.getRoot(), state = null;\n
\n
\t\t\tfor (; node && node !== root; node = node.parentNode) {\n
\t\t\t\tstate = this.getContentEditable(node);\n
\n
\t\t\t\tif (state !== null) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn state;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Destroys all internal references to the DOM to solve IE leak issues.\n
\t\t *\n
\t\t * @method destroy\n
\t\t */\n
\t\tdestroy: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\t// Unbind all events bound to window/document by editor instance\n
\t\t\tif (self.boundEvents) {\n
\t\t\t\tvar i = self.boundEvents.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tvar item = self.boundEvents[i];\n
\t\t\t\t\tthis.events.unbind(item[0], item[1], item[2]);\n
\t\t\t\t}\n
\n
\t\t\t\tself.boundEvents = null;\n
\t\t\t}\n
\n
\t\t\t// Restore sizzle document to window.document\n
\t\t\t// Since the current document might be removed producing "Permission denied" on IE see #6325\n
\t\t\tif (Sizzle.setDocument) {\n
\t\t\t\tSizzle.setDocument();\n
\t\t\t}\n
\n
\t\t\tself.win = self.doc = self.root = self.events = self.frag = null;\n
\t\t},\n
\n
\t\tisChildOf: function(node, parent) {\n
\t\t\twhile (node) {\n
\t\t\t\tif (parent === node) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\tnode = node.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t},\n
\n
\t\t// #ifdef debug\n
\n
\t\tdumpRng: function(r) {\n
\t\t\treturn (\n
\t\t\t\t\'startContainer: \' + r.startContainer.nodeName +\n
\t\t\t\t\', startOffset: \' + r.startOffset +\n
\t\t\t\t\', endContainer: \' + r.endContainer.nodeName +\n
\t\t\t\t\', endOffset: \' + r.endOffset\n
\t\t\t);\n
\t\t},\n
\n
\t\t// #endif\n
\n
\t\t_findSib: function(node, selector, name) {\n
\t\t\tvar self = this, func = selector;\n
\n
\t\t\tif (node) {\n
\t\t\t\t// If expression make a function of it using is\n
\t\t\t\tif (typeof func == \'string\') {\n
\t\t\t\t\tfunc = function(node) {\n
\t\t\t\t\t\treturn self.is(node, selector);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\t// Loop all siblings\n
\t\t\t\tfor (node = node[name]; node; node = node[name]) {\n
\t\t\t\t\tif (func(node)) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn null;\n
\t\t}\n
\t};\n
\n
\t/**\n
\t * Instance of DOMUtils for the current document.\n
\t *\n
\t * @static\n
\t * @property DOM\n
\t * @type tinymce.dom.DOMUtils\n
\t * @example\n
\t * // Example of how to add a class to some element by id\n
\t * tinymce.DOM.addClass(\'someid\', \'someclass\');\n
\t */\n
\tDOMUtils.DOM = new DOMUtils(document);\n
\n
\treturn DOMUtils;\n
});\n
\n
// Included from: js/tinymce/classes/dom/ScriptLoader.js\n
\n
/**\n
 * ScriptLoader.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*globals console*/\n
\n
/**\n
 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks\n
 * when various items gets loaded. This class is useful to load external JavaScript files.\n
 *\n
 * @class tinymce.dom.ScriptLoader\n
 * @example\n
 * // Load a script from a specific URL using the global script loader\n
 * tinymce.ScriptLoader.load(\'somescript.js\');\n
 *\n
 * // Load a script using a unique instance of the script loader\n
 * var scriptLoader = new tinymce.dom.ScriptLoader();\n
 *\n
 * scriptLoader.load(\'somescript.js\');\n
 *\n
 * // Load multiple scripts\n
 * var scriptLoader = new tinymce.dom.ScriptLoader();\n
 *\n
 * scriptLoader.add(\'somescript1.js\');\n
 * scriptLoader.add(\'somescript2.js\');\n
 * scriptLoader.add(\'somescript3.js\');\n
 *\n
 * scriptLoader.loadQueue(function() {\n
 *    alert(\'All scripts are now loaded.\');\n
 * });\n
 */\n
define("tinymce/dom/ScriptLoader", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/util/Tools"\n
], function(DOMUtils, Tools) {\n
\tvar DOM = DOMUtils.DOM;\n
\tvar each = Tools.each, grep = Tools.grep;\n
\n
\tfunction ScriptLoader() {\n
\t\tvar QUEUED = 0,\n
\t\t\tLOADING = 1,\n
\t\t\tLOADED = 2,\n
\t\t\tstates = {},\n
\t\t\tqueue = [],\n
\t\t\tscriptLoadedCallbacks = {},\n
\t\t\tqueueLoadedCallbacks = [],\n
\t\t\tloading = 0,\n
\t\t\tundef;\n
\n
\t\t/**\n
\t\t * Loads a specific script directly without adding it to the load queue.\n
\t\t *\n
\t\t * @method load\n
\t\t * @param {String} url Absolute URL to script to add.\n
\t\t * @param {function} callback Optional callback function to execute ones this script gets loaded.\n
\t\t * @param {Object} scope Optional scope to execute callback in.\n
\t\t */\n
\t\tfunction loadScript(url, callback) {\n
\t\t\tvar dom = DOM, elm, id;\n
\n
\t\t\t// Execute callback when script is loaded\n
\t\t\tfunction done() {\n
\t\t\t\tdom.remove(id);\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\telm.onreadystatechange = elm.onload = elm = null;\n
\t\t\t\t}\n
\n
\t\t\t\tcallback();\n
\t\t\t}\n
\n
\t\t\tfunction error() {\n
\t\t\t\t/*eslint no-console:0 */\n
\n
\t\t\t\t// Report the error so it\'s easier for people to spot loading errors\n
\t\t\t\tif (typeof console !== "undefined" && console.log) {\n
\t\t\t\t\tconsole.log("Failed to load: " + url);\n
\t\t\t\t}\n
\n
\t\t\t\t// We can\'t mark it as done if there is a load error since\n
\t\t\t\t// A) We don\'t want to produce 404 errors on the server and\n
\t\t\t\t// B) the onerror event won\'t fire on all browsers.\n
\t\t\t\t// done();\n
\t\t\t}\n
\n
\t\t\tid = dom.uniqueId();\n
\n
\t\t\t// Create new script element\n
\t\t\telm = document.createElement(\'script\');\n
\t\t\telm.id = id;\n
\t\t\telm.type = \'text/javascript\';\n
\t\t\telm.src = Tools._addCacheSuffix(url);\n
\n
\t\t\t// Seems that onreadystatechange works better on IE 10 onload seems to fire incorrectly\n
\t\t\tif ("onreadystatechange" in elm) {\n
\t\t\t\telm.onreadystatechange = function() {\n
\t\t\t\t\tif (/loaded|complete/.test(elm.readyState)) {\n
\t\t\t\t\t\tdone();\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\t\t\t} else {\n
\t\t\t\telm.onload = done;\n
\t\t\t}\n
\n
\t\t\t// Add onerror event will get fired on some browsers but not all of them\n
\t\t\telm.onerror = error;\n
\n
\t\t\t// Add script to document\n
\t\t\t(document.getElementsByTagName(\'head\')[0] || document.body).appendChild(elm);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if a script has been loaded or not.\n
\t\t *\n
\t\t * @method isDone\n
\t\t * @param {String} url URL to check for.\n
\t\t * @return {Boolean} true/false if the URL is loaded.\n
\t\t */\n
\t\tthis.isDone = function(url) {\n
\t\t\treturn states[url] == LOADED;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Marks a specific script to be loaded. This can be useful if a script got loaded outside\n
\t\t * the script loader or to skip it from loading some script.\n
\t\t *\n
\t\t * @method markDone\n
\t\t * @param {string} u Absolute URL to the script to mark as loaded.\n
\t\t */\n
\t\tthis.markDone = function(url) {\n
\t\t\tstates[url] = LOADED;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Adds a specific script to the load queue of the script loader.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String} url Absolute URL to script to add.\n
\t\t * @param {function} callback Optional callback function to execute ones this script gets loaded.\n
\t\t * @param {Object} scope Optional scope to execute callback in.\n
\t\t */\n
\t\tthis.add = this.load = function(url, callback, scope) {\n
\t\t\tvar state = states[url];\n
\n
\t\t\t// Add url to load queue\n
\t\t\tif (state == undef) {\n
\t\t\t\tqueue.push(url);\n
\t\t\t\tstates[url] = QUEUED;\n
\t\t\t}\n
\n
\t\t\tif (callback) {\n
\t\t\t\t// Store away callback for later execution\n
\t\t\t\tif (!scriptLoadedCallbacks[url]) {\n
\t\t\t\t\tscriptLoadedCallbacks[url] = [];\n
\t\t\t\t}\n
\n
\t\t\t\tscriptLoadedCallbacks[url].push({\n
\t\t\t\t\tfunc: callback,\n
\t\t\t\t\tscope: scope || this\n
\t\t\t\t});\n
\t\t\t}\n
\t\t};\n
\n
\t\t/**\n
\t\t * Starts the loading of the queue.\n
\t\t *\n
\t\t * @method loadQueue\n
\t\t * @param {function} callback Optional callback to execute when all queued items are loaded.\n
\t\t * @param {Object} scope Optional scope to execute the callback in.\n
\t\t */\n
\t\tthis.loadQueue = function(callback, scope) {\n
\t\t\tthis.loadScripts(queue, callback, scope);\n
\t\t};\n
\n
\t\t/**\n
\t\t * Loads the specified queue of files and executes the callback ones they are loaded.\n
\t\t * This method is generally not used outside this class but it might be useful in some scenarios.\n
\t\t *\n
\t\t * @method loadScripts\n
\t\t * @param {Array} scripts Array of queue items to load.\n
\t\t * @param {function} callback Optional callback to execute ones all items are loaded.\n
\t\t * @param {Object} scope Optional scope to execute callback in.\n
\t\t */\n
\t\tthis.loadScripts = function(scripts, callback, scope) {\n
\t\t\tvar loadScripts;\n
\n
\t\t\tfunction execScriptLoadedCallbacks(url) {\n
\t\t\t\t// Execute URL callback functions\n
\t\t\t\teach(scriptLoadedCallbacks[url], function(callback) {\n
\t\t\t\t\tcallback.func.call(callback.scope);\n
\t\t\t\t});\n
\n
\t\t\t\tscriptLoadedCallbacks[url] = undef;\n
\t\t\t}\n
\n
\t\t\tqueueLoadedCallbacks.push({\n
\t\t\t\tfunc: callback,\n
\t\t\t\tscope: scope || this\n
\t\t\t});\n
\n
\t\t\tloadScripts = function() {\n
\t\t\t\tvar loadingScripts = grep(scripts);\n
\n
\t\t\t\t// Current scripts has been handled\n
\t\t\t\tscripts.length = 0;\n
\n
\t\t\t\t// Load scripts that needs to be loaded\n
\t\t\t\teach(loadingScripts, function(url) {\n
\t\t\t\t\t// Script is already loaded then execute script callbacks directly\n
\t\t\t\t\tif (states[url] == LOADED) {\n
\t\t\t\t\t\texecScriptLoadedCallbacks(url);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Is script not loading then start loading it\n
\t\t\t\t\tif (states[url] != LOADING) {\n
\t\t\t\t\t\tstates[url] = LOADING;\n
\t\t\t\t\t\tloading++;\n
\n
\t\t\t\t\t\tloadScript(url, function() {\n
\t\t\t\t\t\t\tstates[url] = LOADED;\n
\t\t\t\t\t\t\tloading--;\n
\n
\t\t\t\t\t\t\texecScriptLoadedCallbacks(url);\n
\n
\t\t\t\t\t\t\t// Load more scripts if they where added by the recently loaded script\n
\t\t\t\t\t\t\tloadScripts();\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// No scripts are currently loading then execute all pending queue loaded callbacks\n
\t\t\t\tif (!loading) {\n
\t\t\t\t\teach(queueLoadedCallbacks, function(callback) {\n
\t\t\t\t\t\tcallback.func.call(callback.scope);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tqueueLoadedCallbacks.length = 0;\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\tloadScripts();\n
\t\t};\n
\t}\n
\n
\tScriptLoader.ScriptLoader = new ScriptLoader();\n
\n
\treturn ScriptLoader;\n
});\n
\n
// Included from: js/tinymce/classes/AddOnManager.js\n
\n
/**\n
 * AddOnManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles the loading of themes/plugins or other add-ons and their language packs.\n
 *\n
 * @class tinymce.AddOnManager\n
 */\n
define("tinymce/AddOnManager", [\n
\t"tinymce/dom/ScriptLoader",\n
\t"tinymce/util/Tools"\n
], function(ScriptLoader, Tools) {\n
\tvar each = Tools.each;\n
\n
\tfunction AddOnManager() {\n
\t\tvar self = this;\n
\n
\t\tself.items = [];\n
\t\tself.urls = {};\n
\t\tself.lookup = {};\n
\t}\n
\n
\tAddOnManager.prototype = {\n
\t\t/**\n
\t\t * Returns the specified add on by the short name.\n
\t\t *\n
\t\t * @method get\n
\t\t * @param {String} name Add-on to look for.\n
\t\t * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.\n
\t\t */\n
\t\tget: function(name) {\n
\t\t\tif (this.lookup[name]) {\n
\t\t\t\treturn this.lookup[name].instance;\n
\t\t\t}\n
\n
\t\t\treturn undefined;\n
\t\t},\n
\n
\t\tdependencies: function(name) {\n
\t\t\tvar result;\n
\n
\t\t\tif (this.lookup[name]) {\n
\t\t\t\tresult = this.lookup[name].dependencies;\n
\t\t\t}\n
\n
\t\t\treturn result || [];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Loads a language pack for the specified add-on.\n
\t\t *\n
\t\t * @method requireLangPack\n
\t\t * @param {String} name Short name of the add-on.\n
\t\t * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.\n
\t\t */\n
\t\trequireLangPack: function(name, languages) {\n
\t\t\tvar language = AddOnManager.language;\n
\n
\t\t\tif (language && AddOnManager.languageLoad !== false) {\n
\t\t\t\tif (languages) {\n
\t\t\t\t\tlanguages = \',\' + languages + \',\';\n
\n
\t\t\t\t\t// Load short form sv.js or long form sv_SE.js\n
\t\t\t\t\tif (languages.indexOf(\',\' + language.substr(0, 2) + \',\') != -1) {\n
\t\t\t\t\t\tlanguage = language.substr(0, 2);\n
\t\t\t\t\t} else if (languages.indexOf(\',\' + language + \',\') == -1) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tScriptLoader.ScriptLoader.add(this.urls[name] + \'/langs/\' + language + \'.js\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a instance of the add-on by it\'s short name.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String} id Short name/id for the add-on.\n
\t\t * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.\n
\t\t * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.\n
\t\t * @example\n
\t\t * // Create a simple plugin\n
\t\t * tinymce.create(\'tinymce.plugins.TestPlugin\', {\n
\t\t *   TestPlugin: function(ed, url) {\n
\t\t *   ed.on(\'click\', function(e) {\n
\t\t *      ed.windowManager.alert(\'Hello World!\');\n
\t\t *   });\n
\t\t *   }\n
\t\t * });\n
\t\t *\n
\t\t * // Register plugin using the add method\n
\t\t * tinymce.PluginManager.add(\'test\', tinymce.plugins.TestPlugin);\n
\t\t *\n
\t\t * // Initialize TinyMCE\n
\t\t * tinymce.init({\n
\t\t *  ...\n
\t\t *  plugins: \'-test\' // Init the plugin but don\'t try to load it\n
\t\t * });\n
\t\t */\n
\t\tadd: function(id, addOn, dependencies) {\n
\t\t\tthis.items.push(addOn);\n
\t\t\tthis.lookup[id] = {instance: addOn, dependencies: dependencies};\n
\n
\t\t\treturn addOn;\n
\t\t},\n
\n
\t\tcreateUrl: function(baseUrl, dep) {\n
\t\t\tif (typeof dep === "object") {\n
\t\t\t\treturn dep;\n
\t\t\t}\n
\n
\t\t\treturn {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};\n
\t\t},\n
\n
\t\t/**\n
\t\t * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.\n
\t\t * This should be used in development mode.  A new compressor/javascript munger process will ensure that the\n
\t\t * components are put together into the plugin.js file and compressed correctly.\n
\t\t *\n
\t\t * @method addComponents\n
\t\t * @param {String} pluginName name of the plugin to load scripts from (will be used to get the base url for the plugins).\n
\t\t * @param {Array} scripts Array containing the names of the scripts to load.\n
\t\t */\n
\t\taddComponents: function(pluginName, scripts) {\n
\t\t\tvar pluginUrl = this.urls[pluginName];\n
\n
\t\t\teach(scripts, function(script) {\n
\t\t\t\tScriptLoader.ScriptLoader.add(pluginUrl + "/" + script);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Loads an add-on from a specific url.\n
\t\t *\n
\t\t * @method load\n
\t\t * @param {String} name Short name of the add-on that gets loaded.\n
\t\t * @param {String} addOnUrl URL to the add-on that will get loaded.\n
\t\t * @param {function} callback Optional callback to execute ones the add-on is loaded.\n
\t\t * @param {Object} scope Optional scope to execute the callback in.\n
\t\t * @example\n
\t\t * // Loads a plugin from an external URL\n
\t\t * tinymce.PluginManager.load(\'myplugin\', \'/some/dir/someplugin/plugin.js\');\n
\t\t *\n
\t\t * // Initialize TinyMCE\n
\t\t * tinymce.init({\n
\t\t *  ...\n
\t\t *  plugins: \'-myplugin\' // Don\'t try to load it again\n
\t\t * });\n
\t\t */\n
\t\tload: function(name, addOnUrl, callback, scope) {\n
\t\t\tvar self = this, url = addOnUrl;\n
\n
\t\t\tfunction loadDependencies() {\n
\t\t\t\tvar dependencies = self.dependencies(name);\n
\n
\t\t\t\teach(dependencies, function(dep) {\n
\t\t\t\t\tvar newUrl = self.createUrl(addOnUrl, dep);\n
\n
\t\t\t\t\tself.load(newUrl.resource, newUrl, undefined, undefined);\n
\t\t\t\t});\n
\n
\t\t\t\tif (callback) {\n
\t\t\t\t\tif (scope) {\n
\t\t\t\t\t\tcallback.call(scope);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tcallback.call(ScriptLoader);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (self.urls[name]) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (typeof addOnUrl === "object") {\n
\t\t\t\turl = addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n
\t\t\t}\n
\n
\t\t\tif (url.indexOf(\'/\') !== 0 && url.indexOf(\'://\') == -1) {\n
\t\t\t\turl = AddOnManager.baseURL + \'/\' + url;\n
\t\t\t}\n
\n
\t\t\tself.urls[name] = url.substring(0, url.lastIndexOf(\'/\'));\n
\n
\t\t\tif (self.lookup[name]) {\n
\t\t\t\tloadDependencies();\n
\t\t\t} else {\n
\t\t\t\tScriptLoader.ScriptLoader.add(url, loadDependencies, scope);\n
\t\t\t}\n
\t\t}\n
\t};\n
\n
\tAddOnManager.PluginManager = new AddOnManager();\n
\tAddOnManager.ThemeManager = new AddOnManager();\n
\n
\treturn AddOnManager;\n
});\n
\n
/**\n
 * TinyMCE theme class.\n
 *\n
 * @class tinymce.Theme\n
 */\n
\n
/**\n
 * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.\n
 *\n
 * @method renderUI\n
 * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.\n
 * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.\n
 */\n
\n
/**\n
 * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.\n
 *\n
 * @class tinymce.Plugin\n
 * @example\n
 * tinymce.PluginManager.add(\'example\', function(editor, url) {\n
 *     // Add a button that opens a window\n
 *     editor.addButton(\'example\', {\n
 *         text: \'My button\',\n
 *         icon: false,\n
 *         onclick: function() {\n
 *             // Open window\n
 *             editor.windowManager.open({\n
 *                 title: \'Example plugin\',\n
 *                 body: [\n
 *                     {type: \'textbox\', name: \'title\', label: \'Title\'}\n
 *                 ],\n
 *                 onsubmit: function(e) {\n
 *                     // Insert content when the window form is submitted\n
 *                     editor.insertContent(\'Title: \' + e.data.title);\n
 *                 }\n
 *             });\n
 *         }\n
 *     });\n
 *\n
 *     // Adds a menu item to the tools menu\n
 *     editor.addMenuItem(\'example\', {\n
 *         text: \'Example plugin\',\n
 *         context: \'tools\',\n
 *         onclick: function() {\n
 *             // Open window with a specific url\n
 *             editor.windowManager.open({\n
 *                 title: \'TinyMCE site\',\n
 *                 url: \'http://www.tinymce.com\',\n
 *                 width: 800,\n
 *                 height: 600,\n
 *                 buttons: [{\n
 *                     text: \'Close\',\n
 *                     onclick: \'close\'\n
 *                 }]\n
 *             });\n
 *         }\n
 *     });\n
 * });\n
 */\n
\n
// Included from: js/tinymce/classes/dom/RangeUtils.js\n
\n
/**\n
 * RangeUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains a few utility methods for ranges.\n
 *\n
 * @class tinymce.dom.RangeUtils\n
 */\n
define("tinymce/dom/RangeUtils", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/TreeWalker"\n
], function(Tools, TreeWalker) {\n
\tvar each = Tools.each;\n
\n
\tfunction getEndChild(container, index) {\n
\t\tvar childNodes = container.childNodes;\n
\n
\t\tindex--;\n
\n
\t\tif (index > childNodes.length - 1) {\n
\t\t\tindex = childNodes.length - 1;\n
\t\t} else if (index < 0) {\n
\t\t\tindex = 0;\n
\t\t}\n
\n
\t\treturn childNodes[index] || container;\n
\t}\n
\n
\tfunction RangeUtils(dom) {\n
\t\t/**\n
\t\t * Walks the specified range like object and executes the callback for each sibling collection it finds.\n
\t\t *\n
\t\t * @private\n
\t\t * @method walk\n
\t\t * @param {Object} rng Range like object.\n
\t\t * @param {function} callback Callback function to execute for each sibling collection.\n
\t\t */\n
\t\tthis.walk = function(rng, callback) {\n
\t\t\tvar startContainer = rng.startContainer,\n
\t\t\t\tstartOffset = rng.startOffset,\n
\t\t\t\tendContainer = rng.endContainer,\n
\t\t\t\tendOffset = rng.endOffset,\n
\t\t\t\tancestor, startPoint,\n
\t\t\t\tendPoint, node, parent, siblings, nodes;\n
\n
\t\t\t// Handle table cell selection the table plugin enables\n
\t\t\t// you to fake select table cells and perform formatting actions on them\n
\t\t\tnodes = dom.select(\'td.mce-item-selected,th.mce-item-selected\');\n
\t\t\tif (nodes.length > 0) {\n
\t\t\t\teach(nodes, function(node) {\n
\t\t\t\t\tcallback([node]);\n
\t\t\t\t});\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Excludes start/end text node if they are out side the range\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Array} nodes Nodes to exclude items from.\n
\t\t\t * @return {Array} Array with nodes excluding the start/end container if needed.\n
\t\t\t */\n
\t\t\tfunction exclude(nodes) {\n
\t\t\t\tvar node;\n
\n
\t\t\t\t// First node is excluded\n
\t\t\t\tnode = nodes[0];\n
\t\t\t\tif (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {\n
\t\t\t\t\tnodes.splice(0, 1);\n
\t\t\t\t}\n
\n
\t\t\t\t// Last node is excluded\n
\t\t\t\tnode = nodes[nodes.length - 1];\n
\t\t\t\tif (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {\n
\t\t\t\t\tnodes.splice(nodes.length - 1, 1);\n
\t\t\t\t}\n
\n
\t\t\t\treturn nodes;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Collects siblings\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Node} node Node to collect siblings from.\n
\t\t\t * @param {String} name Name of the sibling to check for.\n
\t\t\t * @return {Array} Array of collected siblings.\n
\t\t\t */\n
\t\t\tfunction collectSiblings(node, name, end_node) {\n
\t\t\t\tvar siblings = [];\n
\n
\t\t\t\tfor (; node && node != end_node; node = node[name]) {\n
\t\t\t\t\tsiblings.push(node);\n
\t\t\t\t}\n
\n
\t\t\t\treturn siblings;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Find an end point this is the node just before the common ancestor root.\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Node} node Node to start at.\n
\t\t\t * @param {Node} root Root/ancestor element to stop just before.\n
\t\t\t * @return {Node} Node just before the root element.\n
\t\t\t */\n
\t\t\tfunction findEndPoint(node, root) {\n
\t\t\t\tdo {\n
\t\t\t\t\tif (node.parentNode == root) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t} while (node);\n
\t\t\t}\n
\n
\t\t\tfunction walkBoundary(start_node, end_node, next) {\n
\t\t\t\tvar siblingName = next ? \'nextSibling\' : \'previousSibling\';\n
\n
\t\t\t\tfor (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {\n
\t\t\t\t\tparent = node.parentNode;\n
\t\t\t\t\tsiblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);\n
\n
\t\t\t\t\tif (siblings.length) {\n
\t\t\t\t\t\tif (!next) {\n
\t\t\t\t\t\t\tsiblings.reverse();\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tcallback(exclude(siblings));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// If index based start position then resolve it\n
\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {\n
\t\t\t\tstartContainer = startContainer.childNodes[startOffset];\n
\t\t\t}\n
\n
\t\t\t// If index based end position then resolve it\n
\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {\n
\t\t\t\tendContainer = getEndChild(endContainer, endOffset);\n
\t\t\t}\n
\n
\t\t\t// Same container\n
\t\t\tif (startContainer == endContainer) {\n
\t\t\t\treturn callback(exclude([startContainer]));\n
\t\t\t}\n
\n
\t\t\t// Find common ancestor and end points\n
\t\t\tancestor = dom.findCommonAncestor(startContainer, endContainer);\n
\n
\t\t\t// Process left side\n
\t\t\tfor (node = startContainer; node; node = node.parentNode) {\n
\t\t\t\tif (node === endContainer) {\n
\t\t\t\t\treturn walkBoundary(startContainer, ancestor, true);\n
\t\t\t\t}\n
\n
\t\t\t\tif (node === ancestor) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Process right side\n
\t\t\tfor (node = endContainer; node; node = node.parentNode) {\n
\t\t\t\tif (node === startContainer) {\n
\t\t\t\t\treturn walkBoundary(endContainer, ancestor);\n
\t\t\t\t}\n
\n
\t\t\t\tif (node === ancestor) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Find start/end point\n
\t\t\tstartPoint = findEndPoint(startContainer, ancestor) || startContainer;\n
\t\t\tendPoint = findEndPoint(endContainer, ancestor) || endContainer;\n
\n
\t\t\t// Walk left leaf\n
\t\t\twalkBoundary(startContainer, startPoint, true);\n
\n
\t\t\t// Walk the middle from start to end point\n
\t\t\tsiblings = collectSiblings(\n
\t\t\t\tstartPoint == startContainer ? startPoint : startPoint.nextSibling,\n
\t\t\t\t\'nextSibling\',\n
\t\t\t\tendPoint == endContainer ? endPoint.nextSibling : endPoint\n
\t\t\t);\n
\n
\t\t\tif (siblings.length) {\n
\t\t\t\tcallback(exclude(siblings));\n
\t\t\t}\n
\n
\t\t\t// Walk right leaf\n
\t\t\twalkBoundary(endContainer, endPoint);\n
\t\t};\n
\n
\t\t/**\n
\t\t * Splits the specified range at it\'s start/end points.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Range/RangeObject} rng Range to split.\n
\t\t * @return {Object} Range position object.\n
\t\t */\n
\t\tthis.split = function(rng) {\n
\t\t\tvar startContainer = rng.startContainer,\n
\t\t\t\tstartOffset = rng.startOffset,\n
\t\t\t\tendContainer = rng.endContainer,\n
\t\t\t\tendOffset = rng.endOffset;\n
\n
\t\t\tfunction splitText(node, offset) {\n
\t\t\t\treturn node.splitText(offset);\n
\t\t\t}\n
\n
\t\t\t// Handle single text node\n
\t\t\tif (startContainer == endContainer && startContainer.nodeType == 3) {\n
\t\t\t\tif (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n
\t\t\t\t\tendContainer = splitText(startContainer, startOffset);\n
\t\t\t\t\tstartContainer = endContainer.previousSibling;\n
\n
\t\t\t\t\tif (endOffset > startOffset) {\n
\t\t\t\t\t\tendOffset = endOffset - startOffset;\n
\t\t\t\t\t\tstartContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\n
\t\t\t\t\t\tendOffset = endContainer.nodeValue.length;\n
\t\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tendOffset = 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Split startContainer text node if needed\n
\t\t\t\tif (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\n
\t\t\t\t\tstartContainer = splitText(startContainer, startOffset);\n
\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t}\n
\n
\t\t\t\t// Split endContainer text node if needed\n
\t\t\t\tif (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\n
\t\t\t\t\tendContainer = splitText(endContainer, endOffset).previousSibling;\n
\t\t\t\t\tendOffset = endContainer.nodeValue.length;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn {\n
\t\t\t\tstartContainer: startContainer,\n
\t\t\t\tstartOffset: startOffset,\n
\t\t\t\tendContainer: endContainer,\n
\t\t\t\tendOffset: endOffset\n
\t\t\t};\n
\t\t};\n
\n
\t\t/**\n
\t\t * Normalizes the specified range by finding the closest best suitable caret location.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Range} rng Range to normalize.\n
\t\t * @return {Boolean} True/false if the specified range was normalized or not.\n
\t\t */\n
\t\tthis.normalize = function(rng) {\n
\t\t\tvar normalized, collapsed;\n
\n
\t\t\tfunction normalizeEndPoint(start) {\n
\t\t\t\tvar container, offset, walker, body = dom.getRoot(), node, nonEmptyElementsMap;\n
\t\t\t\tvar directionLeft, isAfterNode;\n
\n
\t\t\t\tfunction hasBrBeforeAfter(node, left) {\n
\t\t\t\t\tvar walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);\n
\n
\t\t\t\t\twhile ((node = walker[left ? \'prev\' : \'next\']())) {\n
\t\t\t\t\t\tif (node.nodeName === "BR") {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction isPrevNode(node, name) {\n
\t\t\t\t\treturn node.previousSibling && node.previousSibling.nodeName == name;\n
\t\t\t\t}\n
\n
\t\t\t\t// Walks the dom left/right to find a suitable text node to move the endpoint into\n
\t\t\t\t// It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG\n
\t\t\t\tfunction findTextNodeRelative(left, startNode) {\n
\t\t\t\t\tvar walker, lastInlineElement, parentBlockContainer;\n
\n
\t\t\t\t\tstartNode = startNode || container;\n
\t\t\t\t\tparentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\n
\n
\t\t\t\t\t// Lean left before the BR element if it\'s the only BR within a block element. Gecko bug: #6680\n
\t\t\t\t\t// This: <p><br>|</p> becomes <p>|<br></p>\n
\t\t\t\t\tif (left && startNode.nodeName == \'BR\' && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n
\t\t\t\t\t\tcontainer = startNode.parentNode;\n
\t\t\t\t\t\toffset = dom.nodeIndex(startNode);\n
\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Walk left until we hit a text node we can move to or a block/br/img\n
\t\t\t\t\twalker = new TreeWalker(startNode, parentBlockContainer);\n
\t\t\t\t\twhile ((node = walker[left ? \'prev\' : \'next\']())) {\n
\t\t\t\t\t\t// Break if we hit a non content editable node\n
\t\t\t\t\t\tif (dom.getContentEditableParent(node) === "false") {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Found text node that has a length\n
\t\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length > 0) {\n
\t\t\t\t\t\t\tcontainer = node;\n
\t\t\t\t\t\t\toffset = left ? node.nodeValue.length : 0;\n
\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Break if we find a block or a BR/IMG/INPUT etc\n
\t\t\t\t\t\tif (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tlastInlineElement = node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Only fetch the last inline element when in caret mode for now\n
\t\t\t\t\tif (collapsed && lastInlineElement) {\n
\t\t\t\t\t\tcontainer = lastInlineElement;\n
\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\toffset = 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tcontainer = rng[(start ? \'start\' : \'end\') + \'Container\'];\n
\t\t\t\toffset = rng[(start ? \'start\' : \'end\') + \'Offset\'];\n
\t\t\t\tisAfterNode = container.nodeType == 1 && offset === container.childNodes.length;\n
\t\t\t\tnonEmptyElementsMap = dom.schema.getNonEmptyElements();\n
\t\t\t\tdirectionLeft = start;\n
\n
\t\t\t\tif (container.nodeType == 1 && offset > container.childNodes.length - 1) {\n
\t\t\t\t\tdirectionLeft = false;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the container is a document move it to the body element\n
\t\t\t\tif (container.nodeType === 9) {\n
\t\t\t\t\tcontainer = dom.getRoot();\n
\t\t\t\t\toffset = 0;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the container is body try move it into the closest text node or position\n
\t\t\t\tif (container === body) {\n
\t\t\t\t\t// If start is before/after a image, table etc\n
\t\t\t\t\tif (directionLeft) {\n
\t\t\t\t\t\tnode = container.childNodes[offset > 0 ? offset - 1 : 0];\n
\t\t\t\t\t\tif (node) {\n
\t\t\t\t\t\t\tif (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Resolve the index\n
\t\t\t\t\tif (container.hasChildNodes()) {\n
\t\t\t\t\t\toffset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n
\t\t\t\t\t\tcontainer = container.childNodes[offset];\n
\t\t\t\t\t\toffset = 0;\n
\n
\t\t\t\t\t\t// Don\'t walk into elements that doesn\'t have any child nodes like a IMG\n
\t\t\t\t\t\tif (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {\n
\t\t\t\t\t\t\t// Walk the DOM to find a text node to place the caret at or a BR\n
\t\t\t\t\t\t\tnode = container;\n
\t\t\t\t\t\t\twalker = new TreeWalker(container, body);\n
\n
\t\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\t\t// Found a text node use that position\n
\t\t\t\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length > 0) {\n
\t\t\t\t\t\t\t\t\toffset = directionLeft ? 0 : node.nodeValue.length;\n
\t\t\t\t\t\t\t\t\tcontainer = node;\n
\t\t\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t// Found a BR/IMG element that we can place the caret before\n
\t\t\t\t\t\t\t\tif (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\t\t\t\toffset = dom.nodeIndex(node);\n
\t\t\t\t\t\t\t\t\tcontainer = node.parentNode;\n
\n
\t\t\t\t\t\t\t\t\t// Put caret after image when moving the end point\n
\t\t\t\t\t\t\t\t\tif (node.nodeName == "IMG" && !directionLeft) {\n
\t\t\t\t\t\t\t\t\t\toffset++;\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\tnormalized = true;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t} while ((node = (directionLeft ? walker.next() : walker.prev())));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Lean the caret to the left if possible\n
\t\t\t\tif (collapsed) {\n
\t\t\t\t\t// So this: <b>x</b><i>|x</i>\n
\t\t\t\t\t// Becomes: <b>x|</b><i>x</i>\n
\t\t\t\t\t// Seems that only gecko has issues with this\n
\t\t\t\t\tif (container.nodeType === 3 && offset === 0) {\n
\t\t\t\t\t\tfindTextNodeRelative(true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Lean left into empty inline elements when the caret is before a BR\n
\t\t\t\t\t// So this: <i><b></b><i>|<br></i>\n
\t\t\t\t\t// Becomes: <i><b>|</b><i><br></i>\n
\t\t\t\t\t// Seems that only gecko has issues with this.\n
\t\t\t\t\t// Special edge case for <p><a>x</a>|<br></p> since we don\'t want <p><a>x|</a><br></p>\n
\t\t\t\t\tif (container.nodeType === 1) {\n
\t\t\t\t\t\tnode = container.childNodes[offset];\n
\n
\t\t\t\t\t\t// Offset is after the containers last child\n
\t\t\t\t\t\t// then use the previous child for normalization\n
\t\t\t\t\t\tif (!node) {\n
\t\t\t\t\t\t\tnode = container.childNodes[offset - 1];\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (node && node.nodeName === \'BR\' && !isPrevNode(node, \'A\') &&\n
\t\t\t\t\t\t\t!hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {\n
\t\t\t\t\t\t\tfindTextNodeRelative(true, node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Lean the start of the selection right if possible\n
\t\t\t\t// So this: x[<b>x]</b>\n
\t\t\t\t// Becomes: x<b>[x]</b>\n
\t\t\t\tif (directionLeft && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {\n
\t\t\t\t\tfindTextNodeRelative(false);\n
\t\t\t\t}\n
\n
\t\t\t\t// Set endpoint if it was normalized\n
\t\t\t\tif (normalized) {\n
\t\t\t\t\trng[\'set\' + (start ? \'Start\' : \'End\')](container, offset);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tcollapsed = rng.collapsed;\n
\n
\t\t\tnormalizeEndPoint(true);\n
\n
\t\t\tif (!collapsed) {\n
\t\t\t\tnormalizeEndPoint();\n
\t\t\t}\n
\n
\t\t\t// If it was collapsed then make sure it still is\n
\t\t\tif (normalized && collapsed) {\n
\t\t\t\trng.collapse(true);\n
\t\t\t}\n
\n
\t\t\treturn normalized;\n
\t\t};\n
\t}\n
\n
\t/**\n
\t * Compares two ranges and checks if they are equal.\n
\t *\n
\t * @static\n
\t * @method compareRanges\n
\t * @param {DOMRange} rng1 First range to compare.\n
\t * @param {DOMRange} rng2 First range to compare.\n
\t * @return {Boolean} true/false if the ranges are equal.\n
\t */\n
\tRangeUtils.compareRanges = function(rng1, rng2) {\n
\t\tif (rng1 && rng2) {\n
\t\t\t// Compare native IE ranges\n
\t\t\tif (rng1.item || rng1.duplicate) {\n
\t\t\t\t// Both are control ranges and the selected element matches\n
\t\t\t\tif (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Both are text ranges and the range matches\n
\t\t\t\tif (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Compare w3c ranges\n
\t\t\t\treturn rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn false;\n
\t};\n
\n
\t/**\n
\t * Gets the caret range for the given x/y location.\n
\t *\n
\t * @static\n
\t * @method getCaretRangeFromPoint\n
\t * @param {Number} x X coordinate for range\n
\t * @param {Number} y Y coordinate for range\n
\t * @param {Document} doc Document that x/y are relative to\n
\t * @returns {Range} caret range\n
\t */\n
\tRangeUtils.getCaretRangeFromPoint = function(x, y, doc) {\n
\t\tvar rng, point;\n
\n
\t\tif (doc.caretPositionFromPoint) {\n
\t\t\tpoint = doc.caretPositionFromPoint(x, y);\n
\t\t\trng = doc.createRange();\n
\t\t\trng.setStart(point.offsetNode, point.offset);\n
\t\t\trng.collapse(true);\n
\t\t} else if (doc.caretRangeFromPoint) {\n
\t\t\trng = doc.caretRangeFromPoint(x, y);\n
\t\t} else if (doc.body.createTextRange) {\n
\t\t\trng = doc.body.createTextRange();\n
\n
\t\t\ttry {\n
\t\t\t\trng.moveToPoint(x, y);\n
\t\t\t\trng.collapse(true);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Append to top or bottom depending on drop location\n
\t\t\t\trng.collapse(y < doc.body.clientHeight);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn rng;\n
\t};\n
\n
\tRangeUtils.getNode = function(container, offset) {\n
\t\tif (container.nodeType == 1 && container.hasChildNodes()) {\n
\t\t\tif (offset >= container.childNodes.length) {\n
\t\t\t\toffset = container.childNodes.length - 1;\n
\t\t\t}\n
\n
\t\t\tcontainer = container.childNodes[offset];\n
\t\t}\n
\n
\t\treturn container;\n
\t};\n
\n
\treturn RangeUtils;\n
});\n
\n
// Included from: js/tinymce/classes/NodeChange.js\n
\n
/**\n
 * NodeChange.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles the nodechange event dispatching both manual and though selection change events.\n
 *\n
 * @class tinymce.NodeChange\n
 * @private\n
 */\n
define("tinymce/NodeChange", [\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/Env"\n
], function(RangeUtils, Env) {\n
\treturn function(editor) {\n
\t\tvar lastRng, lastPath = [];\n
\n
\t\t/**\n
\t\t * Returns true/false if the current element path has been changed or not.\n
\t\t *\n
\t\t * @private\n
\t\t * @return {Boolean} True if the element path is the same false if it\'s not.\n
\t\t */\n
\t\tfunction isSameElementPath(startElm) {\n
\t\t\tvar i, currentPath;\n
\n
\t\t\tcurrentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);\n
\t\t\tif (currentPath.length === lastPath.length) {\n
\t\t\t\tfor (i = currentPath.length; i >= 0; i--) {\n
\t\t\t\t\tif (currentPath[i] !== lastPath[i]) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (i === -1) {\n
\t\t\t\t\tlastPath = currentPath;\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tlastPath = currentPath;\n
\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\t// Gecko doesn\'t support the "selectionchange" event\n
\t\tif (!(\'onselectionchange\' in editor.getDoc())) {\n
\t\t\teditor.on(\'NodeChange Click MouseUp KeyUp Focus\', function(e) {\n
\t\t\t\tvar nativeRng, fakeRng;\n
\n
\t\t\t\t// Since DOM Ranges mutate on modification\n
\t\t\t\t// of the DOM we need to clone it\'s contents\n
\t\t\t\tnativeRng = editor.selection.getRng();\n
\t\t\t\tfakeRng = {\n
\t\t\t\t\tstartContainer: nativeRng.startContainer,\n
\t\t\t\t\tstartOffset: nativeRng.startOffset,\n
\t\t\t\t\tendContainer: nativeRng.endContainer,\n
\t\t\t\t\tendOffset: nativeRng.endOffset\n
\t\t\t\t};\n
\n
\t\t\t\t// Always treat nodechange as a selectionchange since applying\n
\t\t\t\t// formatting to the current range wouldn\'t update the range but it\'s parent\n
\t\t\t\tif (e.type == \'nodechange\' || !RangeUtils.compareRanges(fakeRng, lastRng)) {\n
\t\t\t\t\teditor.fire(\'SelectionChange\');\n
\t\t\t\t}\n
\n
\t\t\t\tlastRng = fakeRng;\n
\t\t\t});\n
\t\t}\n
\n
\t\t// IE has a bug where it fires a selectionchange on right click that has a range at the start of the body\n
\t\t// When the contextmenu event fires the selection is located at the right location\n
\t\teditor.on(\'contextmenu\', function() {\n
\t\t\teditor.fire(\'SelectionChange\');\n
\t\t});\n
\n
\t\t// Selection change is delayed ~200ms on IE when you click inside the current range\n
\t\teditor.on(\'SelectionChange\', function() {\n
\t\t\tvar startElm = editor.selection.getStart(true);\n
\n
\t\t\t// IE 8 will fire a selectionchange event with an incorrect selection\n
\t\t\t// when focusing out of table cells. Click inside cell -> toolbar = Invalid SelectionChange event\n
\t\t\tif (!Env.range && editor.selection.isCollapsed()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n
\t\t\t\teditor.nodeChanged({selectionChange: true});\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Fire an extra nodeChange on mouseup for compatibility reasons\n
\t\teditor.on(\'MouseUp\', function(e) {\n
\t\t\tif (!e.isDefaultPrevented()) {\n
\t\t\t\t// Delay nodeChanged call for WebKit edge case issue where the range\n
\t\t\t\t// isn\'t updated until after you click outside a selected image\n
\t\t\t\tif (editor.selection.getNode().nodeName == \'IMG\') {\n
\t\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t\t}, 0);\n
\t\t\t\t} else {\n
\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t/**\n
\t\t * Distpaches out a onNodeChange event to all observers. This method should be called when you\n
\t\t * need to update the UI states or element path etc.\n
\t\t *\n
\t\t * @method nodeChanged\n
\t\t * @param {Object} args Optional args to pass to NodeChange event handlers.\n
\t\t */\n
\t\tthis.nodeChanged = function(args) {\n
\t\t\tvar selection = editor.selection, node, parents, root;\n
\n
\t\t\t// Fix for bug #1896577 it seems that this can not be fired while the editor is loading\n
\t\t\tif (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.settings.readonly) {\n
\t\t\t\t// Get start node\n
\t\t\t\troot = editor.getBody();\n
\t\t\t\tnode = selection.getStart() || root;\n
\t\t\t\tnode = node.ownerDocument != editor.getDoc() ? editor.getBody() : node;\n
\n
\t\t\t\t// Edge case for <p>|<img></p>\n
\t\t\t\tif (node.nodeName == \'IMG\' && selection.isCollapsed()) {\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\t// Get parents and add them to object\n
\t\t\t\tparents = [];\n
\t\t\t\teditor.dom.getParent(node, function(node) {\n
\t\t\t\t\tif (node === root) {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparents.push(node);\n
\t\t\t\t});\n
\n
\t\t\t\targs = args || {};\n
\t\t\t\targs.element = node;\n
\t\t\t\targs.parents = parents;\n
\n
\t\t\t\teditor.fire(\'NodeChange\', args);\n
\t\t\t}\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/html/Node.js\n
\n
/**\n
 * Node.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is a minimalistic implementation of a DOM like node used by the DomParser class.\n
 *\n
 * @example\n
 * var node = new tinymce.html.Node(\'strong\', 1);\n
 * someRoot.append(node);\n
 *\n
 * @class tinymce.html.Node\n
 * @version 3.4\n
 */\n
define("tinymce/html/Node", [], function() {\n
\tvar whiteSpaceRegExp = /^[ \\t\\r\\n]*$/, typeLookup = {\n
\t\t\'#text\': 3,\n
\t\t\'#comment\': 8,\n
\t\t\'#cdata\': 4,\n
\t\t\'#pi\': 7,\n
\t\t\'#doctype\': 10,\n
\t\t\'#document-fragment\': 11\n
\t};\n
\n
\t// Walks the tree left/right\n
\tfunction walk(node, root_node, prev) {\n
\t\tvar sibling, parent, startName = prev ? \'lastChild\' : \'firstChild\', siblingName = prev ? \'prev\' : \'next\';\n
\n
\t\t// Walk into nodes if it has a start\n
\t\tif (node[startName]) {\n
\t\t\treturn node[startName];\n
\t\t}\n
\n
\t\t// Return the sibling if it has one\n
\t\tif (node !== root_node) {\n
\t\t\tsibling = node[siblingName];\n
\n
\t\t\tif (sibling) {\n
\t\t\t\treturn sibling;\n
\t\t\t}\n
\n
\t\t\t// Walk up the parents to look for siblings\n
\t\t\tfor (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {\n
\t\t\t\tsibling = parent[siblingName];\n
\n
\t\t\t\tif (sibling) {\n
\t\t\t\t\treturn sibling;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Constructs a new Node instance.\n
\t *\n
\t * @constructor\n
\t * @method Node\n
\t * @param {String} name Name of the node type.\n
\t * @param {Number} type Numeric type representing the node.\n
\t */\n
\tfunction Node(name, type) {\n
\t\tthis.name = name;\n
\t\tthis.type = type;\n
\n
\t\tif (type === 1) {\n
\t\t\tthis.attributes = [];\n
\t\t\tthis.attributes.map = {};\n
\t\t}\n
\t}\n
\n
\tNode.prototype = {\n
\t\t/**\n
\t\t * Replaces the current node with the specified one.\n
\t\t *\n
\t\t * @example\n
\t\t * someNode.replace(someNewNode);\n
\t\t *\n
\t\t * @method replace\n
\t\t * @param {tinymce.html.Node} node Node to replace the current node with.\n
\t\t * @return {tinymce.html.Node} The old node that got replaced.\n
\t\t */\n
\t\treplace: function(node) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (node.parent) {\n
\t\t\t\tnode.remove();\n
\t\t\t}\n
\n
\t\t\tself.insert(node, self);\n
\t\t\tself.remove();\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets/sets or removes an attribute by name.\n
\t\t *\n
\t\t * @example\n
\t\t * someNode.attr("name", "value"); // Sets an attribute\n
\t\t * console.log(someNode.attr("name")); // Gets an attribute\n
\t\t * someNode.attr("name", null); // Removes an attribute\n
\t\t *\n
\t\t * @method attr\n
\t\t * @param {String} name Attribute name to set or get.\n
\t\t * @param {String} value Optional value to set.\n
\t\t * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.\n
\t\t */\n
\t\tattr: function(name, value) {\n
\t\t\tvar self = this, attrs, i, undef;\n
\n
\t\t\tif (typeof name !== "string") {\n
\t\t\t\tfor (i in name) {\n
\t\t\t\t\tself.attr(i, name[i]);\n
\t\t\t\t}\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\tif ((attrs = self.attributes)) {\n
\t\t\t\tif (value !== undef) {\n
\t\t\t\t\t// Remove attribute\n
\t\t\t\t\tif (value === null) {\n
\t\t\t\t\t\tif (name in attrs.map) {\n
\t\t\t\t\t\t\tdelete attrs.map[name];\n
\n
\t\t\t\t\t\t\ti = attrs.length;\n
\t\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\t\tif (attrs[i].name === name) {\n
\t\t\t\t\t\t\t\t\tattrs = attrs.splice(i, 1);\n
\t\t\t\t\t\t\t\t\treturn self;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn self;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Set attribute\n
\t\t\t\t\tif (name in attrs.map) {\n
\t\t\t\t\t\t// Set attribute\n
\t\t\t\t\t\ti = attrs.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tif (attrs[i].name === name) {\n
\t\t\t\t\t\t\t\tattrs[i].value = value;\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tattrs.push({name: name, value: value});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tattrs.map[name] = value;\n
\n
\t\t\t\t\treturn self;\n
\t\t\t\t}\n
\n
\t\t\t\treturn attrs.map[name];\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Does a shallow clones the node into a new node. It will also exclude id attributes since\n
\t\t * there should only be one id per document.\n
\t\t *\n
\t\t * @example\n
\t\t * var clonedNode = node.clone();\n
\t\t *\n
\t\t * @method clone\n
\t\t * @return {tinymce.html.Node} New copy of the original node.\n
\t\t */\n
\t\tclone: function() {\n
\t\t\tvar self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;\n
\n
\t\t\t// Clone element attributes\n
\t\t\tif ((selfAttrs = self.attributes)) {\n
\t\t\t\tcloneAttrs = [];\n
\t\t\t\tcloneAttrs.map = {};\n
\n
\t\t\t\tfor (i = 0, l = selfAttrs.length; i < l; i++) {\n
\t\t\t\t\tselfAttr = selfAttrs[i];\n
\n
\t\t\t\t\t// Clone everything except id\n
\t\t\t\t\tif (selfAttr.name !== \'id\') {\n
\t\t\t\t\t\tcloneAttrs[cloneAttrs.length] = {name: selfAttr.name, value: selfAttr.value};\n
\t\t\t\t\t\tcloneAttrs.map[selfAttr.name] = selfAttr.value;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tclone.attributes = cloneAttrs;\n
\t\t\t}\n
\n
\t\t\tclone.value = self.value;\n
\t\t\tclone.shortEnded = self.shortEnded;\n
\n
\t\t\treturn clone;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Wraps the node in in another node.\n
\t\t *\n
\t\t * @example\n
\t\t * node.wrap(wrapperNode);\n
\t\t *\n
\t\t * @method wrap\n
\t\t */\n
\t\twrap: function(wrapper) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.parent.insert(wrapper, self);\n
\t\t\twrapper.append(self);\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unwraps the node in other words it removes the node but keeps the children.\n
\t\t *\n
\t\t * @example\n
\t\t * node.unwrap();\n
\t\t *\n
\t\t * @method unwrap\n
\t\t */\n
\t\tunwrap: function() {\n
\t\t\tvar self = this, node, next;\n
\n
\t\t\tfor (node = self.firstChild; node;) {\n
\t\t\t\tnext = node.next;\n
\t\t\t\tself.insert(node, self, true);\n
\t\t\t\tnode = next;\n
\t\t\t}\n
\n
\t\t\tself.remove();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the node from it\'s parent.\n
\t\t *\n
\t\t * @example\n
\t\t * node.remove();\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.html.Node} Current node that got removed.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this, parent = self.parent, next = self.next, prev = self.prev;\n
\n
\t\t\tif (parent) {\n
\t\t\t\tif (parent.firstChild === self) {\n
\t\t\t\t\tparent.firstChild = next;\n
\n
\t\t\t\t\tif (next) {\n
\t\t\t\t\t\tnext.prev = null;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tprev.next = next;\n
\t\t\t\t}\n
\n
\t\t\t\tif (parent.lastChild === self) {\n
\t\t\t\t\tparent.lastChild = prev;\n
\n
\t\t\t\t\tif (prev) {\n
\t\t\t\t\t\tprev.next = null;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tnext.prev = prev;\n
\t\t\t\t}\n
\n
\t\t\t\tself.parent = self.next = self.prev = null;\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Appends a new node as a child of the current node.\n
\t\t *\n
\t\t * @example\n
\t\t * node.append(someNode);\n
\t\t *\n
\t\t * @method append\n
\t\t * @param {tinymce.html.Node} node Node to append as a child of the current one.\n
\t\t * @return {tinymce.html.Node} The node that got appended.\n
\t\t */\n
\t\tappend: function(node) {\n
\t\t\tvar self = this, last;\n
\n
\t\t\tif (node.parent) {\n
\t\t\t\tnode.remove();\n
\t\t\t}\n
\n
\t\t\tlast = self.lastChild;\n
\t\t\tif (last) {\n
\t\t\t\tlast.next = node;\n
\t\t\t\tnode.prev = last;\n
\t\t\t\tself.lastChild = node;\n
\t\t\t} else {\n
\t\t\t\tself.lastChild = self.firstChild = node;\n
\t\t\t}\n
\n
\t\t\tnode.parent = self;\n
\n
\t\t\treturn node;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Inserts a node at a specific position as a child of the current node.\n
\t\t *\n
\t\t * @example\n
\t\t * parentNode.insert(newChildNode, oldChildNode);\n
\t\t *\n
\t\t * @method insert\n
\t\t * @param {tinymce.html.Node} node Node to insert as a child of the current node.\n
\t\t * @param {tinymce.html.Node} ref_node Reference node to set node before/after.\n
\t\t * @param {Boolean} before Optional state to insert the node before the reference node.\n
\t\t * @return {tinymce.html.Node} The node that got inserted.\n
\t\t */\n
\t\tinsert: function(node, ref_node, before) {\n
\t\t\tvar parent;\n
\n
\t\t\tif (node.parent) {\n
\t\t\t\tnode.remove();\n
\t\t\t}\n
\n
\t\t\tparent = ref_node.parent || this;\n
\n
\t\t\tif (before) {\n
\t\t\t\tif (ref_node === parent.firstChild) {\n
\t\t\t\t\tparent.firstChild = node;\n
\t\t\t\t} else {\n
\t\t\t\t\tref_node.prev.next = node;\n
\t\t\t\t}\n
\n
\t\t\t\tnode.prev = ref_node.prev;\n
\t\t\t\tnode.next = ref_node;\n
\t\t\t\tref_node.prev = node;\n
\t\t\t} else {\n
\t\t\t\tif (ref_node === parent.lastChild) {\n
\t\t\t\t\tparent.lastChild = node;\n
\t\t\t\t} else {\n
\t\t\t\t\tref_node.next.prev = node;\n
\t\t\t\t}\n
\n
\t\t\t\tnode.next = ref_node.next;\n
\t\t\t\tnode.prev = ref_node;\n
\t\t\t\tref_node.next = node;\n
\t\t\t}\n
\n
\t\t\tnode.parent = parent;\n
\n
\t\t\treturn node;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Get all children by name.\n
\t\t *\n
\t\t * @method getAll\n
\t\t * @param {String} name Name of the child nodes to collect.\n
\t\t * @return {Array} Array with child nodes matchin the specified name.\n
\t\t */\n
\t\tgetAll: function(name) {\n
\t\t\tvar self = this, node, collection = [];\n
\n
\t\t\tfor (node = self.firstChild; node; node = walk(node, self)) {\n
\t\t\t\tif (node.name === name) {\n
\t\t\t\t\tcollection.push(node);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn collection;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes all children of the current node.\n
\t\t *\n
\t\t * @method empty\n
\t\t * @return {tinymce.html.Node} The current node that got cleared.\n
\t\t */\n
\t\tempty: function() {\n
\t\t\tvar self = this, nodes, i, node;\n
\n
\t\t\t// Remove all children\n
\t\t\tif (self.firstChild) {\n
\t\t\t\tnodes = [];\n
\n
\t\t\t\t// Collect the children\n
\t\t\t\tfor (node = self.firstChild; node; node = walk(node, self)) {\n
\t\t\t\t\tnodes.push(node);\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove the children\n
\t\t\t\ti = nodes.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tnode.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.firstChild = self.lastChild = null;\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the node is to be considered empty or not.\n
\t\t *\n
\t\t * @example\n
\t\t * node.isEmpty({img: true});\n
\t\t * @method isEmpty\n
\t\t * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.\n
\t\t * @return {Boolean} true/false if the node is empty or not.\n
\t\t */\n
\t\tisEmpty: function(elements) {\n
\t\t\tvar self = this, node = self.firstChild, i, name;\n
\n
\t\t\tif (node) {\n
\t\t\t\tdo {\n
\t\t\t\t\tif (node.type === 1) {\n
\t\t\t\t\t\t// Ignore bogus elements\n
\t\t\t\t\t\tif (node.attributes.map[\'data-mce-bogus\']) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Keep empty elements like <img />\n
\t\t\t\t\t\tif (elements[node.name]) {\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Keep bookmark nodes and name attribute like <a name="1"></a>\n
\t\t\t\t\t\ti = node.attributes.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tname = node.attributes[i].name;\n
\t\t\t\t\t\t\tif (name === "name" || name.indexOf(\'data-mce-bookmark\') === 0) {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Keep comments\n
\t\t\t\t\tif (node.type === 8) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Keep non whitespace text nodes\n
\t\t\t\t\tif ((node.type === 3 && !whiteSpaceRegExp.test(node.value))) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t} while ((node = walk(node, self)));\n
\t\t\t}\n
\n
\t\t\treturn true;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Walks to the next or previous node and returns that node or null if it wasn\'t found.\n
\t\t *\n
\t\t * @method walk\n
\t\t * @param {Boolean} prev Optional previous node state defaults to false.\n
\t\t * @return {tinymce.html.Node} Node that is next to or previous of the current node.\n
\t\t */\n
\t\twalk: function(prev) {\n
\t\t\treturn walk(this, null, prev);\n
\t\t}\n
\t};\n
\n
\t/**\n
\t * Creates a node of a specific type.\n
\t *\n
\t * @static\n
\t * @method create\n
\t * @param {String} name Name of the node type to create for example "b" or "#text".\n
\t * @param {Object} attrs Name/value collection of attributes that will be applied to elements.\n
\t */\n
\tNode.create = function(name, attrs) {\n
\t\tvar node, attrName;\n
\n
\t\t// Create node\n
\t\tnode = new Node(name, typeLookup[name] || 1);\n
\n
\t\t// Add attributes if needed\n
\t\tif (attrs) {\n
\t\t\tfor (attrName in attrs) {\n
\t\t\t\tnode.attr(attrName, attrs[attrName]);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn node;\n
\t};\n
\n
\treturn Node;\n
});\n
\n
// Included from: js/tinymce/classes/html/Schema.js\n
\n
/**\n
 * Schema.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Schema validator class.\n
 *\n
 * @class tinymce.html.Schema\n
 * @example\n
 *  if (tinymce.activeEditor.schema.isValidChild(\'p\', \'span\'))\n
 *    alert(\'span is valid child of p.\');\n
 *\n
 *  if (tinymce.activeEditor.schema.getElementRule(\'p\'))\n
 *    alert(\'P is a valid element.\');\n
 *\n
 * @class tinymce.html.Schema\n
 * @version 3.4\n
 */\n
define("tinymce/html/Schema", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar mapCache = {}, dummyObj = {};\n
\tvar makeMap = Tools.makeMap, each = Tools.each, extend = Tools.extend, explode = Tools.explode, inArray = Tools.inArray;\n
\n
\tfunction split(items, delim) {\n
\t\treturn items ? items.split(delim || \' \') : [];\n
\t}\n
\n
\t/**\n
\t * Builds a schema lookup table\n
\t *\n
\t * @private\n
\t * @param {String} type html4, html5 or html5-strict schema type.\n
\t * @return {Object} Schema lookup table.\n
\t */\n
\tfunction compileSchema(type) {\n
\t\tvar schema = {}, globalAttributes, blockContent;\n
\t\tvar phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;\n
\n
\t\tfunction add(name, attributes, children) {\n
\t\t\tvar ni, i, attributesOrder, args = arguments;\n
\n
\t\t\tfunction arrayToMap(array, obj) {\n
\t\t\t\tvar map = {}, i, l;\n
\n
\t\t\t\tfor (i = 0, l = array.length; i < l; i++) {\n
\t\t\t\t\tmap[array[i]] = obj || {};\n
\t\t\t\t}\n
\n
\t\t\t\treturn map;\n
\t\t\t}\n
\n
\t\t\tchildren = children || [];\n
\t\t\tattributes = attributes || "";\n
\n
\t\t\tif (typeof children === "string") {\n
\t\t\t\tchildren = split(children);\n
\t\t\t}\n
\n
\t\t\t// Split string children\n
\t\t\tfor (i = 3; i < args.length; i++) {\n
\t\t\t\tif (typeof args[i] === "string") {\n
\t\t\t\t\targs[i] = split(args[i]);\n
\t\t\t\t}\n
\n
\t\t\t\tchildren.push.apply(children, args[i]);\n
\t\t\t}\n
\n
\t\t\tname = split(name);\n
\t\t\tni = name.length;\n
\t\t\twhile (ni--) {\n
\t\t\t\tattributesOrder = [].concat(globalAttributes, split(attributes));\n
\t\t\t\tschema[name[ni]] = {\n
\t\t\t\t\tattributes: arrayToMap(attributesOrder),\n
\t\t\t\t\tattributesOrder: attributesOrder,\n
\t\t\t\t\tchildren: arrayToMap(children, dummyObj)\n
\t\t\t\t};\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction addAttrs(name, attributes) {\n
\t\t\tvar ni, schemaItem, i, l;\n
\n
\t\t\tname = split(name);\n
\t\t\tni = name.length;\n
\t\t\tattributes = split(attributes);\n
\t\t\twhile (ni--) {\n
\t\t\t\tschemaItem = schema[name[ni]];\n
\t\t\t\tfor (i = 0, l = attributes.length; i < l; i++) {\n
\t\t\t\t\tschemaItem.attributes[attributes[i]] = {};\n
\t\t\t\t\tschemaItem.attributesOrder.push(attributes[i]);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Use cached schema\n
\t\tif (mapCache[type]) {\n
\t\t\treturn mapCache[type];\n
\t\t}\n
\n
\t\t// Attributes present on all elements\n
\t\tglobalAttributes = split("id accesskey class dir lang style tabindex title");\n
\n
\t\t// Event attributes can be opt-in/opt-out\n
\t\t/*eventAttributes = split("onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange " +\n
\t\t\t\t"ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended " +\n
\t\t\t\t"onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart " +\n
\t\t\t\t"onmousedown onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange " +\n
\t\t\t\t"onreset onscroll onseeked onseeking onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate onvolumechange " +\n
\t\t\t\t"onwaiting"\n
\t\t);*/\n
\n
\t\t// Block content elements\n
\t\tblockContent = split(\n
\t\t\t"address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul"\n
\t\t);\n
\n
\t\t// Phrasing content elements from the HTML5 spec (inline)\n
\t\tphrasingContent = split(\n
\t\t\t"a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd " +\n
\t\t\t"label map noscript object q s samp script select small span strong sub sup " +\n
\t\t\t"textarea u var #text #comment"\n
\t\t);\n
\n
\t\t// Add HTML5 items to globalAttributes, blockContent, phrasingContent\n
\t\tif (type != "html4") {\n
\t\t\tglobalAttributes.push.apply(globalAttributes, split("contenteditable contextmenu draggable dropzone " +\n
\t\t\t\t"hidden spellcheck translate"));\n
\t\t\tblockContent.push.apply(blockContent, split("article aside details dialog figure header footer hgroup section nav"));\n
\t\t\tphrasingContent.push.apply(phrasingContent, split("audio canvas command datalist mark meter output picture " +\n
\t\t\t\t"progress time wbr video ruby bdi keygen"));\n
\t\t}\n
\n
\t\t// Add HTML4 elements unless it\'s html5-strict\n
\t\tif (type != "html5-strict") {\n
\t\t\tglobalAttributes.push("xml:lang");\n
\n
\t\t\thtml4PhrasingContent = split("acronym applet basefont big font strike tt");\n
\t\t\tphrasingContent.push.apply(phrasingContent, html4PhrasingContent);\n
\n
\t\t\teach(html4PhrasingContent, function(name) {\n
\t\t\t\tadd(name, "", phrasingContent);\n
\t\t\t});\n
\n
\t\t\thtml4BlockContent = split("center dir isindex noframes");\n
\t\t\tblockContent.push.apply(blockContent, html4BlockContent);\n
\n
\t\t\t// Flow content elements from the HTML5 spec (block+inline)\n
\t\t\tflowContent = [].concat(blockContent, phrasingContent);\n
\n
\t\t\teach(html4BlockContent, function(name) {\n
\t\t\t\tadd(name, "", flowContent);\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Flow content elements from the HTML5 spec (block+inline)\n
\t\tflowContent = flowContent || [].concat(blockContent, phrasingContent);\n
\n
\t\t// HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement\n
\t\t// Schema items <element name>, <specific attributes>, <children ..>\n
\t\tadd("html", "manifest", "head body");\n
\t\tadd("head", "", "base command link meta noscript script style title");\n
\t\tadd("title hr noscript br");\n
\t\tadd("base", "href target");\n
\t\tadd("link", "href rel media hreflang type sizes hreflang");\n
\t\tadd("meta", "name http-equiv content charset");\n
\t\tadd("style", "media type scoped");\n
\t\tadd("script", "src async defer type charset");\n
\t\tadd("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus " +\n
\t\t\t\t"onhashchange onload onmessage onoffline ononline onpagehide onpageshow " +\n
\t\t\t\t"onpopstate onresize onscroll onstorage onunload", flowContent);\n
\t\tadd("address dt dd div caption", "", flowContent);\n
\t\tadd("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);\n
\t\tadd("blockquote", "cite", flowContent);\n
\t\tadd("ol", "reversed start type", "li");\n
\t\tadd("ul", "", "li");\n
\t\tadd("li", "value", flowContent);\n
\t\tadd("dl", "", "dt dd");\n
\t\tadd("a", "href target rel media hreflang type", phrasingContent);\n
\t\tadd("q", "cite", phrasingContent);\n
\t\tadd("ins del", "cite datetime", flowContent);\n
\t\tadd("img", "src sizes srcset alt usemap ismap width height");\n
\t\tadd("iframe", "src name width height", flowContent);\n
\t\tadd("embed", "src type width height");\n
\t\tadd("object", "data type typemustmatch name usemap form width height", flowContent, "param");\n
\t\tadd("param", "name value");\n
\t\tadd("map", "name", flowContent, "area");\n
\t\tadd("area", "alt coords shape href target rel media hreflang type");\n
\t\tadd("table", "border", "caption colgroup thead tfoot tbody tr" + (type == "html4" ? " col" : ""));\n
\t\tadd("colgroup", "span", "col");\n
\t\tadd("col", "span");\n
\t\tadd("tbody thead tfoot", "", "tr");\n
\t\tadd("tr", "", "td th");\n
\t\tadd("td", "colspan rowspan headers", flowContent);\n
\t\tadd("th", "colspan rowspan headers scope abbr", flowContent);\n
\t\tadd("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);\n
\t\tadd("fieldset", "disabled form name", flowContent, "legend");\n
\t\tadd("label", "form for", phrasingContent);\n
\t\tadd("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate " +\n
\t\t\t\t"formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"\n
\t\t);\n
\t\tadd("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value",\n
\t\t\ttype == "html4" ? flowContent : phrasingContent);\n
\t\tadd("select", "disabled form multiple name required size", "option optgroup");\n
\t\tadd("optgroup", "disabled label", "option");\n
\t\tadd("option", "disabled label selected value");\n
\t\tadd("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");\n
\t\tadd("menu", "type label", flowContent, "li");\n
\t\tadd("noscript", "", flowContent);\n
\n
\t\t// Extend with HTML5 elements\n
\t\tif (type != "html4") {\n
\t\t\tadd("wbr");\n
\t\t\tadd("ruby", "", phrasingContent, "rt rp");\n
\t\t\tadd("figcaption", "", flowContent);\n
\t\t\tadd("mark rt rp summary bdi", "", phrasingContent);\n
\t\t\tadd("canvas", "width height", flowContent);\n
\t\t\tadd("video", "src crossorigin poster preload autoplay mediagroup loop " +\n
\t\t\t\t"muted control

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAU=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="5" aka="AAAAAAAAAAU=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string>s width height buffered", flowContent, "track source");\n
\t\t\tadd("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", flowContent, "track source");\n
\t\t\tadd("picture", "", "img source");\n
\t\t\tadd("source", "src srcset type media sizes");\n
\t\t\tadd("track", "kind src srclang label default");\n
\t\t\tadd("datalist", "", phrasingContent, "option");\n
\t\t\tadd("article section nav aside header footer", "", flowContent);\n
\t\t\tadd("hgroup", "", "h1 h2 h3 h4 h5 h6");\n
\t\t\tadd("figure", "", flowContent, "figcaption");\n
\t\t\tadd("time", "datetime", phrasingContent);\n
\t\t\tadd("dialog", "open", flowContent);\n
\t\t\tadd("command", "type label icon disabled checked radiogroup command");\n
\t\t\tadd("output", "for form name", phrasingContent);\n
\t\t\tadd("progress", "value max", phrasingContent);\n
\t\t\tadd("meter", "value min max low high optimum", phrasingContent);\n
\t\t\tadd("details", "open", flowContent, "summary");\n
\t\t\tadd("keygen", "autofocus challenge disabled form keytype name");\n
\t\t}\n
\n
\t\t// Extend with HTML4 attributes unless it\'s html5-strict\n
\t\tif (type != "html5-strict") {\n
\t\t\taddAttrs("script", "language xml:space");\n
\t\t\taddAttrs("style", "xml:space");\n
\t\t\taddAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");\n
\t\t\taddAttrs("embed", "align name hspace vspace");\n
\t\t\taddAttrs("param", "valuetype type");\n
\t\t\taddAttrs("a", "charset name rev shape coords");\n
\t\t\taddAttrs("br", "clear");\n
\t\t\taddAttrs("applet", "codebase archive code object alt name width height align hspace vspace");\n
\t\t\taddAttrs("img", "name longdesc align border hspace vspace");\n
\t\t\taddAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");\n
\t\t\taddAttrs("font basefont", "size color face");\n
\t\t\taddAttrs("input", "usemap align");\n
\t\t\taddAttrs("select", "onchange");\n
\t\t\taddAttrs("textarea");\n
\t\t\taddAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");\n
\t\t\taddAttrs("ul", "type compact");\n
\t\t\taddAttrs("li", "type");\n
\t\t\taddAttrs("ol dl menu dir", "compact");\n
\t\t\taddAttrs("pre", "width xml:space");\n
\t\t\taddAttrs("hr", "align noshade size width");\n
\t\t\taddAttrs("isindex", "prompt");\n
\t\t\taddAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");\n
\t\t\taddAttrs("col", "width align char charoff valign");\n
\t\t\taddAttrs("colgroup", "width align char charoff valign");\n
\t\t\taddAttrs("thead", "align char charoff valign");\n
\t\t\taddAttrs("tr", "align char charoff valign bgcolor");\n
\t\t\taddAttrs("th", "axis align char charoff valign nowrap bgcolor width height");\n
\t\t\taddAttrs("form", "accept");\n
\t\t\taddAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");\n
\t\t\taddAttrs("tfoot", "align char charoff valign");\n
\t\t\taddAttrs("tbody", "align char charoff valign");\n
\t\t\taddAttrs("area", "nohref");\n
\t\t\taddAttrs("body", "background bgcolor text link vlink alink");\n
\t\t}\n
\n
\t\t// Extend with HTML5 attributes unless it\'s html4\n
\t\tif (type != "html4") {\n
\t\t\taddAttrs("input button select textarea", "autofocus");\n
\t\t\taddAttrs("input textarea", "placeholder");\n
\t\t\taddAttrs("a", "download");\n
\t\t\taddAttrs("link script img", "crossorigin");\n
\t\t\taddAttrs("iframe", "sandbox seamless allowfullscreen"); // Excluded: srcdoc\n
\t\t}\n
\n
\t\t// Special: iframe, ruby, video, audio, label\n
\n
\t\t// Delete children of the same name from it\'s parent\n
\t\t// For example: form can\'t have a child of the name form\n
\t\teach(split(\'a form meter progress dfn\'), function(name) {\n
\t\t\tif (schema[name]) {\n
\t\t\t\tdelete schema[name].children[name];\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Delete header, footer, sectioning and heading content descendants\n
\t\t/*each(\'dt th address\', function(name) {\n
\t\t\tdelete schema[name].children[name];\n
\t\t});*/\n
\n
\t\t// Caption can\'t have tables\n
\t\tdelete schema.caption.children.table;\n
\n
\t\t// Delete scripts by default due to possible XSS\n
\t\tdelete schema.script;\n
\n
\t\t// TODO: LI:s can only have value if parent is OL\n
\n
\t\t// TODO: Handle transparent elements\n
\t\t// a ins del canvas map\n
\n
\t\tmapCache[type] = schema;\n
\n
\t\treturn schema;\n
\t}\n
\n
\tfunction compileElementMap(value, mode) {\n
\t\tvar styles;\n
\n
\t\tif (value) {\n
\t\t\tstyles = {};\n
\n
\t\t\tif (typeof value == \'string\') {\n
\t\t\t\tvalue = {\n
\t\t\t\t\t\'*\': value\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\t// Convert styles into a rule list\n
\t\t\teach(value, function(value, key) {\n
\t\t\t\tstyles[key] = styles[key.toUpperCase()] = mode == \'map\' ? makeMap(value, /[, ]/) : explode(value, /[, ]/);\n
\t\t\t});\n
\t\t}\n
\n
\t\treturn styles;\n
\t}\n
\n
\t/**\n
\t * Constructs a new Schema instance.\n
\t *\n
\t * @constructor\n
\t * @method Schema\n
\t * @param {Object} settings Name/value settings object.\n
\t */\n
\treturn function(settings) {\n
\t\tvar self = this, elements = {}, children = {}, patternElements = [], validStyles, invalidStyles, schemaItems;\n
\t\tvar whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;\n
\t\tvar blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;\n
\t\tvar customElementsMap = {}, specialElements = {};\n
\n
\t\t// Creates an lookup table map object for the specified option or the default value\n
\t\tfunction createLookupTable(option, default_value, extendWith) {\n
\t\t\tvar value = settings[option];\n
\n
\t\t\tif (!value) {\n
\t\t\t\t// Get cached default map or make it if needed\n
\t\t\t\tvalue = mapCache[option];\n
\n
\t\t\t\tif (!value) {\n
\t\t\t\t\tvalue = makeMap(default_value, \' \', makeMap(default_value.toUpperCase(), \' \'));\n
\t\t\t\t\tvalue = extend(value, extendWith);\n
\n
\t\t\t\t\tmapCache[option] = value;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Create custom map\n
\t\t\t\tvalue = makeMap(value, /[, ]/, makeMap(value.toUpperCase(), /[, ]/));\n
\t\t\t}\n
\n
\t\t\treturn value;\n
\t\t}\n
\n
\t\tsettings = settings || {};\n
\t\tschemaItems = compileSchema(settings.schema);\n
\n
\t\t// Allow all elements and attributes if verify_html is set to false\n
\t\tif (settings.verify_html === false) {\n
\t\t\tsettings.valid_elements = \'*[*]\';\n
\t\t}\n
\n
\t\tvalidStyles = compileElementMap(settings.valid_styles);\n
\t\tinvalidStyles = compileElementMap(settings.invalid_styles, \'map\');\n
\t\tvalidClasses = compileElementMap(settings.valid_classes, \'map\');\n
\n
\t\t// Setup map objects\n
\t\twhiteSpaceElementsMap = createLookupTable(\'whitespace_elements\', \'pre script noscript style textarea video audio iframe object\');\n
\t\tselfClosingElementsMap = createLookupTable(\'self_closing_elements\', \'colgroup dd dt li option p td tfoot th thead tr\');\n
\t\tshortEndedElementsMap = createLookupTable(\'short_ended_elements\', \'area base basefont br col frame hr img input isindex link \' +\n
\t\t\t\'meta param embed source wbr track\');\n
\t\tboolAttrMap = createLookupTable(\'boolean_attributes\', \'checked compact declare defer disabled ismap multiple nohref noresize \' +\n
\t\t\t\'noshade nowrap readonly selected autoplay loop controls\');\n
\t\tnonEmptyElementsMap = createLookupTable(\'non_empty_elements\', \'td th iframe video audio object script\', shortEndedElementsMap);\n
\t\tmoveCaretBeforeOnEnterElementsMap = createLookupTable(\'move_caret_before_on_enter_elements\', \'table\', nonEmptyElementsMap);\n
\t\ttextBlockElementsMap = createLookupTable(\'text_block_elements\', \'h1 h2 h3 h4 h5 h6 p div address pre form \' +\n
\t\t\t\t\t\t\'blockquote center dir fieldset header footer article section hgroup aside nav figure\');\n
\t\tblockElementsMap = createLookupTable(\'block_elements\', \'hr table tbody thead tfoot \' +\n
\t\t\t\t\t\t\'th tr td li ol ul caption dl dt dd noscript menu isindex option \' +\n
\t\t\t\t\t\t\'datalist select optgroup\', textBlockElementsMap);\n
\t\ttextInlineElementsMap = createLookupTable(\'text_inline_elements\', \'span strong b em i font strike u var cite \' +\n
\t\t\t\t\t\t\t\t\t\t\'dfn code mark q sup sub samp\');\n
\n
\t\teach((settings.special || \'script noscript style textarea\').split(\' \'), function(name) {\n
\t\t\tspecialElements[name] = new RegExp(\'\074\\/\' + name + \'[^\076]*\076\', \'gi\');\n
\t\t});\n
\n
\t\t// Converts a wildcard expression string to a regexp for example *a will become /.*a/.\n
\t\tfunction patternToRegExp(str) {\n
\t\t\treturn new RegExp(\'^\' + str.replace(/([?+*])/g, \'.$1\') + \'$\');\n
\t\t}\n
\n
\t\t// Parses the specified valid_elements string and adds to the current rules\n
\t\t// This function is a bit hard to read since it\'s heavily optimized for speed\n
\t\tfunction addValidElements(validElements) {\n
\t\t\tvar ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,\n
\t\t\t\tprefix, outputName, globalAttributes, globalAttributesOrder, key, value,\n
\t\t\t\telementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)\\])?$/,\n
\t\t\t\tattrRuleRegExp = /^([!\\-])?(\\w+::\\w+|[^=:\074]+)?(?:([=:\074])(.*))?$/,\n
\t\t\t\thasPatternsRegExp = /[*?+]/;\n
\n
\t\t\tif (validElements) {\n
\t\t\t\t// Split valid elements into an array with rules\n
\t\t\t\tvalidElements = split(validElements, \',\');\n
\n
\t\t\t\tif (elements[\'@\']) {\n
\t\t\t\t\tglobalAttributes = elements[\'@\'].attributes;\n
\t\t\t\t\tglobalAttributesOrder = elements[\'@\'].attributesOrder;\n
\t\t\t\t}\n
\n
\t\t\t\t// Loop all rules\n
\t\t\t\tfor (ei = 0, el = validElements.length; ei \074 el; ei++) {\n
\t\t\t\t\t// Parse element rule\n
\t\t\t\t\tmatches = elementRuleRegExp.exec(validElements[ei]);\n
\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\t// Setup local names for matches\n
\t\t\t\t\t\tprefix = matches[1];\n
\t\t\t\t\t\telementName = matches[2];\n
\t\t\t\t\t\toutputName = matches[3];\n
\t\t\t\t\t\tattrData = matches[5];\n
\n
\t\t\t\t\t\t// Create new attributes and attributesOrder\n
\t\t\t\t\t\tattributes = {};\n
\t\t\t\t\t\tattributesOrder = [];\n
\n
\t\t\t\t\t\t// Create the new element\n
\t\t\t\t\t\telement = {\n
\t\t\t\t\t\t\tattributes: attributes,\n
\t\t\t\t\t\t\tattributesOrder: attributesOrder\n
\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\t// Padd empty elements prefix\n
\t\t\t\t\t\tif (prefix === \'#\') {\n
\t\t\t\t\t\t\telement.paddEmpty = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Remove empty elements prefix\n
\t\t\t\t\t\tif (prefix === \'-\') {\n
\t\t\t\t\t\t\telement.removeEmpty = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (matches[4] === \'!\') {\n
\t\t\t\t\t\t\telement.removeEmptyAttrs = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Copy attributes from global rule into current rule\n
\t\t\t\t\t\tif (globalAttributes) {\n
\t\t\t\t\t\t\tfor (key in globalAttributes) {\n
\t\t\t\t\t\t\t\tattributes[key] = globalAttributes[key];\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tattributesOrder.push.apply(attributesOrder, globalAttributesOrder);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Attributes defined\n
\t\t\t\t\t\tif (attrData) {\n
\t\t\t\t\t\t\tattrData = split(attrData, \'|\');\n
\t\t\t\t\t\t\tfor (ai = 0, al = attrData.length; ai \074 al; ai++) {\n
\t\t\t\t\t\t\t\tmatches = attrRuleRegExp.exec(attrData[ai]);\n
\t\t\t\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\t\t\t\tattr = {};\n
\t\t\t\t\t\t\t\t\tattrType = matches[1];\n
\t\t\t\t\t\t\t\t\tattrName = matches[2].replace(/::/g, \':\');\n
\t\t\t\t\t\t\t\t\tprefix = matches[3];\n
\t\t\t\t\t\t\t\t\tvalue = matches[4];\n
\n
\t\t\t\t\t\t\t\t\t// Required\n
\t\t\t\t\t\t\t\t\tif (attrType === \'!\') {\n
\t\t\t\t\t\t\t\t\t\telement.attributesRequired = element.attributesRequired || [];\n
\t\t\t\t\t\t\t\t\t\telement.attributesRequired.push(attrName);\n
\t\t\t\t\t\t\t\t\t\tattr.required = true;\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t// Denied from global\n
\t\t\t\t\t\t\t\t\tif (attrType === \'-\') {\n
\t\t\t\t\t\t\t\t\t\tdelete attributes[attrName];\n
\t\t\t\t\t\t\t\t\t\tattributesOrder.splice(inArray(attributesOrder, attrName), 1);\n
\t\t\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t// Default value\n
\t\t\t\t\t\t\t\t\tif (prefix) {\n
\t\t\t\t\t\t\t\t\t\t// Default value\n
\t\t\t\t\t\t\t\t\t\tif (prefix === \'=\') {\n
\t\t\t\t\t\t\t\t\t\t\telement.attributesDefault = element.attributesDefault || [];\n
\t\t\t\t\t\t\t\t\t\t\telement.attributesDefault.push({name: attrName, value: value});\n
\t\t\t\t\t\t\t\t\t\t\tattr.defaultValue = value;\n
\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\t// Forced value\n
\t\t\t\t\t\t\t\t\t\tif (prefix === \':\') {\n
\t\t\t\t\t\t\t\t\t\t\telement.attributesForced = element.attributesForced || [];\n
\t\t\t\t\t\t\t\t\t\t\telement.attributesForced.push({name: attrName, value: value});\n
\t\t\t\t\t\t\t\t\t\t\tattr.forcedValue = value;\n
\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\t// Required values\n
\t\t\t\t\t\t\t\t\t\tif (prefix === \'\074\') {\n
\t\t\t\t\t\t\t\t\t\t\tattr.validValues = makeMap(value, \'?\');\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t// Check for attribute patterns\n
\t\t\t\t\t\t\t\t\tif (hasPatternsRegExp.test(attrName)) {\n
\t\t\t\t\t\t\t\t\t\telement.attributePatterns = element.attributePatterns || [];\n
\t\t\t\t\t\t\t\t\t\tattr.pattern = patternToRegExp(attrName);\n
\t\t\t\t\t\t\t\t\t\telement.attributePatterns.push(attr);\n
\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t// Add attribute to order list if it doesn\'t already exist\n
\t\t\t\t\t\t\t\t\t\tif (!attributes[attrName]) {\n
\t\t\t\t\t\t\t\t\t\t\tattributesOrder.push(attrName);\n
\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\tattributes[attrName] = attr;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Global rule, store away these for later usage\n
\t\t\t\t\t\tif (!globalAttributes \046\046 elementName == \'@\') {\n
\t\t\t\t\t\t\tglobalAttributes = attributes;\n
\t\t\t\t\t\t\tglobalAttributesOrder = attributesOrder;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Handle substitute elements such as b/strong\n
\t\t\t\t\t\tif (outputName) {\n
\t\t\t\t\t\t\telement.outputName = elementName;\n
\t\t\t\t\t\t\telements[outputName] = element;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Add pattern or exact element\n
\t\t\t\t\t\tif (hasPatternsRegExp.test(elementName)) {\n
\t\t\t\t\t\t\telement.pattern = patternToRegExp(elementName);\n
\t\t\t\t\t\t\tpatternElements.push(element);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\telements[elementName] = element;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction setValidElements(validElements) {\n
\t\t\telements = {};\n
\t\t\tpatternElements = [];\n
\n
\t\t\taddValidElements(validElements);\n
\n
\t\t\teach(schemaItems, function(element, name) {\n
\t\t\t\tchildren[name] = element.children;\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Adds custom non HTML elements to the schema\n
\t\tfunction addCustomElements(customElements) {\n
\t\t\tvar customElementRegExp = /^(~)?(.+)$/;\n
\n
\t\t\tif (customElements) {\n
\t\t\t\t// Flush cached items since we are altering the default maps\n
\t\t\t\tmapCache.text_block_elements = mapCache.block_elements = null;\n
\n
\t\t\t\teach(split(customElements, \',\'), function(rule) {\n
\t\t\t\t\tvar matches = customElementRegExp.exec(rule),\n
\t\t\t\t\t\tinline = matches[1] === \'~\',\n
\t\t\t\t\t\tcloneName = inline ? \'span\' : \'div\',\n
\t\t\t\t\t\tname = matches[2];\n
\n
\t\t\t\t\tchildren[name] = children[cloneName];\n
\t\t\t\t\tcustomElementsMap[name] = cloneName;\n
\n
\t\t\t\t\t// If it\'s not marked as inline then add it to valid block elements\n
\t\t\t\t\tif (!inline) {\n
\t\t\t\t\t\tblockElementsMap[name.toUpperCase()] = {};\n
\t\t\t\t\t\tblockElementsMap[name] = {};\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Add elements clone if needed\n
\t\t\t\t\tif (!elements[name]) {\n
\t\t\t\t\t\tvar customRule = elements[cloneName];\n
\n
\t\t\t\t\t\tcustomRule = extend({}, customRule);\n
\t\t\t\t\t\tdelete customRule.removeEmptyAttrs;\n
\t\t\t\t\t\tdelete customRule.removeEmpty;\n
\n
\t\t\t\t\t\telements[name] = customRule;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Add custom elements at span/div positions\n
\t\t\t\t\teach(children, function(element, elmName) {\n
\t\t\t\t\t\tif (element[cloneName]) {\n
\t\t\t\t\t\t\tchildren[elmName] = element = extend({}, children[elmName]);\n
\t\t\t\t\t\t\telement[name] = element[cloneName];\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Adds valid children to the schema object\n
\t\tfunction addValidChildren(validChildren) {\n
\t\t\tvar childRuleRegExp = /^([+\\-]?)(\\w+)\\[([^\\]]+)\\]$/;\n
\n
\t\t\t// Invalidate the schema cache if the schema is mutated\n
\t\t\tmapCache[settings.schema] = null;\n
\n
\t\t\tif (validChildren) {\n
\t\t\t\teach(split(validChildren, \',\'), function(rule) {\n
\t\t\t\t\tvar matches = childRuleRegExp.exec(rule), parent, prefix;\n
\n
\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\tprefix = matches[1];\n
\n
\t\t\t\t\t\t// Add/remove items from default\n
\t\t\t\t\t\tif (prefix) {\n
\t\t\t\t\t\t\tparent = children[matches[2]];\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tparent = children[matches[2]] = {\'#comment\': {}};\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tparent = children[matches[2]];\n
\n
\t\t\t\t\t\teach(split(matches[3], \'|\'), function(child) {\n
\t\t\t\t\t\t\tif (prefix === \'-\') {\n
\t\t\t\t\t\t\t\tdelete parent[child];\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tparent[child] = {};\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction getElementRule(name) {\n
\t\t\tvar element = elements[name], i;\n
\n
\t\t\t// Exact match found\n
\t\t\tif (element) {\n
\t\t\t\treturn element;\n
\t\t\t}\n
\n
\t\t\t// No exact match then try the patterns\n
\t\t\ti = patternElements.length;\n
\t\t\twhile (i--) {\n
\t\t\t\telement = patternElements[i];\n
\n
\t\t\t\tif (element.pattern.test(name)) {\n
\t\t\t\t\treturn element;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (!settings.valid_elements) {\n
\t\t\t// No valid elements defined then clone the elements from the schema spec\n
\t\t\teach(schemaItems, function(element, name) {\n
\t\t\t\telements[name] = {\n
\t\t\t\t\tattributes: element.attributes,\n
\t\t\t\t\tattributesOrder: element.attributesOrder\n
\t\t\t\t};\n
\n
\t\t\t\tchildren[name] = element.children;\n
\t\t\t});\n
\n
\t\t\t// Switch these on HTML4\n
\t\t\tif (settings.schema != "html5") {\n
\t\t\t\teach(split(\'strong/b em/i\'), function(item) {\n
\t\t\t\t\titem = split(item, \'/\');\n
\t\t\t\t\telements[item[1]].outputName = item[0];\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Add default alt attribute for images\n
\t\t\telements.img.attributesDefault = [{name: \'alt\', value: \'\'}];\n
\n
\t\t\t// Remove these if they are empty by default\n
\t\t\teach(split(\'ol ul sub sup blockquote span font a table tbody tr strong em b i\'), function(name) {\n
\t\t\t\tif (elements[name]) {\n
\t\t\t\t\telements[name].removeEmpty = true;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Padd these by default\n
\t\t\teach(split(\'p h1 h2 h3 h4 h5 h6 th td pre div address caption\'), function(name) {\n
\t\t\t\telements[name].paddEmpty = true;\n
\t\t\t});\n
\n
\t\t\t// Remove these if they have no attributes\n
\t\t\teach(split(\'span\'), function(name) {\n
\t\t\t\telements[name].removeEmptyAttrs = true;\n
\t\t\t});\n
\n
\t\t\t// Remove these by default\n
\t\t\t// TODO: Reenable in 4.1\n
\t\t\t/*each(split(\'script style\'), function(name) {\n
\t\t\t\tdelete elements[name];\n
\t\t\t});*/\n
\t\t} else {\n
\t\t\tsetValidElements(settings.valid_elements);\n
\t\t}\n
\n
\t\taddCustomElements(settings.custom_elements);\n
\t\taddValidChildren(settings.valid_children);\n
\t\taddValidElements(settings.extended_valid_elements);\n
\n
\t\t// Todo: Remove this when we fix list handling to be valid\n
\t\taddValidChildren(\'+ol[ul|ol],+ul[ul|ol]\');\n
\n
\t\t// Delete invalid elements\n
\t\tif (settings.invalid_elements) {\n
\t\t\teach(explode(settings.invalid_elements), function(item) {\n
\t\t\t\tif (elements[item]) {\n
\t\t\t\t\tdelete elements[item];\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t// If the user didn\'t allow span only allow internal spans\n
\t\tif (!getElementRule(\'span\')) {\n
\t\t\taddValidElements(\'span[!data-mce-type|*]\');\n
\t\t}\n
\n
\t\t/**\n
\t\t * Name/value map object with valid parents and children to those parents.\n
\t\t *\n
\t\t * @example\n
\t\t * children = {\n
\t\t *    div:{p:{}, h1:{}}\n
\t\t * };\n
\t\t * @field children\n
\t\t * @type Object\n
\t\t */\n
\t\tself.children = children;\n
\n
\t\t/**\n
\t\t * Name/value map object with valid styles for each element.\n
\t\t *\n
\t\t * @method getValidStyles\n
\t\t * @type Object\n
\t\t */\n
\t\tself.getValidStyles = function() {\n
\t\t\treturn validStyles;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Name/value map object with valid styles for each element.\n
\t\t *\n
\t\t * @method getInvalidStyles\n
\t\t * @type Object\n
\t\t */\n
\t\tself.getInvalidStyles = function() {\n
\t\t\treturn invalidStyles;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Name/value map object with valid classes for each element.\n
\t\t *\n
\t\t * @method getValidClasses\n
\t\t * @type Object\n
\t\t */\n
\t\tself.getValidClasses = function() {\n
\t\t\treturn validClasses;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with boolean attributes.\n
\t\t *\n
\t\t * @method getBoolAttrs\n
\t\t * @return {Object} Name/value lookup map for boolean attributes.\n
\t\t */\n
\t\tself.getBoolAttrs = function() {\n
\t\t\treturn boolAttrMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with block elements.\n
\t\t *\n
\t\t * @method getBlockElements\n
\t\t * @return {Object} Name/value lookup map for block elements.\n
\t\t */\n
\t\tself.getBlockElements = function() {\n
\t\t\treturn blockElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with text block elements. Such as: p,h1-h6,div,address\n
\t\t *\n
\t\t * @method getTextBlockElements\n
\t\t * @return {Object} Name/value lookup map for block elements.\n
\t\t */\n
\t\tself.getTextBlockElements = function() {\n
\t\t\treturn textBlockElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map of inline text format nodes for example strong/span or ins.\n
\t\t *\n
\t\t * @method getTextInlineElements\n
\t\t * @return {Object} Name/value lookup map for text format elements.\n
\t\t */\n
\t\tself.getTextInlineElements = function() {\n
\t\t\treturn textInlineElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with short ended elements such as BR or IMG.\n
\t\t *\n
\t\t * @method getShortEndedElements\n
\t\t * @return {Object} Name/value lookup map for short ended elements.\n
\t\t */\n
\t\tself.getShortEndedElements = function() {\n
\t\t\treturn shortEndedElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with self closing tags such as \074li\076.\n
\t\t *\n
\t\t * @method getSelfClosingElements\n
\t\t * @return {Object} Name/value lookup map for self closing tags elements.\n
\t\t */\n
\t\tself.getSelfClosingElements = function() {\n
\t\t\treturn selfClosingElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with elements that should be treated as contents regardless if it has text\n
\t\t * content in them or not such as TD, VIDEO or IMG.\n
\t\t *\n
\t\t * @method getNonEmptyElements\n
\t\t * @return {Object} Name/value lookup map for non empty elements.\n
\t\t */\n
\t\tself.getNonEmptyElements = function() {\n
\t\t\treturn nonEmptyElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with elements that the caret should be moved in front of after enter is\n
\t\t * pressed\n
\t\t *\n
\t\t * @method getMoveCaretBeforeOnEnterElements\n
\t\t * @return {Object} Name/value lookup map for elements to place the caret in front of.\n
\t\t */\n
\t\tself.getMoveCaretBeforeOnEnterElements = function() {\n
\t\t\treturn moveCaretBeforeOnEnterElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.\n
\t\t *\n
\t\t * @method getWhiteSpaceElements\n
\t\t * @return {Object} Name/value lookup map for white space elements.\n
\t\t */\n
\t\tself.getWhiteSpaceElements = function() {\n
\t\t\treturn whiteSpaceElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns a map with special elements. These are elements that needs to be parsed\n
\t\t * in a special way such as script, style, textarea etc. The map object values\n
\t\t * are regexps used to find the end of the element.\n
\t\t *\n
\t\t * @method getSpecialElements\n
\t\t * @return {Object} Name/value lookup map for special elements.\n
\t\t */\n
\t\tself.getSpecialElements = function() {\n
\t\t\treturn specialElements;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element and it\'s child is valid or not\n
\t\t * according to the schema.\n
\t\t *\n
\t\t * @method isValidChild\n
\t\t * @param {String} name Element name to check for.\n
\t\t * @param {String} child Element child to verify.\n
\t\t * @return {Boolean} True/false if the element is a valid child of the specified parent.\n
\t\t */\n
\t\tself.isValidChild = function(name, child) {\n
\t\t\tvar parent = children[name];\n
\n
\t\t\treturn !!(parent \046\046 parent[child]);\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element name and optional attribute is\n
\t\t * valid according to the schema.\n
\t\t *\n
\t\t * @method isValid\n
\t\t * @param {String} name Name of element to check.\n
\t\t * @param {String} attr Optional attribute name to check for.\n
\t\t * @return {Boolean} True/false if the element and attribute is valid.\n
\t\t */\n
\t\tself.isValid = function(name, attr) {\n
\t\t\tvar attrPatterns, i, rule = getElementRule(name);\n
\n
\t\t\t// Check if it\'s a valid element\n
\t\t\tif (rule) {\n
\t\t\t\tif (attr) {\n
\t\t\t\t\t// Check if attribute name exists\n
\t\t\t\t\tif (rule.attributes[attr]) {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Check if attribute matches a regexp pattern\n
\t\t\t\t\tattrPatterns = rule.attributePatterns;\n
\t\t\t\t\tif (attrPatterns) {\n
\t\t\t\t\t\ti = attrPatterns.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tif (attrPatterns[i].pattern.test(name)) {\n
\t\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// No match\n
\t\t\treturn false;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element is valid or not\n
\t\t * according to the schema.\n
\t\t *\n
\t\t * @method getElementRule\n
\t\t * @param {String} name Element name to check for.\n
\t\t * @return {Object} Element object or undefined if the element isn\'t valid.\n
\t\t */\n
\t\tself.getElementRule = getElementRule;\n
\n
\t\t/**\n
\t\t * Returns an map object of all custom elements.\n
\t\t *\n
\t\t * @method getCustomElements\n
\t\t * @return {Object} Name/value map object of all custom elements.\n
\t\t */\n
\t\tself.getCustomElements = function() {\n
\t\t\treturn customElementsMap;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Parses a valid elements string and adds it to the schema. The valid elements\n
\t\t * format is for example "element[attr=default|otherattr]".\n
\t\t * Existing rules will be replaced with the ones specified, so this extends the schema.\n
\t\t *\n
\t\t * @method addValidElements\n
\t\t * @param {String} valid_elements String in the valid elements format to be parsed.\n
\t\t */\n
\t\tself.addValidElements = addValidElements;\n
\n
\t\t/**\n
\t\t * Parses a valid elements string and sets it to the schema. The valid elements\n
\t\t * format is for example "element[attr=default|otherattr]".\n
\t\t * Existing rules will be replaced with the ones specified, so this extends the schema.\n
\t\t *\n
\t\t * @method setValidElements\n
\t\t * @param {String} valid_elements String in the valid elements format to be parsed.\n
\t\t */\n
\t\tself.setValidElements = setValidElements;\n
\n
\t\t/**\n
\t\t * Adds custom non HTML elements to the schema.\n
\t\t *\n
\t\t * @method addCustomElements\n
\t\t * @param {String} custom_elements Comma separated list of custom elements to add.\n
\t\t */\n
\t\tself.addCustomElements = addCustomElements;\n
\n
\t\t/**\n
\t\t * Parses a valid children string and adds them to the schema structure. The valid children\n
\t\t * format is for example: "element[child1|child2]".\n
\t\t *\n
\t\t * @method addValidChildren\n
\t\t * @param {String} valid_children Valid children elements string to parse\n
\t\t */\n
\t\tself.addValidChildren = addValidChildren;\n
\n
\t\tself.elements = elements;\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/html/SaxParser.js\n
\n
/**\n
 * SaxParser.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*eslint max-depth:[2, 9] */\n
\n
/**\n
 * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will\n
 * always execute the events in the right order for tag soup code like \074b\076\074p\076\074/b\076\074/p\076. It will also remove elements\n
 * and attributes that doesn\'t fit the schema if the validate setting is enabled.\n
 *\n
 * @example\n
 * var parser = new tinymce.html.SaxParser({\n
 *     validate: true,\n
 *\n
 *     comment: function(text) {\n
 *         console.log(\'Comment:\', text);\n
 *     },\n
 *\n
 *     cdata: function(text) {\n
 *         console.log(\'CDATA:\', text);\n
 *     },\n
 *\n
 *     text: function(text, raw) {\n
 *         console.log(\'Text:\', text, \'Raw:\', raw);\n
 *     },\n
 *\n
 *     start: function(name, attrs, empty) {\n
 *         console.log(\'Start:\', name, attrs, empty);\n
 *     },\n
 *\n
 *     end: function(name) {\n
 *         console.log(\'End:\', name);\n
 *     },\n
 *\n
 *     pi: function(name, text) {\n
 *         console.log(\'PI:\', name, text);\n
 *     },\n
 *\n
 *     doctype: function(text) {\n
 *         console.log(\'DocType:\', text);\n
 *     }\n
 * }, schema);\n
 * @class tinymce.html.SaxParser\n
 * @version 3.4\n
 */\n
define("tinymce/html/SaxParser", [\n
\t"tinymce/html/Schema",\n
\t"tinymce/html/Entities",\n
\t"tinymce/util/Tools"\n
], function(Schema, Entities, Tools) {\n
\tvar each = Tools.each;\n
\n
\t/**\n
\t * Returns the index of the end tag for a specific start tag. This can be\n
\t * used to skip all children of a parent element from being processed.\n
\t *\n
\t * @private\n
\t * @method findEndTag\n
\t * @param {tinymce.html.Schema} schema Schema instance to use to match short ended elements.\n
\t * @param {String} html HTML string to find the end tag in.\n
\t * @param {Number} startIndex Indext to start searching at should be after the start tag.\n
\t * @return {Number} Index of the end tag.\n
\t */\n
\tfunction findEndTag(schema, html, startIndex) {\n
\t\tvar count = 1, index, matches, tokenRegExp, shortEndedElements;\n
\n
\t\tshortEndedElements = schema.getShortEndedElements();\n
\t\ttokenRegExp = /\074([!?\\/])?([A-Za-z0-9\\-_\\:\\.]+)((?:\\s+[^"\\\'\076]+(?:(?:"[^"]*")|(?:\\\'[^\\\']*\\\')|[^\076]*))*|\\/|\\s+)\076/g;\n
\t\ttokenRegExp.lastIndex = index = startIndex;\n
\n
\t\twhile ((matches = tokenRegExp.exec(html))) {\n
\t\t\tindex = tokenRegExp.lastIndex;\n
\n
\t\t\tif (matches[1] === \'/\') { // End element\n
\t\t\t\tcount--;\n
\t\t\t} else if (!matches[1]) { // Start element\n
\t\t\t\tif (matches[2] in shortEndedElements) {\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\tcount++;\n
\t\t\t}\n
\n
\t\t\tif (count === 0) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn index;\n
\t}\n
\n
\t/**\n
\t * Constructs a new SaxParser instance.\n
\t *\n
\t * @constructor\n
\t * @method SaxParser\n
\t * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.\n
\t * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.\n
\t */\n
\tfunction SaxParser(settings, schema) {\n
\t\tvar self = this;\n
\n
\t\tfunction noop() {}\n
\n
\t\tsettings = settings || {};\n
\t\tself.schema = schema = schema || new Schema();\n
\n
\t\tif (settings.fix_self_closing !== false) {\n
\t\t\tsettings.fix_self_closing = true;\n
\t\t}\n
\n
\t\t// Add handler functions from settings and setup default handlers\n
\t\teach(\'comment cdata text start end pi doctype\'.split(\' \'), function(name) {\n
\t\t\tif (name) {\n
\t\t\t\tself[name] = settings[name] || noop;\n
\t\t\t}\n
\t\t});\n
\n
\t\t/**\n
\t\t * Parses the specified HTML string and executes the callbacks for each item it finds.\n
\t\t *\n
\t\t * @example\n
\t\t * new SaxParser({...}).parse(\'\074b\076text\074/b\076\');\n
\t\t * @method parse\n
\t\t * @param {String} html Html string to sax parse.\n
\t\t */\n
\t\tself.parse = function(html) {\n
\t\t\tvar self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name;\n
\t\t\tvar isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;\n
\t\t\tvar validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;\n
\t\t\tvar attributesRequired, attributesDefault, attributesForced;\n
\t\t\tvar anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;\n
\t\t\tvar decode = Entities.decode, fixSelfClosing, filteredUrlAttrs = Tools.makeMap(\'src,href,data,background,formaction,poster\');\n
\t\t\tvar scriptUriRegExp = /((java|vb)script|mhtml):/i, dataUriRegExp = /^data:/i;\n
\n
\t\t\tfunction processEndTag(name) {\n
\t\t\t\tvar pos, i;\n
\n
\t\t\t\t// Find position of parent of the same type\n
\t\t\t\tpos = stack.length;\n
\t\t\t\twhile (pos--) {\n
\t\t\t\t\tif (stack[pos].name === name) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Found parent\n
\t\t\t\tif (pos \076= 0) {\n
\t\t\t\t\t// Close all the open elements\n
\t\t\t\t\tfor (i = stack.length - 1; i \076= pos; i--) {\n
\t\t\t\t\t\tname = stack[i];\n
\n
\t\t\t\t\t\tif (name.valid) {\n
\t\t\t\t\t\t\tself.end(name.name);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Remove the open elements from the stack\n
\t\t\t\t\tstack.length = pos;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction parseAttribute(match, name, value, val2, val3) {\n
\t\t\t\tvar attrRule, i, trimRegExp = /[\\s\\u0000-\\u001F]+/g;\n
\n
\t\t\t\tname = name.toLowerCase();\n
\t\t\t\tvalue = name in fillAttrsMap ? name : decode(value || val2 || val3 || \'\'); // Handle boolean attribute than value attribute\n
\n
\t\t\t\t// Validate name and value pass through all data- attributes\n
\t\t\t\tif (validate \046\046 !isInternalElement \046\046 name.indexOf(\'data-\') !== 0) {\n
\t\t\t\t\tattrRule = validAttributesMap[name];\n
\n
\t\t\t\t\t// Find rule by pattern matching\n
\t\t\t\t\tif (!attrRule \046\046 validAttributePatterns) {\n
\t\t\t\t\t\ti = validAttributePatterns.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tattrRule = validAttributePatterns[i];\n
\t\t\t\t\t\t\tif (attrRule.pattern.test(name)) {\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// No rule matched\n
\t\t\t\t\t\tif (i === -1) {\n
\t\t\t\t\t\t\tattrRule = null;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// No attribute rule found\n
\t\t\t\t\tif (!attrRule) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Validate value\n
\t\t\t\t\tif (attrRule.validValues \046\046 !(value in attrRule.validValues)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Block any javascript: urls or non image data uris\n
\t\t\t\tif (filteredUrlAttrs[name] \046\046 !settings.allow_script_urls) {\n
\t\t\t\t\tvar uri = value.replace(trimRegExp, \'\');\n
\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\t// Might throw malformed URI sequence\n
\t\t\t\t\t\turi = decodeURIComponent(uri);\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Fallback to non UTF-8 decoder\n
\t\t\t\t\t\turi = unescape(uri);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (scriptUriRegExp.test(uri)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!settings.allow_html_data_urls \046\046 dataUriRegExp.test(uri) \046\046 !/^data:image\\//i.test(uri)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Add attribute to list and map\n
\t\t\t\tattrList.map[name] = value;\n
\t\t\t\tattrList.push({\n
\t\t\t\t\tname: name,\n
\t\t\t\t\tvalue: value\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Precompile RegExps and map objects\n
\t\t\ttokenRegExp = new RegExp(\'\074(?:\' +\n
\t\t\t\t\'(?:!--([\\\\w\\\\W]*?)--\076)|\' + // Comment\n
\t\t\t\t\'(?:!\\\\[CDATA\\\\[([\\\\w\\\\W]*?)\\\\]\\\\]\076)|\' + // CDATA\n
\t\t\t\t\'(?:!DOCTYPE([\\\\w\\\\W]*?)\076)|\' + // DOCTYPE\n
\t\t\t\t\'(?:\\\\?([^\\\\s\\\\/\074\076]+) ?([\\\\w\\\\W]*?)[?/]\076)|\' + // PI\n
\t\t\t\t\'(?:\\\\/([^\076]+)\076)|\' + // End element\n
\t\t\t\t\'(?:([A-Za-z0-9\\\\-_\\\\:\\\\.]+)((?:\\\\s+[^"\\\'\076]+(?:(?:"[^"]*")|(?:\\\'[^\\\']*\\\')|[^\076]*))*|\\\\/|\\\\s+)\076)\' + // Start element\n
\t\t\t\')\', \'g\');\n
\n
\t\t\tattrRegExp = /([\\w:\\-]+)(?:\\s*=\\s*(?:(?:\\"((?:[^\\"])*)\\")|(?:\\\'((?:[^\\\'])*)\\\')|([^\076\\s]+)))?/g;\n
\n
\t\t\t// Setup lookup tables for empty elements and boolean attributes\n
\t\t\tshortEndedElements = schema.getShortEndedElements();\n
\t\t\tselfClosing = settings.self_closing_elements || schema.getSelfClosingElements();\n
\t\t\tfillAttrsMap = schema.getBoolAttrs();\n
\t\t\tvalidate = settings.validate;\n
\t\t\tremoveInternalElements = settings.remove_internals;\n
\t\t\tfixSelfClosing = settings.fix_self_closing;\n
\t\t\tspecialElements = schema.getSpecialElements();\n
\n
\t\t\twhile ((matches = tokenRegExp.exec(html))) {\n
\t\t\t\t// Text\n
\t\t\t\tif (index \074 matches.index) {\n
\t\t\t\t\tself.text(decode(html.substr(index, matches.index - index)));\n
\t\t\t\t}\n
\n
\t\t\t\tif ((value = matches[6])) { // End element\n
\t\t\t\t\tvalue = value.toLowerCase();\n
\n
\t\t\t\t\t// IE will add a ":" in front of elements it doesn\'t understand like custom elements or HTML5 elements\n
\t\t\t\t\tif (value.charAt(0) === \':\') {\n
\t\t\t\t\t\tvalue = value.substr(1);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tprocessEndTag(value);\n
\t\t\t\t} else if ((value = matches[7])) { // Start element\n
\t\t\t\t\tvalue = value.toLowerCase();\n
\n
\t\t\t\t\t// IE will add a ":" in front of elements it doesn\'t understand like custom elements or HTML5 elements\n
\t\t\t\t\tif (value.charAt(0) === \':\') {\n
\t\t\t\t\t\tvalue = value.substr(1);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tisShortEnded = value in shortEndedElements;\n
\n
\t\t\t\t\t// Is self closing tag for example an \074li\076 after an open \074li\076\n
\t\t\t\t\tif (fixSelfClosing \046\046 selfClosing[value] \046\046 stack.length \076 0 \046\046 stack[stack.length - 1].name === value) {\n
\t\t\t\t\t\tprocessEndTag(value);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Validate element\n
\t\t\t\t\tif (!validate || (elementRule = schema.getElementRule(value))) {\n
\t\t\t\t\t\tisValidElement = true;\n
\n
\t\t\t\t\t\t// Grab attributes map and patters when validation is enabled\n
\t\t\t\t\t\tif (validate) {\n
\t\t\t\t\t\t\tvalidAttributesMap = elementRule.attributes;\n
\t\t\t\t\t\t\tvalidAttributePatterns = elementRule.attributePatterns;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Parse attributes\n
\t\t\t\t\t\tif ((attribsValue = matches[8])) {\n
\t\t\t\t\t\t\tisInternalElement = attribsValue.indexOf(\'data-mce-type\') !== -1; // Check if the element is an internal element\n
\n
\t\t\t\t\t\t\t// If the element has internal attributes then remove it if we are told to do so\n
\t\t\t\t\t\t\tif (isInternalElement \046\046 removeInternalElements) {\n
\t\t\t\t\t\t\t\tisValidElement = false;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tattrList = [];\n
\t\t\t\t\t\t\tattrList.map = {};\n
\n
\t\t\t\t\t\t\tattribsValue.replace(attrRegExp, parseAttribute);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tattrList = [];\n
\t\t\t\t\t\t\tattrList.map = {};\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Process attributes if validation is enabled\n
\t\t\t\t\t\tif (validate \046\046 !isInternalElement) {\n
\t\t\t\t\t\t\tattributesRequired = elementRule.attributesRequired;\n
\t\t\t\t\t\t\tattributesDefault = elementRule.attributesDefault;\n
\t\t\t\t\t\t\tattributesForced = elementRule.attributesForced;\n
\t\t\t\t\t\t\tanyAttributesRequired = elementRule.removeEmptyAttrs;\n
\n
\t\t\t\t\t\t\t// Check if any attribute exists\n
\t\t\t\t\t\t\tif (anyAttributesRequired \046\046 !attrList.length) {\n
\t\t\t\t\t\t\t\tisValidElement = false;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Handle forced attributes\n
\t\t\t\t\t\t\tif (attributesForced) {\n
\t\t\t\t\t\t\t\ti = attributesForced.length;\n
\t\t\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\t\t\tattr = attributesForced[i];\n
\t\t\t\t\t\t\t\t\tname = attr.name;\n
\t\t\t\t\t\t\t\t\tattrValue = attr.value;\n
\n
\t\t\t\t\t\t\t\t\tif (attrValue === \'{$uid}\') {\n
\t\t\t\t\t\t\t\t\t\tattrValue = \'mce_\' + idCount++;\n
\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\tattrList.map[name] = attrValue;\n
\t\t\t\t\t\t\t\t\tattrList.push({name: name, value: attrValue});\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Handle default attributes\n
\t\t\t\t\t\t\tif (attributesDefault) {\n
\t\t\t\t\t\t\t\ti = attributesDefault.length;\n
\t\t\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\t\t\tattr = attributesDefault[i];\n
\t\t\t\t\t\t\t\t\tname = attr.name;\n
\n
\t\t\t\t\t\t\t\t\tif (!(name in attrList.map)) {\n
\t\t\t\t\t\t\t\t\t\tattrValue = attr.value;\n
\n
\t\t\t\t\t\t\t\t\t\tif (attrValue === \'{$uid}\') {\n
\t\t\t\t\t\t\t\t\t\t\tattrValue = \'mce_\' + idCount++;\n
\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\tattrList.map[name] = attrValue;\n
\t\t\t\t\t\t\t\t\t\tattrList.push({name: name, value: attrValue});\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Handle required attributes\n
\t\t\t\t\t\t\tif (attributesRequired) {\n
\t\t\t\t\t\t\t\ti = attributesRequired.length;\n
\t\t\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\t\t\tif (attributesRequired[i] in attrList.map) {\n
\t\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t// None of the required attributes where found\n
\t\t\t\t\t\t\t\tif (i === -1) {\n
\t\t\t\t\t\t\t\t\tisValidElement = false;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Invalidate element if it\'s marked as bogus\n
\t\t\t\t\t\t\tif ((attr = attrList.map[\'data-mce-bogus\'])) {\n
\t\t\t\t\t\t\t\tif (attr === \'all\') {\n
\t\t\t\t\t\t\t\t\tindex = findEndTag(schema, html, tokenRegExp.lastIndex);\n
\t\t\t\t\t\t\t\t\ttokenRegExp.lastIndex = index;\n
\t\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tisValidElement = false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (isValidElement) {\n
\t\t\t\t\t\t\tself.start(value, attrList, isShortEnded);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tisValidElement = false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Treat script, noscript and style a bit different since they may include code that looks like elements\n
\t\t\t\t\tif ((endRegExp = specialElements[value])) {\n
\t\t\t\t\t\tendRegExp.lastIndex = index = matches.index + matches[0].length;\n
\n
\t\t\t\t\t\tif ((matches = endRegExp.exec(html))) {\n
\t\t\t\t\t\t\tif (isValidElement) {\n
\t\t\t\t\t\t\t\ttext = html.substr(index, matches.index - index);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tindex = matches.index + matches[0].length;\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\ttext = html.substr(index);\n
\t\t\t\t\t\t\tindex = html.length;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (isValidElement) {\n
\t\t\t\t\t\t\tif (text.length \076 0) {\n
\t\t\t\t\t\t\t\tself.text(text, true);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tself.end(value);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\ttokenRegExp.lastIndex = index;\n
\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Push value on to stack\n
\t\t\t\t\tif (!isShortEnded) {\n
\t\t\t\t\t\tif (!attribsValue || attribsValue.indexOf(\'/\') != attribsValue.length - 1) {\n
\t\t\t\t\t\t\tstack.push({name: value, valid: isValidElement});\n
\t\t\t\t\t\t} else if (isValidElement) {\n
\t\t\t\t\t\t\tself.end(value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else if ((value = matches[1])) { // Comment\n
\t\t\t\t\t// Padd comment value to avoid browsers from parsing invalid comments as HTML\n
\t\t\t\t\tif (value.charAt(0) === \'\076\') {\n
\t\t\t\t\t\tvalue = \' \' + value;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!settings.allow_conditional_comments \046\046 value.substr(0, 3) === \'[if\') {\n
\t\t\t\t\t\tvalue = \' \' + value;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.comment(value);\n
\t\t\t\t} else if ((value = matches[2])) { // CDATA\n
\t\t\t\t\tself.cdata(value);\n
\t\t\t\t} else if ((value = matches[3])) { // DOCTYPE\n
\t\t\t\t\tself.doctype(value);\n
\t\t\t\t} else if ((value = matches[4])) { // PI\n
\t\t\t\t\tself.pi(value, matches[5]);\n
\t\t\t\t}\n
\n
\t\t\t\tindex = matches.index + matches[0].length;\n
\t\t\t}\n
\n
\t\t\t// Text\n
\t\t\tif (index \074 html.length) {\n
\t\t\t\tself.text(decode(html.substr(index)));\n
\t\t\t}\n
\n
\t\t\t// Close any open elements\n
\t\t\tfor (i = stack.length - 1; i \076= 0; i--) {\n
\t\t\t\tvalue = stack[i];\n
\n
\t\t\t\tif (value.valid) {\n
\t\t\t\t\tself.end(value.name);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\t}\n
\n
\tSaxParser.findEndTag = findEndTag;\n
\n
\treturn SaxParser;\n
});\n
\n
// Included from: js/tinymce/classes/html/DomParser.js\n
\n
/**\n
 * DomParser.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make\n
 * sure that the node tree is valid according to the specified schema.\n
 * So for example: \074p\076a\074p\076b\074/p\076c\074/p\076 will become \074p\076a\074/p\076\074p\076b\074/p\076\074p\076c\074/p\076\n
 *\n
 * @example\n
 * var parser = new tinymce.html.DomParser({validate: true}, schema);\n
 * var rootNode = parser.parse(\'\074h1\076content\074/h1\076\');\n
 *\n
 * @class tinymce.html.DomParser\n
 * @version 3.4\n
 */\n
define("tinymce/html/DomParser", [\n
\t"tinymce/html/Node",\n
\t"tinymce/html/Schema",\n
\t"tinymce/html/SaxParser",\n
\t"tinymce/util/Tools"\n
], function(Node, Schema, SaxParser, Tools) {\n
\tvar makeMap = Tools.makeMap, each = Tools.each, explode = Tools.explode, extend = Tools.extend;\n
\n
\t/**\n
\t * Constructs a new DomParser instance.\n
\t *\n
\t * @constructor\n
\t * @method DomParser\n
\t * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.\n
\t * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.\n
\t */\n
\treturn function(settings, schema) {\n
\t\tvar self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};\n
\n
\t\tsettings = settings || {};\n
\t\tsettings.validate = "validate" in settings ? settings.validate : true;\n
\t\tsettings.root_name = settings.root_name || \'body\';\n
\t\tself.schema = schema = schema || new Schema();\n
\n
\t\tfunction fixInvalidChildren(nodes) {\n
\t\t\tvar ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;\n
\t\t\tvar nonEmptyElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;\n
\n
\t\t\tnonSplitableElements = makeMap(\'tr,td,th,tbody,thead,tfoot,table\');\n
\t\t\tnonEmptyElements = schema.getNonEmptyElements();\n
\t\t\ttextBlockElements = schema.getTextBlockElements();\n
\t\t\tspecialElements = schema.getSpecialElements();\n
\n
\t\t\tfor (ni = 0; ni \074 nodes.length; ni++) {\n
\t\t\t\tnode = nodes[ni];\n
\n
\t\t\t\t// Already removed or fixed\n
\t\t\t\tif (!node.parent || node.fixed) {\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the invalid element is a text block and the text block is within a parent LI element\n
\t\t\t\t// Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office\n
\t\t\t\tif (textBlockElements[node.name] \046\046 node.parent.name == \'li\') {\n
\t\t\t\t\t// Move sibling text blocks after LI element\n
\t\t\t\t\tsibling = node.next;\n
\t\t\t\t\twhile (sibling) {\n
\t\t\t\t\t\tif (textBlockElements[sibling.name]) {\n
\t\t\t\t\t\t\tsibling.name = \'li\';\n
\t\t\t\t\t\t\tsibling.fixed = true;\n
\t\t\t\t\t\t\tnode.parent.insert(sibling, node.parent);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tsibling = sibling.next;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Unwrap current text block\n
\t\t\t\t\tnode.unwrap(node);\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// Get list of all parent nodes until we find a valid parent to stick the child into\n
\t\t\t\tparents = [node];\n
\t\t\t\tfor (parent = node.parent; parent \046\046 !schema.isValidChild(parent.name, node.name) \046\046\n
\t\t\t\t\t!nonSplitableElements[parent.name]; parent = parent.parent) {\n
\t\t\t\t\tparents.push(parent);\n
\t\t\t\t}\n
\n
\t\t\t\t// Found a suitable parent\n
\t\t\t\tif (parent \046\046 parents.length \076 1) {\n
\t\t\t\t\t// Reverse the array since it makes looping easier\n
\t\t\t\t\tparents.reverse();\n
\n
\t\t\t\t\t// Clone the related parent and insert that after the moved node\n
\t\t\t\t\tnewParent = currentNode = self.filterNode(parents[0].clone());\n
\n
\t\t\t\t\t// Start cloning and moving children on the left side of the target node\n
\t\t\t\t\tfor (i = 0; i \074 parents.length - 1; i++) {\n
\t\t\t\t\t\tif (schema.isValidChild(currentNode.name, parents[i].name)) {\n
\t\t\t\t\t\t\ttempNode = self.filterNode(parents[i].clone());\n
\t\t\t\t\t\t\tcurrentNode.append(tempNode);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\ttempNode = currentNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tfor (childNode = parents[i].firstChild; childNode \046\046 childNode != parents[i + 1];) {\n
\t\t\t\t\t\t\tnextNode = childNode.next;\n
\t\t\t\t\t\t\ttempNode.append(childNode);\n
\t\t\t\t\t\t\tchildNode = nextNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tcurrentNode = tempNode;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!newParent.isEmpty(nonEmptyElements)) {\n
\t\t\t\t\t\tparent.insert(newParent, parents[0], true);\n
\t\t\t\t\t\tparent.insert(node, newParent);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tparent.insert(node, parents[0], true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Check if the element is empty by looking through it\'s contents and special treatment for \074p\076\074br /\076\074/p\076\n
\t\t\t\t\tparent = parents[0];\n
\t\t\t\t\tif (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild \046\046 parent.firstChild.name === \'br\') {\n
\t\t\t\t\t\tparent.empty().remove();\n
\t\t\t\t\t}\n
\t\t\t\t} else if (node.parent) {\n
\t\t\t\t\t// If it\'s an LI try to find a UL/OL for it or wrap it\n
\t\t\t\t\tif (node.name === \'li\') {\n
\t\t\t\t\t\tsibling = node.prev;\n
\t\t\t\t\t\tif (sibling \046\046 (sibling.name === \'ul\' || sibling.name === \'ul\')) {\n
\t\t\t\t\t\t\tsibling.append(node);\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tsibling = node.next;\n
\t\t\t\t\t\tif (sibling \046\046 (sibling.name === \'ul\' || sibling.name === \'ul\')) {\n
\t\t\t\t\t\t\tsibling.insert(node, sibling.firstChild, true);\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode.wrap(self.filterNode(new Node(\'ul\', 1)));\n
\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Try wrapping the element in a DIV\n
\t\t\t\t\tif (schema.isValidChild(node.parent.name, \'div\') \046\046 schema.isValidChild(\'div\', node.name)) {\n
\t\t\t\t\t\tnode.wrap(self.filterNode(new Node(\'div\', 1)));\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// We failed wrapping it, then remove or unwrap it\n
\t\t\t\t\t\tif (specialElements[node.name]) {\n
\t\t\t\t\t\t\tnode.empty().remove();\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode.unwrap();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Runs the specified node though the element and attributes filters.\n
\t\t *\n
\t\t * @method filterNode\n
\t\t * @param {tinymce.html.Node} Node the node to run filters on.\n
\t\t * @return {tinymce.html.Node} The passed in node.\n
\t\t */\n
\t\tself.filterNode = function(node) {\n
\t\t\tvar i, name, list;\n
\n
\t\t\t// Run element filters\n
\t\t\tif (name in nodeFilters) {\n
\t\t\t\tlist = matchedNodes[name];\n
\n
\t\t\t\tif (list) {\n
\t\t\t\t\tlist.push(node);\n
\t\t\t\t} else {\n
\t\t\t\t\tmatchedNodes[name] = [node];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Run attribute filters\n
\t\t\ti = attributeFilters.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tname = attributeFilters[i].name;\n
\n
\t\t\t\tif (name in node.attributes.map) {\n
\t\t\t\t\tlist = matchedAttributes[name];\n
\n
\t\t\t\t\tif (list) {\n
\t\t\t\t\t\tlist.push(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tmatchedAttributes[name] = [node];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn node;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Adds a node filter function to the parser, the parser will collect the specified nodes by name\n
\t\t * and then execute the callback ones it has finished parsing the document.\n
\t\t *\n
\t\t * @example\n
\t\t * parser.addNodeFilter(\'p,h1\', function(nodes, name) {\n
\t\t *\t\tfor (var i = 0; i \074 nodes.length; i++) {\n
\t\t *\t\t\tconsole.log(nodes[i].name);\n
\t\t *\t\t}\n
\t\t * });\n
\t\t * @method addNodeFilter\n
\t\t * @method {String} name Comma separated list of nodes to collect.\n
\t\t * @param {function} callback Callback function to execute once it has collected nodes.\n
\t\t */\n
\t\tself.addNodeFilter = function(name, callback) {\n
\t\t\teach(explode(name), function(name) {\n
\t\t\t\tvar list = nodeFilters[name];\n
\n
\t\t\t\tif (!list) {\n
\t\t\t\t\tnodeFilters[name] = list = [];\n
\t\t\t\t}\n
\n
\t\t\t\tlist.push(callback);\n
\t\t\t});\n
\t\t};\n
\n
\t\t/**\n
\t\t * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes\n
\t\t * and then execute the callback ones it has finished parsing the document.\n
\t\t *\n
\t\t * @example\n
\t\t * parser.addAttributeFilter(\'src,href\', function(nodes, name) {\n
\t\t *\t\tfor (var i = 0; i \074 nodes.length; i++) {\n
\t\t *\t\t\tconsole.log(nodes[i].name);\n
\t\t *\t\t}\n
\t\t * });\n
\t\t * @method addAttributeFilter\n
\t\t * @method {String} name Comma separated list of nodes to collect.\n
\t\t * @param {function} callback Callback function to execute once it has collected nodes.\n
\t\t */\n
\t\tself.addAttributeFilter = function(name, callback) {\n
\t\t\teach(explode(name), function(name) {\n
\t\t\t\tvar i;\n
\n
\t\t\t\tfor (i = 0; i \074 attributeFilters.length; i++) {\n
\t\t\t\t\tif (attributeFilters[i].name === name) {\n
\t\t\t\t\t\tattributeFilters[i].callbacks.push(callback);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tattributeFilters.push({name: name, callbacks: [callback]});\n
\t\t\t});\n
\t\t};\n
\n
\t\t/**\n
\t\t * Parses the specified HTML string into a DOM like node tree and returns the result.\n
\t\t *\n
\t\t * @example\n
\t\t * var rootNode = new DomParser({...}).parse(\'\074b\076text\074/b\076\');\n
\t\t * @method parse\n
\t\t * @param {String} html Html string to sax parse.\n
\t\t * @param {Object} args Optional args object that gets passed to all filter functions.\n
\t\t * @return {tinymce.html.Node} Root node containing the tree.\n
\t\t */\n
\t\tself.parse = function(html, args) {\n
\t\t\tvar parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate;\n
\t\t\tvar blockElements, startWhiteSpaceRegExp, invalidChildren = [], isInWhiteSpacePreservedElement;\n
\t\t\tvar endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements;\n
\t\t\tvar children, nonEmptyElements, rootBlockName;\n
\n
\t\t\targs = args || {};\n
\t\t\tmatchedNodes = {};\n
\t\t\tmatchedAttributes = {};\n
\t\t\tblockElements = extend(makeMap(\'script,style,head,html,body,title,meta,param\'), schema.getBlockElements());\n
\t\t\tnonEmptyElements = schema.getNonEmptyElements();\n
\t\t\tchildren = schema.children;\n
\t\t\tvalidate = settings.validate;\n
\t\t\trootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;\n
\n
\t\t\twhiteSpaceElements = schema.getWhiteSpaceElements();\n
\t\t\tstartWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n
\t\t\tendWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n
\t\t\tallWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n
\t\t\tisAllWhiteSpaceRegExp = /^[ \\t\\r\\n]+$/;\n
\n
\t\t\tfunction addRootBlocks() {\n
\t\t\t\tvar node = rootNode.firstChild, next, rootBlockNode;\n
\n
\t\t\t\t// Removes whitespace at beginning and end of block so:\n
\t\t\t\t// \074p\076 x \074/p\076 -\076 \074p\076x\074/p\076\n
\t\t\t\tfunction trim(rootBlockNode) {\n
\t\t\t\t\tif (rootBlockNode) {\n
\t\t\t\t\t\tnode = rootBlockNode.firstChild;\n
\t\t\t\t\t\tif (node \046\046 node.type == 3) {\n
\t\t\t\t\t\t\tnode.value = node.value.replace(startWhiteSpaceRegExp, \'\');\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = rootBlockNode.lastChild;\n
\t\t\t\t\t\tif (node \046\046 node.type == 3) {\n
\t\t\t\t\t\t\tnode.value = node.value.replace(endWhiteSpaceRegExp, \'\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditabe root\n
\t\t\t\tif (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\twhile (node) {\n
\t\t\t\t\tnext = node.next;\n
\n
\t\t\t\t\tif (node.type == 3 || (node.type == 1 \046\046 node.name !== \'p\' \046\046\n
\t\t\t\t\t\t!blockElements[node.name] \046\046 !node.attr(\'data-mce-type\'))) {\n
\t\t\t\t\t\tif (!rootBlockNode) {\n
\t\t\t\t\t\t\t// Create a new root block element\n
\t\t\t\t\t\t\trootBlockNode = createNode(rootBlockName, 1);\n
\t\t\t\t\t\t\trootBlockNode.attr(settings.forced_root_block_attrs);\n
\t\t\t\t\t\t\trootNode.insert(rootBlockNode, node);\n
\t\t\t\t\t\t\trootBlockNode.append(node);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trootBlockNode.append(node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\ttrim(rootBlockNode);\n
\t\t\t\t\t\trootBlockNode = null;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = next;\n
\t\t\t\t}\n
\n
\t\t\t\ttrim(rootBlockNode);\n
\t\t\t}\n
\n
\t\t\tfunction createNode(name, type) {\n
\t\t\t\tvar node = new Node(name, type), list;\n
\n
\t\t\t\tif (name in nodeFilters) {\n
\t\t\t\t\tlist = matchedNodes[name];\n
\n
\t\t\t\t\tif (list) {\n
\t\t\t\t\t\tlist.push(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tmatchedNodes[name] = [node];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\tfunction removeWhitespaceBefore(node) {\n
\t\t\t\tvar textNode, textNodeNext, textVal, sibling, blockElements = schema.getBlockElements();\n
\n
\t\t\t\tfor (textNode = node.prev; textNode \046\046 textNode.type === 3;) {\n
\t\t\t\t\ttextVal = textNode.value.replace(endWhiteSpaceRegExp, \'\');\n
\n
\t\t\t\t\t// Found a text node with non whitespace then trim that and break\n
\t\t\t\t\tif (textVal.length \076 0) {\n
\t\t\t\t\t\ttextNode.value = textVal;\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\ttextNodeNext = textNode.next;\n
\n
\t\t\t\t\t// Fix for bug #7543 where bogus nodes would produce empty\n
\t\t\t\t\t// text nodes and these would be removed if a nested list was before it\n
\t\t\t\t\tif (textNodeNext) {\n
\t\t\t\t\t\tif (textNodeNext.type == 3 \046\046 textNodeNext.value.length) {\n
\t\t\t\t\t\t\ttextNode = textNode.prev;\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (!blockElements[textNodeNext.name] \046\046 textNodeNext.name != \'script\' \046\046 textNodeNext.name != \'style\') {\n
\t\t\t\t\t\t\ttextNode = textNode.prev;\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tsibling = textNode.prev;\n
\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\ttextNode = sibling;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction cloneAndExcludeBlocks(input) {\n
\t\t\t\tvar name, output = {};\n
\n
\t\t\t\tfor (name in input) {\n
\t\t\t\t\tif (name !== \'li\' \046\046 name != \'p\') {\n
\t\t\t\t\t\toutput[name] = input[name];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn output;\n
\t\t\t}\n
\n
\t\t\tparser = new SaxParser({\n
\t\t\t\tvalidate: validate,\n
\t\t\t\tallow_script_urls: settings.allow_script_urls,\n
\t\t\t\tallow_conditional_comments: settings.allow_conditional_comments,\n
\n
\t\t\t\t// Exclude P and LI from DOM parsing since it\'s treated better by the DOM parser\n
\t\t\t\tself_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),\n
\n
\t\t\t\tcdata: function(text) {\n
\t\t\t\t\tnode.append(createNode(\'#cdata\', 4)).value = text;\n
\t\t\t\t},\n
\n
\t\t\t\ttext: function(text, raw) {\n
\t\t\t\t\tvar textNode;\n
\n
\t\t\t\t\t// Trim all redundant whitespace on non white space elements\n
\t\t\t\t\tif (!isInWhiteSpacePreservedElement) {\n
\t\t\t\t\t\ttext = text.replace(allWhiteSpaceRegExp, \' \');\n
\n
\t\t\t\t\t\tif (node.lastChild \046\046 blockElements[node.lastChild.name]) {\n
\t\t\t\t\t\t\ttext = text.replace(startWhiteSpaceRegExp, \'\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Do we need to create the node\n
\t\t\t\t\tif (text.length !== 0) {\n
\t\t\t\t\t\ttextNode = createNode(\'#text\', 3);\n
\t\t\t\t\t\ttextNode.raw = !!raw;\n
\t\t\t\t\t\tnode.append(textNode).value = text;\n
\t\t\t\t\t}\n
\t\t\t\t},\n
\n
\t\t\t\tcomment: function(text) {\n
\t\t\t\t\tnode.append(createNode(\'#comment\', 8)).value = text;\n
\t\t\t\t},\n
\n
\t\t\t\tpi: function(name, text) {\n
\t\t\t\t\tnode.append(createNode(name, 7)).value = text;\n
\t\t\t\t\tremoveWhitespaceBefore(node);\n
\t\t\t\t},\n
\n
\t\t\t\tdoctype: function(text) {\n
\t\t\t\t\tvar newNode;\n
\n
\t\t\t\t\tnewNode = node.append(createNode(\'#doctype\', 10));\n
\t\t\t\t\tnewNode.value = text;\n
\t\t\t\t\tremoveWhitespaceBefore(node);\n
\t\t\t\t},\n
\n
\t\t\t\tstart: function(name, attrs, empty) {\n
\t\t\t\t\tvar newNode, attrFiltersLen, elementRule, attrName, parent;\n
\n
\t\t\t\t\telementRule = validate ? schema.getElementRule(name) : {};\n
\t\t\t\t\tif (elementRule) {\n
\t\t\t\t\t\tnewNode = createNode(elementRule.outputName || name, 1);\n
\t\t\t\t\t\tnewNode.attributes = attrs;\n
\t\t\t\t\t\tnewNode.shortEnded = empty;\n
\n
\t\t\t\t\t\tnode.append(newNode);\n
\n
\t\t\t\t\t\t// Check if node is valid child of the parent node is the child is\n
\t\t\t\t\t\t// unknown we don\'t collect it since it\'s probably a custom element\n
\t\t\t\t\t\tparent = children[node.name];\n
\t\t\t\t\t\tif (parent \046\046 children[newNode.name] \046\046 !parent[newNode.name]) {\n
\t\t\t\t\t\t\tinvalidChildren.push(newNode);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tattrFiltersLen = attributeFilters.length;\n
\t\t\t\t\t\twhile (attrFiltersLen--) {\n
\t\t\t\t\t\t\tattrName = attributeFilters[attrFiltersLen].name;\n
\n
\t\t\t\t\t\t\tif (attrName in attrs.map) {\n
\t\t\t\t\t\t\t\tlist = matchedAttributes[attrName];\n
\n
\t\t\t\t\t\t\t\tif (list) {\n
\t\t\t\t\t\t\t\t\tlist.push(newNode);\n
\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\tmatchedAttributes[attrName] = [newNode];\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Trim whitespace before block\n
\t\t\t\t\t\tif (blockElements[name]) {\n
\t\t\t\t\t\t\tremoveWhitespaceBefore(newNode);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Change current node if the element wasn\'t empty i.e not \074br /\076 or \074img /\076\n
\t\t\t\t\t\tif (!empty) {\n
\t\t\t\t\t\t\tnode = newNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Check if we are inside a whitespace preserved element\n
\t\t\t\t\t\tif (!isInWhiteSpacePreservedElement \046\046 whiteSpaceElements[name]) {\n
\t\t\t\t\t\t\tisInWhiteSpacePreservedElement = true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t},\n
\n
\t\t\t\tend: function(name) {\n
\t\t\t\t\tvar textNode, elementRule, text, sibling, tempNode;\n
\n
\t\t\t\t\telementRule = validate ? schema.getElementRule(name) : {};\n
\t\t\t\t\tif (elementRule) {\n
\t\t\t\t\t\tif (blockElements[name]) {\n
\t\t\t\t\t\t\tif (!isInWhiteSpacePreservedElement) {\n
\t\t\t\t\t\t\t\t// Trim whitespace of the first node in a block\n
\t\t\t\t\t\t\t\ttextNode = node.firstChild;\n
\t\t\t\t\t\t\t\tif (textNode \046\046 textNode.type === 3) {\n
\t\t\t\t\t\t\t\t\ttext = textNode.value.replace(startWhiteSpaceRegExp, \'\');\n
\n
\t\t\t\t\t\t\t\t\t// Any characters left after trim or should we remove it\n
\t\t\t\t\t\t\t\t\tif (text.length \076 0) {\n
\t\t\t\t\t\t\t\t\t\ttextNode.value = text;\n
\t\t\t\t\t\t\t\t\t\ttextNode = textNode.next;\n
\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\tsibling = textNode.next;\n
\t\t\t\t\t\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\n
\t\t\t\t\t\t\t\t\t\t// Remove any pure whitespace siblings\n
\t\t\t\t\t\t\t\t\t\twhile (textNode \046\046 textNode.type === 3) {\n
\t\t\t\t\t\t\t\t\t\t\ttext = textNode.value;\n
\t\t\t\t\t\t\t\t\t\t\tsibling = textNode.next;\n
\n
\t\t\t\t\t\t\t\t\t\t\tif (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {\n
\t\t\t\t\t\t\t\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t// Trim whitespace of the last node in a block\n
\t\t\t\t\t\t\t\ttextNode = node.lastChild;\n
\t\t\t\t\t\t\t\tif (textNode \046\046 textNode.type === 3) {\n
\t\t\t\t\t\t\t\t\ttext = textNode.value.replace(endWhiteSpaceRegExp, \'\');\n
\n
\t\t\t\t\t\t\t\t\t// Any characters left after trim or should we remove it\n
\t\t\t\t\t\t\t\t\tif (text.length \076 0) {\n
\t\t\t\t\t\t\t\t\t\ttextNode.value = text;\n
\t\t\t\t\t\t\t\t\t\ttextNode = textNode.prev;\n
\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\tsibling = textNode.prev;\n
\t\t\t\t\t\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\n
\t\t\t\t\t\t\t\t\t\t// Remove any pure whitespace siblings\n
\t\t\t\t\t\t\t\t\t\twhile (textNode \046\046 textNode.type === 3) {\n
\t\t\t\t\t\t\t\t\t\t\ttext = textNode.value;\n
\t\t\t\t\t\t\t\t\t\t\tsibling = textNode.prev;\n
\n
\t\t\t\t\t\t\t\t\t\t\tif (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {\n
\t\t\t\t\t\t\t\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\t\ttextNode = sibling;\n
\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Trim start white space\n
\t\t\t\t\t\t\t// Removed due to: #5424\n
\t\t\t\t\t\t\t/*textNode = node.prev;\n
\t\t\t\t\t\t\tif (textNode \046\046 textNode.type === 3) {\n
\t\t\t\t\t\t\t\ttext = textNode.value.replace(startWhiteSpaceRegExp, \'\');\n
\n
\t\t\t\t\t\t\t\tif (text.length \076 0)\n
\t\t\t\t\t\t\t\t\ttextNode.value = text;\n
\t\t\t\t\t\t\t\telse\n
\t\t\t\t\t\t\t\t\ttextNode.remove();\n
\t\t\t\t\t\t\t}*/\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Check if we exited a whitespace preserved element\n
\t\t\t\t\t\tif (isInWhiteSpacePreservedElement \046\046 whiteSpaceElements[name]) {\n
\t\t\t\t\t\t\tisInWhiteSpacePreservedElement = false;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Handle empty nodes\n
\t\t\t\t\t\tif (elementRule.removeEmpty || elementRule.paddEmpty) {\n
\t\t\t\t\t\t\tif (node.isEmpty(nonEmptyElements)) {\n
\t\t\t\t\t\t\t\tif (elementRule.paddEmpty) {\n
\t\t\t\t\t\t\t\t\tnode.empty().append(new Node(\'#text\', \'3\')).value = \'\\u00a0\';\n
\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t// Leave nodes that have a name like \074a name="name"\076\n
\t\t\t\t\t\t\t\t\tif (!node.attributes.map.name \046\046 !node.attributes.map.id) {\n
\t\t\t\t\t\t\t\t\t\ttempNode = node.parent;\n
\n
\t\t\t\t\t\t\t\t\t\tif (blockElements[node.name]) {\n
\t\t\t\t\t\t\t\t\t\t\tnode.empty().remove();\n
\t\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\t\tnode.unwrap();\n
\t\t\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t\t\tnode = tempNode;\n
\t\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = node.parent;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}, schema);\n
\n
\t\t\trootNode = node = new Node(args.context || settings.root_name, 11);\n
\n
\t\t\tparser.parse(html);\n
\n
\t\t\t// Fix invalid children or report invalid children in a contextual parsing\n
\t\t\tif (validate \046\046 invalidChildren.length) {\n
\t\t\t\tif (!args.context) {\n
\t\t\t\t\tfixInvalidChildren(invalidChildren);\n
\t\t\t\t} else {\n
\t\t\t\t\targs.invalid = true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Wrap nodes in the root into block elements if the root is body\n
\t\t\tif (rootBlockName \046\046 (rootNode.name == \'body\' || args.isRootContent)) {\n
\t\t\t\taddRootBlocks();\n
\t\t\t}\n
\n
\t\t\t// Run filters only when the contents is valid\n
\t\t\tif (!args.invalid) {\n
\t\t\t\t// Run node filters\n
\t\t\t\tfor (name in matchedNodes) {\n
\t\t\t\t\tlist = nodeFilters[name];\n
\t\t\t\t\tnodes = matchedNodes[name];\n
\n
\t\t\t\t\t// Remove already removed children\n
\t\t\t\t\tfi = nodes.length;\n
\t\t\t\t\twhile (fi--) {\n
\t\t\t\t\t\tif (!nodes[fi].parent) {\n
\t\t\t\t\t\t\tnodes.splice(fi, 1);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfor (i = 0, l = list.length; i \074 l; i++) {\n
\t\t\t\t\t\tlist[i](nodes, name, args);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Run attribute filters\n
\t\t\t\tfor (i = 0, l = attributeFilters.length; i \074 l; i++) {\n
\t\t\t\t\tlist = attributeFilters[i];\n
\n
\t\t\t\t\tif (list.name in matchedAttributes) {\n
\t\t\t\t\t\tnodes = matchedAttributes[list.name];\n
\n
\t\t\t\t\t\t// Remove already removed children\n
\t\t\t\t\t\tfi = nodes.length;\n
\t\t\t\t\t\twhile (fi--) {\n
\t\t\t\t\t\t\tif (!nodes[fi].parent) {\n
\t\t\t\t\t\t\t\tnodes.splice(fi, 1);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tfor (fi = 0, fl = list.callbacks.length; fi \074 fl; fi++) {\n
\t\t\t\t\t\t\tlist.callbacks[fi](nodes, list.name, args);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn rootNode;\n
\t\t};\n
\n
\t\t// Remove \074br\076 at end of block elements Gecko and WebKit injects BR elements to\n
\t\t// make it possible to place the caret inside empty blocks. This logic tries to remove\n
\t\t// these elements and keep br elements that where intended to be there intact\n
\t\tif (settings.remove_trailing_brs) {\n
\t\t\tself.addNodeFilter(\'br\', function(nodes) {\n
\t\t\t\tvar i, l = nodes.length, node, blockElements = extend({}, schema.getBlockElements());\n
\t\t\t\tvar nonEmptyElements = schema.getNonEmptyElements(), parent, lastParent, prev, prevName;\n
\t\t\t\tvar elementRule, textNode;\n
\n
\t\t\t\t// Remove brs from body element as well\n
\t\t\t\tblockElements.body = 1;\n
\n
\t\t\t\t// Must loop forwards since it will otherwise remove all brs in \074p\076a\074br\076\074br\076\074br\076\074/p\076\n
\t\t\t\tfor (i = 0; i \074 l; i++) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tparent = node.parent;\n
\n
\t\t\t\t\tif (blockElements[node.parent.name] \046\046 node === parent.lastChild) {\n
\t\t\t\t\t\t// Loop all nodes to the left of the current node and check for other BR elements\n
\t\t\t\t\t\t// excluding bookmarks since they are invisible\n
\t\t\t\t\t\tprev = node.prev;\n
\t\t\t\t\t\twhile (prev) {\n
\t\t\t\t\t\t\tprevName = prev.name;\n
\n
\t\t\t\t\t\t\t// Ignore bookmarks\n
\t\t\t\t\t\t\tif (prevName !== "span" || prev.attr(\'data-mce-type\') !== \'bookmark\') {\n
\t\t\t\t\t\t\t\t// Found a non BR element\n
\t\t\t\t\t\t\t\tif (prevName !== "br") {\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\t// Found another br it\'s a \074br\076\074br\076 structure then don\'t remove anything\n
\t\t\t\t\t\t\t\tif (prevName === \'br\') {\n
\t\t\t\t\t\t\t\t\tnode = null;\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tprev = prev.prev;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (node) {\n
\t\t\t\t\t\t\tnode.remove();\n
\n
\t\t\t\t\t\t\t// Is the parent to be considered empty after we removed the BR\n
\t\t\t\t\t\t\tif (parent.isEmpty(nonEmptyElements)) {\n
\t\t\t\t\t\t\t\telementRule = schema.getElementRule(parent.name);\n
\n
\t\t\t\t\t\t\t\t// Remove or padd the element depending on schema rule\n
\t\t\t\t\t\t\t\tif (elementRule) {\n
\t\t\t\t\t\t\t\t\tif (elementRule.removeEmpty) {\n
\t\t\t\t\t\t\t\t\t\tparent.remove();\n
\t\t\t\t\t\t\t\t\t} else if (elementRule.paddEmpty) {\n
\t\t\t\t\t\t\t\t\t\tparent.empty().append(new Node(\'#text\', 3)).value = \'\\u00a0\';\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Replaces BR elements inside inline elements like \074p\076\074b\076\074i\076\074br\076\074/i\076\074/b\076\074/p\076\n
\t\t\t\t\t\t// so they become \074p\076\074b\076\074i\076\046nbsp;\074/i\076\074/b\076\074/p\076\n
\t\t\t\t\t\tlastParent = node;\n
\t\t\t\t\t\twhile (parent \046\046 parent.firstChild === lastParent \046\046 parent.lastChild === lastParent) {\n
\t\t\t\t\t\t\tlastParent = parent;\n
\n
\t\t\t\t\t\t\tif (blockElements[parent.name]) {\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tparent = parent.parent;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (lastParent === parent) {\n
\t\t\t\t\t\t\ttextNode = new Node(\'#text\', 3);\n
\t\t\t\t\t\t\ttextNode.value = \'\\u00a0\';\n
\t\t\t\t\t\t\tnode.replace(textNode);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.\n
\t\tif (!settings.allow_html_in_named_anchor) {\n
\t\t\tself.addAttributeFilter(\'id,name\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, sibling, prevSibling, parent, node;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tif (node.name === \'a\' \046\046 node.firstChild \046\046 !node.attr(\'href\')) {\n
\t\t\t\t\t\tparent = node.parent;\n
\n
\t\t\t\t\t\t// Move children after current node\n
\t\t\t\t\t\tsibling = node.lastChild;\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\tprevSibling = sibling.prev;\n
\t\t\t\t\t\t\tparent.insert(sibling, node);\n
\t\t\t\t\t\t\tsibling = prevSibling;\n
\t\t\t\t\t\t} while (sibling);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\tif (settings.validate \046\046 schema.getValidClasses()) {\n
\t\t\tself.addAttributeFilter(\'class\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node, classList, ci, className, classValue;\n
\t\t\t\tvar validClasses = schema.getValidClasses(), validClassesMap, valid;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tclassList = node.attr(\'class\').split(\' \');\n
\t\t\t\t\tclassValue = \'\';\n
\n
\t\t\t\t\tfor (ci = 0; ci \074 classList.length; ci++) {\n
\t\t\t\t\t\tclassName = classList[ci];\n
\t\t\t\t\t\tvalid = false;\n
\n
\t\t\t\t\t\tvalidClassesMap = validClasses[\'*\'];\n
\t\t\t\t\t\tif (validClassesMap \046\046 validClassesMap[className]) {\n
\t\t\t\t\t\t\tvalid = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tvalidClassesMap = validClasses[node.name];\n
\t\t\t\t\t\tif (!valid \046\046 validClassesMap \046\046 validClassesMap[className]) {\n
\t\t\t\t\t\t\tvalid = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (valid) {\n
\t\t\t\t\t\t\tif (classValue) {\n
\t\t\t\t\t\t\t\tclassValue += \' \';\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tclassValue += className;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!classValue.length) {\n
\t\t\t\t\t\tclassValue = null;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode.attr(\'class\', classValue);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/html/Writer.js\n
\n
/**\n
 * Writer.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.\n
 *\n
 * @class tinymce.html.Writer\n
 * @example\n
 * var writer = new tinymce.html.Writer({indent: true});\n
 * var parser = new tinymce.html.SaxParser(writer).parse(\'\074p\076\074br\076\074/p\076\');\n
 * console.log(writer.getContent());\n
 *\n
 * @class tinymce.html.Writer\n
 * @version 3.4\n
 */\n
define("tinymce/html/Writer", [\n
\t"tinymce/html/Entities",\n
\t"tinymce/util/Tools"\n
], function(Entities, Tools) {\n
\tvar makeMap = Tools.makeMap;\n
\n
\t/**\n
\t * Constructs a new Writer instance.\n
\t *\n
\t * @constructor\n
\t * @method Writer\n
\t * @param {Object} settings Name/value settings object.\n
\t */\n
\treturn function(settings) {\n
\t\tvar html = [], indent, indentBefore, indentAfter, encode, htmlOutput;\n
\n
\t\tsettings = settings || {};\n
\t\tindent = settings.indent;\n
\t\tindentBefore = makeMap(settings.indent_before || \'\');\n
\t\tindentAfter = makeMap(settings.indent_after || \'\');\n
\t\tencode = Entities.getEncodeFunc(settings.entity_encoding || \'raw\', settings.entities);\n
\t\thtmlOutput = settings.element_format == "html";\n
\n
\t\treturn {\n
\t\t\t/**\n
\t\t\t * Writes the a start element such as \074p id="a"\076.\n
\t\t\t *\n
\t\t\t * @method start\n
\t\t\t * @param {String} name Name of the element.\n
\t\t\t * @param {Array} attrs Optional attribute array or undefined if it hasn\'t any.\n
\t\t\t * @param {Boolean} empty Optional empty state if the tag should end like \074br /\076.\n
\t\t\t */\n
\t\t\tstart: function(name, attrs, empty) {\n
\t\t\t\tvar i, l, attr, value;\n
\n
\t\t\t\tif (indent \046\046 indentBefore[name] \046\046 html.length \076 0) {\n
\t\t\t\t\tvalue = html[html.length - 1];\n
\n
\t\t\t\t\tif (value.length \076 0 \046\046 value !== \'\\n\') {\n
\t\t\t\t\t\thtml.push(\'\\n\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\thtml.push(\'\074\', name);\n
\n
\t\t\t\tif (attrs) {\n
\t\t\t\t\tfor (i = 0, l = attrs.length; i \074 l; i++) {\n
\t\t\t\t\t\tattr = attrs[i];\n
\t\t\t\t\t\thtml.push(\' \', attr.name, \'="\', encode(attr.value, true), \'"\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (!empty || htmlOutput) {\n
\t\t\t\t\thtml[html.length] = \'\076\';\n
\t\t\t\t} else {\n
\t\t\t\t\thtml[html.length] = \' /\076\';\n
\t\t\t\t}\n
\n
\t\t\t\tif (empty \046\046 indent \046\046 indentAfter[name] \046\046 html.length \076 0) {\n
\t\t\t\t\tvalue = html[html.length - 1];\n
\n
\t\t\t\t\tif (value.length \076 0 \046\046 value !== \'\\n\') {\n
\t\t\t\t\t\thtml.push(\'\\n\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes the a end element such as \074/p\076.\n
\t\t\t *\n
\t\t\t * @method end\n
\t\t\t * @param {String} name Name of the element.\n
\t\t\t */\n
\t\t\tend: function(name) {\n
\t\t\t\tvar value;\n
\n
\t\t\t\t/*if (indent \046\046 indentBefore[name] \046\046 html.length \076 0) {\n
\t\t\t\t\tvalue = html[html.length - 1];\n
\n
\t\t\t\t\tif (value.length \076 0 \046\046 value !== \'\\n\')\n
\t\t\t\t\t\thtml.push(\'\\n\');\n
\t\t\t\t}*/\n
\n
\t\t\t\thtml.push(\'\074/\', name, \'\076\');\n
\n
\t\t\t\tif (indent \046\046 indentAfter[name] \046\046 html.length \076 0) {\n
\t\t\t\t\tvalue = html[html.length - 1];\n
\n
\t\t\t\t\tif (value.length \076 0 \046\046 value !== \'\\n\') {\n
\t\t\t\t\t\thtml.push(\'\\n\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes a text node.\n
\t\t\t *\n
\t\t\t * @method text\n
\t\t\t * @param {String} text String to write out.\n
\t\t\t * @param {Boolean} raw Optional raw state if true the contents wont get encoded.\n
\t\t\t */\n
\t\t\ttext: function(text, raw) {\n
\t\t\t\tif (text.length \076 0) {\n
\t\t\t\t\thtml[html.length] = raw ? text : encode(text);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes a cdata node such as \074![CDATA[data]]\076.\n
\t\t\t *\n
\t\t\t * @method cdata\n
\t\t\t * @para</string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAY=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="6" aka="AAAAAAAAAAY=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string>m {String} text String to write out inside the cdata.\n
\t\t\t */\n
\t\t\tcdata: function(text) {\n
\t\t\t\thtml.push(\'\074![CDATA[\', text, \']]\076\');\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes a comment node such as \074!-- Comment --\076.\n
\t\t\t *\n
\t\t\t * @method cdata\n
\t\t\t * @param {String} text String to write out inside the comment.\n
\t\t\t */\n
\t\t\tcomment: function(text) {\n
\t\t\t\thtml.push(\'\074!--\', text, \'--\076\');\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes a PI node such as \074?xml attr="value" ?\076.\n
\t\t\t *\n
\t\t\t * @method pi\n
\t\t\t * @param {String} name Name of the pi.\n
\t\t\t * @param {String} text String to write out inside the pi.\n
\t\t\t */\n
\t\t\tpi: function(name, text) {\n
\t\t\t\tif (text) {\n
\t\t\t\t\thtml.push(\'\074?\', name, \' \', encode(text), \'?\076\');\n
\t\t\t\t} else {\n
\t\t\t\t\thtml.push(\'\074?\', name, \'?\076\');\n
\t\t\t\t}\n
\n
\t\t\t\tif (indent) {\n
\t\t\t\t\thtml.push(\'\\n\');\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Writes a doctype node such as \074!DOCTYPE data\076.\n
\t\t\t *\n
\t\t\t * @method doctype\n
\t\t\t * @param {String} text String to write out inside the doctype.\n
\t\t\t */\n
\t\t\tdoctype: function(text) {\n
\t\t\t\thtml.push(\'\074!DOCTYPE\', text, \'\076\', indent ? \'\\n\' : \'\');\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Resets the internal buffer if one wants to reuse the writer.\n
\t\t\t *\n
\t\t\t * @method reset\n
\t\t\t */\n
\t\t\treset: function() {\n
\t\t\t\thtml.length = 0;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Returns the contents that got serialized.\n
\t\t\t *\n
\t\t\t * @method getContent\n
\t\t\t * @return {String} HTML contents that got written down.\n
\t\t\t */\n
\t\t\tgetContent: function() {\n
\t\t\t\treturn html.join(\'\').replace(/\\n$/, \'\');\n
\t\t\t}\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/html/Serializer.js\n
\n
/**\n
 * Serializer.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to serialize down the DOM tree into a string using a Writer instance.\n
 *\n
 *\n
 * @example\n
 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse(\'\074p\076text\074/p\076\'));\n
 * @class tinymce.html.Serializer\n
 * @version 3.4\n
 */\n
define("tinymce/html/Serializer", [\n
\t"tinymce/html/Writer",\n
\t"tinymce/html/Schema"\n
], function(Writer, Schema) {\n
\t/**\n
\t * Constructs a new Serializer instance.\n
\t *\n
\t * @constructor\n
\t * @method Serializer\n
\t * @param {Object} settings Name/value settings object.\n
\t * @param {tinymce.html.Schema} schema Schema instance to use.\n
\t */\n
\treturn function(settings, schema) {\n
\t\tvar self = this, writer = new Writer(settings);\n
\n
\t\tsettings = settings || {};\n
\t\tsettings.validate = "validate" in settings ? settings.validate : true;\n
\n
\t\tself.schema = schema = schema || new Schema();\n
\t\tself.writer = writer;\n
\n
\t\t/**\n
\t\t * Serializes the specified node into a string.\n
\t\t *\n
\t\t * @example\n
\t\t * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse(\'\074p\076text\074/p\076\'));\n
\t\t * @method serialize\n
\t\t * @param {tinymce.html.Node} node Node instance to serialize.\n
\t\t * @return {String} String with HTML based on DOM tree.\n
\t\t */\n
\t\tself.serialize = function(node) {\n
\t\t\tvar handlers, validate;\n
\n
\t\t\tvalidate = settings.validate;\n
\n
\t\t\thandlers = {\n
\t\t\t\t// #text\n
\t\t\t\t3: function(node) {\n
\t\t\t\t\twriter.text(node.value, node.raw);\n
\t\t\t\t},\n
\n
\t\t\t\t// #comment\n
\t\t\t\t8: function(node) {\n
\t\t\t\t\twriter.comment(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Processing instruction\n
\t\t\t\t7: function(node) {\n
\t\t\t\t\twriter.pi(node.name, node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Doctype\n
\t\t\t\t10: function(node) {\n
\t\t\t\t\twriter.doctype(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// CDATA\n
\t\t\t\t4: function(node) {\n
\t\t\t\t\twriter.cdata(node.value);\n
\t\t\t\t},\n
\n
\t\t\t\t// Document fragment\n
\t\t\t\t11: function(node) {\n
\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\twalk(node);\n
\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\twriter.reset();\n
\n
\t\t\tfunction walk(node) {\n
\t\t\t\tvar handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;\n
\n
\t\t\t\tif (!handler) {\n
\t\t\t\t\tname = node.name;\n
\t\t\t\t\tisEmpty = node.shortEnded;\n
\t\t\t\t\tattrs = node.attributes;\n
\n
\t\t\t\t\t// Sort attributes\n
\t\t\t\t\tif (validate \046\046 attrs \046\046 attrs.length \076 1) {\n
\t\t\t\t\t\tsortedAttrs = [];\n
\t\t\t\t\t\tsortedAttrs.map = {};\n
\n
\t\t\t\t\t\telementRule = schema.getElementRule(node.name);\n
\t\t\t\t\t\tfor (i = 0, l = elementRule.attributesOrder.length; i \074 l; i++) {\n
\t\t\t\t\t\t\tattrName = elementRule.attributesOrder[i];\n
\n
\t\t\t\t\t\t\tif (attrName in attrs.map) {\n
\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\n
\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\n
\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tfor (i = 0, l = attrs.length; i \074 l; i++) {\n
\t\t\t\t\t\t\tattrName = attrs[i].name;\n
\n
\t\t\t\t\t\t\tif (!(attrName in sortedAttrs.map)) {\n
\t\t\t\t\t\t\t\tattrValue = attrs.map[attrName];\n
\t\t\t\t\t\t\t\tsortedAttrs.map[attrName] = attrValue;\n
\t\t\t\t\t\t\t\tsortedAttrs.push({name: attrName, value: attrValue});\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tattrs = sortedAttrs;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\twriter.start(node.name, attrs, isEmpty);\n
\n
\t\t\t\t\tif (!isEmpty) {\n
\t\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\t\twalk(node);\n
\t\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\twriter.end(name);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\thandler(node);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Serialize element and treat all non elements as fragments\n
\t\t\tif (node.type == 1 \046\046 !settings.inner) {\n
\t\t\t\twalk(node);\n
\t\t\t} else {\n
\t\t\t\thandlers[11](node);\n
\t\t\t}\n
\n
\t\t\treturn writer.getContent();\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/Serializer.js\n
\n
/**\n
 * Serializer.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for\n
 * more details and examples on how to use this class.\n
 *\n
 * @class tinymce.dom.Serializer\n
 */\n
define("tinymce/dom/Serializer", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/html/DomParser",\n
\t"tinymce/html/Entities",\n
\t"tinymce/html/Serializer",\n
\t"tinymce/html/Node",\n
\t"tinymce/html/Schema",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools"\n
], function(DOMUtils, DomParser, Entities, Serializer, Node, Schema, Env, Tools) {\n
\tvar each = Tools.each, trim = Tools.trim;\n
\tvar DOM = DOMUtils.DOM;\n
\n
\t/**\n
\t * Constructs a new DOM serializer class.\n
\t *\n
\t * @constructor\n
\t * @method Serializer\n
\t * @param {Object} settings Serializer settings object.\n
\t * @param {tinymce.Editor} editor Optional editor to bind events to and get schema/dom from.\n
\t */\n
\treturn function(settings, editor) {\n
\t\tvar dom, schema, htmlParser;\n
\n
\t\tif (editor) {\n
\t\t\tdom = editor.dom;\n
\t\t\tschema = editor.schema;\n
\t\t}\n
\n
\t\t// Default DOM and Schema if they are undefined\n
\t\tdom = dom || DOM;\n
\t\tschema = schema || new Schema(settings);\n
\t\tsettings.entity_encoding = settings.entity_encoding || \'named\';\n
\t\tsettings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;\n
\n
\t\thtmlParser = new DomParser(settings, schema);\n
\n
\t\t// Convert tabindex back to elements when serializing contents\n
\t\thtmlParser.addAttributeFilter(\'data-mce-tabindex\', function(nodes, name) {\n
\t\t\tvar i = nodes.length, node;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\t\t\t\tnode.attr(\'tabindex\', node.attributes.map[\'data-mce-tabindex\']);\n
\t\t\t\tnode.attr(name, null);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed\n
\t\thtmlParser.addAttributeFilter(\'src,href,style\', function(nodes, name) {\n
\t\t\tvar i = nodes.length, node, value, internalName = \'data-mce-\' + name;\n
\t\t\tvar urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\tvalue = node.attributes.map[internalName];\n
\t\t\t\tif (value !== undef) {\n
\t\t\t\t\t// Set external name to internal value and remove internal\n
\t\t\t\t\tnode.attr(name, value.length \076 0 ? value : null);\n
\t\t\t\t\tnode.attr(internalName, null);\n
\t\t\t\t} else {\n
\t\t\t\t\t// No internal attribute found then convert the value we have in the DOM\n
\t\t\t\t\tvalue = node.attributes.map[name];\n
\n
\t\t\t\t\tif (name === "style") {\n
\t\t\t\t\t\tvalue = dom.serializeStyle(dom.parseStyle(value), node.name);\n
\t\t\t\t\t} else if (urlConverter) {\n
\t\t\t\t\t\tvalue = urlConverter.call(urlConverterScope, value, name, node.name);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode.attr(name, value.length \076 0 ? value : null);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Remove internal classes mceItem\074..\076 or mceSelected\n
\t\thtmlParser.addAttributeFilter(\'class\', function(nodes) {\n
\t\t\tvar i = nodes.length, node, value;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\t\t\t\tvalue = node.attr(\'class\');\n
\n
\t\t\t\tif (value) {\n
\t\t\t\t\tvalue = node.attr(\'class\').replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, \'\');\n
\t\t\t\t\tnode.attr(\'class\', value.length \076 0 ? value : null);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Remove bookmark elements\n
\t\thtmlParser.addAttributeFilter(\'data-mce-type\', function(nodes, name, args) {\n
\t\t\tvar i = nodes.length, node;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\tif (node.attributes.map[\'data-mce-type\'] === \'bookmark\' \046\046 !args.cleanup) {\n
\t\t\t\t\tnode.remove();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\thtmlParser.addNodeFilter(\'noscript\', function(nodes) {\n
\t\t\tvar i = nodes.length, node;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i].firstChild;\n
\n
\t\t\t\tif (node) {\n
\t\t\t\t\tnode.value = Entities.decode(node.value);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Force script into CDATA sections and remove the mce- prefix also add comments around styles\n
\t\thtmlParser.addNodeFilter(\'script,style\', function(nodes, name) {\n
\t\t\tvar i = nodes.length, node, value, type;\n
\n
\t\t\tfunction trim(value) {\n
\t\t\t\t/*jshint maxlen:255 */\n
\t\t\t\t/*eslint max-len:0 */\n
\t\t\t\treturn value.replace(/(\074!--\\[CDATA\\[|\\]\\]--\076)/g, \'\\n\')\n
\t\t\t\t\t\t.replace(/^[\\r\\n]*|[\\r\\n]*$/g, \'\')\n
\t\t\t\t\t\t.replace(/^\\s*((\074!--)?(\\s*\\/\\/)?\\s*\074!\\[CDATA\\[|(\074!--\\s*)?\\/\\*\\s*\074!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*\074!--|\\/\\*\\s*\074!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, \'\')\n
\t\t\t\t\t\t.replace(/\\s*(\\/\\*\\s*\\]\\]\076\\s*\\*\\/(--\076)?|\\s*\\/\\/\\s*\\]\\]\076(--\076)?|\\/\\/\\s*(--\076)?|\\]\\]\076|\\/\\*\\s*--\076\\s*\\*\\/|\\s*--\076\\s*)\\s*$/g, \'\');\n
\t\t\t}\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\t\t\t\tvalue = node.firstChild ? node.firstChild.value : \'\';\n
\n
\t\t\t\tif (name === "script") {\n
\t\t\t\t\t// Remove mce- prefix from script elements and remove default type since the user specified\n
\t\t\t\t\t// a script element without type attribute\n
\t\t\t\t\ttype = node.attr(\'type\');\n
\t\t\t\t\tif (type) {\n
\t\t\t\t\t\tnode.attr(\'type\', type == \'mce-no/type\' ? null : type.replace(/^mce\\-/, \'\'));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (value.length \076 0) {\n
\t\t\t\t\t\tnode.firstChild.value = \'// \074![CDATA[\\n\' + trim(value) + \'\\n// ]]\076\';\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (value.length \076 0) {\n
\t\t\t\t\t\tnode.firstChild.value = \'\074!--\\n\' + trim(value) + \'\\n--\076\';\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Convert comments to cdata and handle protected comments\n
\t\thtmlParser.addNodeFilter(\'#comment\', function(nodes) {\n
\t\t\tvar i = nodes.length, node;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\tif (node.value.indexOf(\'[CDATA[\') === 0) {\n
\t\t\t\t\tnode.name = \'#cdata\';\n
\t\t\t\t\tnode.type = 4;\n
\t\t\t\t\tnode.value = node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, \'\');\n
\t\t\t\t} else if (node.value.indexOf(\'mce:protected \') === 0) {\n
\t\t\t\t\tnode.name = "#text";\n
\t\t\t\t\tnode.type = 3;\n
\t\t\t\t\tnode.raw = true;\n
\t\t\t\t\tnode.value = unescape(node.value).substr(14);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\thtmlParser.addNodeFilter(\'xml:namespace,input\', function(nodes, name) {\n
\t\t\tvar i = nodes.length, node;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tnode = nodes[i];\n
\t\t\t\tif (node.type === 7) {\n
\t\t\t\t\tnode.remove();\n
\t\t\t\t} else if (node.type === 1) {\n
\t\t\t\t\tif (name === "input" \046\046 !("type" in node.attributes.map)) {\n
\t\t\t\t\t\tnode.attr(\'type\', \'text\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Fix list elements, TODO: Replace this later\n
\t\tif (settings.fix_list_elements) {\n
\t\t\thtmlParser.addNodeFilter(\'ul,ol\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node, parentNode;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tparentNode = node.parent;\n
\n
\t\t\t\t\tif (parentNode.name === \'ul\' || parentNode.name === \'ol\') {\n
\t\t\t\t\t\tif (node.prev \046\046 node.prev.name === \'li\') {\n
\t\t\t\t\t\t\tnode.prev.append(node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Remove internal data attributes\n
\t\thtmlParser.addAttributeFilter(\n
\t\t\t\'data-mce-src,data-mce-href,data-mce-style,\' +\n
\t\t\t\'data-mce-selected,data-mce-expando,\' +\n
\t\t\t\'data-mce-type,data-mce-resize\',\n
\n
\t\t\tfunction(nodes, name) {\n
\t\t\t\tvar i = nodes.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnodes[i].attr(name, null);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t);\n
\n
\t\t// Return public methods\n
\t\treturn {\n
\t\t\t/**\n
\t\t\t * Schema instance that was used to when the Serializer was constructed.\n
\t\t\t *\n
\t\t\t * @field {tinymce.html.Schema} schema\n
\t\t\t */\n
\t\t\tschema: schema,\n
\n
\t\t\t/**\n
\t\t\t * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name\n
\t\t\t * and then execute the callback ones it has finished parsing the document.\n
\t\t\t *\n
\t\t\t * @example\n
\t\t\t * parser.addNodeFilter(\'p,h1\', function(nodes, name) {\n
\t\t\t *\t\tfor (var i = 0; i \074 nodes.length; i++) {\n
\t\t\t *\t\t\tconsole.log(nodes[i].name);\n
\t\t\t *\t\t}\n
\t\t\t * });\n
\t\t\t * @method addNodeFilter\n
\t\t\t * @method {String} name Comma separated list of nodes to collect.\n
\t\t\t * @param {function} callback Callback function to execute once it has collected nodes.\n
\t\t\t */\n
\t\t\taddNodeFilter: htmlParser.addNodeFilter,\n
\n
\t\t\t/**\n
\t\t\t * Adds a attribute filter function to the parser used by the serializer, the parser will\n
\t\t\t * collect nodes that has the specified attributes\n
\t\t\t * and then execute the callback ones it has finished parsing the document.\n
\t\t\t *\n
\t\t\t * @example\n
\t\t\t * parser.addAttributeFilter(\'src,href\', function(nodes, name) {\n
\t\t\t *\t\tfor (var i = 0; i \074 nodes.length; i++) {\n
\t\t\t *\t\t\tconsole.log(nodes[i].name);\n
\t\t\t *\t\t}\n
\t\t\t * });\n
\t\t\t * @method addAttributeFilter\n
\t\t\t * @method {String} name Comma separated list of nodes to collect.\n
\t\t\t * @param {function} callback Callback function to execute once it has collected nodes.\n
\t\t\t */\n
\t\t\taddAttributeFilter: htmlParser.addAttributeFilter,\n
\n
\t\t\t/**\n
\t\t\t * Serializes the specified browser DOM node into a HTML string.\n
\t\t\t *\n
\t\t\t * @method serialize\n
\t\t\t * @param {DOMNode} node DOM node to serialize.\n
\t\t\t * @param {Object} args Arguments option that gets passed to event handlers.\n
\t\t\t */\n
\t\t\tserialize: function(node, args) {\n
\t\t\t\tvar self = this, impl, doc, oldDoc, htmlSerializer, content;\n
\n
\t\t\t\t// Explorer won\'t clone contents of script and style and the\n
\t\t\t\t// selected index of select elements are cleared on a clone operation.\n
\t\t\t\tif (Env.ie \046\046 dom.select(\'script,style,select,map\').length \076 0) {\n
\t\t\t\t\tcontent = node.innerHTML;\n
\t\t\t\t\tnode = node.cloneNode(false);\n
\t\t\t\t\tdom.setHTML(node, content);\n
\t\t\t\t} else {\n
\t\t\t\t\tnode = node.cloneNode(true);\n
\t\t\t\t}\n
\n
\t\t\t\t// Nodes needs to be attached to something in WebKit/Opera\n
\t\t\t\t// This fix will make DOM ranges and make Sizzle happy!\n
\t\t\t\timpl = node.ownerDocument.implementation;\n
\t\t\t\tif (impl.createHTMLDocument) {\n
\t\t\t\t\t// Create an empty HTML document\n
\t\t\t\t\tdoc = impl.createHTMLDocument("");\n
\n
\t\t\t\t\t// Add the element or it\'s children if it\'s a body element to the new document\n
\t\t\t\t\teach(node.nodeName == \'BODY\' ? node.childNodes : [node], function(node) {\n
\t\t\t\t\t\tdoc.body.appendChild(doc.importNode(node, true));\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Grab first child or body element for serialization\n
\t\t\t\t\tif (node.nodeName != \'BODY\') {\n
\t\t\t\t\t\tnode = doc.body.firstChild;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tnode = doc.body;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// set the new document in DOMUtils so createElement etc works\n
\t\t\t\t\toldDoc = dom.doc;\n
\t\t\t\t\tdom.doc = doc;\n
\t\t\t\t}\n
\n
\t\t\t\targs = args || {};\n
\t\t\t\targs.format = args.format || \'html\';\n
\n
\t\t\t\t// Don\'t wrap content if we want selected html\n
\t\t\t\tif (args.selection) {\n
\t\t\t\t\targs.forced_root_block = \'\';\n
\t\t\t\t}\n
\n
\t\t\t\t// Pre process\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\targs.node = node;\n
\t\t\t\t\tself.onPreProcess(args);\n
\t\t\t\t}\n
\n
\t\t\t\t// Setup serializer\n
\t\t\t\thtmlSerializer = new Serializer(settings, schema);\n
\n
\t\t\t\t// Parse and serialize HTML\n
\t\t\t\targs.content = htmlSerializer.serialize(\n
\t\t\t\t\thtmlParser.parse(trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args)\n
\t\t\t\t);\n
\n
\t\t\t\t// Replace all BOM characters for now until we can find a better solution\n
\t\t\t\tif (!args.cleanup) {\n
\t\t\t\t\targs.content = args.content.replace(/\\uFEFF/g, \'\');\n
\t\t\t\t}\n
\n
\t\t\t\t// Post process\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\tself.onPostProcess(args);\n
\t\t\t\t}\n
\n
\t\t\t\t// Restore the old document if it was changed\n
\t\t\t\tif (oldDoc) {\n
\t\t\t\t\tdom.doc = oldDoc;\n
\t\t\t\t}\n
\n
\t\t\t\targs.node = null;\n
\n
\t\t\t\treturn args.content;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Adds valid elements rules to the serializers schema instance this enables you to specify things\n
\t\t\t * like what elements should be outputted and what attributes specific elements might have.\n
\t\t\t * Consult the Wiki for more details on this format.\n
\t\t\t *\n
\t\t\t * @method addRules\n
\t\t\t * @param {String} rules Valid elements rules string to add to schema.\n
\t\t\t */\n
\t\t\taddRules: function(rules) {\n
\t\t\t\tschema.addValidElements(rules);\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Sets the valid elements rules to the serializers schema instance this enables you to specify things\n
\t\t\t * like what elements should be outputted and what attributes specific elements might have.\n
\t\t\t * Consult the Wiki for more details on this format.\n
\t\t\t *\n
\t\t\t * @method setRules\n
\t\t\t * @param {String} rules Valid elements rules string.\n
\t\t\t */\n
\t\t\tsetRules: function(rules) {\n
\t\t\t\tschema.setValidElements(rules);\n
\t\t\t},\n
\n
\t\t\tonPreProcess: function(args) {\n
\t\t\t\tif (editor) {\n
\t\t\t\t\teditor.fire(\'PreProcess\', args);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tonPostProcess: function(args) {\n
\t\t\t\tif (editor) {\n
\t\t\t\t\teditor.fire(\'PostProcess\', args);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/TridentSelection.js\n
\n
/**\n
 * TridentSelection.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Selection class for old explorer versions. This one fakes the\n
 * native selection object available on modern browsers.\n
 *\n
 * @class tinymce.dom.TridentSelection\n
 */\n
define("tinymce/dom/TridentSelection", [], function() {\n
\tfunction Selection(selection) {\n
\t\tvar self = this, dom = selection.dom, FALSE = false;\n
\n
\t\tfunction getPosition(rng, start) {\n
\t\t\tvar checkRng, startIndex = 0, endIndex, inside,\n
\t\t\t\tchildren, child, offset, index, position = -1, parent;\n
\n
\t\t\t// Setup test range, collapse it and get the parent\n
\t\t\tcheckRng = rng.duplicate();\n
\t\t\tcheckRng.collapse(start);\n
\t\t\tparent = checkRng.parentElement();\n
\n
\t\t\t// Check if the selection is within the right document\n
\t\t\tif (parent.ownerDocument !== selection.dom.doc) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// IE will report non editable elements as it\'s parent so look for an editable one\n
\t\t\twhile (parent.contentEditable === "false") {\n
\t\t\t\tparent = parent.parentNode;\n
\t\t\t}\n
\n
\t\t\t// If parent doesn\'t have any children then return that we are inside the element\n
\t\t\tif (!parent.hasChildNodes()) {\n
\t\t\t\treturn {node: parent, inside: 1};\n
\t\t\t}\n
\n
\t\t\t// Setup node list and endIndex\n
\t\t\tchildren = parent.children;\n
\t\t\tendIndex = children.length - 1;\n
\n
\t\t\t// Perform a binary search for the position\n
\t\t\twhile (startIndex \074= endIndex) {\n
\t\t\t\tindex = Math.floor((startIndex + endIndex) / 2);\n
\n
\t\t\t\t// Move selection to node and compare the ranges\n
\t\t\t\tchild = children[index];\n
\t\t\t\tcheckRng.moveToElementText(child);\n
\t\t\t\tposition = checkRng.compareEndPoints(start ? \'StartToStart\' : \'EndToEnd\', rng);\n
\n
\t\t\t\t// Before/after or an exact match\n
\t\t\t\tif (position \076 0) {\n
\t\t\t\t\tendIndex = index - 1;\n
\t\t\t\t} else if (position \074 0) {\n
\t\t\t\t\tstartIndex = index + 1;\n
\t\t\t\t} else {\n
\t\t\t\t\treturn {node: child};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Check if child position is before or we didn\'t find a position\n
\t\t\tif (position \074 0) {\n
\t\t\t\t// No element child was found use the parent element and the offset inside that\n
\t\t\t\tif (!child) {\n
\t\t\t\t\tcheckRng.moveToElementText(parent);\n
\t\t\t\t\tcheckRng.collapse(true);\n
\t\t\t\t\tchild = parent;\n
\t\t\t\t\tinside = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tcheckRng.collapse(false);\n
\t\t\t\t}\n
\n
\t\t\t\t// Walk character by character in text node until we hit the selected range endpoint,\n
\t\t\t\t// hit the end of document or parent isn\'t the right one\n
\t\t\t\t// We need to walk char by char since rng.text or rng.htmlText will trim line endings\n
\t\t\t\toffset = 0;\n
\t\t\t\twhile (checkRng.compareEndPoints(start ? \'StartToStart\' : \'StartToEnd\', rng) !== 0) {\n
\t\t\t\t\tif (checkRng.move(\'character\', 1) === 0 || parent != checkRng.parentElement()) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\toffset++;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Child position is after the selection endpoint\n
\t\t\t\tcheckRng.collapse(true);\n
\n
\t\t\t\t// Walk character by character in text node until we hit the selected range endpoint, hit\n
\t\t\t\t// the end of document or parent isn\'t the right one\n
\t\t\t\toffset = 0;\n
\t\t\t\twhile (checkRng.compareEndPoints(start ? \'StartToStart\' : \'StartToEnd\', rng) !== 0) {\n
\t\t\t\t\tif (checkRng.move(\'character\', -1) === 0 || parent != checkRng.parentElement()) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\toffset++;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn {node: child, position: position, offset: offset, inside: inside};\n
\t\t}\n
\n
\t\t// Returns a W3C DOM compatible range object by using the IE Range API\n
\t\tfunction getRange() {\n
\t\t\tvar ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark;\n
\n
\t\t\t// If selection is outside the current document just return an empty range\n
\t\t\telement = ieRange.item ? ieRange.item(0) : ieRange.parentElement();\n
\t\t\tif (element.ownerDocument != dom.doc) {\n
\t\t\t\treturn domRange;\n
\t\t\t}\n
\n
\t\t\tcollapsed = selection.isCollapsed();\n
\n
\t\t\t// Handle control selection\n
\t\t\tif (ieRange.item) {\n
\t\t\t\tdomRange.setStart(element.parentNode, dom.nodeIndex(element));\n
\t\t\t\tdomRange.setEnd(domRange.startContainer, domRange.startOffset + 1);\n
\n
\t\t\t\treturn domRange;\n
\t\t\t}\n
\n
\t\t\tfunction findEndPoint(start) {\n
\t\t\t\tvar endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;\n
\n
\t\t\t\tcontainer = endPoint.node;\n
\t\t\t\toffset = endPoint.offset;\n
\n
\t\t\t\tif (endPoint.inside \046\046 !container.hasChildNodes()) {\n
\t\t\t\t\tdomRange[start ? \'setStart\' : \'setEnd\'](container, 0);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (offset === undef) {\n
\t\t\t\t\tdomRange[start ? \'setStartBefore\' : \'setEndAfter\'](container);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (endPoint.position \074 0) {\n
\t\t\t\t\tsibling = endPoint.inside ? container.firstChild : container.nextSibling;\n
\n
\t\t\t\t\tif (!sibling) {\n
\t\t\t\t\t\tdomRange[start ? \'setStartAfter\' : \'setEndAfter\'](container);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!offset) {\n
\t\t\t\t\t\tif (sibling.nodeType == 3) {\n
\t\t\t\t\t\t\tdomRange[start ? \'setStart\' : \'setEnd\'](sibling, 0);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tdomRange[start ? \'setStartBefore\' : \'setEndBefore\'](sibling);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Find the text node and offset\n
\t\t\t\t\twhile (sibling) {\n
\t\t\t\t\t\tif (sibling.nodeType == 3) {\n
\t\t\t\t\t\t\tnodeValue = sibling.nodeValue;\n
\t\t\t\t\t\t\ttextNodeOffset += nodeValue.length;\n
\n
\t\t\t\t\t\t\t// We are at or passed the position we where looking for\n
\t\t\t\t\t\t\tif (textNodeOffset \076= offset) {\n
\t\t\t\t\t\t\t\tcontainer = sibling;\n
\t\t\t\t\t\t\t\ttextNodeOffset -= offset;\n
\t\t\t\t\t\t\t\ttextNodeOffset = nodeValue.length - textNodeOffset;\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tsibling = sibling.nextSibling;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// Find the text node and offset\n
\t\t\t\t\tsibling = container.previousSibling;\n
\n
\t\t\t\t\tif (!sibling) {\n
\t\t\t\t\t\treturn domRange[start ? \'setStartBefore\' : \'setEndBefore\'](container);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// If there isn\'t any text to loop then use the first position\n
\t\t\t\t\tif (!offset) {\n
\t\t\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\t\t\tdomRange[start ? \'setStart\' : \'setEnd\'](sibling, container.nodeValue.length);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tdomRange[start ? \'setStartAfter\' : \'setEndAfter\'](sibling);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\twhile (sibling) {\n
\t\t\t\t\t\tif (sibling.nodeType == 3) {\n
\t\t\t\t\t\t\ttextNodeOffset += sibling.nodeValue.length;\n
\n
\t\t\t\t\t\t\t// We are at or passed the position we where looking for\n
\t\t\t\t\t\t\tif (textNodeOffset \076= offset) {\n
\t\t\t\t\t\t\t\tcontainer = sibling;\n
\t\t\t\t\t\t\t\ttextNodeOffset -= offset;\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tsibling = sibling.previousSibling;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tdomRange[start ? \'setStart\' : \'setEnd\'](container, textNodeOffset);\n
\t\t\t}\n
\n
\t\t\ttry {\n
\t\t\t\t// Find start point\n
\t\t\t\tfindEndPoint(true);\n
\n
\t\t\t\t// Find end point if needed\n
\t\t\t\tif (!collapsed) {\n
\t\t\t\t\tfindEndPoint();\n
\t\t\t\t}\n
\t\t\t} catch (ex) {\n
\t\t\t\t// IE has a nasty bug where text nodes might throw "invalid argument" when you\n
\t\t\t\t// access the nodeValue or other properties of text nodes. This seems to happend when\n
\t\t\t\t// text nodes are split into two nodes by a delete/backspace call. So lets detect it and try to fix it.\n
\t\t\t\tif (ex.number == -2147024809) {\n
\t\t\t\t\t// Get the current selection\n
\t\t\t\t\tbookmark = self.getBookmark(2);\n
\n
\t\t\t\t\t// Get start element\n
\t\t\t\t\ttmpRange = ieRange.duplicate();\n
\t\t\t\t\ttmpRange.collapse(true);\n
\t\t\t\t\telement = tmpRange.parentElement();\n
\n
\t\t\t\t\t// Get end element\n
\t\t\t\t\tif (!collapsed) {\n
\t\t\t\t\t\ttmpRange = ieRange.duplicate();\n
\t\t\t\t\t\ttmpRange.collapse(false);\n
\t\t\t\t\t\telement2 = tmpRange.parentElement();\n
\t\t\t\t\t\telement2.innerHTML = element2.innerHTML;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Remove the broken elements\n
\t\t\t\t\telement.innerHTML = element.innerHTML;\n
\n
\t\t\t\t\t// Restore the selection\n
\t\t\t\t\tself.moveToBookmark(bookmark);\n
\n
\t\t\t\t\t// Since the range has moved we need to re-get it\n
\t\t\t\t\tieRange = selection.getRng();\n
\n
\t\t\t\t\t// Find start point\n
\t\t\t\t\tfindEndPoint(true);\n
\n
\t\t\t\t\t// Find end point if needed\n
\t\t\t\t\tif (!collapsed) {\n
\t\t\t\t\t\tfindEndPoint();\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tthrow ex; // Throw other errors\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn domRange;\n
\t\t}\n
\n
\t\tthis.getBookmark = function(type) {\n
\t\t\tvar rng = selection.getRng(), bookmark = {};\n
\n
\t\t\tfunction getIndexes(node) {\n
\t\t\t\tvar parent, root, children, i, indexes = [];\n
\n
\t\t\t\tparent = node.parentNode;\n
\t\t\t\troot = dom.getRoot().parentNode;\n
\n
\t\t\t\twhile (parent != root \046\046 parent.nodeType !== 9) {\n
\t\t\t\t\tchildren = parent.children;\n
\n
\t\t\t\t\ti = children.length;\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tif (node === children[i]) {\n
\t\t\t\t\t\t\tindexes.push(i);\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = parent;\n
\t\t\t\t\tparent = parent.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\treturn indexes;\n
\t\t\t}\n
\n
\t\t\tfunction getBookmarkEndPoint(start) {\n
\t\t\t\tvar position;\n
\n
\t\t\t\tposition = getPosition(rng, start);\n
\t\t\t\tif (position) {\n
\t\t\t\t\treturn {\n
\t\t\t\t\t\tposition: position.position,\n
\t\t\t\t\t\toffset: position.offset,\n
\t\t\t\t\t\tindexes: getIndexes(position.node),\n
\t\t\t\t\t\tinside: position.inside\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Non ubstructive bookmark\n
\t\t\tif (type === 2) {\n
\t\t\t\t// Handle text selection\n
\t\t\t\tif (!rng.item) {\n
\t\t\t\t\tbookmark.start = getBookmarkEndPoint(true);\n
\n
\t\t\t\t\tif (!selection.isCollapsed()) {\n
\t\t\t\t\t\tbookmark.end = getBookmarkEndPoint();\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tbookmark.start = {ctrl: true, indexes: getIndexes(rng.item(0))};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn bookmark;\n
\t\t};\n
\n
\t\tthis.moveToBookmark = function(bookmark) {\n
\t\t\tvar rng, body = dom.doc.body;\n
\n
\t\t\tfunction resolveIndexes(indexes) {\n
\t\t\t\tvar node, i, idx, children;\n
\n
\t\t\t\tnode = dom.getRoot();\n
\t\t\t\tfor (i = indexes.length - 1; i \076= 0; i--) {\n
\t\t\t\t\tchildren = node.children;\n
\t\t\t\t\tidx = indexes[i];\n
\n
\t\t\t\t\tif (idx \074= children.length - 1) {\n
\t\t\t\t\t\tnode = children[idx];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\tfunction setBookmarkEndPoint(start) {\n
\t\t\t\tvar endPoint = bookmark[start ? \'start\' : \'end\'], moveLeft, moveRng, undef, offset;\n
\n
\t\t\t\tif (endPoint) {\n
\t\t\t\t\tmoveLeft = endPoint.position \076 0;\n
\n
\t\t\t\t\tmoveRng = body.createTextRange();\n
\t\t\t\t\tmoveRng.moveToElementText(resolveIndexes(endPoint.indexes));\n
\n
\t\t\t\t\toffset = endPoint.offset;\n
\t\t\t\t\tif (offset !== undef) {\n
\t\t\t\t\t\tmoveRng.collapse(endPoint.inside || moveLeft);\n
\t\t\t\t\t\tmoveRng.moveStart(\'character\', moveLeft ? -offset : offset);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tmoveRng.collapse(start);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\trng.setEndPoint(start ? \'StartToStart\' : \'EndToStart\', moveRng);\n
\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\trng.collapse(true);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (bookmark.start) {\n
\t\t\t\tif (bookmark.start.ctrl) {\n
\t\t\t\t\trng = body.createControlRange();\n
\t\t\t\t\trng.addElement(resolveIndexes(bookmark.start.indexes));\n
\t\t\t\t\trng.select();\n
\t\t\t\t} else {\n
\t\t\t\t\trng = body.createTextRange();\n
\t\t\t\t\tsetBookmarkEndPoint(true);\n
\t\t\t\t\tsetBookmarkEndPoint();\n
\t\t\t\t\trng.select();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\n
\t\tthis.addRange = function(rng) {\n
\t\t\tvar ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, sibling,\n
\t\t\t\tdoc = selection.dom.doc, body = doc.body, nativeRng, ctrlElm;\n
\n
\t\t\tfunction setEndPoint(start) {\n
\t\t\t\tvar container, offset, marker, tmpRng, nodes;\n
\n
\t\t\t\tmarker = dom.create(\'a\');\n
\t\t\t\tcontainer = start ? startContainer : endContainer;\n
\t\t\t\toffset = start ? startOffset : endOffset;\n
\t\t\t\ttmpRng = ieRng.duplicate();\n
\n
\t\t\t\tif (container == doc || container == doc.documentElement) {\n
\t\t\t\t\tcontainer = body;\n
\t\t\t\t\toffset = 0;\n
\t\t\t\t}\n
\n
\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\tcontainer.parentNode.insertBefore(marker, container);\n
\t\t\t\t\ttmpRng.moveToElementText(marker);\n
\t\t\t\t\ttmpRng.moveStart(\'character\', offset);\n
\t\t\t\t\tdom.remove(marker);\n
\t\t\t\t\tieRng.setEndPoint(start ? \'StartToStart\' : \'EndToEnd\', tmpRng);\n
\t\t\t\t} else {\n
\t\t\t\t\tnodes = container.childNodes;\n
\n
\t\t\t\t\tif (nodes.length) {\n
\t\t\t\t\t\tif (offset \076= nodes.length) {\n
\t\t\t\t\t\t\tdom.insertAfter(marker, nodes[nodes.length - 1]);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tcontainer.insertBefore(marker, nodes[offset]);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\ttmpRng.moveToElementText(marker);\n
\t\t\t\t\t} else if (container.canHaveHTML) {\n
\t\t\t\t\t\t// Empty node selection for example \074div\076|\074/div\076\n
\t\t\t\t\t\t// Setting innerHTML with a span marker then remove that marker seems to keep empty block elements open\n
\t\t\t\t\t\tcontainer.innerHTML = \'\074span\076\046#xFEFF;\074/span\076\';\n
\t\t\t\t\t\tmarker = container.firstChild;\n
\t\t\t\t\t\ttmpRng.moveToElementText(marker);\n
\t\t\t\t\t\ttmpRng.collapse(FALSE); // Collapse false works better than true for some odd reason\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tieRng.setEndPoint(start ? \'StartToStart\' : \'EndToEnd\', tmpRng);\n
\t\t\t\t\tdom.remove(marker);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Setup some shorter versions\n
\t\t\tstartContainer = rng.startContainer;\n
\t\t\tstartOffset = rng.startOffset;\n
\t\t\tendContainer = rng.endContainer;\n
\t\t\tendOffset = rng.endOffset;\n
\t\t\tieRng = body.createTextRange();\n
\n
\t\t\t// If single element selection then try making a control selection out of it\n
\t\t\tif (startContainer == endContainer \046\046 startContainer.nodeType == 1) {\n
\t\t\t\t// Trick to place the caret inside an empty block element like \074p\076\074/p\076\n
\t\t\t\tif (startOffset == endOffset \046\046 !startContainer.hasChildNodes()) {\n
\t\t\t\t\tif (startContainer.canHaveHTML) {\n
\t\t\t\t\t\t// Check if previous sibling is an empty block if it is then we need to render it\n
\t\t\t\t\t\t// IE would otherwise move the caret into the sibling instead of the empty startContainer see: #5236\n
\t\t\t\t\t\t// Example this: \074p\076\074/p\076\074p\076|\074/p\076 would become this: \074p\076|\074/p\076\074p\076\074/p\076\n
\t\t\t\t\t\tsibling = startContainer.previousSibling;\n
\t\t\t\t\t\tif (sibling \046\046 !sibling.hasChildNodes() \046\046 dom.isBlock(sibling)) {\n
\t\t\t\t\t\t\tsibling.innerHTML = \'\046#xFEFF;\';\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tsibling = null;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tstartContainer.innerHTML = \'\074span\076\046#xFEFF;\074/span\076\074span\076\046#xFEFF;\074/span\076\';\n
\t\t\t\t\t\tieRng.moveToElementText(startContainer.lastChild);\n
\t\t\t\t\t\tieRng.select();\n
\t\t\t\t\t\tdom.doc.selection.clear();\n
\t\t\t\t\t\tstartContainer.innerHTML = \'\';\n
\n
\t\t\t\t\t\tif (sibling) {\n
\t\t\t\t\t\t\tsibling.innerHTML = \'\';\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstartOffset = dom.nodeIndex(startContainer);\n
\t\t\t\t\tstartContainer = startContainer.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\tif (startOffset == endOffset - 1) {\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\tctrlElm = startContainer.childNodes[startOffset];\n
\t\t\t\t\t\tctrlRng = body.createControlRange();\n
\t\t\t\t\t\tctrlRng.addElement(ctrlElm);\n
\t\t\t\t\t\tctrlRng.select();\n
\n
\t\t\t\t\t\t// Check if the range produced is on the correct element and is a control range\n
\t\t\t\t\t\t// On IE 8 it will select the parent contentEditable container if you select an inner element see: #5398\n
\t\t\t\t\t\tnativeRng = selection.getRng();\n
\t\t\t\t\t\tif (nativeRng.item \046\046 ctrlElm === nativeRng.item(0)) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Ignore\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Set start/end point of selection\n
\t\t\tsetEndPoint(true);\n
\t\t\tsetEndPoint();\n
\n
\t\t\t// Select the new range and scroll it into view\n
\t\t\tieRng.select();\n
\t\t};\n
\n
\t\t// Expose range method\n
\t\tthis.getRangeAt = getRange;\n
\t}\n
\n
\treturn Selection;\n
});\n
\n
// Included from: js/tinymce/classes/util/VK.js\n
\n
/**\n
 * VK.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This file exposes a set of the common KeyCodes for use. Please grow it as needed.\n
 */\n
define("tinymce/util/VK", [\n
\t"tinymce/Env"\n
], function(Env) {\n
\treturn {\n
\t\tBACKSPACE: 8,\n
\t\tDELETE: 46,\n
\t\tDOWN: 40,\n
\t\tENTER: 13,\n
\t\tLEFT: 37,\n
\t\tRIGHT: 39,\n
\t\tSPACEBAR: 32,\n
\t\tTAB: 9,\n
\t\tUP: 38,\n
\n
\t\tmodifierPressed: function(e) {\n
\t\t\treturn e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);\n
\t\t},\n
\n
\t\tmetaKeyPressed: function(e) {\n
\t\t\t// Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states\n
\t\t\treturn (Env.mac ? e.metaKey : e.ctrlKey \046\046 !e.altKey);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/ControlSelection.js\n
\n
/**\n
 * ControlSelection.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles control selection of elements. Controls are elements\n
 * that can be resized and needs to be selected as a whole. It adds custom resize handles\n
 * to all browser engines that support properly disabling the built in resize logic.\n
 *\n
 * @class tinymce.dom.ControlSelection\n
 */\n
define("tinymce/dom/ControlSelection", [\n
\t"tinymce/util/VK",\n
\t"tinymce/util/Tools",\n
\t"tinymce/Env"\n
], function(VK, Tools, Env) {\n
\treturn function(selection, editor) {\n
\t\tvar dom = editor.dom, each = Tools.each;\n
\t\tvar selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle, lastMouseDownEvent;\n
\t\tvar startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n
\t\tvar width, height, editableDoc = editor.getDoc(), rootDocument = document, isIE = Env.ie \046\046 Env.ie \074 11;\n
\t\tvar abs = Math.abs, round = Math.round, rootElement = editor.getBody(), startScrollWidth, startScrollHeight;\n
\n
\t\t// Details about each resize handle how to scale etc\n
\t\tresizeHandles = {\n
\t\t\t// Name: x multiplier, y multiplier, delta size x, delta size y\n
\t\t\t/*n: [0.5, 0, 0, -1],\n
\t\t\te: [1, 0.5, 1, 0],\n
\t\t\ts: [0.5, 1, 0, 1],\n
\t\t\tw: [0, 0.5, -1, 0],*/\n
\t\t\tnw: [0, 0, -1, -1],\n
\t\t\tne: [1, 0, 1, -1],\n
\t\t\tse: [1, 1, 1, 1],\n
\t\t\tsw: [0, 1, -1, 1]\n
\t\t};\n
\n
\t\t// Add CSS for resize handles, cloned element and selected\n
\t\tvar rootClass = \'.mce-content-body\';\n
\t\teditor.contentStyles.push(\n
\t\t\trootClass + \' div.mce-resizehandle {\' +\n
\t\t\t\t\'position: absolute;\' +\n
\t\t\t\t\'border: 1px solid black;\' +\n
\t\t\t\t\'background: #FFF;\' +\n
\t\t\t\t\'width: 7px;\' +\n
\t\t\t\t\'height: 7px;\' +\n
\t\t\t\t\'z-index: 10000\' +\n
\t\t\t\'}\' +\n
\t\t\trootClass + \' .mce-resizehandle:hover {\' +\n
\t\t\t\t\'background: #000\' +\n
\t\t\t\'}\' +\n
\t\t\trootClass + \' img[data-mce-selected], hr[data-mce-selected] {\' +\n
\t\t\t\t\'outline: 1px solid black;\' +\n
\t\t\t\t\'resize: none\' + // Have been talks about implementing this in browsers\n
\t\t\t\'}\' +\n
\t\t\trootClass + \' .mce-clonedresizable {\' +\n
\t\t\t\t\'position: absolute;\' +\n
\t\t\t\t(Env.gecko ? \'\' : \'outline: 1px dashed black;\') + // Gecko produces trails while resizing\n
\t\t\t\t\'opacity: .5;\' +\n
\t\t\t\t\'filter: alpha(opacity=50);\' +\n
\t\t\t\t\'z-index: 10000\' +\n
\t\t\t\'}\' +\n
\t\t\trootClass + \' .mce-resize-helper {\' +\n
\t\t\t\t\'background: #555;\' +\n
\t\t\t\t\'background: rgba(0,0,0,0.75);\' +\n
\t\t\t\t\'border-radius: 3px;\' +\n
\t\t\t\t\'border: 1px;\' +\n
\t\t\t\t\'color: white;\' +\n
\t\t\t\t\'display: none;\' +\n
\t\t\t\t\'font-family: sans-serif;\' +\n
\t\t\t\t\'font-size: 12px;\' +\n
\t\t\t\t\'white-space: nowrap;\' +\n
\t\t\t\t\'line-height: 14px;\' +\n
\t\t\t\t\'margin: 5px 10px;\' +\n
\t\t\t\t\'padding: 5px;\' +\n
\t\t\t\t\'position: absolute;\' +\n
\t\t\t\t\'z-index: 10001\' +\n
\t\t\t\'}\'\n
\t\t);\n
\n
\t\tfunction isResizable(elm) {\n
\t\t\tvar selector = editor.settings.object_resizing;\n
\n
\t\t\tif (selector === false || Env.iOS) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tif (typeof selector != \'string\') {\n
\t\t\t\tselector = \'table,img,div\';\n
\t\t\t}\n
\n
\t\t\tif (elm.getAttribute(\'data-mce-resize\') === \'false\') {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\treturn editor.dom.is(elm, selector);\n
\t\t}\n
\n
\t\tfunction resizeGhostElement(e) {\n
\t\t\tvar deltaX, deltaY, proportional;\n
\t\t\tvar resizeHelperX, resizeHelperY;\n
\n
\t\t\t// Calc new width/height\n
\t\t\tdeltaX = e.screenX - startX;\n
\t\t\tdeltaY = e.screenY - startY;\n
\n
\t\t\t// Calc new size\n
\t\t\twidth = deltaX * selectedHandle[2] + startW;\n
\t\t\theight = deltaY * selectedHandle[3] + startH;\n
\n
\t\t\t// Never scale down lower than 5 pixels\n
\t\t\twidth = width \074 5 ? 5 : width;\n
\t\t\theight = height \074 5 ? 5 : height;\n
\n
\t\t\tif (selectedElm.nodeName == "IMG" \046\046 editor.settings.resize_img_proportional !== false) {\n
\t\t\t\tproportional = !VK.modifierPressed(e);\n
\t\t\t} else {\n
\t\t\t\tproportional = VK.modifierPressed(e) || (selectedElm.nodeName == "IMG" \046\046 selectedHandle[2] * selectedHandle[3] !== 0);\n
\t\t\t}\n
\n
\t\t\t// Constrain proportions\n
\t\t\tif (proportional) {\n
\t\t\t\tif (abs(deltaX) \076 abs(deltaY)) {\n
\t\t\t\t\theight = round(width * ratio);\n
\t\t\t\t\twidth = round(height / ratio);\n
\t\t\t\t} else {\n
\t\t\t\t\twidth = round(height / ratio);\n
\t\t\t\t\theight = round(width * ratio);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Update ghost size\n
\t\t\tdom.setStyles(selectedElmGhost, {\n
\t\t\t\twidth: width,\n
\t\t\t\theight: height\n
\t\t\t});\n
\n
\t\t\t// Update resize helper position\n
\t\t\tresizeHelperX = selectedHandle.startPos.x + deltaX;\n
\t\t\tresizeHelperY = selectedHandle.startPos.y + deltaY;\n
\t\t\tresizeHelperX = resizeHelperX \076 0 ? resizeHelperX : 0;\n
\t\t\tresizeHelperY = resizeHelperY \076 0 ? resizeHelperY : 0;\n
\n
\t\t\tdom.setStyles(resizeHelper, {\n
\t\t\t\tleft: resizeHelperX,\n
\t\t\t\ttop: resizeHelperY,\n
\t\t\t\tdisplay: \'block\'\n
\t\t\t});\n
\n
\t\t\tresizeHelper.innerHTML = width + \' \046times; \' + height;\n
\n
\t\t\t// Update ghost X position if needed\n
\t\t\tif (selectedHandle[2] \074 0 \046\046 selectedElmGhost.clientWidth \074= width) {\n
\t\t\t\tdom.setStyle(selectedElmGhost, \'left\', selectedElmX + (startW - width));\n
\t\t\t}\n
\n
\t\t\t// Update ghost Y position if needed\n
\t\t\tif (selectedHandle[3] \074 0 \046\046 selectedElmGhost.clientHeight \074= height) {\n
\t\t\t\tdom.setStyle(selectedElmGhost, \'top\', selectedElmY + (startH - height));\n
\t\t\t}\n
\n
\t\t\t// Calculate how must overflow we got\n
\t\t\tdeltaX = rootElement.scrollWidth - startScrollWidth;\n
\t\t\tdeltaY = rootElement.scrollHeight - startScrollHeight;\n
\n
\t\t\t// Re-position the resize helper based on the overflow\n
\t\t\tif (deltaX + deltaY !== 0) {\n
\t\t\t\tdom.setStyles(resizeHelper, {\n
\t\t\t\t\tleft: resizeHelperX - deltaX,\n
\t\t\t\t\ttop: resizeHelperY - deltaY\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (!resizeStarted) {\n
\t\t\t\teditor.fire(\'ObjectResizeStart\', {target: selectedElm, width: startW, height: startH});\n
\t\t\t\tresizeStarted = true;\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction endGhostResize() {\n
\t\t\tresizeStarted = false;\n
\n
\t\t\tfunction setSizeProp(name, value) {\n
\t\t\t\tif (value) {\n
\t\t\t\t\t// Resize by using style or attribute\n
\t\t\t\t\tif (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) {\n
\t\t\t\t\t\tdom.setStyle(selectedElm, name, value);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tdom.setAttrib(selectedElm, name, value);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Set width/height properties\n
\t\t\tsetSizeProp(\'width\', width);\n
\t\t\tsetSizeProp(\'height\', height);\n
\n
\t\t\tdom.unbind(editableDoc, \'mousemove\', resizeGhostElement);\n
\t\t\tdom.unbind(editableDoc, \'mouseup\', endGhostResize);\n
\n
\t\t\tif (rootDocument != editableDoc) {\n
\t\t\t\tdom.unbind(rootDocument, \'mousemove\', resizeGhostElement);\n
\t\t\t\tdom.unbind(rootDocument, \'mouseup\', endGhostResize);\n
\t\t\t}\n
\n
\t\t\t// Remove ghost/helper and update resize handle positions\n
\t\t\tdom.remove(selectedElmGhost);\n
\t\t\tdom.remove(resizeHelper);\n
\n
\t\t\tif (!isIE || selectedElm.nodeName == "TABLE") {\n
\t\t\t\tshowResizeRect(selectedElm);\n
\t\t\t}\n
\n
\t\t\teditor.fire(\'ObjectResized\', {target: selectedElm, width: width, height: height});\n
\t\t\tdom.setAttrib(selectedElm, \'style\', dom.getAttrib(selectedElm, \'style\'));\n
\t\t\teditor.nodeChanged();\n
\t\t}\n
\n
\t\tfunction showResizeRect(targetElm, mouseDownHandleName, mouseDownEvent) {\n
\t\t\tvar position, targetWidth, targetHeight, e, rect;\n
\n
\t\t\tunbindResizeHandleEvents();\n
\n
\t\t\t// Get position and size of target\n
\t\t\tposition = dom.getPos(targetElm, rootElement);\n
\t\t\tselectedElmX = position.x;\n
\t\t\tselectedElmY = position.y;\n
\t\t\trect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption\n
\t\t\ttargetWidth = rect.width || (rect.right - rect.left);\n
\t\t\ttargetHeight = rect.height || (rect.bottom - rect.top);\n
\n
\t\t\t// Reset width/height if user selects a new image/table\n
\t\t\tif (selectedElm != targetElm) {\n
\t\t\t\tdetachResizeStartListener();\n
\t\t\t\tselectedElm = targetElm;\n
\t\t\t\twidth = height = 0;\n
\t\t\t}\n
\n
\t\t\t// Makes it possible to disable resizing\n
\t\t\te = editor.fire(\'ObjectSelected\', {target: targetElm});\n
\n
\t\t\tif (isResizable(targetElm) \046\046 !e.isDefaultPrevented()) {\n
\t\t\t\teach(resizeHandles, function(handle, name) {\n
\t\t\t\t\tvar handleElm;\n
\n
\t\t\t\t\tfunction startDrag(e) {\n
\t\t\t\t\t\tstartX = e.screenX;\n
\t\t\t\t\t\tstartY = e.screenY;\n
\t\t\t\t\t\tstartW = selectedElm.clientWidth;\n
\t\t\t\t\t\tstartH = selectedElm.clientHeight;\n
\t\t\t\t\t\tratio = startH / startW;\n
\t\t\t\t\t\tselectedHandle = handle;\n
\n
\t\t\t\t\t\thandle.startPos = {\n
\t\t\t\t\t\t\tx: targetWidth * handle[0] + selectedElmX,\n
\t\t\t\t\t\t\ty: targetHeight * handle[1] + selectedElmY\n
\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\tstartScrollWidth = rootElement.scrollWidth;\n
\t\t\t\t\t\tstartScrollHeight = rootElement.scrollHeight;\n
\n
\t\t\t\t\t\tselectedElmGhost = selectedElm.cloneNode(true);\n
\t\t\t\t\t\tdom.addClass(selectedElmGhost, \'mce-clonedresizable\');\n
\t\t\t\t\t\tdom.setAttrib(selectedElmGhost, \'data-mce-bogus\', \'all\');\n
\t\t\t\t\t\tselectedElmGhost.contentEditable = false; // Hides IE move layer cursor\n
\t\t\t\t\t\tselectedElmGhost.unSelectabe = true;\n
\t\t\t\t\t\tdom.setStyles(selectedElmGhost, {\n
\t\t\t\t\t\t\tleft: selectedElmX,\n
\t\t\t\t\t\t\ttop: selectedElmY,\n
\t\t\t\t\t\t\tmargin: 0\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\tselectedElmGhost.removeAttribute(\'data-mce-selected\');\n
\t\t\t\t\t\trootElement.appendChild(selectedElmGhost);\n
\n
\t\t\t\t\t\tdom.bind(editableDoc, \'mousemove\', resizeGhostElement);\n
\t\t\t\t\t\tdom.bind(editableDoc, \'mouseup\', endGhostResize);\n
\n
\t\t\t\t\t\tif (rootDocument != editableDoc) {\n
\t\t\t\t\t\t\tdom.bind(rootDocument, \'mousemove\', resizeGhostElement);\n
\t\t\t\t\t\t\tdom.bind(rootDocument, \'mouseup\', endGhostResize);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tresizeHelper = dom.add(rootElement, \'div\', {\n
\t\t\t\t\t\t\t\'class\': \'mce-resize-helper\',\n
\t\t\t\t\t\t\t\'data-mce-bogus\': \'all\'\n
\t\t\t\t\t\t}, startW + \' \046times; \' + startH);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (mouseDownHandleName) {\n
\t\t\t\t\t\t// Drag started by IE native resizestart\n
\t\t\t\t\t\tif (name == mouseDownHandleName) {\n
\t\t\t\t\t\t\tstartDrag(mouseDownEvent);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Get existing or render resize handle\n
\t\t\t\t\thandleElm = dom.get(\'mceResizeHandle\' + name);\n
\t\t\t\t\tif (handleElm) {\n
\t\t\t\t\t\tdom.remove(handleElm);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\thandleElm = dom.add(rootElement, \'div\', {\n
\t\t\t\t\t\tid: \'mceResizeHandle\' + name,\n
\t\t\t\t\t\t\'data-mce-bogus\': \'all\',\n
\t\t\t\t\t\t\'class\': \'mce-resizehandle\',\n
\t\t\t\t\t\tunselectable: true,\n
\t\t\t\t\t\tstyle: \'cursor:\' + name + \'-resize; margin:0; padding:0\'\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Hides IE move layer cursor\n
\t\t\t\t\t// If we set it on Chrome we get this wounderful bug: #6725\n
\t\t\t\t\tif (Env.ie) {\n
\t\t\t\t\t\thandleElm.contentEditable = false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tdom.bind(handleElm, \'mousedown\', function(e) {\n
\t\t\t\t\t\te.stopImmediatePropagation();\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\tstartDrag(e);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\thandle.elm = handleElm;\n
\n
\t\t\t\t\t// Position element\n
\t\t\t\t\tdom.setStyles(handleElm, {\n
\t\t\t\t\t\tleft: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),\n
\t\t\t\t\t\ttop: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\thideResizeRect();\n
\t\t\t}\n
\n
\t\t\tselectedElm.setAttribute(\'data-mce-selected\', \'1\');\n
\t\t}\n
\n
\t\tfunction hideResizeRect() {\n
\t\t\tvar name, handleElm;\n
\n
\t\t\tunbindResizeHandleEvents();\n
\n
\t\t\tif (selectedElm) {\n
\t\t\t\tselectedElm.removeAttribute(\'data-mce-selected\');\n
\t\t\t}\n
\n
\t\t\tfor (name in resizeHandles) {\n
\t\t\t\thandleElm = dom.get(\'mceResizeHandle\' + name);\n
\t\t\t\tif (handleElm) {\n
\t\t\t\t\tdom.unbind(handleElm);\n
\t\t\t\t\tdom.remove(handleElm);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction updateResizeRect(e) {\n
\t\t\tvar startElm, controlElm;\n
\n
\t\t\tfunction isChildOrEqual(node, parent) {\n
\t\t\t\tif (node) {\n
\t\t\t\t\tdo {\n
\t\t\t\t\t\tif (node === parent) {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} while ((node = node.parentNode));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Ignore all events while resizing or if the editor instance was removed\n
\t\t\tif (resizeStarted || editor.removed) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v\n
\t\t\teach(dom.select(\'img[data-mce-selected],hr[data-mce-selected]\'), function(img) {\n
\t\t\t\timg.removeAttribute(\'data-mce-selected\');\n
\t\t\t});\n
\n
\t\t\tcontrolElm = e.type == \'mousedown\' ? e.target : selection.getNode();\n
\t\t\tcontrolElm = dom.$(controlElm).closest(isIE ? \'table\' : \'table,img,hr\')[0];\n
\n
\t\t\tif (isChildOrEqual(controlElm, rootElement)) {\n
\t\t\t\tdisableGeckoResize();\n
\t\t\t\tstartElm = selection.getStart(true);\n
\n
\t\t\t\tif (isChildOrEqual(startElm, controlElm) \046\046 isChildOrEqual(selection.getEnd(true), controlElm)) {\n
\t\t\t\t\tif (!isIE || (controlElm != startElm \046\046 startElm.nodeName !== \'IMG\')) {\n
\t\t\t\t\t\tshowResizeRect(controlElm);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\thideResizeRect();\n
\t\t}\n
\n
\t\tfunction attachEvent(elm, name, func) {\n
\t\t\tif (elm \046\046 elm.attachEvent) {\n
\t\t\t\telm.attachEvent(\'on\' + name, func);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction detachEvent(elm, name, func) {\n
\t\t\tif (elm \046\046 elm.detachEvent) {\n
\t\t\t\telm.detachEvent(\'on\' + name, func);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction resizeNativeStart(e) {\n
\t\t\tvar target = e.srcElement, pos, name, corner, cornerX, cornerY, relativeX, relativeY;\n
\n
\t\t\tpos = target.getBoundingClientRect();\n
\t\t\trelativeX = lastMouseDownEvent.clientX - pos.left;\n
\t\t\trelativeY = lastMouseDownEvent.clientY - pos.top;\n
\n
\t\t\t// Figure out what corner we are draging on\n
\t\t\tfor (name in resizeHandles) {\n
\t\t\t\tcorner = resizeHandles[name];\n
\n
\t\t\t\tcornerX = target.offsetWidth * corner[0];\n
\t\t\t\tcornerY = target.offsetHeight * corner[1];\n
\n
\t\t\t\tif (abs(cornerX - relativeX) \074 8 \046\046 abs(cornerY - relativeY) \074 8) {\n
\t\t\t\t\tselectedHandle = corner;\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Remove native selection and let the magic begin\n
\t\t\tresizeStarted = true;\n
\t\t\teditor.fire(\'ObjectResizeStart\', {\n
\t\t\t\ttarget: selectedElm,\n
\t\t\t\twidth: selectedElm.clientWidth,\n
\t\t\t\theight: selectedElm.clientHeight\n
\t\t\t});\n
\t\t\teditor.getDoc().selection.empty();\n
\t\t\tshowResizeRect(target, name, lastMouseDownEvent);\n
\t\t}\n
\n
\t\tfunction nativeControlSelect(e) {\n
\t\t\tvar target = e.srcElement;\n
\n
\t\t\tif (target != selectedElm) {\n
\t\t\t\teditor.fire(\'ObjectSelected\', {target: target});\n
\t\t\t\tdetachResizeStartListener();\n
\n
\t\t\t\tif (target.id.indexOf(\'mceResizeHandle\') === 0) {\n
\t\t\t\t\te.returnValue = false;\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (target.nodeName == \'IMG\' || target.nodeName == \'TABLE\') {\n
\t\t\t\t\thideResizeRect();\n
\t\t\t\t\tselectedElm = target;\n
\t\t\t\t\tattachEvent(target, \'resizestart\', resizeNativeStart);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction detachResizeStartListener() {\n
\t\t\tdetachEvent(selectedElm, \'resizestart\', resizeNativeStart);\n
\t\t}\n
\n
\t\tfunction unbindResizeHandleEvents() {\n
\t\t\tfor (var name in resizeHandles) {\n
\t\t\t\tvar handle = resizeHandles[name];\n
\n
\t\t\t\tif (handle.elm) {\n
\t\t\t\t\tdom.unbind(handle.elm);\n
\t\t\t\t\tdelete handle.elm;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction disableGeckoResize() {\n
\t\t\ttry {\n
\t\t\t\t// Disable object resizing on Gecko\n
\t\t\t\teditor.getDoc().execCommand(\'enableObjectResizing\', false, false);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction controlSelect(elm) {\n
\t\t\tvar ctrlRng;\n
\n
\t\t\tif (!isIE) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tctrlRng = editableDoc.body.createControlRange();\n
\n
\t\t\ttry {\n
\t\t\t\tctrlRng.addElement(elm);\n
\t\t\t\tctrlRng.select();\n
\t\t\t\treturn true;\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore since the element can\'t be control selected for example a P tag\n
\t\t\t}\n
\t\t}\n
\n
\t\teditor.on(\'init\', function() {\n
\t\t\tif (isIE) {\n
\t\t\t\t// Hide the resize rect on resize and reselect the image\n
\t\t\t\teditor.on(\'ObjectResized\', function(e) {\n
\t\t\t\t\tif (e.target.nodeName != \'TABLE\') {\n
\t\t\t\t\t\thideResizeRect();\n
\t\t\t\t\t\tcontrolSelect(e.target);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tattachEvent(rootElement, \'controlselect\', nativeControlSelect);\n
\n
\t\t\t\teditor.on(\'mousedown\', function(e) {\n
\t\t\t\t\tlastMouseDownEvent = e;\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\tdisableGeckoResize();\n
\n
\t\t\t\t// Sniff sniff, hard to feature detect this stuff\n
\t\t\t\tif (Env.ie \076= 11) {\n
\t\t\t\t\t// Needs to be mousedown for drag/drop to work on IE 11\n
\t\t\t\t\t// Needs to be click on Edge to properly select images\n
\t\t\t\t\teditor.on(\'mousedown click\', function(e) {\n
\t\t\t\t\t\tvar nodeName = e.target.nodeName;\n
\n
\t\t\t\t\t\tif (!resizeStarted \046\046 /^(TABLE|IMG|HR)$/.test(nodeName)) {\n
\t\t\t\t\t\t\teditor.selection.select(e.target, nodeName == \'TABLE\');\n
\n
\t\t\t\t\t\t\t// Only fire once since nodeChange is expensive\n
\t\t\t\t\t\t\tif (e.type == \'mousedown\') {\n
\t\t\t\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\n
\t\t\t\t\teditor.dom.bind(rootElement, \'mscontrolselect\', function(e) {\n
\t\t\t\t\t\tif (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {\n
\t\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\t\t// This moves the selection from being a control selection to a text like selection like in WebKit #6753\n
\t\t\t\t\t\t\t// TODO: Fix this the day IE works like other browsers without this nasty native ugly control selections.\n
\t\t\t\t\t\t\tif (e.target.tagName == \'IMG\') {\n
\t\t\t\t\t\t\t\twindow.setTimeout(function() {\n
\t\t\t\t\t\t\t\t\teditor.selection.select(e.target);\n
\t\t\t\t\t\t\t\t}, 0);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\teditor.on(\'nodechange ResizeEditor ResizeWindow drop\', function(e) {\n
\t\t\t\tif (window.requestAnimationFrame) {\n
\t\t\t\t\twindow.requestAnimationFrame(function() {\n
\t\t\t\t\t\tupdateResizeRect(e);\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\tupdateResizeRect(e);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Update resize rect while typing in a table\n
\t\t\teditor.on(\'keydown keyup\', function(e) {\n
\t\t\t\tif (selectedElm \046\046 selectedElm.nodeName == "TABLE") {\n
\t\t\t\t\tupdateResizeRect(e);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.on(\'hide\', hideResizeRect);\n
\n
\t\t\t// Hide rect on focusout since it would float on top of windows otherwise\n
\t\t\t//editor.on(\'focusout\', hideResizeRect);\n
\t\t});\n
\n
\t\teditor.on(\'remove\', unbindResizeHandleEvents);\n
\n
\t\tfunction destroy() {\n
\t\t\tselectedElm = selectedElmGhost = null;\n
\n
\t\t\tif (isIE) {\n
\t\t\t\tdetachResizeStartListener();\n
\t\t\t\tdetachEvent(rootElement, \'controlselect\', nativeControlSelect);\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn {\n
\t\t\tisResizable: isResizable,\n
\t\t\tshowResizeRect: showResizeRect,\n
\t\t\thideResizeRect: hideResizeRect,\n
\t\t\tupdateResizeRect: updateResizeRect,\n
\t\t\tcontrolSelect: controlSelect,\n
\t\t\tdestroy: destroy\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/dom/BookmarkManager.js\n
\n
/**\n
 * BookmarkManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles selection bookmarks.\n
 *\n
 * @class tinymce.dom.BookmarkManager\n
 */\n
define("tinymce/dom/BookmarkManager", [\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools"\n
], function(Env, Tools) {\n
\t/**\n
\t * Constructs a new BookmarkManager instance for a specific selection instance.\n
\t *\n
\t * @constructor\n
\t * @method BookmarkManager\n
\t * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.\n
\t */\n
\tfunction BookmarkManager(selection) {\n
\t\tvar dom = selection.dom;\n
\n
\t\t/**\n
\t\t * Returns a bookmark location for the current selection. This bookmark object\n
\t\t * can then be used to restore the selection after some content modification to the document.\n
\t\t *\n
\t\t * @method getBookmark\n
\t\t * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.\n
\t\t * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.\n
\t\t * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.\n
\t\t * @example\n
\t\t * // Stores a bookmark of the current selection\n
\t\t * var bm = tinymce.activeEditor.selection.getBookmark();\n
\t\t *\n
\t\t * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + \'Some new content\');\n
\t\t *\n
\t\t * // Restore the selection bookmark\n
\t\t * tinymce.activeEditor.selection.moveToBookmark(bm);\n
\t\t */\n
\t\tthis.getBookmark = function(type, normalized) {\n
\t\t\tvar rng, rng2, id, collapsed, name, element, chr = \'\046#xFEFF;\', styles;\n
\n
\t\t\tfunction findIndex(name, element) {\n
\t\t\t\tvar index = 0;\n
\n
\t\t\t\tTools.each(dom.select(name), function(node, i) {\n
\t\t\t\t\tif (node == element) {\n
\t\t\t\t\t\tindex = i;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn index;\n
\t\t\t}\n
\n
\t\t\tfunction normalizeTableCellSelection(rng) {\n
\t\t\t\tfunction moveEndPoint(start) {\n
\t\t\t\t\tvar container, offset, childNodes, prefix = start ? \'start\' : \'end\';\n
\n
\t\t\t\t\tcontainer = rng[prefix + \'Container\'];\n
\t\t\t\t\toffset = rng[prefix + \'Offset\'];\n
\n
\t\t\t\t\tif (container.nodeType == 1 \046\046 container.nodeName == "TR") {\n
\t\t\t\t\t\tchildNodes = container.childNodes;\n
\t\t\t\t\t\tcontainer = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n
\t\t\t\t\t\tif (container) {\n
\t\t\t\t\t\t\toffset = start ? 0 : container.childNodes.length;\n
\t\t\t\t\t\t\trng[\'set\' + (start ? \'Start\' : \'End\')](container, offset);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tmoveEndPoint(true);\n
\t\t\t\tmoveEndPoint();\n
\n
\t\t\t\treturn rng;\n
\t\t\t}\n
\n
\t\t\tfunction getLocation() {\n
\t\t\t\tvar rng = selection.getRng(true), root = dom.getRoot(), bookmark = {};\n
\n
\t\t\t\tfunction getPoint(rng, start) {\n
\t\t\t\t\tvar container = rng[start ? \'startContainer\' : \'endContainer\'],\n
\t\t\t\t\t\toffset = rng[start ? \'startOffset\' : \'endOffset\'], point = [], node, childNodes, after = 0;\n
\n
\t\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\t\tif (normalized) {\n
\t\t\t\t\t\t\tfor (node = container.previousSibling; node \046\046 node.nodeType == 3; node = node.previousSibling) {\n
\t\t\t\t\t\t\t\toffset += node.nodeValue.length;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tpoint.push(offset);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tchildNodes = container.childNodes;\n
\n
\t\t\t\t\t\tif (offset \076= childNodes.length \046\046 childNodes.length) {\n
\t\t\t\t\t\t\tafter = 1;\n
\t\t\t\t\t\t\toffset = Math.max(0, childNodes.length - 1);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tpoint.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfor (; container \046\046 container != root; container = container.parentNode) {\n
\t\t\t\t\t\tpoint.push(dom.nodeIndex(container, normalized));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn point;\n
\t\t\t\t}\n
\n
\t\t\t\tbookmark.start = getPoint(rng, true);\n
\n
\t\t\t\tif (!selection.isCollapsed()) {\n
\t\t\t\t\tbookmark.end = getPoint(rng);\n
\t\t\t\t}\n
\n
\t\t\t\treturn bookmark;\n
\t\t\t}\n
\n
\t\t\tif (type == 2) {\n
\t\t\t\telement = selection.getNode();\n
\t\t\t\tname = element ? element.nodeName : null;\n
\n
\t\t\t\tif (name == \'IMG\') {\n
\t\t\t\t\treturn {name: name, index: findIndex(name, element)};\n
\t\t\t\t}\n
\n
\t\t\t\tif (selection.tridentSel) {\n
\t\t\t\t\treturn selection.tridentSel.getBookmark(type);\n
\t\t\t\t}\n
\n
\t\t\t\treturn getLocation();\n
\t\t\t}\n
\n
\t\t\t// Handle simple range\n
\t\t\tif (type) {\n
\t\t\t\treturn {rng: selection.getRng()};\n
\t\t\t}\n
\n
\t\t\trng = selection.getRng();\n
\t\t\tid = dom.uniqueId();\n
\t\t\tcollapsed = selection.isCollapsed();\n
\t\t\tstyles = \'overflow:hidden;line-height:0px\';\n
\n
\t\t\t// Explorer method\n
\t\t\tif (rng.duplicate || rng.item) {\n
\t\t\t\t// Text selection\n
\t\t\t\tif (!rng.item) {\n
\t\t\t\t\trng2 = rng.duplicate();\n
\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\t// Insert start marker\n
\t\t\t\t\t\trng.collapse();\n
\t\t\t\t\t\trng.pasteHTML(\'\074span data-mce-type="bookmark" id="\' + id + \'_start" style="\' + styles + \'"\076\' + chr + \'\074/span\076\');\n
\n
\t\t\t\t\t\t// Insert end marker\n
\t\t\t\t\t\tif (!collapsed) {\n
\t\t\t\t\t\t\trng2.collapse(false);\n
\n
\t\t\t\t\t\t\t// Detect the empty space after block elements in IE and move the\n
\t\t\t\t\t\t\t// end back one character \074p\076\074/p\076] becomes \074p\076]\074/p\076\n
\t\t\t\t\t\t\trng.moveToElementText(rng2.parentElement());\n
\t\t\t\t\t\t\tif (rng.compareEndPoints(\'StartToEnd\', rng2) === 0) {\n
\t\t\t\t\t\t\t\trng2.move(\'character\', -1);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\trng2.pasteHTML(\'\074span data-mce-type="bookmark" id="\' + id + \'_end" style="\' + styles + \'"\076\' + chr + \'\074/span\076\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// IE might throw unspecified error so lets ignore it\n
\t\t\t\t\t\treturn null;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// Control selection\n
\t\t\t\t\telement = rng.item(0);\n
\t\t\t\t\tname = element.nodeName;\n
\n
\t\t\t\t\treturn {name: name, index: findIndex(name, element)};\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\telement = selection.getNode();\n
\t\t\t\tname = element.nodeName;\n
\t\t\t\tif (name == \'IMG\') {\n
\t\t\t\t\treturn {name: name, index: findIndex(name, element)};\n
\t\t\t\t}\n
\n
\t\t\t\t// W3C method\n
\t\t\t\trng2 = normalizeTableCellSelection(rng.cloneRange());\n
\n
\t\t\t\t// Insert end marker\n
\t\t\t\tif (!collapsed) {\n
\t\t\t\t\trng2.collapse(false);\n
\t\t\t\t\trng2.insertNode(dom.create(\'span\', {\'data-mce-type\': "bookmark", id: id + \'_end\', style: styles}, chr));\n
\t\t\t\t}\n
\n
\t\t\t\trng = normalizeTableCellSelection(rng);\n
\t\t\t\trng.collapse(true);\n
\t\t\t\trng.insertNode(dom.create(\'span\', {\'data-mce-type\': "bookmark", id: id + \'_start\', style: styles}, chr));\n
\t\t\t}\n
\n
\t\t\tselection.moveToBookmark({id: id, keep: 1});\n
\n
\t\t\treturn {id: id};\n
\t\t};\n
\n
\t\t/**\n
\t\t * Restores the selection to the specified bookmark.\n
\t\t *\n
\t\t * @method moveToBookmark\n
\t\t * @param {Object} bookmark Bookmark to restore selection from.\n
\t\t * @return {Boolean} true/false if it was successful or not.\n
\t\t * @example\n
\t\t * // Stores a bookmark of the current selection\n
\t\t * var bm = tinymce.activeEditor.selection.getBookmark();\n
\t\t *\n
\t\t * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + \'Some new content\');\n
\t\t *\n
\t\t * // Restore the selection bookmark\n
\t\t * tinymce.activeEditor.selection.moveToBookmark(bm);\n
\t\t */\n
\t\tthis.moveToBookmark = function(bookmark) {\n
\t\t\tvar rng, root, startContainer, endContainer, startOffset, endOffset;\n
\n
\t\t\tfunction setEndPoint(start) {\n
\t\t\t\tvar point = bookmark[start ? \'start\' : \'end\'], i, node, offset, children;\n
\n
\t\t\t\tif (point) {\n
\t\t\t\t\toffset = point[0];\n
\n
\t\t\t\t\t// Find container node\n
\t\t\t\t\tfor (node = root, i = point.length - 1; i \076= 1; i--) {\n
\t\t\t\t\t\tchildren = node.childNodes;\n
\n
\t\t\t\t\t\tif (point[i] \076 children.length - 1) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = children[point[i]];\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Move text offset to best suitable location\n
\t\t\t\t\tif (node.nodeType === 3) {\n
\t\t\t\t\t\toffset = Math.min(point[0], node.nodeValue.length);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Move element offset to best suitable location\n
\t\t\t\t\tif (node.nodeType === 1) {\n
\t\t\t\t\t\toffset = Math.min(point[0], node.childNodes.length);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Set offset within container node\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\trng.setStart(node, offset);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setEnd(node, offset);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tfunction restoreEndPoint(suffix) {\n
\t\t\t\tvar marker = dom.get(bookmark.id + \'_\' + suffix), node, idx, next, prev, keep = bookmark.keep;\n
\n
\t\t\t\tif (marker) {\n
\t\t\t\t\tnode = marker.parentNode;\n
\n
\t\t\t\t\tif (suffix == \'start\') {\n
\t\t\t\t\t\tif (!keep) {\n
\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode = marker.firstChild;\n
\t\t\t\t\t\t\tidx = 1;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tstartContainer = endContainer = node;\n
\t\t\t\t\t\tstartOffset = endOffset = idx;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tif (!keep) {\n
\t\t\t\t\t\t\tidx = dom.nodeIndex(marker);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode = marker.firstChild;\n
\t\t\t\t\t\t\tidx = 1;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tendContainer = node;\n
\t\t\t\t\t\tendOffset = idx;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!keep) {\n
\t\t\t\t\t\tprev = marker.previousSibling;\n
\t\t\t\t\t\tnext = marker.nextSibling;\n
\n
\t\t\t\t\t\t// Remove all marker text nodes\n
\t\t\t\t\t\tTools.each(Tools.grep(marker.childNodes), function(node) {\n
\t\t\t\t\t\t\tif (node.nodeType == 3) {\n
\t\t\t\t\t\t\t\tnode.nodeValue = node.nodeValue.replace(/\\uFEFF/g, \'\');\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t// Remove marker but keep children if for example contents where inserted into the marker\n
\t\t\t\t\t\t// Also remove duplicated instances of the marker for example by a\n
\t\t\t\t\t\t// split operation or by WebKit auto split on paste feature\n
\t\t\t\t\t\twhile ((marker = dom.get(bookmark.id + \'_\' + suffix))) {\n
\t\t\t\t\t\t\tdom.remove(marker, 1);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// If siblings are text nodes then merge them unless it\'s Opera since it some how removes the node\n
\t\t\t\t\t\t// and we are sniffing since adding a lot of detection code for a browser with 3% of the market\n
\t\t\t\t\t\t// isn\'t worth the effort. Sorry, Opera but it\'s just a fact\n
\t\t\t\t\t\tif (prev \046\046 next \046\046 prev.nodeType == next.nodeType \046\046 prev.nodeType == 3 \046\046 !Env.opera) {\n
\t\t\t\t\t\t\tidx = prev.nodeValue.length;\n
\t\t\t\t\t\t\tprev.appendData(next.nodeValue);\n
\t\t\t\t\t\t\tdom.remove(next);\n
\n
\t\t\t\t\t\t\tif (suffix == \'start\') {\n
\t\t\t\t\t\t\t\tstartContainer = endContainer = prev;\n
\t\t\t\t\t\t\t\tstartOffset = endOffset = idx;\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tendContainer = prev;\n
\t\t\t\t\t\t\t\tendOffset = idx;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction addBogus(node) {\n
\t\t\t\t// Adds a bogus BR element for empty block elements\n
\t\t\t\tif (dom.isBlock(node) \046\046 !node.innerHTML \046\046 !Env.ie) {\n
\t\t\t\t\tnode.innerHTML = \'\074br data-mce-bogus="1" /\076\';\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\tif (bookmark) {\n
\t\t\t\tif (bookmark.start) {\n
\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\troot = dom.getRoot();\n
\n
\t\t\t\t\tif (selection.tridentSel) {\n
\t\t\t\t\t\treturn selection.tridentSel.moveToBookmark(bookmark);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (setEndPoint(true) \046\046 setEndPoint()) {\n
\t\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (bookmark.id) {\n
\t\t\t\t\t// Restore start/end points\n
\t\t\t\t\trestoreEndPoint(\'start\');\n
\t\t\t\t\trestoreEndPoint(\'end\');\n
\n
\t\t\t\t\tif (startContainer) {\n
\t\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\t\trng.setStart(addBogus(startContainer), startOffset);\n
\t\t\t\t\t\trng.setEnd(addBogus(endContainer), endOffset);\n
\t\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (bookmark.name) {\n
\t\t\t\t\tselection.select(dom.select(bookmark.name)[bookmark.index]);\n
\t\t\t\t} else if (bookmark.rng) {\n
\t\t\t\t\tselection.setRng(bookmark.rng);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t};\n
\t}\n
\n
\t/**\n
\t * Returns true/false if the specified node is a bookmark node or not.\n
\t *\n
\t * @static\n
\t * @method isBookmarkNode\n
\t * @param {DOMNode} node DOM Node to check if it\'s a bookmark node or not.\n
\t * @return {Boolean} true/false if the node is a bookmark node or not.\n
\t */\n
\tBookmarkManager.isBookmarkNode = function(node) {\n
\t\treturn node \046\046 node.tagName === \'SPAN\' \046\046 node.getAttribute(\'data-mce-type\') === \'bookmark\';\n
\t};\n
\n
\treturn BookmarkManager;\n
});\n
\n
// Included from: js/tinymce/classes/dom/Selection.js\n
\n
/**\n
 * Selection.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles text and control selection it\'s an crossbrowser utility class.\n
 * Consult the TinyMCE Wiki API for more details and examples on how to use this class.\n
 *\n
 * @class tinymce.dom.Selection\n
 * @example\n
 * // Getting the currently selected node for the active editor\n
 * alert(tinymce.activeEditor.selection.getNode().nodeName);\n
 */\n
define("tinymce/dom/Selection", [\n
\t"tinymce/dom/TreeWalker",\n
\t"tinymce/dom/TridentSelection",\n
\t"tinymce/dom/ControlSelection",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/dom/BookmarkManager",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools"\n
], function(TreeWalker, TridentSelection, ControlSelection, RangeUtils, BookmarkManager, Env, Tools) {\n
\tvar each = Tools.each, trim = Tools.trim;\n
\tvar isIE = Env.ie;\n
\n
\t/**\n
\t * Constructs a new selection instance.\n
\t *\n
\t * @constructor\n
\t * @method Selection\n
\t * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.\n
\t * @param {Window} win Window to bind the selection object to.\n
\t * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.\n
\t */\n
\tfunction Selection(dom, win, serializer, editor) {\n
\t\tvar self = this;\n
\n
\t\tself.dom = dom;\n
\t\tself.win = win;\n
\t\tself.serializer = serializer;\n
\t\tself.editor = editor;\n
\t\tself.bookmarkManager = new BookmarkManager(self);\n
\t\tself.controlSelection = new ControlSelection(self, editor);\n
\n
\t\t// No W3C Range support\n
\t\tif (!self.win.getSelection) {\n
\t\t\tself.tridentSel = new TridentSelection(self);\n
\t\t}\n
\t}\n
\n
\tSelection.prototype = {\n
\t\t/**\n
\t\t * Move the selection cursor range to the specified node and offset.\n
\t\t * If there is no node specified it will move it to the first suitable location within the body.\n
\t\t *\n
\t\t * @method setCursorLocation\n
\t\t * @param {Node} node Optional node to put the cursor in.\n
\t\t * @param {Number} offset Optional offset from the start of the node to put the cursor at.\n
\t\t */\n
\t\tsetCursorLocation: function(node, offset) {\n
\t\t\tvar self = this, rng = self.dom.createRng();\n
\n
\t\t\tif (!node) {\n
\t\t\t\tself._moveEndPoint(rng, self.editor.getBody(), true);\n
\t\t\t\tself.setRng(rng);\n
\t\t\t} else {\n
\t\t\t\trng.setStart(node, offset);\n
\t\t\t\trng.setEnd(node, offset);\n
\t\t\t\tself.setRng(rng);\n
\t\t\t\tself.collapse(false);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the selected contents using the DOM serializer passed in to this class.\n
\t\t *\n
\t\t * @method getContent\n
\t\t * @param {Object} s Optional settings class with for example output format text or html.\n
\t\t * @return {String} Selected contents in for example HTML format.\n
\t\t * @example\n
\t\t * // Alerts the currently selected contents\n
\t\t * alert(tinymce.activeEditor.selection.getContent());\n
\t\t *\n
\t\t * // Alerts the currently selected contents as plain text\n
\t\t * alert(tinymce.activeEditor.selection.getContent({format: \'text\'}));\n
\t\t */\n
\t\tgetContent: function(args) {\n
\t\t\tvar self = this, rng = self.getRng(), tmpElm = self.dom.create("body");\n
\t\t\tvar se = self.getSel(), whiteSpaceBefore, whiteSpaceAfter, fragment;\n
\n
\t\t\targs = args || {};\n
\t\t\twhiteSpaceBefore = whiteSpaceAfter = \'\';\n
\t\t\targs.get = true;\n
\t\t\targs.format = args.format || \'html\';\n
\t\t\targs.selection = true;\n
\t\t\tself.editor.fire(\'BeforeGetContent\', args);\n
\n
\t\t\tif (args.format == \'text\') {\n
\t\t\t\treturn self.isCollapsed() ? \'\' : (rng.text || (se.toString ? se.toString() : \'\'));\n
\t\t\t}\n
\n
\t\t\tif (rng.cloneContents) {\n
\t\t\t\tfragment = rng.cloneContents();\n
\n
\t\t\t\tif (fragment) {\n
\t\t\t\t\ttmpElm.appendChild(fragment);\n
\t\t\t\t}\n
\t\t\t} else if (rng.item !== undefined || rng.htmlText !== undefined) {\n
\t\t\t\t// IE will produce invalid markup if elements are present that\n
\t\t\t\t// it doesn\'t understand like custom elements or HTML5 elements.\n
\t\t\t\t// Adding a BR in front of the contents and then remoiving it seems to fix it though.\n
\t\t\t\ttmpElm.innerHTML = \'\074br\076\' + (rng.item ? rng.item(0).outerHTML : rng.htmlText);\n
\t\t\t\ttmpElm.removeChild(tmpElm.firstChild);\n
\t\t\t} else {\n
\t\t\t\ttmpElm.innerHTML = rng.toString();\n
\t\t\t}\n
\n
\t\t\t// Keep whitespace before and after\n
\t\t\tif (/^\\s/.test(tmpElm.innerHTML)) {\n
\t\t\t\twhiteSpaceBefore = \' \';\n
\t\t\t}\n
\n
\t\t\tif (/\\s+$/.test(tmpElm.innerHTML)) {\n
\t\t\t\twhiteSpaceAfter = \' \';\n
\t\t\t}\n
\n
\t\t\targs.getInner = true;\n
\n
\t\t\targs.content = self.isCollapsed() ? \'\' : whiteSpaceBefore + self.serializer.serialize(tmpElm, args) + whiteSpaceAfter;\n
\t\t\tself.editor.fire(\'GetContent\', args);\n
\n
\t\t\treturn args.content;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the current selection to the specified content. If any contents is selected it will be replaced\n
\t\t * with the contents passed in to this function. If there is no selection the contents will be inserted\n
\t\t * where the caret is placed in the editor/page.\n
\t\t *\n
\t\t * @method setContent\n
\t\t * @param {String} content HTML contents to set could also be other formats depending on settings.\n
\t\t * @param {Object} args Optional settings object with for example data format.\n
\t\t * @example\n
\t\t * // Inserts some HTML contents at the current selection\n
\t\t * tinymce.activeEditor.selection.setContent(\'\074strong\076Some contents\074/strong\076\');\n
\t\t */\n
\t\tsetContent: function(co</string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAc=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="7" aka="AAAAAAAAAAc=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

ntent, args) {\n
\t\t\tvar self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;\n
\n
\t\t\targs = args || {format: \'html\'};\n
\t\t\targs.set = true;\n
\t\t\targs.selection = true;\n
\t\t\tcontent = args.content = content;\n
\n
\t\t\t// Dispatch before set content event\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.editor.fire(\'BeforeSetContent\', args);\n
\t\t\t}\n
\n
\t\t\tcontent = args.content;\n
\n
\t\t\tif (rng.insertNode) {\n
\t\t\t\t// Make caret marker since insertNode places the caret in the beginning of text after insert\n
\t\t\t\tcontent += \'<span id="__caret">_</span>\';\n
\n
\t\t\t\t// Delete and insert new node\n
\t\t\t\tif (rng.startContainer == doc && rng.endContainer == doc) {\n
\t\t\t\t\t// WebKit will fail if the body is empty since the range is then invalid and it can\'t insert contents\n
\t\t\t\t\tdoc.body.innerHTML = content;\n
\t\t\t\t} else {\n
\t\t\t\t\trng.deleteContents();\n
\n
\t\t\t\t\tif (doc.body.childNodes.length === 0) {\n
\t\t\t\t\t\tdoc.body.innerHTML = content;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// createContextualFragment doesn\'t exists in IE 9 DOMRanges\n
\t\t\t\t\t\tif (rng.createContextualFragment) {\n
\t\t\t\t\t\t\trng.insertNode(rng.createContextualFragment(content));\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Fake createContextualFragment call in IE 9\n
\t\t\t\t\t\t\tfrag = doc.createDocumentFragment();\n
\t\t\t\t\t\t\ttemp = doc.createElement(\'div\');\n
\n
\t\t\t\t\t\t\tfrag.appendChild(temp);\n
\t\t\t\t\t\t\ttemp.outerHTML = content;\n
\n
\t\t\t\t\t\t\trng.insertNode(frag);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Move to caret marker\n
\t\t\t\tcaretNode = self.dom.get(\'__caret\');\n
\n
\t\t\t\t// Make sure we wrap it compleatly, Opera fails with a simple select call\n
\t\t\t\trng = doc.createRange();\n
\t\t\t\trng.setStartBefore(caretNode);\n
\t\t\t\trng.setEndBefore(caretNode);\n
\t\t\t\tself.setRng(rng);\n
\n
\t\t\t\t// Remove the caret position\n
\t\t\t\tself.dom.remove(\'__caret\');\n
\n
\t\t\t\ttry {\n
\t\t\t\t\tself.setRng(rng);\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Might fail on Opera for some odd reason\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\t// Delete content and get caret text selection\n
\t\t\t\t\tdoc.execCommand(\'Delete\', false, null);\n
\t\t\t\t\trng = self.getRng();\n
\t\t\t\t}\n
\n
\t\t\t\t// Explorer removes spaces from the beginning of pasted contents\n
\t\t\t\tif (/^\\s+/.test(content)) {\n
\t\t\t\t\trng.pasteHTML(\'<span id="__mce_tmp">_</span>\' + content);\n
\t\t\t\t\tself.dom.remove(\'__mce_tmp\');\n
\t\t\t\t} else {\n
\t\t\t\t\trng.pasteHTML(content);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Dispatch set content event\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.editor.fire(\'SetContent\', args);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the start element of a selection range. If the start is in a text\n
\t\t * node the parent element will be returned.\n
\t\t *\n
\t\t * @method getStart\n
\t\t * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.\n
\t\t * @return {Element} Start element of selection range.\n
\t\t */\n
\t\tgetStart: function(real) {\n
\t\t\tvar self = this, rng = self.getRng(), startElement, parentElement, checkRng, node;\n
\n
\t\t\tif (rng.duplicate || rng.item) {\n
\t\t\t\t// Control selection, return first item\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\treturn rng.item(0);\n
\t\t\t\t}\n
\n
\t\t\t\t// Get start element\n
\t\t\t\tcheckRng = rng.duplicate();\n
\t\t\t\tcheckRng.collapse(1);\n
\t\t\t\tstartElement = checkRng.parentElement();\n
\t\t\t\tif (startElement.ownerDocument !== self.dom.doc) {\n
\t\t\t\t\tstartElement = self.dom.getRoot();\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if range parent is inside the start element, then return the inner parent element\n
\t\t\t\t// This will fix issues when a single element is selected, IE would otherwise return the wrong start element\n
\t\t\t\tparentElement = node = rng.parentElement();\n
\t\t\t\twhile ((node = node.parentNode)) {\n
\t\t\t\t\tif (node == startElement) {\n
\t\t\t\t\t\tstartElement = parentElement;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn startElement;\n
\t\t\t}\n
\n
\t\t\tstartElement = rng.startContainer;\n
\n
\t\t\tif (startElement.nodeType == 1 && startElement.hasChildNodes()) {\n
\t\t\t\tif (!real || !rng.collapsed) {\n
\t\t\t\t\tstartElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (startElement && startElement.nodeType == 3) {\n
\t\t\t\treturn startElement.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn startElement;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the end element of a selection range. If the end is in a text\n
\t\t * node the parent element will be returned.\n
\t\t *\n
\t\t * @method getEnd\n
\t\t * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.\n
\t\t * @return {Element} End element of selection range.\n
\t\t */\n
\t\tgetEnd: function(real) {\n
\t\t\tvar self = this, rng = self.getRng(), endElement, endOffset;\n
\n
\t\t\tif (rng.duplicate || rng.item) {\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\treturn rng.item(0);\n
\t\t\t\t}\n
\n
\t\t\t\trng = rng.duplicate();\n
\t\t\t\trng.collapse(0);\n
\t\t\t\tendElement = rng.parentElement();\n
\t\t\t\tif (endElement.ownerDocument !== self.dom.doc) {\n
\t\t\t\t\tendElement = self.dom.getRoot();\n
\t\t\t\t}\n
\n
\t\t\t\tif (endElement && endElement.nodeName == \'BODY\') {\n
\t\t\t\t\treturn endElement.lastChild || endElement;\n
\t\t\t\t}\n
\n
\t\t\t\treturn endElement;\n
\t\t\t}\n
\n
\t\t\tendElement = rng.endContainer;\n
\t\t\tendOffset = rng.endOffset;\n
\n
\t\t\tif (endElement.nodeType == 1 && endElement.hasChildNodes()) {\n
\t\t\t\tif (!real || !rng.collapsed) {\n
\t\t\t\t\tendElement = endElement.childNodes[endOffset > 0 ? endOffset - 1 : endOffset];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (endElement && endElement.nodeType == 3) {\n
\t\t\t\treturn endElement.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn endElement;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a bookmark location for the current selection. This bookmark object\n
\t\t * can then be used to restore the selection after some content modification to the document.\n
\t\t *\n
\t\t * @method getBookmark\n
\t\t * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.\n
\t\t * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.\n
\t\t * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.\n
\t\t * @example\n
\t\t * // Stores a bookmark of the current selection\n
\t\t * var bm = tinymce.activeEditor.selection.getBookmark();\n
\t\t *\n
\t\t * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + \'Some new content\');\n
\t\t *\n
\t\t * // Restore the selection bookmark\n
\t\t * tinymce.activeEditor.selection.moveToBookmark(bm);\n
\t\t */\n
\t\tgetBookmark: function(type, normalized) {\n
\t\t\treturn this.bookmarkManager.getBookmark(type, normalized);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Restores the selection to the specified bookmark.\n
\t\t *\n
\t\t * @method moveToBookmark\n
\t\t * @param {Object} bookmark Bookmark to restore selection from.\n
\t\t * @return {Boolean} true/false if it was successful or not.\n
\t\t * @example\n
\t\t * // Stores a bookmark of the current selection\n
\t\t * var bm = tinymce.activeEditor.selection.getBookmark();\n
\t\t *\n
\t\t * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + \'Some new content\');\n
\t\t *\n
\t\t * // Restore the selection bookmark\n
\t\t * tinymce.activeEditor.selection.moveToBookmark(bm);\n
\t\t */\n
\t\tmoveToBookmark: function(bookmark) {\n
\t\t\treturn this.bookmarkManager.moveToBookmark(bookmark);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Selects the specified element. This will place the start and end of the selection range around the element.\n
\t\t *\n
\t\t * @method select\n
\t\t * @param {Element} node HMTL DOM element to select.\n
\t\t * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.\n
\t\t * @return {Element} Selected element the same element as the one that got passed in.\n
\t\t * @example\n
\t\t * // Select the first paragraph in the active editor\n
\t\t * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select(\'p\')[0]);\n
\t\t */\n
\t\tselect: function(node, content) {\n
\t\t\tvar self = this, dom = self.dom, rng = dom.createRng(), idx;\n
\n
\t\t\t// Clear stored range set by FocusManager\n
\t\t\tself.lastFocusBookmark = null;\n
\n
\t\t\tif (node) {\n
\t\t\t\tif (!content && self.controlSelection.controlSelect(node)) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tidx = dom.nodeIndex(node);\n
\t\t\t\trng.setStart(node.parentNode, idx);\n
\t\t\t\trng.setEnd(node.parentNode, idx + 1);\n
\n
\t\t\t\t// Find first/last text node or BR element\n
\t\t\t\tif (content) {\n
\t\t\t\t\tself._moveEndPoint(rng, node, true);\n
\t\t\t\t\tself._moveEndPoint(rng, node);\n
\t\t\t\t}\n
\n
\t\t\t\tself.setRng(rng);\n
\t\t\t}\n
\n
\t\t\treturn node;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the selection range is collapsed or not. Collapsed means if it\'s a caret or a larger selection.\n
\t\t *\n
\t\t * @method isCollapsed\n
\t\t * @return {Boolean} true/false state if the selection range is collapsed or not.\n
\t\t * Collapsed means if it\'s a caret or a larger selection.\n
\t\t */\n
\t\tisCollapsed: function() {\n
\t\t\tvar self = this, rng = self.getRng(), sel = self.getSel();\n
\n
\t\t\tif (!rng || rng.item) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tif (rng.compareEndPoints) {\n
\t\t\t\treturn rng.compareEndPoints(\'StartToEnd\', rng) === 0;\n
\t\t\t}\n
\n
\t\t\treturn !sel || rng.collapsed;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Collapse the selection to start or end of range.\n
\t\t *\n
\t\t * @method collapse\n
\t\t * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to start.\n
\t\t */\n
\t\tcollapse: function(toStart) {\n
\t\t\tvar self = this, rng = self.getRng(), node;\n
\n
\t\t\t// Control range on IE\n
\t\t\tif (rng.item) {\n
\t\t\t\tnode = rng.item(0);\n
\t\t\t\trng = self.win.document.body.createTextRange();\n
\t\t\t\trng.moveToElementText(node);\n
\t\t\t}\n
\n
\t\t\trng.collapse(!!toStart);\n
\t\t\tself.setRng(rng);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the browsers internal selection object.\n
\t\t *\n
\t\t * @method getSel\n
\t\t * @return {Selection} Internal browser selection object.\n
\t\t */\n
\t\tgetSel: function() {\n
\t\t\tvar win = this.win;\n
\n
\t\t\treturn win.getSelection ? win.getSelection() : win.document.selection;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the browsers internal range object.\n
\t\t *\n
\t\t * @method getRng\n
\t\t * @param {Boolean} w3c Forces a compatible W3C range on IE.\n
\t\t * @return {Range} Internal browser range object.\n
\t\t * @see http://www.quirksmode.org/dom/range_intro.html\n
\t\t * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/\n
\t\t */\n
\t\tgetRng: function(w3c) {\n
\t\t\tvar self = this, selection, rng, elm, doc = self.win.document, ieRng;\n
\n
\t\t\tfunction tryCompareBoundaryPoints(how, sourceRange, destinationRange) {\n
\t\t\t\ttry {\n
\t\t\t\t\treturn sourceRange.compareBoundaryPoints(how, destinationRange);\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Gecko throws wrong document exception if the range points\n
\t\t\t\t\t// to nodes that where removed from the dom #6690\n
\t\t\t\t\t// Browsers should mutate existing DOMRange instances so that they always point\n
\t\t\t\t\t// to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink\n
\t\t\t\t\t// For performance reasons just return -1\n
\t\t\t\t\treturn -1;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Use last rng passed from FocusManager if it\'s available this enables\n
\t\t\t// calls to editor.selection.getStart() to work when caret focus is lost on IE\n
\t\t\tif (!w3c && self.lastFocusBookmark) {\n
\t\t\t\tvar bookmark = self.lastFocusBookmark;\n
\n
\t\t\t\t// Convert bookmark to range IE 11 fix\n
\t\t\t\tif (bookmark.startContainer) {\n
\t\t\t\t\trng = doc.createRange();\n
\t\t\t\t\trng.setStart(bookmark.startContainer, bookmark.startOffset);\n
\t\t\t\t\trng.setEnd(bookmark.endContainer, bookmark.endOffset);\n
\t\t\t\t} else {\n
\t\t\t\t\trng = bookmark;\n
\t\t\t\t}\n
\n
\t\t\t\treturn rng;\n
\t\t\t}\n
\n
\t\t\t// Found tridentSel object then we need to use that one\n
\t\t\tif (w3c && self.tridentSel) {\n
\t\t\t\treturn self.tridentSel.getRangeAt(0);\n
\t\t\t}\n
\n
\t\t\ttry {\n
\t\t\t\tif ((selection = self.getSel())) {\n
\t\t\t\t\tif (selection.rangeCount > 0) {\n
\t\t\t\t\t\trng = selection.getRangeAt(0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng = selection.createRange ? selection.createRange() : doc.createRange();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} catch (ex) {\n
\t\t\t\t// IE throws unspecified error here if TinyMCE is placed in a frame/iframe\n
\t\t\t}\n
\n
\t\t\t// We have W3C ranges and it\'s IE then fake control selection since IE9 doesn\'t handle that correctly yet\n
\t\t\t// IE 11 doesn\'t support the selection object so we check for that as well\n
\t\t\tif (isIE && rng && rng.setStart && doc.selection) {\n
\t\t\t\ttry {\n
\t\t\t\t\t// IE will sometimes throw an exception here\n
\t\t\t\t\tieRng = doc.selection.createRange();\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Ignore\n
\t\t\t\t}\n
\n
\t\t\t\tif (ieRng && ieRng.item) {\n
\t\t\t\t\telm = ieRng.item(0);\n
\t\t\t\t\trng = doc.createRange();\n
\t\t\t\t\trng.setStartBefore(elm);\n
\t\t\t\t\trng.setEndAfter(elm);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// No range found then create an empty one\n
\t\t\t// This can occur when the editor is placed in a hidden container element on Gecko\n
\t\t\t// Or on IE when there was an exception\n
\t\t\tif (!rng) {\n
\t\t\t\trng = doc.createRange ? doc.createRange() : doc.body.createTextRange();\n
\t\t\t}\n
\n
\t\t\t// If range is at start of document then move it to start of body\n
\t\t\tif (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {\n
\t\t\t\telm = self.dom.getRoot();\n
\t\t\t\trng.setStart(elm, 0);\n
\t\t\t\trng.setEnd(elm, 0);\n
\t\t\t}\n
\n
\t\t\tif (self.selectedRange && self.explicitRange) {\n
\t\t\t\tif (tryCompareBoundaryPoints(rng.START_TO_START, rng, self.selectedRange) === 0 &&\n
\t\t\t\t\ttryCompareBoundaryPoints(rng.END_TO_END, rng, self.selectedRange) === 0) {\n
\t\t\t\t\t// Safari, Opera and Chrome only ever select text which causes the range to change.\n
\t\t\t\t\t// This lets us use the originally set range if the selection hasn\'t been changed by the user.\n
\t\t\t\t\trng = self.explicitRange;\n
\t\t\t\t} else {\n
\t\t\t\t\tself.selectedRange = null;\n
\t\t\t\t\tself.explicitRange = null;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn rng;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Changes the selection to the specified DOM range.\n
\t\t *\n
\t\t * @method setRng\n
\t\t * @param {Range} rng Range to select.\n
\t\t */\n
\t\tsetRng: function(rng, forward) {\n
\t\t\tvar self = this, sel, node;\n
\n
\t\t\tif (!rng) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Is IE specific range\n
\t\t\tif (rng.select) {\n
\t\t\t\ttry {\n
\t\t\t\t\trng.select();\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Needed for some odd IE bug #1843306\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!self.tridentSel) {\n
\t\t\t\tsel = self.getSel();\n
\n
\t\t\t\tif (sel) {\n
\t\t\t\t\tself.explicitRange = rng;\n
\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\tsel.removeAllRanges();\n
\t\t\t\t\t\tsel.addRange(rng);\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// IE might throw errors here if the editor is within a hidden container and selection is changed\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Forward is set to false and we have an extend function\n
\t\t\t\t\tif (forward === false && sel.extend) {\n
\t\t\t\t\t\tsel.collapse(rng.endContainer, rng.endOffset);\n
\t\t\t\t\t\tsel.extend(rng.startContainer, rng.startOffset);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// adding range isn\'t always successful so we need to check range count otherwise an exception can occur\n
\t\t\t\t\tself.selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n
\t\t\t\t}\n
\n
\t\t\t\t// WebKit egde case selecting images works better using setBaseAndExtent\n
\t\t\t\tif (!rng.collapsed && rng.startContainer == rng.endContainer && sel.setBaseAndExtent && !Env.ie) {\n
\t\t\t\t\tif (rng.endOffset - rng.startOffset < 2) {\n
\t\t\t\t\t\tif (rng.startContainer.hasChildNodes()) {\n
\t\t\t\t\t\t\tnode = rng.startContainer.childNodes[rng.startOffset];\n
\t\t\t\t\t\t\tif (node && node.tagName == \'IMG\') {\n
\t\t\t\t\t\t\t\tself.getSel().setBaseAndExtent(node, 0, node, 1);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Is W3C Range fake range on IE\n
\t\t\t\tif (rng.cloneRange) {\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\tself.tridentSel.addRange(rng);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t//IE9 throws an error here if called before selection is placed in the editor\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the current selection to the specified DOM element.\n
\t\t *\n
\t\t * @method setNode\n
\t\t * @param {Element} elm Element to set as the contents of the selection.\n
\t\t * @return {Element} Returns the element that got passed in.\n
\t\t * @example\n
\t\t * // Inserts a DOM node at current selection/caret location\n
\t\t * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create(\'img\', {src: \'some.gif\', title: \'some title\'}));\n
\t\t */\n
\t\tsetNode: function(elm) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.setContent(self.dom.getOuterHTML(elm));\n
\n
\t\t\treturn elm;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the currently selected element or the common ancestor element for both start and end of the selection.\n
\t\t *\n
\t\t * @method getNode\n
\t\t * @return {Element} Currently selected element or common ancestor element.\n
\t\t * @example\n
\t\t * // Alerts the currently selected elements node name\n
\t\t * alert(tinymce.activeEditor.selection.getNode().nodeName);\n
\t\t */\n
\t\tgetNode: function() {\n
\t\t\tvar self = this, rng = self.getRng(), elm;\n
\t\t\tvar startContainer = rng.startContainer, endContainer = rng.endContainer;\n
\t\t\tvar startOffset = rng.startOffset, endOffset = rng.endOffset, root = self.dom.getRoot();\n
\n
\t\t\tfunction skipEmptyTextNodes(node, forwards) {\n
\t\t\t\tvar orig = node;\n
\n
\t\t\t\twhile (node && node.nodeType === 3 && node.length === 0) {\n
\t\t\t\t\tnode = forwards ? node.nextSibling : node.previousSibling;\n
\t\t\t\t}\n
\n
\t\t\t\treturn node || orig;\n
\t\t\t}\n
\n
\t\t\t// Range maybe lost after the editor is made visible again\n
\t\t\tif (!rng) {\n
\t\t\t\treturn root;\n
\t\t\t}\n
\n
\t\t\tif (rng.setStart) {\n
\t\t\t\telm = rng.commonAncestorContainer;\n
\n
\t\t\t\t// Handle selection a image or other control like element such as anchors\n
\t\t\t\tif (!rng.collapsed) {\n
\t\t\t\t\tif (startContainer == endContainer) {\n
\t\t\t\t\t\tif (endOffset - startOffset < 2) {\n
\t\t\t\t\t\t\tif (startContainer.hasChildNodes()) {\n
\t\t\t\t\t\t\t\telm = startContainer.childNodes[startOffset];\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// If the anchor node is a element instead of a text node then return this element\n
\t\t\t\t\t//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)\n
\t\t\t\t\t//\treturn sel.anchorNode.childNodes[sel.anchorOffset];\n
\n
\t\t\t\t\t// Handle cases where the selection is immediately wrapped around a node and return that node instead of it\'s parent.\n
\t\t\t\t\t// This happens when you double click an underlined word in FireFox.\n
\t\t\t\t\tif (startContainer.nodeType === 3 && endContainer.nodeType === 3) {\n
\t\t\t\t\t\tif (startContainer.length === startOffset) {\n
\t\t\t\t\t\t\tstartContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tstartContainer = startContainer.parentNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (endOffset === 0) {\n
\t\t\t\t\t\t\tendContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tendContainer = endContainer.parentNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (startContainer && startContainer === endContainer) {\n
\t\t\t\t\t\t\treturn startContainer;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (elm && elm.nodeType == 3) {\n
\t\t\t\t\treturn elm.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\treturn elm;\n
\t\t\t}\n
\n
\t\t\telm = rng.item ? rng.item(0) : rng.parentElement();\n
\n
\t\t\t// IE 7 might return elements outside the iframe\n
\t\t\tif (elm.ownerDocument !== self.win.document) {\n
\t\t\t\telm = root;\n
\t\t\t}\n
\n
\t\t\treturn elm;\n
\t\t},\n
\n
\t\tgetSelectedBlocks: function(startElm, endElm) {\n
\t\t\tvar self = this, dom = self.dom, node, root, selectedBlocks = [];\n
\n
\t\t\troot = dom.getRoot();\n
\t\t\tstartElm = dom.getParent(startElm || self.getStart(), dom.isBlock);\n
\t\t\tendElm = dom.getParent(endElm || self.getEnd(), dom.isBlock);\n
\n
\t\t\tif (startElm && startElm != root) {\n
\t\t\t\tselectedBlocks.push(startElm);\n
\t\t\t}\n
\n
\t\t\tif (startElm && endElm && startElm != endElm) {\n
\t\t\t\tnode = startElm;\n
\n
\t\t\t\tvar walker = new TreeWalker(startElm, root);\n
\t\t\t\twhile ((node = walker.next()) && node != endElm) {\n
\t\t\t\t\tif (dom.isBlock(node)) {\n
\t\t\t\t\t\tselectedBlocks.push(node);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (endElm && startElm != endElm && endElm != root) {\n
\t\t\t\tselectedBlocks.push(endElm);\n
\t\t\t}\n
\n
\t\t\treturn selectedBlocks;\n
\t\t},\n
\n
\t\tisForward: function() {\n
\t\t\tvar dom = this.dom, sel = this.getSel(), anchorRange, focusRange;\n
\n
\t\t\t// No support for selection direction then always return true\n
\t\t\tif (!sel || !sel.anchorNode || !sel.focusNode) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tanchorRange = dom.createRng();\n
\t\t\tanchorRange.setStart(sel.anchorNode, sel.anchorOffset);\n
\t\t\tanchorRange.collapse(true);\n
\n
\t\t\tfocusRange = dom.createRng();\n
\t\t\tfocusRange.setStart(sel.focusNode, sel.focusOffset);\n
\t\t\tfocusRange.collapse(true);\n
\n
\t\t\treturn anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n
\t\t},\n
\n
\t\tnormalize: function() {\n
\t\t\tvar self = this, rng = self.getRng();\n
\n
\t\t\tif (Env.range && new RangeUtils(self.dom).normalize(rng)) {\n
\t\t\t\tself.setRng(rng, self.isForward());\n
\t\t\t}\n
\n
\t\t\treturn rng;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes callback when the current selection starts/stops matching the specified selector. The current\n
\t\t * state will be passed to the callback as it\'s first argument.\n
\t\t *\n
\t\t * @method selectorChanged\n
\t\t * @param {String} selector CSS selector to check for.\n
\t\t * @param {function} callback Callback with state and args when the selector is matches or not.\n
\t\t */\n
\t\tselectorChanged: function(selector, callback) {\n
\t\t\tvar self = this, currentSelectors;\n
\n
\t\t\tif (!self.selectorChangedData) {\n
\t\t\t\tself.selectorChangedData = {};\n
\t\t\t\tcurrentSelectors = {};\n
\n
\t\t\t\tself.editor.on(\'NodeChange\', function(e) {\n
\t\t\t\t\tvar node = e.element, dom = self.dom, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};\n
\n
\t\t\t\t\t// Check for new matching selectors\n
\t\t\t\t\teach(self.selectorChangedData, function(callbacks, selector) {\n
\t\t\t\t\t\teach(parents, function(node) {\n
\t\t\t\t\t\t\tif (dom.is(node, selector)) {\n
\t\t\t\t\t\t\t\tif (!currentSelectors[selector]) {\n
\t\t\t\t\t\t\t\t\t// Execute callbacks\n
\t\t\t\t\t\t\t\t\teach(callbacks, function(callback) {\n
\t\t\t\t\t\t\t\t\t\tcallback(true, {node: node, selector: selector, parents: parents});\n
\t\t\t\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t\t\t\tcurrentSelectors[selector] = callbacks;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tmatchedSelectors[selector] = callbacks;\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Check if current selectors still match\n
\t\t\t\t\teach(currentSelectors, function(callbacks, selector) {\n
\t\t\t\t\t\tif (!matchedSelectors[selector]) {\n
\t\t\t\t\t\t\tdelete currentSelectors[selector];\n
\n
\t\t\t\t\t\t\teach(callbacks, function(callback) {\n
\t\t\t\t\t\t\t\tcallback(false, {node: node, selector: selector, parents: parents});\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Add selector listeners\n
\t\t\tif (!self.selectorChangedData[selector]) {\n
\t\t\t\tself.selectorChangedData[selector] = [];\n
\t\t\t}\n
\n
\t\t\tself.selectorChangedData[selector].push(callback);\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\tgetScrollContainer: function() {\n
\t\t\tvar scrollContainer, node = this.dom.getRoot();\n
\n
\t\t\twhile (node && node.nodeName != \'BODY\') {\n
\t\t\t\tif (node.scrollHeight > node.clientHeight) {\n
\t\t\t\t\tscrollContainer = node;\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tnode = node.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn scrollContainer;\n
\t\t},\n
\n
\t\tscrollIntoView: function(elm) {\n
\t\t\tvar y, viewPort, self = this, dom = self.dom, root = dom.getRoot(), viewPortY, viewPortH;\n
\n
\t\t\tfunction getPos(elm) {\n
\t\t\t\tvar x = 0, y = 0;\n
\n
\t\t\t\tvar offsetParent = elm;\n
\t\t\t\twhile (offsetParent && offsetParent.nodeType) {\n
\t\t\t\t\tx += offsetParent.offsetLeft || 0;\n
\t\t\t\t\ty += offsetParent.offsetTop || 0;\n
\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n
\t\t\t\t}\n
\n
\t\t\t\treturn {x: x, y: y};\n
\t\t\t}\n
\n
\t\t\tif (root.nodeName != \'BODY\') {\n
\t\t\t\tvar scrollContainer = self.getScrollContainer();\n
\t\t\t\tif (scrollContainer) {\n
\t\t\t\t\ty = getPos(elm).y - getPos(scrollContainer).y;\n
\t\t\t\t\tviewPortH = scrollContainer.clientHeight;\n
\t\t\t\t\tviewPortY = scrollContainer.scrollTop;\n
\t\t\t\t\tif (y < viewPortY || y + 25 > viewPortY + viewPortH) {\n
\t\t\t\t\t\tscrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tviewPort = dom.getViewPort(self.editor.getWin());\n
\t\t\ty = dom.getPos(elm).y;\n
\t\t\tviewPortY = viewPort.y;\n
\t\t\tviewPortH = viewPort.h;\n
\t\t\tif (y < viewPort.y || y + 25 > viewPortY + viewPortH) {\n
\t\t\t\tself.editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);\n
\t\t\t}\n
\t\t},\n
\n
\t\tplaceCaretAt: function(clientX, clientY) {\n
\t\t\tvar doc = this.editor.getDoc(), rng, point;\n
\n
\t\t\tif (doc.caretPositionFromPoint) {\n
\t\t\t\tpoint = doc.caretPositionFromPoint(clientX, clientY);\n
\t\t\t\trng = doc.createRange();\n
\t\t\t\trng.setStart(point.offsetNode, point.offset);\n
\t\t\t\trng.collapse(true);\n
\t\t\t} else if (doc.caretRangeFromPoint) {\n
\t\t\t\trng = doc.caretRangeFromPoint(clientX, clientY);\n
\t\t\t} else if (doc.body.createTextRange) {\n
\t\t\t\trng = doc.body.createTextRange();\n
\n
\t\t\t\ttry {\n
\t\t\t\t\trng.moveToPoint(clientX, clientY);\n
\t\t\t\t\trng.collapse(true);\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\trng.collapse(clientY < doc.body.clientHeight);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tthis.setRng(rng);\n
\t\t},\n
\n
\t\t_moveEndPoint: function(rng, node, start) {\n
\t\t\tvar root = node, walker = new TreeWalker(node, root);\n
\t\t\tvar nonEmptyElementsMap = this.dom.schema.getNonEmptyElements();\n
\n
\t\t\tdo {\n
\t\t\t\t// Text node\n
\t\t\t\tif (node.nodeType == 3 && trim(node.nodeValue).length !== 0) {\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\trng.setStart(node, 0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setEnd(node, node.nodeValue.length);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// BR/IMG/INPUT elements but not table cells\n
\t\t\t\tif (nonEmptyElementsMap[node.nodeName] && !/^(TD|TH)$/.test(node.nodeName)) {\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\trng.setStartBefore(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tif (node.nodeName == \'BR\') {\n
\t\t\t\t\t\t\trng.setEndBefore(node);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setEndAfter(node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Found empty text block old IE can place the selection inside those\n
\t\t\t\tif (Env.ie && Env.ie < 11 && this.dom.isBlock(node) && this.dom.isEmpty(node)) {\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\trng.setStart(node, 0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setEnd(node, 0);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t} while ((node = (start ? walker.next() : walker.prev())));\n
\n
\t\t\t// Failed to find any text node or other suitable location then move to the root of body\n
\t\t\tif (root.nodeName == \'BODY\') {\n
\t\t\t\tif (start) {\n
\t\t\t\t\trng.setStart(root, 0);\n
\t\t\t\t} else {\n
\t\t\t\t\trng.setEnd(root, root.childNodes.length);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\tdestroy: function() {\n
\t\t\tthis.win = null;\n
\t\t\tthis.controlSelection.destroy();\n
\t\t}\n
\t};\n
\n
\treturn Selection;\n
});\n
\n
// Included from: js/tinymce/classes/dom/ElementUtils.js\n
\n
/**\n
 * ElementUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Utility class for various element specific functions.\n
 *\n
 * @private\n
 */\n
define("tinymce/dom/ElementUtils", [\n
\t"tinymce/dom/BookmarkManager",\n
\t"tinymce/util/Tools"\n
], function(BookmarkManager, Tools) {\n
\tvar each = Tools.each;\n
\n
\tfunction ElementUtils(dom) {\n
\t\t/**\n
\t\t * Compares two nodes and checks if it\'s attributes and styles matches.\n
\t\t * This doesn\'t compare classes as items since their order is significant.\n
\t\t *\n
\t\t * @method compare\n
\t\t * @param {Node} node1 First node to compare with.\n
\t\t * @param {Node} node2 Second node to compare with.\n
\t\t * @return {boolean} True/false if the nodes are the same or not.\n
\t\t */\n
\t\tthis.compare = function(node1, node2) {\n
\t\t\t// Not the same name\n
\t\t\tif (node1.nodeName != node2.nodeName) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Returns all the nodes attributes excluding internal ones, styles and classes.\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Node} node Node to get attributes from.\n
\t\t\t * @return {Object} Name/value object with attributes and attribute values.\n
\t\t\t */\n
\t\t\tfunction getAttribs(node) {\n
\t\t\t\tvar attribs = {};\n
\n
\t\t\t\teach(dom.getAttribs(node), function(attr) {\n
\t\t\t\t\tvar name = attr.nodeName.toLowerCase();\n
\n
\t\t\t\t\t// Don\'t compare internal attributes or style\n
\t\t\t\t\tif (name.indexOf(\'_\') !== 0 && name !== \'style\' && name !== \'data-mce-style\') {\n
\t\t\t\t\t\tattribs[name] = dom.getAttrib(node, name);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn attribs;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Compares two objects checks if it\'s key + value exists in the other one.\n
\t\t\t *\n
\t\t\t * @private\n
\t\t\t * @param {Object} obj1 First object to compare.\n
\t\t\t * @param {Object} obj2 Second object to compare.\n
\t\t\t * @return {boolean} True/false if the objects matches or not.\n
\t\t\t */\n
\t\t\tfunction compareObjects(obj1, obj2) {\n
\t\t\t\tvar value, name;\n
\n
\t\t\t\tfor (name in obj1) {\n
\t\t\t\t\t// Obj1 has item obj2 doesn\'t have\n
\t\t\t\t\tif (obj1.hasOwnProperty(name)) {\n
\t\t\t\t\t\tvalue = obj2[name];\n
\n
\t\t\t\t\t\t// Obj2 doesn\'t have obj1 item\n
\t\t\t\t\t\tif (typeof value == "undefined") {\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Obj2 item has a different value\n
\t\t\t\t\t\tif (obj1[name] != value) {\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Delete similar value\n
\t\t\t\t\t\tdelete obj2[name];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if obj 2 has something obj 1 doesn\'t have\n
\t\t\t\tfor (name in obj2) {\n
\t\t\t\t\t// Obj2 has item obj1 doesn\'t have\n
\t\t\t\t\tif (obj2.hasOwnProperty(name)) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Attribs are not the same\n
\t\t\tif (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\t// Styles are not the same\n
\t\t\tif (!compareObjects(dom.parseStyle(dom.getAttrib(node1, \'style\')), dom.parseStyle(dom.getAttrib(node2, \'style\')))) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\treturn !BookmarkManager.isBookmarkNode(node1) && !BookmarkManager.isBookmarkNode(node2);\n
\t\t};\n
\t}\n
\n
\treturn ElementUtils;\n
});\n
\n
// Included from: js/tinymce/classes/fmt/Preview.js\n
\n
/**\n
 * Preview.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Internal class for generating previews styles for formats.\n
 *\n
 * Example:\n
 *  Preview.getCssText(editor, \'bold\');\n
 *\n
 * @class tinymce.fmt.Preview\n
 * @private\n
 */\n
define("tinymce/fmt/Preview", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar each = Tools.each;\n
\n
\tfunction getCssText(editor, format) {\n
\t\tvar name, previewElm, dom = editor.dom;\n
\t\tvar previewCss = \'\', parentFontSize, previewStyles;\n
\n
\t\tpreviewStyles = editor.settings.preview_styles;\n
\n
\t\t// No preview forced\n
\t\tif (previewStyles === false) {\n
\t\t\treturn \'\';\n
\t\t}\n
\n
\t\t// Default preview\n
\t\tif (!previewStyles) {\n
\t\t\tpreviewStyles = \'font-family font-size font-weight font-style text-decoration \' +\n
\t\t\t\t\'text-transform color background-color border border-radius outline text-shadow\';\n
\t\t}\n
\n
\t\t// Removes any variables since these can\'t be previewed\n
\t\tfunction removeVars(val) {\n
\t\t\treturn val.replace(/%(\\w+)/g, \'\');\n
\t\t}\n
\n
\t\t// Create block/inline element to use for preview\n
\t\tif (typeof format == "string") {\n
\t\t\tformat = editor.formatter.get(format);\n
\t\t\tif (!format) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tformat = format[0];\n
\t\t}\n
\n
\t\tname = format.block || format.inline || \'span\';\n
\t\tpreviewElm = dom.create(name);\n
\n
\t\t// Add format styles to preview element\n
\t\teach(format.styles, function(value, name) {\n
\t\t\tvalue = removeVars(value);\n
\n
\t\t\tif (value) {\n
\t\t\t\tdom.setStyle(previewElm, name, value);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Add attributes to preview element\n
\t\teach(format.attributes, function(value, name) {\n
\t\t\tvalue = removeVars(value);\n
\n
\t\t\tif (value) {\n
\t\t\t\tdom.setAttrib(previewElm, name, value);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Add classes to preview element\n
\t\teach(format.classes, function(value) {\n
\t\t\tvalue = removeVars(value);\n
\n
\t\t\tif (!dom.hasClass(previewElm, value)) {\n
\t\t\t\tdom.addClass(previewElm, value);\n
\t\t\t}\n
\t\t});\n
\n
\t\teditor.fire(\'PreviewFormats\');\n
\n
\t\t// Add the previewElm outside the visual area\n
\t\tdom.setStyles(previewElm, {position: \'absolute\', left: -0xFFFF});\n
\t\teditor.getBody().appendChild(previewElm);\n
\n
\t\t// Get parent container font size so we can compute px values out of em/% for older IE:s\n
\t\tparentFontSize = dom.getStyle(editor.getBody(), \'fontSize\', true);\n
\t\tparentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;\n
\n
\t\teach(previewStyles.split(\' \'), function(name) {\n
\t\t\tvar value = dom.getStyle(previewElm, name, true);\n
\n
\t\t\t// If background is transparent then check if the body has a background color we can use\n
\t\t\tif (name == \'background-color\' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n
\t\t\t\tvalue = dom.getStyle(editor.getBody(), name, true);\n
\n
\t\t\t\t// Ignore white since it\'s the default color, not the nicest fix\n
\t\t\t\t// TODO: Fix this by detecting runtime style\n
\t\t\t\tif (dom.toHex(value).toLowerCase() == \'#ffffff\') {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (name == \'color\') {\n
\t\t\t\t// Ignore black since it\'s the default color, not the nicest fix\n
\t\t\t\t// TODO: Fix this by detecting runtime style\n
\t\t\t\tif (dom.toHex(value).toLowerCase() == \'#000000\') {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Old IE won\'t calculate the font size so we need to do that manually\n
\t\t\tif (name == \'font-size\') {\n
\t\t\t\tif (/em|%$/.test(value)) {\n
\t\t\t\t\tif (parentFontSize === 0) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Convert font size from em/% to px\n
\t\t\t\t\tvalue = parseFloat(value, 10) / (/%$/.test(value) ? 100 : 1);\n
\t\t\t\t\tvalue = (value * parentFontSize) + \'px\';\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (name == "border" && value) {\n
\t\t\t\tpreviewCss += \'padding:0 2px;\';\n
\t\t\t}\n
\n
\t\t\tpreviewCss += name + \':\' + value + \';\';\n
\t\t});\n
\n
\t\teditor.fire(\'AfterPreviewFormats\');\n
\n
\t\t//previewCss += \'line-height:normal\';\n
\n
\t\tdom.remove(previewElm);\n
\n
\t\treturn previewCss;\n
\t}\n
\n
\treturn {\n
\t\tgetCssText: getCssText\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/Formatter.js\n
\n
/**\n
 * Formatter.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Text formatter engine class. This class is used to apply formats like bold, italic, font size\n
 * etc to the current selection or specific nodes. This engine was build to replace the browsers\n
 * default formatting logic for execCommand due to it\'s inconsistent and buggy behavior.\n
 *\n
 * @class tinymce.Formatter\n
 * @example\n
 *  tinymce.activeEditor.formatter.register(\'mycustomformat\', {\n
 *    inline: \'span\',\n
 *    styles: {color: \'#ff0000\'}\n
 *  });\n
 *\n
 *  tinymce.activeEditor.formatter.apply(\'mycustomformat\');\n
 */\n
define("tinymce/Formatter", [\n
\t"tinymce/dom/TreeWalker",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/dom/BookmarkManager",\n
\t"tinymce/dom/ElementUtils",\n
\t"tinymce/util/Tools",\n
\t"tinymce/fmt/Preview"\n
], function(TreeWalker, RangeUtils, BookmarkManager, ElementUtils, Tools, Preview) {\n
\t/**\n
\t * Constructs a new formatter instance.\n
\t *\n
\t * @constructor Formatter\n
\t * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.\n
\t */\n
\treturn function(ed) {\n
\t\tvar formats = {},\n
\t\t\tdom = ed.dom,\n
\t\t\tselection = ed.selection,\n
\t\t\trangeUtils = new RangeUtils(dom),\n
\t\t\tisValid = ed.schema.isValidChild,\n
\t\t\tisBlock = dom.isBlock,\n
\t\t\tforcedRootBlock = ed.settings.forced_root_block,\n
\t\t\tnodeIndex = dom.nodeIndex,\n
\t\t\tINVISIBLE_CHAR = \'\\uFEFF\',\n
\t\t\tMCE_ATTR_RE = /^(src|href|style)$/,\n
\t\t\tFALSE = false,\n
\t\t\tTRUE = true,\n
\t\t\tformatChangeData,\n
\t\t\tundef,\n
\t\t\tgetContentEditable = dom.getContentEditable,\n
\t\t\tdisableCaretContainer,\n
\t\t\tmarkCaretContainersBogus,\n
\t\t\tisBookmarkNode = BookmarkManager.isBookmarkNode;\n
\n
\t\tvar each = Tools.each,\n
\t\t\tgrep = Tools.grep,\n
\t\t\twalk = Tools.walk,\n
\t\t\textend = Tools.extend;\n
\n
\t\tfunction isTextBlock(name) {\n
\t\t\tif (name.nodeType) {\n
\t\t\t\tname = name.nodeName;\n
\t\t\t}\n
\n
\t\t\treturn !!ed.schema.getTextBlockElements()[name.toLowerCase()];\n
\t\t}\n
\n
\t\tfunction isTableCell(node) {\n
\t\t\treturn /^(TH|TD)$/.test(node.nodeName);\n
\t\t}\n
\n
\t\tfunction isInlineBlock(node) {\n
\t\t\treturn node && /^(IMG)$/.test(node.nodeName);\n
\t\t}\n
\n
\t\tfunction getParents(node, selector) {\n
\t\t\treturn dom.getParents(node, selector, dom.getRoot());\n
\t\t}\n
\n
\t\tfunction isCaretNode(node) {\n
\t\t\treturn node.nodeType === 1 && node.id === \'_mce_caret\';\n
\t\t}\n
\n
\t\tfunction defaultFormats() {\n
\t\t\tregister({\n
\t\t\t\tvaligntop: [\n
\t\t\t\t\t{selector: \'td,th\', styles: {\'verticalAlign\': \'top\'}}\n
\t\t\t\t],\n
\n
\t\t\t\tvalignmiddle: [\n
\t\t\t\t\t{selector: \'td,th\', styles: {\'verticalAlign\': \'middle\'}}\n
\t\t\t\t],\n
\n
\t\t\t\tvalignbottom: [\n
\t\t\t\t\t{selector: \'td,th\', styles: {\'verticalAlign\': \'bottom\'}}\n
\t\t\t\t],\n
\n
\t\t\t\talignleft: [\n
\t\t\t\t\t{selector: \'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li\', styles: {textAlign: \'left\'}, defaultBlock: \'div\'},\n
\t\t\t\t\t{selector: \'img,table\', collapsed: false, styles: {\'float\': \'left\'}}\n
\t\t\t\t],\n
\n
\t\t\t\taligncenter: [\n
\t\t\t\t\t{selector: \'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li\', styles: {textAlign: \'center\'}, defaultBlock: \'div\'},\n
\t\t\t\t\t{selector: \'img\', collapsed: false, styles: {display: \'block\', marginLeft: \'auto\', marginRight: \'auto\'}},\n
\t\t\t\t\t{selector: \'table\', collapsed: false, styles: {marginLeft: \'auto\', marginRight: \'auto\'}}\n
\t\t\t\t],\n
\n
\t\t\t\talignright: [\n
\t\t\t\t\t{selector: \'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li\', styles: {textAlign: \'right\'}, defaultBlock: \'div\'},\n
\t\t\t\t\t{selector: \'img,table\', collapsed: false, styles: {\'float\': \'right\'}}\n
\t\t\t\t],\n
\n
\t\t\t\talignjustify: [\n
\t\t\t\t\t{selector: \'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li\', styles: {textAlign: \'justify\'}, defaultBlock: \'div\'}\n
\t\t\t\t],\n
\n
\t\t\t\tbold: [\n
\t\t\t\t\t{inline: \'strong\', remove: \'all\'},\n
\t\t\t\t\t{inline: \'span\', styles: {fontWeight: \'bold\'}},\n
\t\t\t\t\t{inline: \'b\', remove: \'all\'}\n
\t\t\t\t],\n
\n
\t\t\t\titalic: [\n
\t\t\t\t\t{inline: \'em\', remove: \'all\'},\n
\t\t\t\t\t{inline: \'span\', styles: {fontStyle: \'italic\'}},\n
\t\t\t\t\t{inline: \'i\', remove: \'all\'}\n
\t\t\t\t],\n
\n
\t\t\t\tunderline: [\n
\t\t\t\t\t{inline: \'span\', styles: {textDecoration: \'underline\'}, exact: true},\n
\t\t\t\t\t{inline: \'u\', remove: \'all\'}\n
\t\t\t\t],\n
\n
\t\t\t\tstrikethrough: [\n
\t\t\t\t\t{inline: \'span\', styles: {textDecoration: \'line-through\'}, exact: true},\n
\t\t\t\t\t{inline: \'strike\', remove: \'all\'}\n
\t\t\t\t],\n
\n
\t\t\t\tforecolor: {inline: \'span\', styles: {color: \'%value\'}, links: true, remove_similar: true},\n
\t\t\t\thilitecolor: {inline: \'span\', styles: {backgroundColor: \'%value\'}, links: true, remove_similar: true},\n
\t\t\t\tfontname: {inline: \'span\', styles: {fontFamily: \'%value\'}},\n
\t\t\t\tfontsize: {inline: \'span\', styles: {fontSize: \'%value\'}},\n
\t\t\t\tfontsize_class: {inline: \'span\', attributes: {\'class\': \'%value\'}},\n
\t\t\t\tblockquote: {block: \'blockquote\', wrapper: 1, remove: \'all\'},\n
\t\t\t\tsubscript: {inline: \'sub\'},\n
\t\t\t\tsuperscript: {inline: \'sup\'},\n
\t\t\t\tcode: {inline: \'code\'},\n
\n
\t\t\t\tlink: {inline: \'a\', selector: \'a\', remove: \'all\', split: true, deep: true,\n
\t\t\t\t\tonmatch: function() {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t},\n
\n
\t\t\t\t\tonformat: function(elm, fmt, vars) {\n
\t\t\t\t\t\teach(vars, function(value, key) {\n
\t\t\t\t\t\t\tdom.setAttrib(elm, key, value);\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t},\n
\n
\t\t\t\tremoveformat: [\n
\t\t\t\t\t{\n
\t\t\t\t\t\tselector: \'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins\',\n
\t\t\t\t\t\tremove: \'all\',\n
\t\t\t\t\t\tsplit: true,\n
\t\t\t\t\t\texpand: false,\n
\t\t\t\t\t\tblock_expand: true,\n
\t\t\t\t\t\tdeep: true\n
\t\t\t\t\t},\n
\t\t\t\t\t{selector: \'span\', attributes: [\'style\', \'class\'], remove: \'empty\', split: true, expand: false, deep: true},\n
\t\t\t\t\t{selector: \'*\', attributes: [\'style\', \'class\'], split: false, expand: false, deep: true}\n
\t\t\t\t]\n
\t\t\t});\n
\n
\t\t\t// Register default block formats\n
\t\t\teach(\'p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp\'.split(/\\s/), function(name) {\n
\t\t\t\tregister(name, {block: name, remove: \'all\'});\n
\t\t\t});\n
\n
\t\t\t// Register user defined formats\n
\t\t\tregister(ed.settings.formats);\n
\t\t}\n
\n
\t\tfunction addKeyboardShortcuts() {\n
\t\t\t// Add some inline shortcuts\n
\t\t\ted.addShortcut(\'meta+b\', \'bold_desc\', \'Bold\');\n
\t\t\ted.addShortcut(\'meta+i\', \'italic_desc\', \'Italic\');\n
\t\t\ted.addShortcut(\'meta+u\', \'underline_desc\', \'Underline\');\n
\n
\t\t\t// BlockFormat shortcuts keys\n
\t\t\tfor (var i = 1; i <= 6; i++) {\n
\t\t\t\ted.addShortcut(\'access+\' + i, \'\', [\'FormatBlock\', false, \'h\' + i]);\n
\t\t\t}\n
\n
\t\t\ted.addShortcut(\'access+7\', \'\', [\'FormatBlock\', false, \'p\']);\n
\t\t\ted.addShortcut(\'access+8\', \'\', [\'FormatBlock\', false, \'div\']);\n
\t\t\ted.addShortcut(\'access+9\', \'\', [\'FormatBlock\', false, \'address\']);\n
\t\t}\n
\n
\t\t// Public functions\n
\n
\t\t/**\n
\t\t * Returns the format by name or all formats if no name is specified.\n
\t\t *\n
\t\t * @method get\n
\t\t * @param {String} name Optional name to retrive by.\n
\t\t * @return {Array/Object} Array/Object with all registred formats or a specific format.\n
\t\t */\n
\t\tfunction get(name) {\n
\t\t\treturn name ? formats[name] : formats;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Registers a specific format by name.\n
\t\t *\n
\t\t * @method register\n
\t\t * @param {Object/String} name Name of the format for example "bold".\n
\t\t * @param {Object/Array} format Optional format object or array of format variants\n
\t\t * can only be omitted if the first arg is an object.\n
\t\t */\n
\t\tfunction register(name, format) {\n
\t\t\tif (name) {\n
\t\t\t\tif (typeof name !== \'string\') {\n
\t\t\t\t\teach(name, function(format, name) {\n
\t\t\t\t\t\tregister(name, format);\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\t// Force format into array and add it to internal collection\n
\t\t\t\t\tformat = format.length ? format : [format];\n
\n
\t\t\t\t\teach(format, function(format) {\n
\t\t\t\t\t\t// Set deep to false by default on selector formats this to avoid removing\n
\t\t\t\t\t\t// alignment on images inside paragraphs when alignment is changed on paragraphs\n
\t\t\t\t\t\tif (format.deep === undef) {\n
\t\t\t\t\t\t\tformat.deep = !format.selector;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Default to true\n
\t\t\t\t\t\tif (format.split === undef) {\n
\t\t\t\t\t\t\tformat.split = !format.selector || format.inline;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Default to true\n
\t\t\t\t\t\tif (format.remove === undef && format.selector && !format.inline) {\n
\t\t\t\t\t\t\tformat.remove = \'none\';\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Mark format as a mixed format inline + block level\n
\t\t\t\t\t\tif (format.selector && format.inline) {\n
\t\t\t\t\t\t\tformat.mixed = true;\n
\t\t\t\t\t\t\tformat.block_expand = true;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Split classes if needed\n
\t\t\t\t\t\tif (typeof format.classes === \'string\') {\n
\t\t\t\t\t\t\tformat.classes = format.classes.split(/\\s+/);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tformats[name] = format;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Unregister a specific format by name.\n
\t\t *\n
\t\t * @method unregister\n
\t\t * @param {String} name Name of the format for example "bold".\n
\t\t */\n
\t\tfunction unregister(name) {\n
\t\t\tif (name && formats[name]) {\n
\t\t\t\tdelete formats[name];\n
\t\t\t}\n
\n
\t\t\treturn formats;\n
\t\t}\n
\n
\t\tfunction getTextDecoration(node) {\n
\t\t\tvar decoration;\n
\n
\t\t\ted.dom.getParent(node, function(n) {\n
\t\t\t\tdecoration = ed.dom.getStyle(n, \'text-decoration\');\n
\t\t\t\treturn decoration && decoration !== \'none\';\n
\t\t\t});\n
\n
\t\t\treturn decoration;\n
\t\t}\n
\n
\t\tfunction processUnderlineAndColor(node) {\n
\t\t\tvar textDecoration;\n
\t\t\tif (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {\n
\t\t\t\ttextDecoration = getTextDecoration(node.parentNode);\n
\t\t\t\tif (ed.dom.getStyle(node, \'color\') && textDecoration) {\n
\t\t\t\t\ted.dom.setStyle(node, \'text-decoration\', textDecoration);\n
\t\t\t\t} else if (ed.dom.getStyle(node, \'text-decoration\') === textDecoration) {\n
\t\t\t\t\ted.dom.setStyle(node, \'text-decoration\', null);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Applies the specified format to the current selection or specified node.\n
\t\t *\n
\t\t * @method apply\n
\t\t * @param {String} name Name of format to apply.\n
\t\t * @param {Object} vars Optional list of variables to replace within format before applying it.\n
\t\t * @param {Node} node Optional node to apply the format to defaults to current selection.\n
\t\t */\n
\t\tfunction apply(name, vars, node) {\n
\t\t\tvar formatList = get(name), format = formatList[0], bookmark, rng, isCollapsed = !node && selection.isCollapsed();\n
\n
\t\t\tfunction setElementFormat(elm, fmt) {\n
\t\t\t\tfmt = fmt || format;\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\tif (fmt.onformat) {\n
\t\t\t\t\t\tfmt.onformat(elm, fmt, vars, node);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teach(fmt.styles, function(value, name) {\n
\t\t\t\t\t\tdom.setStyle(elm, name, replaceVars(value, vars));\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Needed for the WebKit span spam bug\n
\t\t\t\t\t// TODO: Remove this once WebKit/Blink fixes this\n
\t\t\t\t\tif (fmt.styles) {\n
\t\t\t\t\t\tvar styleVal = dom.getAttrib(elm, \'style\');\n
\n
\t\t\t\t\t\tif (styleVal) {\n
\t\t\t\t\t\t\telm.setAttribute(\'data-mce-style\', styleVal);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teach(fmt.attributes, function(value, name) {\n
\t\t\t\t\t\tdom.setAttrib(elm, name, replaceVars(value, vars));\n
\t\t\t\t\t});\n
\n
\t\t\t\t\teach(fmt.classes, function(value) {\n
\t\t\t\t\t\tvalue = replaceVars(value, vars);\n
\n
\t\t\t\t\t\tif (!dom.hasClass(elm, value)) {\n
\t\t\t\t\t\t\tdom.addClass(elm, value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction adjustSelectionToVisibleSelection() {\n
\t\t\t\tfunction findSelectionEnd(start, end) {\n
\t\t\t\t\tvar walker = new TreeWalker(end);\n
\t\t\t\t\tfor (node = walker.current(); node; node = walker.prev()) {\n
\t\t\t\t\t\tif (node.childNodes.length > 1 || node == start || node.tagName == \'BR\') {\n
\t\t\t\t\t\t\treturn node;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Adjust selection so that a end container with a end offset of zero is not included in the selection\n
\t\t\t\t// as this isn\'t visible to the user.\n
\t\t\t\tvar rng = ed.selection.getRng();\n
\t\t\t\tvar start = rng.startContainer;\n
\t\t\t\tvar end = rng.endContainer;\n
\n
\t\t\t\tif (start != end && rng.endOffset === 0) {\n
\t\t\t\t\tvar newEnd = findSelectionEnd(start, end);\n
\t\t\t\t\tvar endOffset = newEnd.nodeType == 3 ? newEnd.length : newEnd.childNodes.length;\n
\n
\t\t\t\t\trng.setEnd(newEnd, endOffset);\n
\t\t\t\t}\n
\n
\t\t\t\treturn rng;\n
\t\t\t}\n
\n
\t\t\tfunction applyRngStyle(rng, bookmark, node_specific) {\n
\t\t\t\tvar newWrappers = [], wrapName, wrapElm, contentEditable = true;\n
\n
\t\t\t\t// Setup wrapper element\n
\t\t\t\twrapName = format.inline || format.block;\n
\t\t\t\twrapElm = dom.create(wrapName);\n
\t\t\t\tsetElementFormat(wrapElm);\n
\n
\t\t\t\trangeUtils.walk(rng, function(nodes) {\n
\t\t\t\t\tvar currentWrapElm;\n
\n
\t\t\t\t\t/**\n
\t\t\t\t\t * Process a list of nodes wrap them.\n
\t\t\t\t\t */\n
\t\t\t\t\tfunction process(node) {\n
\t\t\t\t\t\tvar nodeName, parentName, found, hasContentEditableState, lastContentEditable;\n
\n
\t\t\t\t\t\tlastContentEditable = contentEditable;\n
\t\t\t\t\t\tnodeName = node.nodeName.toLowerCase();\n
\t\t\t\t\t\tparentName = node.parentNode.nodeName.toLowerCase();\n
\n
\t\t\t\t\t\t// Node has a contentEditable value\n
\t\t\t\t\t\tif (node.nodeType === 1 && getContentEditable(node)) {\n
\t\t\t\t\t\t\tlastContentEditable = contentEditable;\n
\t\t\t\t\t\t\tcontentEditable = getContentEditable(node) === "true";\n
\t\t\t\t\t\t\thasContentEditableState = true; // We don\'t want to wrap the container only it\'s children\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Stop wrapping on br elements\n
\t\t\t\t\t\tif (isEq(nodeName, \'br\')) {\n
\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\n
\t\t\t\t\t\t\t// Remove any br elements when we wrap things\n
\t\t\t\t\t\t\tif (format.block) {\n
\t\t\t\t\t\t\t\tdom.remove(node);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// If node is wrapper type\n
\t\t\t\t\t\tif (format.wrapper && matchNode(node, name, vars)) {\n
\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Can we rename the block\n
\t\t\t\t\t\t// TODO: Break this if up, too complex\n
\t\t\t\t\t\tif (contentEditable && !hasContentEditableState && format.block &&\n
\t\t\t\t\t\t\t!format.wrapper && isTextBlock(nodeName) && isValid(parentName, wrapName)) {\n
\t\t\t\t\t\t\tnode = dom.rename(node, wrapName);\n
\t\t\t\t\t\t\tsetElementFormat(node);\n
\t\t\t\t\t\t\tnewWrappers.push(node);\n
\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Handle selector patterns\n
\t\t\t\t\t\tif (format.selector) {\n
\t\t\t\t\t\t\t// Look for matching formats\n
\t\t\t\t\t\t\teach(formatList, function(format) {\n
\t\t\t\t\t\t\t\t// Check collapsed state if it exists\n
\t\t\t\t\t\t\t\tif (\'collapsed\' in format && format.collapsed !== isCollapsed) {\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tif (dom.is(node, format.selector) && !isCaretNode(node)) {\n
\t\t\t\t\t\t\t\t\tsetElementFormat(node, format);\n
\t\t\t\t\t\t\t\t\tfound = true;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t\t// Continue processing if a selector match wasn\'t found and a inline element is defined\n
\t\t\t\t\t\t\tif (!format.inline || found) {\n
\t\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Is it valid to wrap this item\n
\t\t\t\t\t\t// TODO: Break this if up, too complex\n
\t\t\t\t\t\tif (contentEditable && !hasContentEditableState && isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&\n
\t\t\t\t\t\t\t\t!(!node_specific && node.nodeType === 3 &&\n
\t\t\t\t\t\t\t\tnode.nodeValue.length === 1 &&\n
\t\t\t\t\t\t\t\tnode.nodeValue.charCodeAt(0) === 65279) &&\n
\t\t\t\t\t\t\t\t!isCaretNode(node) &&\n
\t\t\t\t\t\t\t\t(!format.inline || !isBlock(node))) {\n
\t\t\t\t\t\t\t// Start wrapping\n
\t\t\t\t\t\t\tif (!currentWrapElm) {\n
\t\t\t\t\t\t\t\t// Wrap the node\n
\t\t\t\t\t\t\t\tcurrentWrapElm = dom.clone(wrapElm, FALSE);\n
\t\t\t\t\t\t\t\tnode.parentNode.insertBefore(currentWrapElm, node);\n
\t\t\t\t\t\t\t\tnewWrappers.push(currentWrapElm);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tcurrentWrapElm.appendChild(node);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Start a new wrapper for possible children\n
\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\n
\t\t\t\t\t\t\teach(grep(node.childNodes), process);\n
\n
\t\t\t\t\t\t\tif (hasContentEditableState) {\n
\t\t\t\t\t\t\t\tcontentEditable = lastContentEditable; // Restore last contentEditable state from stack\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// End the last wrapper\n
\t\t\t\t\t\t\tcurrentWrapElm = 0;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Process siblings from range\n
\t\t\t\t\teach(nodes, process);\n
\t\t\t\t});\n
\n
\t\t\t\t// Apply formats to links as well to get the color of the underline to change as well\n
\t\t\t\tif (format.links === true) {\n
\t\t\t\t\teach(newWrappers, function(node) {\n
\t\t\t\t\t\tfunction process(node) {\n
\t\t\t\t\t\t\tif (node.nodeName === \'A\') {\n
\t\t\t\t\t\t\t\tsetElementFormat(node, format);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\teach(grep(node.childNodes), process);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tprocess(node);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\t// Cleanup\n
\t\t\t\teach(newWrappers, function(node) {\n
\t\t\t\t\tvar childCount;\n
\n
\t\t\t\t\tfunction getChildCount(node) {\n
\t\t\t\t\t\tvar count = 0;\n
\n
\t\t\t\t\t\teach(node.childNodes, function(node) {\n
\t\t\t\t\t\t\tif (!isWhiteSpaceNode(node) && !isBookmarkNode(node)) {\n
\t\t\t\t\t\t\t\tcount++;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\treturn count;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfunction mergeStyles(node) {\n
\t\t\t\t\t\tvar child, clone;\n
\n
\t\t\t\t\t\teach(node.childNodes, function(node) {\n
\t\t\t\t\t\t\tif (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {\n
\t\t\t\t\t\t\t\tchild = node;\n
\t\t\t\t\t\t\t\treturn FALSE; // break loop\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t// If child was found and of the same type as the current node\n
\t\t\t\t\t\tif (child && !isBookmarkNode(child) && matchName(child, format)) {\n
\t\t\t\t\t\t\tclone = dom.clone(child, FALSE);\n
\t\t\t\t\t\t\tsetElementFormat(clone);\n
\n
\t\t\t\t\t\t\tdom.replace(clone, node, TRUE);\n
\t\t\t\t\t\t\tdom.remove(child, 1);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn clone || node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tchildCount = getChildCount(node);\n
\n
\t\t\t\t\t// Remove empty nodes but only if there is multiple wrappers and they are not block\n
\t\t\t\t\t// elements so never remove single <h1></h1> since that would remove the\n
\t\t\t\t\t// currrent empty block element where the caret is at\n
\t\t\t\t\tif ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {\n
\t\t\t\t\t\tdom.remove(node, 1);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (format.inline || format.wrapper) {\n
\t\t\t\t\t\t// Merges the current node with it\'s children of similar type to reduce the number of elements\n
\t\t\t\t\t\tif (!format.exact && childCount === 1) {\n
\t\t\t\t\t\t\tnode = mergeStyles(node);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Remove/merge children\n
\t\t\t\t\t\teach(formatList, function(format) {\n
\t\t\t\t\t\t\t// Merge all children of similar type will move styles from child to parent\n
\t\t\t\t\t\t\t// this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>\n
\t\t\t\t\t\t\t// will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>\n
\t\t\t\t\t\t\teach(dom.select(format.inline, node), function(child) {\n
\t\t\t\t\t\t\t\tif (isBookmarkNode(child)) {\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tremoveFormat(format, vars, child, format.exact ? child : null);\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t// Remove child if direct parent is of same type\n
\t\t\t\t\t\tif (matchNode(node.parentNode, name, vars)) {\n
\t\t\t\t\t\t\tdom.remove(node, 1);\n
\t\t\t\t\t\t\tnode = 0;\n
\t\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Look for parent with similar style format\n
\t\t\t\t\t\tif (format.merge_with_parents) {\n
\t\t\t\t\t\t\tdom.getParent(node.parentNode, function(parent) {\n
\t\t\t\t\t\t\t\tif (matchNode(parent, name, vars)) {\n
\t\t\t\t\t\t\t\t\tdom.remove(node, 1);\n
\t\t\t\t\t\t\t\t\tnode = 0;\n
\t\t\t\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>\n
\t\t\t\t\t\tif (node && format.merge_siblings !== false) {\n
\t\t\t\t\t\t\tnode = mergeSiblings(getNonWhiteSpaceSibling(node), node);\n
\t\t\t\t\t\t\tnode = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (format) {\n
\t\t\t\tif (node) {\n
\t\t\t\t\tif (node.nodeType) {\n
\t\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\t\trng.setStartBefore(node);\n
\t\t\t\t\t\trng.setEndAfter(node);\n
\t\t\t\t\t\tapplyRngStyle(expandRng(rng, formatList), null, true);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tapplyRngStyle(node, null, true);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (!isCollapsed || !format.inline || dom.select(\'td.mce-item-selected,th.mce-item-selected\').length) {\n
\t\t\t\t\t\t// Obtain selection node before selection is unselected by applyRngStyle()\n
\t\t\t\t\t\tvar curSelNode = ed.selection.getNode();\n
\n
\t\t\t\t\t\t// If the formats have a default block and we can\'t find a parent block then\n
\t\t\t\t\t\t// start wrapping it with a DIV this is for forced_root_blocks: false\n
\t\t\t\t\t\t// It\'s kind of a hack but people should be using the default block type P since all desktop editors work that way\n
\t\t\t\t\t\tif (!forcedRootBlock && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {\n
\t\t\t\t\t\t\tapply(formatList[0].defaultBlock);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Apply formatting to selection\n
\t\t\t\t\t\ted.selection.setRng(adjustSelectionToVisibleSelection());\n
\t\t\t\t\t\tbookmark = selection.getBookmark();\n
\t\t\t\t\t\tapplyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);\n
\n
\t\t\t\t\t\t// Colored nodes should be underlined so that the color of the underline matches the text color.\n
\t\t\t\t\t\tif (format.styles && (format.styles.color || format.styles.textDecoration)) {\n
\t\t\t\t\t\t\twalk(curSelNode, processUnderlineAndColor, \'childNodes\');\n
\t\t\t\t\t\t\tprocessUnderlineAndColor(curSelNode);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tselection.moveToBookmark(bookmark);\n
\t\t\t\t\t\tmoveStart(selection.getRng(TRUE));\n
\t\t\t\t\t\ted.nodeChanged();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tperformCaretAction(\'apply\', name, vars);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes the specified format from the current selection or specified node.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {String} name Name of format to remove.\n
\t\t * @param {Object} vars Optional list of variables to replace within format before removing it.\n
\t\t * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.\n
\t\t */\n
\t\tfunction remove(name, vars, node, similar) {\n
\t\t\tvar formatList = get(name), format = formatList[0], bookmark, rng, contentEditable = true;\n
\n
\t\t\t// Merges the styles for each node\n
\t\t\tfunction process(node) {\n
\t\t\t\tvar children, i, l, lastContentEditable, hasContentEditableState;\n
\n
\t\t\t\t// Node has a contentEditable value\n
\t\t\t\tif (node.nodeType === 1 && getContentEditable(node)) {\n
\t\t\t\t\tlastContentEditable = contentEditable;\n
\t\t\t\t\tcontentEditable = getContentEditable(node) === "true";\n
\t\t\t\t\thasContentEditableState = true; // We don\'t want to wrap the container only it\'s children\n
\t\t\t\t}\n
\n
\t\t\t\t// Grab the children first since the nodelist might be changed\n
\t\t\t\tchildren = grep(node.childNodes);\n
\n
\t\t\t\t// Process current node\n
\t\t\t\tif (contentEditable && !hasContentEditableState) {\n
\t\t\t\t\tfor (i = 0, l = formatList.length; i < l; i++) {\n
\t\t\t\t\t\tif (removeFormat(formatList[i], vars, node, node)) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Process the children\n
\t\t\t\tif (format.deep) {\n
\t\t\t\t\tif (children.length) {\n
\t\t\t\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n
\t\t\t\t\t\t\tprocess(children[i]);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (hasContentEditableState) {\n
\t\t\t\t\t\t\tcontentEditable = lastContentEditable; // Restore last contentEditable state from stack\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction findFormatRoot(container) {\n
\t\t\t\tvar formatRoot;\n
\n
\t\t\t\t// Find format root\n
\t\t\t\teach(getParents(container.parentNode).reverse(), function(parent) {\n
\t\t\t\t\tvar format;\n
\n
\t\t\t\t\t// Find format root element\n
\t\t\t\t\tif (!formatRoot && parent.id != \'_start\' && parent.id != \'_end\') {\n
\t\t\t\t\t\t// Is the node matching the format we are looking for\n
\t\t\t\t\t\tformat = matchNode(parent, name, vars, similar);\n
\t\t\t\t\t\tif (format && format.split !== false) {\n
\t\t\t\t\t\t\tformatRoot = parent;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn formatRoot;\n
\t\t\t}\n
\n
\t\t\tfunction wrapAndSplit(formatRoot, container, target, split) {\n
\t\t\t\tvar parent, clone, lastClone, firstClone, i, formatRootParent;\n
\n
\t\t\t\t// Format root found then clone formats and split it\n
\t\t\t\tif (formatRoot) {\n
\t\t\t\t\tformatRootParent = formatRoot.parentNode;\n
\n
\t\t\t\t\tfor (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {\n
\t\t\t\t\t\tclone = dom.clone(parent, FALSE);\n
\n
\t\t\t\t\t\tfor (i = 0; i < formatList.length; i++) {\n
\t\t\t\t\t\t\tif (removeFormat(formatList[i], vars, clone, clone)) {\n
\t\t\t\t\t\t\t\tclone = 0;\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Build wrapper node\n
\t\t\t\t\t\tif (clone) {\n
\t\t\t\t\t\t\tif (lastClone) {\n
\t\t\t\t\t\t\t\tclone.appendChild(lastClone);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (!firstClone) {\n
\t\t\t\t\t\t\t\tfirstClone = clone;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tlastClone = clone;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Never split block elements if the format is mixed\n
\t\t\t\t\tif (split && (!format.mixed || !isBlock(formatRoot))) {\n
\t\t\t\t\t\tcontainer = dom.split(formatRoot, container);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Wrap container in cloned formats\n
\t\t\t\t\tif (lastClone) {\n
\t\t\t\t\t\ttarget.parentNode.insertBefore(lastClone, target);\n
\t\t\t\t\t\tfirstClone.appendChild(target);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\tfunction splitToFormatRoot(container) {\n
\t\t\t\treturn wrapAndSplit(findFormatRoot(container), container, container, true);\n
\t\t\t}\n
\n
\t\t\tfunction unwrap(start) {\n
\t\t\t\tvar node = dom.get(start ? \'_start\' : \'_end\'),\n
\t\t\t\t\tout = node[start ? \'firstChild\' : \'lastChild\'];\n
\n
\t\t\t\t// If the end is placed within the start the result will be removed\n
\t\t\t\t// So this checks if the out node is a bookmark node if it is it\n
\t\t\t\t// checks for another more suitable node\n
\t\t\t\tif (isBookmarkNode(out)) {\n
\t\t\t\t\tout = out[start ? \'firstChild\' : \'lastChild\'];\n
\t\t\t\t}\n
\n
\t\t\t\t// Since dom.remove removes empty text nodes then we need to try to find a better node\n
\t\t\t\tif (out.nodeType == 3 && out.data.length === 0) {\n
\t\t\t\t\tout = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tdom.remove(node, true);\n
\n
\t\t\t\treturn out;\n
\t\t\t}\n
\n
\t\t\tfunction removeRngStyle(rng) {\n
\t\t\t\tvar startContainer, endContainer;\n
\t\t\t\tvar commonAncestorContainer = rng.commonAncestorContainer;\n
\n
\t\t\t\trng = expandRng(rng, formatList, TRUE);\n
\n
\t\t\t\tif (format.split) {\n
\t\t\t\t\tstartContainer = getContainer(rng, TRUE);\n
\t\t\t\t\tendContainer = getContainer(rng);\n
\n
\t\t\t\t\tif (startContainer != endContainer) {\n
\t\t\t\t\t\t// WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN\n
\t\t\t\t\t\t// so let\'s see if we can use the first child instead\n
\t\t\t\t\t\t// This will happen if you triple click a table cell and use remove formatting\n
\t\t\t\t\t\tif (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {\n
\t\t\t\t\t\t\tif (startContainer.nodeName == "TR") {\n
\t\t\t\t\t\t\t\tstartContainer = startContainer.firstChild.firstChild || startContainer;\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tstartContainer = startContainer.firstChild || startContainer;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Try to adjust endContainer as well if cells on the same row were selected - bug #6410\n
\t\t\t\t\t\tif (commonAncestorContainer &&\n
\t\t\t\t\t\t\t/^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) &&\n
\t\t\t\t\t\t\tisTableCell(endContainer) && endContainer.firstChild) {\n
\t\t\t\t\t\t\tendContainer = endContainer.firstChild || endContainer;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (dom.isChildOf(startContainer, endContainer) && !isBlock(endContainer) &&\n
\t\t\t\t\t\t\t!isTableCell(startContainer) && !isTableCell(endContainer)) {\n
\t\t\t\t\t\t\tstartContainer = wrap(startContainer, \'span\', {id: \'_start\', \'data-mce-type\': \'bookmark\'});\n
\t\t\t\t\t\t\tsplitToFormatRoot(startContainer);\n
\t\t\t\t\t\t\tstartContainer = unwrap(TRUE);\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Wrap start/end nodes in span element since these might be cloned/moved\n
\t\t\t\t\t\tstartContainer = wrap(startContainer, \'span\', {id: \'_start\', \'data-mce-type\': \'bookmark\'});\n
\t\t\t\t\t\tendContainer = wrap(endContainer, \'span\', {id: \'_end\', \'data-mce-type\': \'bookmark\'});\n
\n
\t\t\t\t\t\t// Split start/end\n
\t\t\t\t\t\tsplitToFormatRoot(startContainer);\n
\t\t\t\t\t\tsplitToFormatRoot(endContainer);\n
\n
\t\t\t\t\t\t// Unwrap start/end to get real elements again\n
\t\t\t\t\t\tstartContainer = unwrap(TRUE);\n
\t\t\t\t\t\tendContainer = unwrap();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tstartContainer = endContainer = splitToFormatRoot(startContainer);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Update range positions since they might have changed after the split operations\n
\t\t\t\t\trng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n
\t\t\t\t\trng.startOffset = nodeIndex(startContainer);\n
\t\t\t\t\trng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n
\t\t\t\t\trng.endOffset = nodeIndex(endContainer) + 1;\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove items between start/end\n
\t\t\t\trangeUtils.walk(rng, function(nodes) {\n
\t\t\t\t\teach(nodes, function(node) {\n
\t\t\t\t\t\tprocess(node);\n
\n
\t\t\t\t\t\t// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.\n
\t\t\t\t\t\tif (node.nodeType === 1 && ed.dom.getStyle(node, \'text-decoration\') === \'underline\' &&\n
\t\t\t\t\t\t\tnode.parentNode && getTextDecoration(node.parentNode) === \'underline\') {\n
\t\t\t\t\t\t\tremoveFormat({\n
\t\t\t\t\t\t\t\t\'deep\': false,\n
\t\t\t\t\t\t\t\t\'exact\': true,\n
\t\t\t\t\t\t\t\t\'inline\': \'span\',\n
\t\t\t\t\t\t\t\t\'styles\': {\n
\t\t\t\t\t\t\t\t\t\'textDecoration\': \'underline\'\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}, null, node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Handle node\n
\t\t\tif (node) {\n
\t\t\t\tif (node.nodeType) {\n
\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\trng.setStartBefore(node);\n
\t\t\t\t\trng.setEndAfter(node);\n
\t\t\t\t\tremoveRngStyle(rng);\n
\t\t\t\t} else {\n
\t\t\t\t\tremoveRngStyle(node);\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!selection.isCollapsed() || !format.inline || dom.select(\'td.mce-item-selected,th.mce-item-selected\').length) {\n
\t\t\t\tbookmark = selection.getBookmark();\n
\t\t\t\tremoveRngStyle(selection.getRng(TRUE));\n
\t\t\t\tselection.moveToBookmark(bookmark);\n
\n
\t\t\t\t// Check if start element still has formatting then we are at: "<b>text|</b>text"\n
\t\t\t\t// and need to move the start into the next text node\n
\t\t\t\tif (format.inline && match(name, vars, selection.getStart())) {\n
\t\t\t\t\tmoveStart(selection.getRng(true));\n
\t\t\t\t}\n
\n
\t\t\t\ted.nodeChanged();\n
\t\t\t} else {\n
\t\t\t\tperformCaretAction(\'remove\', name, vars, similar);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Toggles the specified format on/off.\n
\t\t *\n
\t\t * @method toggle\n
\t\t * @param {String} name Name of format to apply/remove.\n
\t\t * @param {Object} vars Optional list of variables to replace within format before applying/removing it.\n
\t\t * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.\n
\t\t */\n
\t\tfunction toggle(name, vars, node) {\n
\t\t\tvar fmt = get(name);\n
\n
\t\t\tif (match(name, vars, node) && (!(\'toggle\' in fmt[0]) || fmt[0].toggle)) {\n
\t\t\t\tremove(name, vars, node);\n
\t\t\t} else {\n
\t\t\t\tapply(name, vars, node);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Return true/false if the specified node has the specified format.\n
\t\t *\n
\t\t * @method matchNode\n
\t\t * @param {Node} node Node to check the format on.\n
\t\t * @param {String} name Format name to check.\n
\t\t * @param {Object} vars Optional list of variables to replace before checking it.\n
\t\t * @param {Boolean} similar Match format that has similar properties.\n
\t\t * @return {Object} Returns the format object it matches or undefined if it doesn\'t match.\n
\t\t */\n
\t\tfunction matchNode(node, name, vars, similar) {\n
\t\t\tvar formatList = get(name), format, i, classes;\n
\n
\t\t\tfunction matchItems(node, format, item_name) {\n
\t\t\t\tvar key, value, items = format[item_name], i;\n
\n
\t\t\t\t// Custom match\n
\t\t\t\tif (format.onmatch) {\n
\t\t\t\t\treturn format.onmatch(node, format, item_name);\n
\t\t\t\t}\n
\n
\t\t\t\t// Check all items\n
\t\t\t\tif (items) {\n
\t\t\t\t\t// Non indexed object\n
\t\t\t\t\tif (items.length === undef) {\n
\t\t\t\t\t\tfor (key in items) {\n
\t\t\t\t\t\t\tif (items.hasOwnProperty(key)) {\n
\t\t\t\t\t\t\t\tif (item_name === \'attributes\') {\n
\t\t\t\t\t\t\t\t\tvalue = dom.getAttrib(node, key);\n
\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\tvalue = getStyle(node, key);\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tif (similar && !value && !format.exact) {\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tif ((!similar || format.exact) && !isEq(value, normalizeStyleValue(replaceVars(items[key], vars), key))) {\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Only one match needed for indexed arrays\n
\t\t\t\t\t\tfor (i = 0; i < items.length; i++) {\n
\t\t\t\t\t\t\tif (item_name === \'attributes\' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) {\n
\t\t\t\t\t\t\t\treturn format;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn format;\n
\t\t\t}\n
\n
\t\t\tif (formatList && node) {\n
\t\t\t\t// Check each format in list\n
\t\t\t\tfor (i = 0; i < formatList.length; i++) {\n
\t\t\t\t\tformat = formatList[i];\n
\n
\t\t\t\t\t// Name name, attributes, styles and classes\n
\t\t\t\t\tif (matchName(node, format) && matchItems(node, format, \'attributes\') && matchItems(node, format, \'styles\')) {\n
\t\t\t\t\t\t// Match classes\n
\t\t\t\t\t\tif ((classes = format.classes)) {\n
\t\t\t\t\t\t\tfor (i = 0; i < classes.length; i++) {\n
\t\t\t\t\t\t\t\tif (!dom.hasClass(node, classes[i])) {\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn format;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Matches the current selection or specified node against the specified format name.\n
\t\t *\n
\t\t * @method match\n
\t\t * @param {String} name Name of format to match.\n
\t\t * @param {Object} vars Optional list of variables to replace before checking it.\n
\t\t * @param {Node} node Optional node to check.\n
\t\t * @return {boolean} true/false if the specified selection/node matches the format.\n
\t\t */\n
\t\tfunction match(name, vars, node) {\n
\t\t\tvar startNode;\n
\n
\t\t\tfunction matchParents(node) {\n
\t\t\t\tvar root = dom.getRoot();\n
\n
\t\t\t\tif (node === root) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\t// Find first node with similar format settings\n
\t\t\t\tnode = dom.getParent(node, function(node) {\n
\t\t\t\t\treturn node.parentNode === root || !!matchNode(node, name, vars, true);\n
\t\t\t\t});\n
\n
\t\t\t\t// Do an exact check on the similar format element\n
\t\t\t\treturn matchNode(node, name, vars);\n
\t\t\t}\n
\n
\t\t\t// Check specified node\n
\t\t\tif (node) {\n
\t\t\t\treturn matchParents(node);\n
\t\t\t}\n
\n
\t\t\t// Check selected node\n
\t\t\tnode = selection.getNode();\n
\t\t\tif (matchParents(node)) {\n
\t\t\t\treturn TRUE;\n
\t\t\t}\n
\n
\t\t\t// Check start node if it\'s different\n
\t\t\tstartNode = selection.getStart();\n
\t\t\tif (startNode != node) {\n
\t\t\t\tif (matchParents(startNode)) {\n
\t\t\t\t\treturn TRUE;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn FALSE;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Matches the current selection against the array of formats and returns a new array with matching formats.\n
\t\t *\n
\t\t * @method matchAll\n
\t\t * @param {Array} names Name of format to match.\n
\t\t * @param {Object} vars Optional list of variables to replace before checking it.\n
\t\t * @return {Array} Array with matched formats.\n
\t\t */\n
\t\tfunction matchAll(names, vars) {\n
\t\t\tvar startElement, matchedFormatNames = [], checkedMap = {};\n
\n
\t\t\t// Check start of selection for formats\n
\t\t\tstartElement = selection.getStart();\n
\t\t\tdom.getParent(startElement, function(node) {\n
\t\t\t\tvar i, name;\n
\n
\t\t\t\tfor (i = 0; i < names.length; i++) {\n
\t\t\t\t\tname = names[i];\n
\n
\t\t\t\t\tif (!checkedMap[name] && matchNode(node, name, vars)) {\n
\t\t\t\t\t\tcheckedMap[name] = true;\n
\t\t\t\t\t\tmatchedFormatNames.push(name);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}, dom.getRoot());\n
\n
\t\t\treturn matchedFormatNames;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified format can be applied to the current selection or not. It\n
\t\t * will currently only check the state for selector formats, it returns true on all other format types.\n
\t\t *\n
\t\t * @method canApply\n
\t\t * @param {String} name Name of format to check.\n
\t\t * @return {boolean} true/false if the specified format can be applied to the current selection/node.\n
\t\t */\n
\t\tfunction canApply(name) {\n
\t\t\tvar formatList = get(name), startNode, parents, i, x, selector;\n
\n
\t\t\tif (formatList) {\n
\t\t\t\tstartNode = selection.getStart();\n
\t\t\t\tparents = getParents(startNode);\n
\n
\t\t\t\tfor (x = formatList.length - 1; x >= 0; x--) {\n
\t\t\t\t\tselector = formatList[x].selector;\n
\n
\t\t\t\t\t// Format is not selector based then always return TRUE\n
\t\t\t\t\t// Is it has a defaultBlock then it\'s likely it can be applied for example align on a non block element line\n
\t\t\t\t\tif (!selector || formatList[x].defaultBlock) {

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAg=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="8" aka="AAAAAAAAAAg=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

\n
\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\n
\t\t\t\t\t\tif (dom.is(parents[i], selector)) {\n
\t\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn FALSE;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Executes the specified callback when the current selection matches the formats or not.\n
\t\t *\n
\t\t * @method formatChanged\n
\t\t * @param {String} formats Comma separated list of formats to check for.\n
\t\t * @param {function} callback Callback with state and args when the format is changed/toggled on/off.\n
\t\t * @param {Boolean} similar True/false state if the match should handle similar or exact formats.\n
\t\t */\n
\t\tfunction formatChanged(formats, callback, similar) {\n
\t\t\tvar currentFormats;\n
\n
\t\t\t// Setup format node change logic\n
\t\t\tif (!formatChangeData) {\n
\t\t\t\tformatChangeData = {};\n
\t\t\t\tcurrentFormats = {};\n
\n
\t\t\t\ted.on(\'NodeChange\', function(e) {\n
\t\t\t\t\tvar parents = getParents(e.element), matchedFormats = {};\n
\n
\t\t\t\t\t// Ignore bogus nodes like the <a> tag created by moveStart()\n
\t\t\t\t\tparents = Tools.grep(parents, function(node) {\n
\t\t\t\t\t\treturn node.nodeType == 1 && !node.getAttribute(\'data-mce-bogus\');\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Check for new formats\n
\t\t\t\t\teach(formatChangeData, function(callbacks, format) {\n
\t\t\t\t\t\teach(parents, function(node) {\n
\t\t\t\t\t\t\tif (matchNode(node, format, {}, callbacks.similar)) {\n
\t\t\t\t\t\t\t\tif (!currentFormats[format]) {\n
\t\t\t\t\t\t\t\t\t// Execute callbacks\n
\t\t\t\t\t\t\t\t\teach(callbacks, function(callback) {\n
\t\t\t\t\t\t\t\t\t\tcallback(true, {node: node, format: format, parents: parents});\n
\t\t\t\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t\t\t\tcurrentFormats[format] = callbacks;\n
\t\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t\tmatchedFormats[format] = callbacks;\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Check if current formats still match\n
\t\t\t\t\teach(currentFormats, function(callbacks, format) {\n
\t\t\t\t\t\tif (!matchedFormats[format]) {\n
\t\t\t\t\t\t\tdelete currentFormats[format];\n
\n
\t\t\t\t\t\t\teach(callbacks, function(callback) {\n
\t\t\t\t\t\t\t\tcallback(false, {node: e.element, format: format, parents: parents});\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Add format listeners\n
\t\t\teach(formats.split(\',\'), function(format) {\n
\t\t\t\tif (!formatChangeData[format]) {\n
\t\t\t\t\tformatChangeData[format] = [];\n
\t\t\t\t\tformatChangeData[format].similar = similar;\n
\t\t\t\t}\n
\n
\t\t\t\tformatChangeData[format].push(callback);\n
\t\t\t});\n
\n
\t\t\treturn this;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns a preview css text for the specified format.\n
\t\t *\n
\t\t * @method getCssText\n
\t\t * @param {String/Object} format Format to generate preview css text for.\n
\t\t * @return {String} Css text for the specified format.\n
\t\t * @example\n
\t\t * var cssText1 = editor.formatter.getCssText(\'bold\');\n
\t\t * var cssText2 = editor.formatter.getCssText({inline: \'b\'});\n
\t\t */\n
\t\tfunction getCssText(format) {\n
\t\t\treturn Preview.getCssText(ed, format);\n
\t\t}\n
\n
\t\t// Expose to public\n
\t\textend(this, {\n
\t\t\tget: get,\n
\t\t\tregister: register,\n
\t\t\tunregister: unregister,\n
\t\t\tapply: apply,\n
\t\t\tremove: remove,\n
\t\t\ttoggle: toggle,\n
\t\t\tmatch: match,\n
\t\t\tmatchAll: matchAll,\n
\t\t\tmatchNode: matchNode,\n
\t\t\tcanApply: canApply,\n
\t\t\tformatChanged: formatChanged,\n
\t\t\tgetCssText: getCssText\n
\t\t});\n
\n
\t\t// Initialize\n
\t\tdefaultFormats();\n
\t\taddKeyboardShortcuts();\n
\t\ted.on(\'BeforeGetContent\', function(e) {\n
\t\t\tif (markCaretContainersBogus && e.format != \'raw\') {\n
\t\t\t\tmarkCaretContainersBogus();\n
\t\t\t}\n
\t\t});\n
\t\ted.on(\'mouseup keydown\', function(e) {\n
\t\t\tif (disableCaretContainer) {\n
\t\t\t\tdisableCaretContainer(e);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Private functions\n
\n
\t\t/**\n
\t\t * Checks if the specified nodes name matches the format inline/block or selector.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} node Node to match against the specified format.\n
\t\t * @param {Object} format Format object o match with.\n
\t\t * @return {boolean} true/false if the format matches.\n
\t\t */\n
\t\tfunction matchName(node, format) {\n
\t\t\t// Check for inline match\n
\t\t\tif (isEq(node, format.inline)) {\n
\t\t\t\treturn TRUE;\n
\t\t\t}\n
\n
\t\t\t// Check for block match\n
\t\t\tif (isEq(node, format.block)) {\n
\t\t\t\treturn TRUE;\n
\t\t\t}\n
\n
\t\t\t// Check for selector match\n
\t\t\tif (format.selector) {\n
\t\t\t\treturn node.nodeType == 1 && dom.is(node, format.selector);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Compares two string/nodes regardless of their case.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {String/Node} Node or string to compare.\n
\t\t * @param {String/Node} Node or string to compare.\n
\t\t * @return {boolean} True/false if they match.\n
\t\t */\n
\t\tfunction isEq(str1, str2) {\n
\t\t\tstr1 = str1 || \'\';\n
\t\t\tstr2 = str2 || \'\';\n
\n
\t\t\tstr1 = \'\' + (str1.nodeName || str1);\n
\t\t\tstr2 = \'\' + (str2.nodeName || str2);\n
\n
\t\t\treturn str1.toLowerCase() == str2.toLowerCase();\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the style by name on the specified node. This method modifies the style\n
\t\t * contents to make it more easy to match. This will resolve a few browser issues.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} node to get style from.\n
\t\t * @param {String} name Style name to get.\n
\t\t * @return {String} Style item value.\n
\t\t */\n
\t\tfunction getStyle(node, name) {\n
\t\t\treturn normalizeStyleValue(dom.getStyle(node, name), name);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Normalize style value by name. This method modifies the style contents\n
\t\t * to make it more easy to match. This will resolve a few browser issues.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} node to get style from.\n
\t\t * @param {String} name Style name to get.\n
\t\t * @return {String} Style item value.\n
\t\t */\n
\t\tfunction normalizeStyleValue(value, name) {\n
\t\t\t// Force the format to hex\n
\t\t\tif (name == \'color\' || name == \'backgroundColor\') {\n
\t\t\t\tvalue = dom.toHex(value);\n
\t\t\t}\n
\n
\t\t\t// Opera will return bold as 700\n
\t\t\tif (name == \'fontWeight\' && value == 700) {\n
\t\t\t\tvalue = \'bold\';\n
\t\t\t}\n
\n
\t\t\t// Normalize fontFamily so "\'Font name\', Font" becomes: "Font name,Font"\n
\t\t\tif (name == \'fontFamily\') {\n
\t\t\t\tvalue = value.replace(/[\\\'\\"]/g, \'\').replace(/,\\s+/g, \',\');\n
\t\t\t}\n
\n
\t\t\treturn \'\' + value;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Replaces variables in the value. The variable format is %var.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {String} value Value to replace variables in.\n
\t\t * @param {Object} vars Name/value array with variables to replace.\n
\t\t * @return {String} New value with replaced variables.\n
\t\t */\n
\t\tfunction replaceVars(value, vars) {\n
\t\t\tif (typeof value != "string") {\n
\t\t\t\tvalue = value(vars);\n
\t\t\t} else if (vars) {\n
\t\t\t\tvalue = value.replace(/%(\\w+)/g, function(str, name) {\n
\t\t\t\t\treturn vars[name] || str;\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn value;\n
\t\t}\n
\n
\t\tfunction isWhiteSpaceNode(node) {\n
\t\t\treturn node && node.nodeType === 3 && /^([\\t \\r\\n]+|)$/.test(node.nodeValue);\n
\t\t}\n
\n
\t\tfunction wrap(node, name, attrs) {\n
\t\t\tvar wrapper = dom.create(name, attrs);\n
\n
\t\t\tnode.parentNode.insertBefore(wrapper, node);\n
\t\t\twrapper.appendChild(node);\n
\n
\t\t\treturn wrapper;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Expands the specified range like object to depending on format.\n
\t\t *\n
\t\t * For example on block formats it will move the start/end position\n
\t\t * to the beginning of the current block.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Object} rng Range like object.\n
\t\t * @param {Array} formats Array with formats to expand by.\n
\t\t * @return {Object} Expanded range like object.\n
\t\t */\n
\t\tfunction expandRng(rng, format, remove) {\n
\t\t\tvar lastIdx, leaf, endPoint,\n
\t\t\t\tstartContainer = rng.startContainer,\n
\t\t\t\tstartOffset = rng.startOffset,\n
\t\t\t\tendContainer = rng.endContainer,\n
\t\t\t\tendOffset = rng.endOffset;\n
\n
\t\t\t// This function walks up the tree if there is no siblings before/after the node\n
\t\t\tfunction findParentContainer(start) {\n
\t\t\t\tvar container, parent, sibling, siblingName, root;\n
\n
\t\t\t\tcontainer = parent = start ? startContainer : endContainer;\n
\t\t\t\tsiblingName = start ? \'previousSibling\' : \'nextSibling\';\n
\t\t\t\troot = dom.getRoot();\n
\n
\t\t\t\tfunction isBogusBr(node) {\n
\t\t\t\t\treturn node.nodeName == "BR" && node.getAttribute(\'data-mce-bogus\') && !node.nextSibling;\n
\t\t\t\t}\n
\n
\t\t\t\t// If it\'s a text node and the offset is inside the text\n
\t\t\t\tif (container.nodeType == 3 && !isWhiteSpaceNode(container)) {\n
\t\t\t\t\tif (start ? startOffset > 0 : endOffset < container.nodeValue.length) {\n
\t\t\t\t\t\treturn container;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t/*eslint no-constant-condition:0 */\n
\t\t\t\twhile (true) {\n
\t\t\t\t\t// Stop expanding on block elements\n
\t\t\t\t\tif (!format[0].block_expand && isBlock(parent)) {\n
\t\t\t\t\t\treturn parent;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Walk left/right\n
\t\t\t\t\tfor (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n
\t\t\t\t\t\tif (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling) && !isBogusBr(sibling)) {\n
\t\t\t\t\t\t\treturn parent;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Check if we can move up are we at root level or body level\n
\t\t\t\t\tif (parent.parentNode == root) {\n
\t\t\t\t\t\tcontainer = parent;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparent = parent.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\t// This function walks down the tree to find the leaf at the selection.\n
\t\t\t// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.\n
\t\t\tfunction findLeaf(node, offset) {\n
\t\t\t\tif (offset === undef) {\n
\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\n
\t\t\t\t}\n
\n
\t\t\t\twhile (node && node.hasChildNodes()) {\n
\t\t\t\t\tnode = node.childNodes[offset];\n
\t\t\t\t\tif (node) {\n
\t\t\t\t\t\toffset = node.nodeType === 3 ? node.length : node.childNodes.length;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t\treturn {node: node, offset: offset};\n
\t\t\t}\n
\n
\t\t\t// If index based start position then resolve it\n
\t\t\tif (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {\n
\t\t\t\tlastIdx = startContainer.childNodes.length - 1;\n
\t\t\t\tstartContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];\n
\n
\t\t\t\tif (startContainer.nodeType == 3) {\n
\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// If index based end position then resolve it\n
\t\t\tif (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {\n
\t\t\t\tlastIdx = endContainer.childNodes.length - 1;\n
\t\t\t\tendContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];\n
\n
\t\t\t\tif (endContainer.nodeType == 3) {\n
\t\t\t\t\tendOffset = endContainer.nodeValue.length;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Expands the node to the closes contentEditable false element if it exists\n
\t\t\tfunction findParentContentEditable(node) {\n
\t\t\t\tvar parent = node;\n
\n
\t\t\t\twhile (parent) {\n
\t\t\t\t\tif (parent.nodeType === 1 && getContentEditable(parent)) {\n
\t\t\t\t\t\treturn getContentEditable(parent) === "false" ? parent : node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparent = parent.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\tfunction findWordEndPoint(container, offset, start) {\n
\t\t\t\tvar walker, node, pos, lastTextNode;\n
\n
\t\t\t\tfunction findSpace(node, offset) {\n
\t\t\t\t\tvar pos, pos2, str = node.nodeValue;\n
\n
\t\t\t\t\tif (typeof offset == "undefined") {\n
\t\t\t\t\t\toffset = start ? str.length : 0;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\tpos = str.lastIndexOf(\' \', offset);\n
\t\t\t\t\t\tpos2 = str.lastIndexOf(\'\\u00a0\', offset);\n
\t\t\t\t\t\tpos = pos > pos2 ? pos : pos2;\n
\n
\t\t\t\t\t\t// Include the space on remove to avoid tag soup\n
\t\t\t\t\t\tif (pos !== -1 && !remove) {\n
\t\t\t\t\t\t\tpos++;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tpos = str.indexOf(\' \', offset);\n
\t\t\t\t\t\tpos2 = str.indexOf(\'\\u00a0\', offset);\n
\t\t\t\t\t\tpos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn pos;\n
\t\t\t\t}\n
\n
\t\t\t\tif (container.nodeType === 3) {\n
\t\t\t\t\tpos = findSpace(container, offset);\n
\n
\t\t\t\t\tif (pos !== -1) {\n
\t\t\t\t\t\treturn {container: container, offset: pos};\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tlastTextNode = container;\n
\t\t\t\t}\n
\n
\t\t\t\t// Walk the nodes inside the block\n
\t\t\t\twalker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());\n
\t\t\t\twhile ((node = walker[start ? \'prev\' : \'next\']())) {\n
\t\t\t\t\tif (node.nodeType === 3) {\n
\t\t\t\t\t\tlastTextNode = node;\n
\t\t\t\t\t\tpos = findSpace(node);\n
\n
\t\t\t\t\t\tif (pos !== -1) {\n
\t\t\t\t\t\t\treturn {container: node, offset: pos};\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else if (isBlock(node)) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (lastTextNode) {\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\toffset = 0;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\toffset = lastTextNode.length;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn {container: lastTextNode, offset: offset};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction findSelectorEndPoint(container, sibling_name) {\n
\t\t\t\tvar parents, i, y, curFormat;\n
\n
\t\t\t\tif (container.nodeType == 3 && container.nodeValue.length === 0 && container[sibling_name]) {\n
\t\t\t\t\tcontainer = container[sibling_name];\n
\t\t\t\t}\n
\n
\t\t\t\tparents = getParents(container);\n
\t\t\t\tfor (i = 0; i < parents.length; i++) {\n
\t\t\t\t\tfor (y = 0; y < format.length; y++) {\n
\t\t\t\t\t\tcurFormat = format[y];\n
\n
\t\t\t\t\t\t// If collapsed state is set then skip formats that doesn\'t match that\n
\t\t\t\t\t\tif ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (dom.is(parents[i], curFormat.selector)) {\n
\t\t\t\t\t\t\treturn parents[i];\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\tfunction findBlockEndPoint(container, sibling_name) {\n
\t\t\t\tvar node, root = dom.getRoot();\n
\n
\t\t\t\t// Expand to block of similar type\n
\t\t\t\tif (!format[0].wrapper) {\n
\t\t\t\t\tnode = dom.getParent(container, format[0].block, root);\n
\t\t\t\t}\n
\n
\t\t\t\t// Expand to first wrappable block element or any block element\n
\t\t\t\tif (!node) {\n
\t\t\t\t\tnode = dom.getParent(container.nodeType == 3 ? container.parentNode : container, function(node) {\n
\t\t\t\t\t\t// Fixes #6183 where it would expand to editable parent element in inline mode\n
\t\t\t\t\t\treturn node != root && isTextBlock(node);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\t// Exclude inner lists from wrapping\n
\t\t\t\tif (node && format[0].wrapper) {\n
\t\t\t\t\tnode = getParents(node, \'ul,ol\').reverse()[0] || node;\n
\t\t\t\t}\n
\n
\t\t\t\t// Didn\'t find a block element look for first/last wrappable element\n
\t\t\t\tif (!node) {\n
\t\t\t\t\tnode = container;\n
\n
\t\t\t\t\twhile (node[sibling_name] && !isBlock(node[sibling_name])) {\n
\t\t\t\t\t\tnode = node[sibling_name];\n
\n
\t\t\t\t\t\t// Break on BR but include it will be removed later on\n
\t\t\t\t\t\t// we can\'t remove it now since we need to check if it can be wrapped\n
\t\t\t\t\t\tif (isEq(node, \'br\')) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn node || container;\n
\t\t\t}\n
\n
\t\t\t// Expand to closest contentEditable element\n
\t\t\tstartContainer = findParentContentEditable(startContainer);\n
\t\t\tendContainer = findParentContentEditable(endContainer);\n
\n
\t\t\t// Exclude bookmark nodes if possible\n
\t\t\tif (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {\n
\t\t\t\tstartContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n
\t\t\t\tstartContainer = startContainer.nextSibling || startContainer;\n
\n
\t\t\t\tif (startContainer.nodeType == 3) {\n
\t\t\t\t\tstartOffset = 0;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {\n
\t\t\t\tendContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n
\t\t\t\tendContainer = endContainer.previousSibling || endContainer;\n
\n
\t\t\t\tif (endContainer.nodeType == 3) {\n
\t\t\t\t\tendOffset = endContainer.length;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (format[0].inline) {\n
\t\t\t\tif (rng.collapsed) {\n
\t\t\t\t\t// Expand left to closest word boundary\n
\t\t\t\t\tendPoint = findWordEndPoint(startContainer, startOffset, true);\n
\t\t\t\t\tif (endPoint) {\n
\t\t\t\t\t\tstartContainer = endPoint.container;\n
\t\t\t\t\t\tstartOffset = endPoint.offset;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Expand right to closest word boundary\n
\t\t\t\t\tendPoint = findWordEndPoint(endContainer, endOffset);\n
\t\t\t\t\tif (endPoint) {\n
\t\t\t\t\t\tendContainer = endPoint.container;\n
\t\t\t\t\t\tendOffset = endPoint.offset;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Avoid applying formatting to a trailing space.\n
\t\t\t\tleaf = findLeaf(endContainer, endOffset);\n
\t\t\t\tif (leaf.node) {\n
\t\t\t\t\twhile (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {\n
\t\t\t\t\t\tleaf = findLeaf(leaf.node.previousSibling);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&\n
\t\t\t\t\t\t\tleaf.node.nodeValue.charAt(leaf.offset - 1) === \' \') {\n
\n
\t\t\t\t\t\tif (leaf.offset > 1) {\n
\t\t\t\t\t\t\tendContainer = leaf.node;\n
\t\t\t\t\t\t\tendContainer.splitText(leaf.offset - 1);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Move start/end point up the tree if the leaves are sharp and if we are in different containers\n
\t\t\t// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!\n
\t\t\t// This will reduce the number of wrapper elements that needs to be created\n
\t\t\t// Move start point up the tree\n
\t\t\tif (format[0].inline || format[0].block_expand) {\n
\t\t\t\tif (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {\n
\t\t\t\t\tstartContainer = findParentContainer(true);\n
\t\t\t\t}\n
\n
\t\t\t\tif (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {\n
\t\t\t\t\tendContainer = findParentContainer();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Expand start/end container to matching selector\n
\t\t\tif (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {\n
\t\t\t\t// Find new startContainer/endContainer if there is better one\n
\t\t\t\tstartContainer = findSelectorEndPoint(startContainer, \'previousSibling\');\n
\t\t\t\tendContainer = findSelectorEndPoint(endContainer, \'nextSibling\');\n
\t\t\t}\n
\n
\t\t\t// Expand start/end container to matching block element or text node\n
\t\t\tif (format[0].block || format[0].selector) {\n
\t\t\t\t// Find new startContainer/endContainer if there is better one\n
\t\t\t\tstartContainer = findBlockEndPoint(startContainer, \'previousSibling\');\n
\t\t\t\tendContainer = findBlockEndPoint(endContainer, \'nextSibling\');\n
\n
\t\t\t\t// Non block element then try to expand up the leaf\n
\t\t\t\tif (format[0].block) {\n
\t\t\t\t\tif (!isBlock(startContainer)) {\n
\t\t\t\t\t\tstartContainer = findParentContainer(true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!isBlock(endContainer)) {\n
\t\t\t\t\t\tendContainer = findParentContainer();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Setup index for startContainer\n
\t\t\tif (startContainer.nodeType == 1) {\n
\t\t\t\tstartOffset = nodeIndex(startContainer);\n
\t\t\t\tstartContainer = startContainer.parentNode;\n
\t\t\t}\n
\n
\t\t\t// Setup index for endContainer\n
\t\t\tif (endContainer.nodeType == 1) {\n
\t\t\t\tendOffset = nodeIndex(endContainer) + 1;\n
\t\t\t\tendContainer = endContainer.parentNode;\n
\t\t\t}\n
\n
\t\t\t// Return new range like object\n
\t\t\treturn {\n
\t\t\t\tstartContainer: startContainer,\n
\t\t\t\tstartOffset: startOffset,\n
\t\t\t\tendContainer: endContainer,\n
\t\t\t\tendOffset: endOffset\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction isColorFormatAndAnchor(node, format) {\n
\t\t\treturn format.links && node.tagName == \'A\';\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes the specified format for the specified node. It will also remove the node if it doesn\'t have\n
\t\t * any attributes if the format specifies it to do so.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Object} format Format object with items to remove from node.\n
\t\t * @param {Object} vars Name/value object with variables to apply to format.\n
\t\t * @param {Node} node Node to remove the format styles on.\n
\t\t * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.\n
\t\t * @return {Boolean} True/false if the node was removed or not.\n
\t\t */\n
\t\tfunction removeFormat(format, vars, node, compare_node) {\n
\t\t\tvar i, attrs, stylesModified;\n
\n
\t\t\t// Check if node matches format\n
\t\t\tif (!matchName(node, format) && !isColorFormatAndAnchor(node, format)) {\n
\t\t\t\treturn FALSE;\n
\t\t\t}\n
\n
\t\t\t// Should we compare with format attribs and styles\n
\t\t\tif (format.remove != \'all\') {\n
\t\t\t\t// Remove styles\n
\t\t\t\teach(format.styles, function(value, name) {\n
\t\t\t\t\tvalue = normalizeStyleValue(replaceVars(value, vars), name);\n
\n
\t\t\t\t\t// Indexed array\n
\t\t\t\t\tif (typeof name === \'number\') {\n
\t\t\t\t\t\tname = value;\n
\t\t\t\t\t\tcompare_node = 0;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (format.remove_similar || (!compare_node || isEq(getStyle(compare_node, name), value))) {\n
\t\t\t\t\t\tdom.setStyle(node, name, \'\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstylesModified = 1;\n
\t\t\t\t});\n
\n
\t\t\t\t// Remove style attribute if it\'s empty\n
\t\t\t\tif (stylesModified && dom.getAttrib(node, \'style\') === \'\') {\n
\t\t\t\t\tnode.removeAttribute(\'style\');\n
\t\t\t\t\tnode.removeAttribute(\'data-mce-style\');\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove attributes\n
\t\t\t\teach(format.attributes, function(value, name) {\n
\t\t\t\t\tvar valueOut;\n
\n
\t\t\t\t\tvalue = replaceVars(value, vars);\n
\n
\t\t\t\t\t// Indexed array\n
\t\t\t\t\tif (typeof name === \'number\') {\n
\t\t\t\t\t\tname = value;\n
\t\t\t\t\t\tcompare_node = 0;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {\n
\t\t\t\t\t\t// Keep internal classes\n
\t\t\t\t\t\tif (name == \'class\') {\n
\t\t\t\t\t\t\tvalue = dom.getAttrib(node, name);\n
\t\t\t\t\t\t\tif (value) {\n
\t\t\t\t\t\t\t\t// Build new class value where everything is removed except the internal prefixed classes\n
\t\t\t\t\t\t\t\tvalueOut = \'\';\n
\t\t\t\t\t\t\t\teach(value.split(/\\s+/), function(cls) {\n
\t\t\t\t\t\t\t\t\tif (/mce\\-\\w+/.test(cls)) {\n
\t\t\t\t\t\t\t\t\t\tvalueOut += (valueOut ? \' \' : \'\') + cls;\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t\t\t// We got some internal classes left\n
\t\t\t\t\t\t\t\tif (valueOut) {\n
\t\t\t\t\t\t\t\t\tdom.setAttrib(node, name, valueOut);\n
\t\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// IE6 has a bug where the attribute doesn\'t get removed correctly\n
\t\t\t\t\t\tif (name == "class") {\n
\t\t\t\t\t\t\tnode.removeAttribute(\'className\');\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Remove mce prefixed attributes\n
\t\t\t\t\t\tif (MCE_ATTR_RE.test(name)) {\n
\t\t\t\t\t\t\tnode.removeAttribute(\'data-mce-\' + name);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode.removeAttribute(name);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Remove classes\n
\t\t\t\teach(format.classes, function(value) {\n
\t\t\t\t\tvalue = replaceVars(value, vars);\n
\n
\t\t\t\t\tif (!compare_node || dom.hasClass(compare_node, value)) {\n
\t\t\t\t\t\tdom.removeClass(node, value);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Check for non internal attributes\n
\t\t\t\tattrs = dom.getAttribs(node);\n
\t\t\t\tfor (i = 0; i < attrs.length; i++) {\n
\t\t\t\t\tif (attrs[i].nodeName.indexOf(\'_\') !== 0) {\n
\t\t\t\t\t\treturn FALSE;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Remove the inline child if it\'s empty for example <b> or <span>\n
\t\t\tif (format.remove != \'none\') {\n
\t\t\t\tremoveNode(node, format);\n
\t\t\t\treturn TRUE;\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes the node and wrap it\'s children in paragraphs before doing so or\n
\t\t * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.\n
\t\t *\n
\t\t * If the div in the node below gets removed:\n
\t\t *  text<div>text</div>text\n
\t\t *\n
\t\t * Output becomes:\n
\t\t *  text<div><br />text<br /></div>text\n
\t\t *\n
\t\t * So when the div is removed the result is:\n
\t\t *  text<br />text<br />text\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} node Node to remove + apply BR/P elements to.\n
\t\t * @param {Object} format Format rule.\n
\t\t * @return {Node} Input node.\n
\t\t */\n
\t\tfunction removeNode(node, format) {\n
\t\t\tvar parentNode = node.parentNode, rootBlockElm;\n
\n
\t\t\tfunction find(node, next, inc) {\n
\t\t\t\tnode = getNonWhiteSpaceSibling(node, next, inc);\n
\n
\t\t\t\treturn !node || (node.nodeName == \'BR\' || isBlock(node));\n
\t\t\t}\n
\n
\t\t\tif (format.block) {\n
\t\t\t\tif (!forcedRootBlock) {\n
\t\t\t\t\t// Append BR elements if needed before we remove the block\n
\t\t\t\t\tif (isBlock(node) && !isBlock(parentNode)) {\n
\t\t\t\t\t\tif (!find(node, FALSE) && !find(node.firstChild, TRUE, 1)) {\n
\t\t\t\t\t\t\tnode.insertBefore(dom.create(\'br\'), node.firstChild);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (!find(node, TRUE) && !find(node.lastChild, FALSE, 1)) {\n
\t\t\t\t\t\t\tnode.appendChild(dom.create(\'br\'));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// Wrap the block in a forcedRootBlock if we are at the root of document\n
\t\t\t\t\tif (parentNode == dom.getRoot()) {\n
\t\t\t\t\t\tif (!format.list_block || !isEq(node, format.list_block)) {\n
\t\t\t\t\t\t\teach(grep(node.childNodes), function(node) {\n
\t\t\t\t\t\t\t\tif (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {\n
\t\t\t\t\t\t\t\t\tif (!rootBlockElm) {\n
\t\t\t\t\t\t\t\t\t\trootBlockElm = wrap(node, forcedRootBlock);\n
\t\t\t\t\t\t\t\t\t\tdom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);\n
\t\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\t\trootBlockElm.appendChild(node);\n
\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\trootBlockElm = 0;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Never remove nodes that isn\'t the specified inline element if a selector is specified too\n
\t\t\tif (format.selector && format.inline && !isEq(format.inline, node)) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tdom.remove(node, 1);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the next/previous non whitespace node.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} node Node to start at.\n
\t\t * @param {boolean} next (Optional) Include next or previous node defaults to previous.\n
\t\t * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.\n
\t\t * @return {Node} Next or previous node or undefined if it wasn\'t found.\n
\t\t */\n
\t\tfunction getNonWhiteSpaceSibling(node, next, inc) {\n
\t\t\tif (node) {\n
\t\t\t\tnext = next ? \'nextSibling\' : \'previousSibling\';\n
\n
\t\t\t\tfor (node = inc ? node : node[next]; node; node = node[next]) {\n
\t\t\t\t\tif (node.nodeType == 1 || !isWhiteSpaceNode(node)) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Merges the next/previous sibling element if they match.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Node} prev Previous node to compare/merge.\n
\t\t * @param {Node} next Next node to compare/merge.\n
\t\t * @return {Node} Next node if we didn\'t merge and prev node if we did.\n
\t\t */\n
\t\tfunction mergeSiblings(prev, next) {\n
\t\t\tvar sibling, tmpSibling, elementUtils = new ElementUtils(dom);\n
\n
\t\t\tfunction findElementSibling(node, sibling_name) {\n
\t\t\t\tfor (sibling = node; sibling; sibling = sibling[sibling_name]) {\n
\t\t\t\t\tif (sibling.nodeType == 3 && sibling.nodeValue.length !== 0) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (sibling.nodeType == 1 && !isBookmarkNode(sibling)) {\n
\t\t\t\t\t\treturn sibling;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn node;\n
\t\t\t}\n
\n
\t\t\t// Check if next/prev exists and that they are elements\n
\t\t\tif (prev && next) {\n
\t\t\t\t// If previous sibling is empty then jump over it\n
\t\t\t\tprev = findElementSibling(prev, \'previousSibling\');\n
\t\t\t\tnext = findElementSibling(next, \'nextSibling\');\n
\n
\t\t\t\t// Compare next and previous nodes\n
\t\t\t\tif (elementUtils.compare(prev, next)) {\n
\t\t\t\t\t// Append nodes between\n
\t\t\t\t\tfor (sibling = prev.nextSibling; sibling && sibling != next;) {\n
\t\t\t\t\t\ttmpSibling = sibling;\n
\t\t\t\t\t\tsibling = sibling.nextSibling;\n
\t\t\t\t\t\tprev.appendChild(tmpSibling);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Remove next node\n
\t\t\t\t\tdom.remove(next);\n
\n
\t\t\t\t\t// Move children into prev node\n
\t\t\t\t\teach(grep(next.childNodes), function(node) {\n
\t\t\t\t\t\tprev.appendChild(node);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\treturn prev;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn next;\n
\t\t}\n
\n
\t\tfunction getContainer(rng, start) {\n
\t\t\tvar container, offset, lastIdx;\n
\n
\t\t\tcontainer = rng[start ? \'startContainer\' : \'endContainer\'];\n
\t\t\toffset = rng[start ? \'startOffset\' : \'endOffset\'];\n
\n
\t\t\tif (container.nodeType == 1) {\n
\t\t\t\tlastIdx = container.childNodes.length - 1;\n
\n
\t\t\t\tif (!start && offset) {\n
\t\t\t\t\toffset--;\n
\t\t\t\t}\n
\n
\t\t\t\tcontainer = container.childNodes[offset > lastIdx ? lastIdx : offset];\n
\t\t\t}\n
\n
\t\t\t// If start text node is excluded then walk to the next node\n
\t\t\tif (container.nodeType === 3 && start && offset >= container.nodeValue.length) {\n
\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).next() || container;\n
\t\t\t}\n
\n
\t\t\t// If end text node is excluded then walk to the previous node\n
\t\t\tif (container.nodeType === 3 && !start && offset === 0) {\n
\t\t\t\tcontainer = new TreeWalker(container, ed.getBody()).prev() || container;\n
\t\t\t}\n
\n
\t\t\treturn container;\n
\t\t}\n
\n
\t\tfunction performCaretAction(type, name, vars, similar) {\n
\t\t\tvar caretContainerId = \'_mce_caret\', debug = ed.settings.caret_debug;\n
\n
\t\t\t// Creates a caret container bogus element\n
\t\t\tfunction createCaretContainer(fill) {\n
\t\t\t\tvar caretContainer = dom.create(\'span\', {id: caretContainerId, \'data-mce-bogus\': true, style: debug ? \'color:red\' : \'\'});\n
\n
\t\t\t\tif (fill) {\n
\t\t\t\t\tcaretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));\n
\t\t\t\t}\n
\n
\t\t\t\treturn caretContainer;\n
\t\t\t}\n
\n
\t\t\tfunction isCaretContainerEmpty(node, nodes) {\n
\t\t\t\twhile (node) {\n
\t\t\t\t\tif ((node.nodeType === 3 && node.nodeValue !== INVISIBLE_CHAR) || node.childNodes.length > 1) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Collect nodes\n
\t\t\t\t\tif (nodes && node.nodeType === 1) {\n
\t\t\t\t\t\tnodes.push(node);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.firstChild;\n
\t\t\t\t}\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Returns any parent caret container element\n
\t\t\tfunction getParentCaretContainer(node) {\n
\t\t\t\twhile (node) {\n
\t\t\t\t\tif (node.id === caretContainerId) {\n
\t\t\t\t\t\treturn node;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Finds the first text node in the specified node\n
\t\t\tfunction findFirstTextNode(node) {\n
\t\t\t\tvar walker;\n
\n
\t\t\t\tif (node) {\n
\t\t\t\t\twalker = new TreeWalker(node, node);\n
\n
\t\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\n
\t\t\t\t\t\tif (node.nodeType === 3) {\n
\t\t\t\t\t\t\treturn node;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Removes the caret container for the specified node or all on the current document\n
\t\t\tfunction removeCaretContainer(node, move_caret) {\n
\t\t\t\tvar child, rng;\n
\n
\t\t\t\tif (!node) {\n
\t\t\t\t\tnode = getParentCaretContainer(selection.getStart());\n
\n
\t\t\t\t\tif (!node) {\n
\t\t\t\t\t\twhile ((node = dom.get(caretContainerId))) {\n
\t\t\t\t\t\t\tremoveCaretContainer(node, false);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\trng = selection.getRng(true);\n
\n
\t\t\t\t\tif (isCaretContainerEmpty(node)) {\n
\t\t\t\t\t\tif (move_caret !== false) {\n
\t\t\t\t\t\t\trng.setStartBefore(node);\n
\t\t\t\t\t\t\trng.setEndBefore(node);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tdom.remove(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tchild = findFirstTextNode(node);\n
\n
\t\t\t\t\t\tif (child.nodeValue.charAt(0) === INVISIBLE_CHAR) {\n
\t\t\t\t\t\t\tchild.deleteData(0, 1);\n
\n
\t\t\t\t\t\t\t// Fix for bug #6976\n
\t\t\t\t\t\t\tif (rng.startContainer == child && rng.startOffset > 0) {\n
\t\t\t\t\t\t\t\trng.setStart(child, rng.startOffset - 1);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (rng.endContainer == child && rng.endOffset > 0) {\n
\t\t\t\t\t\t\t\trng.setEnd(child, rng.endOffset - 1);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tdom.remove(node, 1);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Applies formatting to the caret postion\n
\t\t\tfunction applyCaretFormat() {\n
\t\t\t\tvar rng, caretContainer, textNode, offset, bookmark, container, text;\n
\n
\t\t\t\trng = selection.getRng(true);\n
\t\t\t\toffset = rng.startOffset;\n
\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\ttext = container.nodeValue;\n
\n
\t\t\t\tcaretContainer = getParentCaretContainer(selection.getStart());\n
\t\t\t\tif (caretContainer) {\n
\t\t\t\t\ttextNode = findFirstTextNode(caretContainer);\n
\t\t\t\t}\n
\n
\t\t\t\t// Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character\n
\t\t\t\tif (text && offset > 0 && offset < text.length && /\\w/.test(text.charAt(offset)) && /\\w/.test(text.charAt(offset - 1))) {\n
\t\t\t\t\t// Get bookmark of caret position\n
\t\t\t\t\tbookmark = selection.getBookmark();\n
\n
\t\t\t\t\t// Collapse bookmark range (WebKit)\n
\t\t\t\t\trng.collapse(true);\n
\n
\t\t\t\t\t// Expand the range to the closest word and split it at those points\n
\t\t\t\t\trng = expandRng(rng, get(name));\n
\t\t\t\t\trng = rangeUtils.split(rng);\n
\n
\t\t\t\t\t// Apply the format to the range\n
\t\t\t\t\tapply(name, vars, rng);\n
\n
\t\t\t\t\t// Move selection back to caret position\n
\t\t\t\t\tselection.moveToBookmark(bookmark);\n
\t\t\t\t} else {\n
\t\t\t\t\tif (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {\n
\t\t\t\t\t\tcaretContainer = createCaretContainer(true);\n
\t\t\t\t\t\ttextNode = caretContainer.firstChild;\n
\n
\t\t\t\t\t\trng.insertNode(caretContainer);\n
\t\t\t\t\t\toffset = 1;\n
\n
\t\t\t\t\t\tapply(name, vars, caretContainer);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tapply(name, vars, caretContainer);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Move selection to text node\n
\t\t\t\t\tselection.setCursorLocation(textNode, offset);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction removeCaretFormat() {\n
\t\t\t\tvar rng = selection.getRng(true), container, offset, bookmark,\n
\t\t\t\t\thasContentAfter, node, formatNode, parents = [], i, caretContainer;\n
\n
\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\toffset = rng.startOffset;\n
\t\t\t\tnode = container;\n
\n
\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\tif (offset != container.nodeValue.length) {\n
\t\t\t\t\t\thasContentAfter = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\twhile (node) {\n
\t\t\t\t\tif (matchNode(node, name, vars, similar)) {\n
\t\t\t\t\t\tformatNode = node;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (node.nextSibling) {\n
\t\t\t\t\t\thasContentAfter = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparents.push(node);\n
\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\t// Node doesn\'t have the specified format\n
\t\t\t\tif (!formatNode) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Is there contents after the caret then remove the format on the element\n
\t\t\t\tif (hasContentAfter) {\n
\t\t\t\t\t// Get bookmark of caret position\n
\t\t\t\t\tbookmark = selection.getBookmark();\n
\n
\t\t\t\t\t// Collapse bookmark range (WebKit)\n
\t\t\t\t\trng.collapse(true);\n
\n
\t\t\t\t\t// Expand the range to the closest word and split it at those points\n
\t\t\t\t\trng = expandRng(rng, get(name), true);\n
\t\t\t\t\trng = rangeUtils.split(rng);\n
\n
\t\t\t\t\t// Remove the format from the range\n
\t\t\t\t\tremove(name, vars, rng);\n
\n
\t\t\t\t\t// Move selection back to caret position\n
\t\t\t\t\tselection.moveToBookmark(bookmark);\n
\t\t\t\t} else {\n
\t\t\t\t\tcaretContainer = createCaretContainer();\n
\n
\t\t\t\t\tnode = caretContainer;\n
\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\n
\t\t\t\t\t\tnode.appendChild(dom.clone(parents[i], false));\n
\t\t\t\t\t\tnode = node.firstChild;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Insert invisible character into inner most format element\n
\t\t\t\t\tnode.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));\n
\t\t\t\t\tnode = node.firstChild;\n
\n
\t\t\t\t\tvar block = dom.getParent(formatNode, isTextBlock);\n
\n
\t\t\t\t\tif (block && dom.isEmpty(block)) {\n
\t\t\t\t\t\t// Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>\n
\t\t\t\t\t\tformatNode.parentNode.replaceChild(caretContainer, formatNode);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Insert caret container after the formated node\n
\t\t\t\t\t\tdom.insertAfter(caretContainer, formatNode);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Move selection to text node\n
\t\t\t\t\tselection.setCursorLocation(node, 1);\n
\n
\t\t\t\t\t// If the formatNode is empty, we can remove it safely.\n
\t\t\t\t\tif (dom.isEmpty(formatNode)) {\n
\t\t\t\t\t\tdom.remove(formatNode);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Checks if the parent caret container node isn\'t empty if that is the case it\n
\t\t\t// will remove the bogus state on all children that isn\'t empty\n
\t\t\tfunction unmarkBogusCaretParents() {\n
\t\t\t\tvar caretContainer;\n
\n
\t\t\t\tcaretContainer = getParentCaretContainer(selection.getStart());\n
\t\t\t\tif (caretContainer && !dom.isEmpty(caretContainer)) {\n
\t\t\t\t\twalk(caretContainer, function(node) {\n
\t\t\t\t\t\tif (node.nodeType == 1 && node.id !== caretContainerId && !dom.isEmpty(node)) {\n
\t\t\t\t\t\t\tdom.setAttrib(node, \'data-mce-bogus\', null);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}, \'childNodes\');\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Only bind the caret events once\n
\t\t\tif (!ed._hasCaretEvents) {\n
\t\t\t\t// Mark current caret container elements as bogus when getting the contents so we don\'t end up with empty elements\n
\t\t\t\tmarkCaretContainersBogus = function() {\n
\t\t\t\t\tvar nodes = [], i;\n
\n
\t\t\t\t\tif (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {\n
\t\t\t\t\t\t// Mark children\n
\t\t\t\t\t\ti = nodes.length;\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tdom.setAttrib(nodes[i], \'data-mce-bogus\', \'1\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\tdisableCaretContainer = function(e) {\n
\t\t\t\t\tvar keyCode = e.keyCode;\n
\n
\t\t\t\t\tremoveCaretContainer();\n
\n
\t\t\t\t\t// Remove caret container on keydown and it\'s a backspace, enter or left/right arrow keys\n
\t\t\t\t\t// Backspace key needs to check if the range is collapsed due to bug #6780\n
\t\t\t\t\tif ((keyCode == 8 && selection.isCollapsed()) || keyCode == 37 || keyCode == 39) {\n
\t\t\t\t\t\tremoveCaretContainer(getParentCaretContainer(selection.getStart()));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tunmarkBogusCaretParents();\n
\t\t\t\t};\n
\n
\t\t\t\t// Remove bogus state if they got filled by contents using editor.selection.setContent\n
\t\t\t\ted.on(\'SetContent\', function(e) {\n
\t\t\t\t\tif (e.selection) {\n
\t\t\t\t\t\tunmarkBogusCaretParents();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t\ted._hasCaretEvents = true;\n
\t\t\t}\n
\n
\t\t\t// Do apply or remove caret format\n
\t\t\tif (type == "apply") {\n
\t\t\t\tapplyCaretFormat();\n
\t\t\t} else {\n
\t\t\t\tremoveCaretFormat();\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the start to the first suitable text node.\n
\t\t */\n
\t\tfunction moveStart(rng) {\n
\t\t\tvar container = rng.startContainer,\n
\t\t\t\t\toffset = rng.startOffset, isAtEndOfText,\n
\t\t\t\t\twalker, node, nodes, tmpNode;\n
\n
\t\t\tif (rng.startContainer == rng.endContainer) {\n
\t\t\t\tif (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Convert text node into index if possible\n
\t\t\tif (container.nodeType == 3 && offset >= container.nodeValue.length) {\n
\t\t\t\t// Get the parent container location and walk from there\n
\t\t\t\toffset = nodeIndex(container);\n
\t\t\t\tcontainer = container.parentNode;\n
\t\t\t\tisAtEndOfText = true;\n
\t\t\t}\n
\n
\t\t\t// Move startContainer/startOffset in to a suitable node\n
\t\t\tif (container.nodeType == 1) {\n
\t\t\t\tnodes = container.childNodes;\n
\t\t\t\tcontainer = nodes[Math.min(offset, nodes.length - 1)];\n
\t\t\t\twalker = new TreeWalker(container, dom.getParent(container, dom.isBlock));\n
\n
\t\t\t\t// If offset is at end of the parent node walk to the next one\n
\t\t\t\tif (offset > nodes.length - 1 || isAtEndOfText) {\n
\t\t\t\t\twalker.next();\n
\t\t\t\t}\n
\n
\t\t\t\tfor (node = walker.current(); node; node = walker.next()) {\n
\t\t\t\t\tif (node.nodeType == 3 && !isWhiteSpaceNode(node)) {\n
\t\t\t\t\t\t// IE has a "neat" feature where it moves the start node into the closest element\n
\t\t\t\t\t\t// we can avoid this by inserting an element before it and then remove it after we set the selection\n
\t\t\t\t\t\ttmpNode = dom.create(\'a\', {\'data-mce-bogus\': \'all\'}, INVISIBLE_CHAR);\n
\t\t\t\t\t\tnode.parentNode.insertBefore(tmpNode, node);\n
\n
\t\t\t\t\t\t// Set selection and remove tmpNode\n
\t\t\t\t\t\trng.setStart(node, 0);\n
\t\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t\t\tdom.remove(tmpNode);\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/UndoManager.js\n
\n
/**\n
 * UndoManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles the undo/redo history levels for the editor. Since the build in undo/redo has major drawbacks a custom one was needed.\n
 *\n
 * @class tinymce.UndoManager\n
 */\n
define("tinymce/UndoManager", [\n
\t"tinymce/util/VK",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/html/SaxParser"\n
], function(VK, Env, Tools, SaxParser) {\n
\tvar trim = Tools.trim, trimContentRegExp;\n
\n
\ttrimContentRegExp = new RegExp([\n
\t\t\'<span[^>]+data-mce-bogus[^>]+>[\\u200B\\uFEFF]+<\\\\/span>\', // Trim bogus spans like caret containers\n
\t\t\'\\\\s?data-mce-selected="[^"]+"\' // Trim temporaty data-mce prefixed attributes like data-mce-selected\n
\t].join(\'|\'), \'gi\');\n
\n
\treturn function(editor) {\n
\t\tvar self = this, index = 0, data = [], beforeBookmark, isFirstTypedCharacter, locks = 0;\n
\n
\t\t/**\n
\t\t * Returns a trimmed version of the editor contents to be used for the undo level. This\n
\t\t * will remove any data-mce-bogus="all" marked elements since these are used for UI it will also\n
\t\t * remove the data-mce-selected attributes used for selection of objects and caret containers.\n
\t\t * It will keep all data-mce-bogus="1" elements since these can be used to place the caret etc and will\n
\t\t * be removed by the serialization logic when you save.\n
\t\t *\n
\t\t * @private\n
\t\t * @return {String} HTML contents of the editor excluding some internal bogus elements.\n
\t\t */\n
\t\tfunction getContent() {\n
\t\t\tvar content = editor.getContent({format: \'raw\', no_events: 1});\n
\t\t\tvar bogusAllRegExp = /<(\\w+) [^>]*data-mce-bogus="all"[^>]*>/g;\n
\t\t\tvar endTagIndex, index, matchLength, matches, shortEndedElements, schema = editor.schema;\n
\n
\t\t\tcontent = content.replace(trimContentRegExp, \'\');\n
\t\t\tshortEndedElements = schema.getShortEndedElements();\n
\n
\t\t\t// Remove all bogus elements marked with "all"\n
\t\t\twhile ((matches = bogusAllRegExp.exec(content))) {\n
\t\t\t\tindex = bogusAllRegExp.lastIndex;\n
\t\t\t\tmatchLength = matches[0].length;\n
\n
\t\t\t\tif (shortEndedElements[matches[1]]) {\n
\t\t\t\t\tendTagIndex = index;\n
\t\t\t\t} else {\n
\t\t\t\t\tendTagIndex = SaxParser.findEndTag(schema, content, index);\n
\t\t\t\t}\n
\n
\t\t\t\tcontent = content.substring(0, index - matchLength) + content.substring(endTagIndex);\n
\t\t\t\tbogusAllRegExp.lastIndex = index - matchLength;\n
\t\t\t}\n
\n
\t\t\treturn trim(content);\n
\t\t}\n
\n
\t\tfunction setDirty(state) {\n
\t\t\teditor.isNotDirty = !state;\n
\t\t}\n
\n
\t\tfunction addNonTypingUndoLevel(e) {\n
\t\t\tself.typing = false;\n
\t\t\tself.add({}, e);\n
\t\t}\n
\n
\t\t// Add initial undo level when the editor is initialized\n
\t\teditor.on(\'init\', function() {\n
\t\t\tself.add();\n
\t\t});\n
\n
\t\t// Get position before an execCommand is processed\n
\t\teditor.on(\'BeforeExecCommand\', function(e) {\n
\t\t\tvar cmd = e.command;\n
\n
\t\t\tif (cmd != \'Undo\' && cmd != \'Redo\' && cmd != \'mceRepaint\') {\n
\t\t\t\tself.beforeChange();\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Add undo level after an execCommand call was made\n
\t\teditor.on(\'ExecCommand\', function(e) {\n
\t\t\tvar cmd = e.command;\n
\n
\t\t\tif (cmd != \'Undo\' && cmd != \'Redo\' && cmd != \'mceRepaint\') {\n
\t\t\t\taddNonTypingUndoLevel(e);\n
\t\t\t}\n
\t\t});\n
\n
\t\teditor.on(\'ObjectResizeStart\', function() {\n
\t\t\tself.beforeChange();\n
\t\t});\n
\n
\t\teditor.on(\'SaveContent ObjectResized blur\', addNonTypingUndoLevel);\n
\t\teditor.on(\'DragEnd\', addNonTypingUndoLevel);\n
\n
\t\teditor.on(\'KeyUp\', function(e) {\n
\t\t\tvar keyCode = e.keyCode;\n
\n
\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45 || keyCode == 13 || e.ctrlKey) {\n
\t\t\t\taddNonTypingUndoLevel();\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\n
\t\t\tif (keyCode == 46 || keyCode == 8 || (Env.mac && (keyCode == 91 || keyCode == 93))) {\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\n
\t\t\t// Fire a TypingUndo event on the first character entered\n
\t\t\tif (isFirstTypedCharacter && self.typing) {\n
\t\t\t\t// Make it dirty if the content was changed after typing the first character\n
\t\t\t\tif (!editor.isDirty()) {\n
\t\t\t\t\tsetDirty(data[0] && getContent() != data[0].content);\n
\n
\t\t\t\t\t// Fire initial change event\n
\t\t\t\t\tif (!editor.isNotDirty) {\n
\t\t\t\t\t\teditor.fire(\'change\', {level: data[0], lastLevel: null});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\teditor.fire(\'TypingUndo\');\n
\t\t\t\tisFirstTypedCharacter = false;\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\t\t});\n
\n
\t\teditor.on(\'KeyDown\', function(e) {\n
\t\t\tvar keyCode = e.keyCode;\n
\n
\t\t\t// Is caracter positon keys left,right,up,down,home,end,pgdown,pgup,enter\n
\t\t\tif ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45) {\n
\t\t\t\tif (self.typing) {\n
\t\t\t\t\taddNonTypingUndoLevel(e);\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// If key isn\'t Ctrl+Alt/AltGr\n
\t\t\tvar modKey = (e.ctrlKey && !e.altKey) || e.metaKey;\n
\t\t\tif ((keyCode < 16 || keyCode > 20) && keyCode != 224 && keyCode != 91 && !self.typing && !modKey) {\n
\t\t\t\tself.beforeChange();\n
\t\t\t\tself.typing = true;\n
\t\t\t\tself.add({}, e);\n
\t\t\t\tisFirstTypedCharacter = true;\n
\t\t\t}\n
\t\t});\n
\n
\t\teditor.on(\'MouseDown\', function(e) {\n
\t\t\tif (self.typing) {\n
\t\t\t\taddNonTypingUndoLevel(e);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Add keyboard shortcuts for undo/redo keys\n
\t\teditor.addShortcut(\'meta+z\', \'\', \'Undo\');\n
\t\teditor.addShortcut(\'meta+y,meta+shift+z\', \'\', \'Redo\');\n
\n
\t\teditor.on(\'AddUndo Undo Redo ClearUndos\', function(e) {\n
\t\t\tif (!e.isDefaultPrevented()) {\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\t\t});\n
\n
\t\t/*eslint consistent-this:0 */\n
\t\tself = {\n
\t\t\t// Explose for debugging reasons\n
\t\t\tdata: data,\n
\n
\t\t\t/**\n
\t\t\t * State if the user is currently typing or not. This will add a typing operation into one undo\n
\t\t\t * level instead of one new level for each keystroke.\n
\t\t\t *\n
\t\t\t * @field {Boolean} typing\n
\t\t\t */\n
\t\t\ttyping: false,\n
\n
\t\t\t/**\n
\t\t\t * Stores away a bookmark to be used when performing an undo action so that the selection is before\n
\t\t\t * the change has been made.\n
\t\t\t *\n
\t\t\t * @method beforeChange\n
\t\t\t */\n
\t\t\tbeforeChange: function() {\n
\t\t\t\tif (!locks) {\n
\t\t\t\t\tbeforeBookmark = editor.selection.getBookmark(2, true);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Adds a new undo level/snapshot to the undo list.\n
\t\t\t *\n
\t\t\t * @method add\n
\t\t\t * @param {Object} level Optional undo level object to add.\n
\t\t\t * @param {DOMEvent} Event Optional event responsible for the creation of the undo level.\n
\t\t\t * @return {Object} Undo level that got added or null it a level wasn\'t needed.\n
\t\t\t */\n
\t\t\tadd: function(level, event) {\n
\t\t\t\tvar i, settings = editor.settings, lastLevel;\n
\n
\t\t\t\tlevel = level || {};\n
\t\t\t\tlevel.content = getContent();\n
\n
\t\t\t\tif (locks || editor.removed) {\n
\t\t\t\t\treturn null;\n
\t\t\t\t}\n
\n
\t\t\t\tlastLevel = data[index];\n
\t\t\t\tif (editor.fire(\'BeforeAddUndo\', {level: level, lastLevel: lastLevel, originalEvent: event}).isDefaultPrevented()) {\n
\t\t\t\t\treturn null;\n
\t\t\t\t}\n
\n
\t\t\t\t// Add undo level if needed\n
\t\t\t\tif (lastLevel && lastLevel.content == level.content) {\n
\t\t\t\t\treturn null;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set before bookmark on previous level\n
\t\t\t\tif (data[index]) {\n
\t\t\t\t\tdata[index].beforeBookmark = beforeBookmark;\n
\t\t\t\t}\n
\n
\t\t\t\t// Time to compress\n
\t\t\t\tif (settings.custom_undo_redo_levels) {\n
\t\t\t\t\tif (data.length > settings.custom_undo_redo_levels) {\n
\t\t\t\t\t\tfor (i = 0; i < data.length - 1; i++) {\n
\t\t\t\t\t\t\tdata[i] = data[i + 1];\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tdata.length--;\n
\t\t\t\t\t\tindex = data.length;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Get a non intrusive normalized bookmark\n
\t\t\t\tlevel.bookmark = editor.selection.getBookmark(2, true);\n
\n
\t\t\t\t// Crop array if needed\n
\t\t\t\tif (index < data.length - 1) {\n
\t\t\t\t\tdata.length = index + 1;\n
\t\t\t\t}\n
\n
\t\t\t\tdata.push(level);\n
\t\t\t\tindex = data.length - 1;\n
\n
\t\t\t\tvar args = {level: level, lastLevel: lastLevel, originalEvent: event};\n
\n
\t\t\t\teditor.fire(\'AddUndo\', args);\n
\n
\t\t\t\tif (index > 0) {\n
\t\t\t\t\tsetDirty(true);\n
\t\t\t\t\teditor.fire(\'change\', args);\n
\t\t\t\t}\n
\n
\t\t\t\treturn level;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Undoes the last action.\n
\t\t\t *\n
\t\t\t * @method undo\n
\t\t\t * @return {Object} Undo level or null if no undo was performed.\n
\t\t\t */\n
\t\t\tundo: function() {\n
\t\t\t\tvar level;\n
\n
\t\t\t\tif (self.typing) {\n
\t\t\t\t\tself.add();\n
\t\t\t\t\tself.typing = false;\n
\t\t\t\t}\n
\n
\t\t\t\tif (index > 0) {\n
\t\t\t\t\tlevel = data[--index];\n
\n
\t\t\t\t\t// Undo to first index then set dirty state to false\n
\t\t\t\t\tif (index === 0) {\n
\t\t\t\t\t\tsetDirty(false);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teditor.setContent(level.content, {format: \'raw\'});\n
\t\t\t\t\teditor.selection.moveToBookmark(level.beforeBookmark);\n
\n
\t\t\t\t\teditor.fire(\'undo\', {level: level});\n
\t\t\t\t}\n
\n
\t\t\t\treturn level;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Redoes the last action.\n
\t\t\t *\n
\t\t\t * @method redo\n
\t\t\t * @return {Object} Redo level or null if no redo was performed.\n
\t\t\t */\n
\t\t\tredo: function() {\n
\t\t\t\tvar level;\n
\n
\t\t\t\tif (index < data.length - 1) {\n
\t\t\t\t\tlevel = data[++index];\n
\n
\t\t\t\t\teditor.setContent(level.content, {format: \'raw\'});\n
\t\t\t\t\teditor.selection.moveToBookmark(level.bookmark);\n
\t\t\t\t\tsetDirty(true);\n
\n
\t\t\t\t\teditor.fire(\'redo\', {level: level});\n
\t\t\t\t}\n
\n
\t\t\t\treturn level;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Removes all undo levels.\n
\t\t\t *\n
\t\t\t * @method clear\n
\t\t\t */\n
\t\t\tclear: function() {\n
\t\t\t\tdata = [];\n
\t\t\t\tindex = 0;\n
\t\t\t\tself.typing = false;\n
\t\t\t\teditor.fire(\'ClearUndos\');\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Returns true/false if the undo manager has any undo levels.\n
\t\t\t *\n
\t\t\t * @method hasUndo\n
\t\t\t * @return {Boolean} true/false if the undo manager has any undo levels.\n
\t\t\t */\n
\t\t\thasUndo: function() {\n
\t\t\t\t// Has undo levels or typing and content isn\'t the same as the initial level\n
\t\t\t\treturn index > 0 || (self.typing && data[0] && getContent() != data[0].content);\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Returns true/false if the undo manager has any redo levels.\n
\t\t\t *\n
\t\t\t * @method hasRedo\n
\t\t\t * @return {Boolean} true/false if the undo manager has any redo levels.\n
\t\t\t */\n
\t\t\thasRedo: function() {\n
\t\t\t\treturn index < data.length - 1 && !this.typing;\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Executes the specified function in an undo transation. The selection\n
\t\t\t * before the modification will be stored to the undo stack and if the DOM changes\n
\t\t\t * it will add a new undo level. Any methods within the transation that adds undo levels will\n
\t\t\t * be ignored. So a transation can include calls to execCommand or editor.insertContent.\n
\t\t\t *\n
\t\t\t * @method transact\n
\t\t\t * @param {function} callback Function to execute dom manipulation logic in.\n
\t\t\t */\n
\t\t\ttransact: function(callback) {\n
\t\t\t\tself.beforeChange();\n
\n
\t\t\t\ttry {\n
\t\t\t\t\tlocks++;\n
\t\t\t\t\tcallback();\n
\t\t\t\t} finally {\n
\t\t\t\t\tlocks--;\n
\t\t\t\t}\n
\n
\t\t\t\tself.add();\n
\t\t\t}\n
\t\t};\n
\n
\t\treturn self;\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/EnterKey.js\n
\n
/**\n
 * EnterKey.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Contains logic for handling the enter key to split/generate block elements.\n
 */\n
define("tinymce/EnterKey", [\n
\t"tinymce/dom/TreeWalker",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/Env"\n
], function(TreeWalker, RangeUtils, Env) {\n
\tvar isIE = Env.ie && Env.ie < 11;\n
\n
\treturn function(editor) {\n
\t\tvar dom = editor.dom, selection = editor.selection, settings = editor.settings;\n
\t\tvar undoManager = editor.undoManager, schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements(),\n
\t\t\tmoveCaretBeforeOnEnterElementsMap = schema.getMoveCaretBeforeOnEnterElements();\n
\n
\t\tfunction handleEnterKey(evt) {\n
\t\t\tvar rng, tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey,\n
\t\t\t\tnewBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;\n
\n
\t\t\t// Returns true if the block can be split into two blocks or not\n
\t\t\tfunction canSplitBlock(node) {\n
\t\t\t\treturn node &&\n
\t\t\t\t\tdom.isBlock(node) &&\n
\t\t\t\t\t!/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&\n
\t\t\t\t\t!/^(fixed|absolute)/i.test(node.style.position) &&\n
\t\t\t\t\tdom.getContentEditable(node) !== "true";\n
\t\t\t}\n
\n
\t\t\t// Renders empty block on IE\n
\t\t\tfunction renderBlockOnIE(block) {\n
\t\t\t\tvar oldRng;\n
\n
\t\t\t\tif (dom.isBlock(block)) {\n
\t\t\t\t\toldRng = selection.getRng();\n
\t\t\t\t\tblock.appendChild(dom.create(\'span\', null, \'\\u00a0\'));\n
\t\t\t\t\tselection.select(block);\n
\t\t\t\t\tblock.lastChild.outerHTML = \'\';\n
\t\t\t\t\tselection.setRng(oldRng);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>\n
\t\t\tfunction trimInlineElementsOnLeftSideOfBlock(block) {\n
\t\t\t\tvar node = block, firstChilds = [], i;\n
\n
\t\t\t\tif (!node) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Find inner most first child ex: <p><i><b>*</b></i></p>\n
\t\t\t\twhile ((node = node.firstChild)) {\n
\t\t\t\t\tif (dom.isBlock(node)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (node.nodeType == 1 && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\tfirstChilds.push(node);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\ti = firstChilds.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = firstChilds[i];\n
\t\t\t\t\tif (!node.hasChildNodes() || (node.firstChild == node.lastChild && node.firstChild.nodeValue === \'\')) {\n
\t\t\t\t\t\tdom.remove(node);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Remove <a> </a> see #5381\n
\t\t\t\t\t\tif (node.nodeName == "A" && (node.innerText || node.textContent) === \' \') {\n
\t\t\t\t\t\t\tdom.remove(node);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Moves the caret to a suitable position within the root for example in the first non\n
\t\t\t// pure whitespace text node or before an image\n
\t\t\tfunction moveToCaretPosition(root) {\n
\t\t\t\tvar walker, node, rng, lastNode = root, tempElm;\n
\t\t\t\tfunction firstNonWhiteSpaceNodeSibling(node) {\n
\t\t\t\t\twhile (node) {\n
\t\t\t\t\t\tif (node.nodeType == 1 || (node.nodeType == 3 && node.data && /[\\r\\n\\s]/.test(node.data))) {\n
\t\t\t\t\t\t\treturn node;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (!root) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Old IE versions doesn\'t properly render blocks with br elements in them\n
\t\t\t\t// For example <p><br></p> wont be rendered correctly in a contentEditable area\n
\t\t\t\t// until you remove the br producing <p></p>\n
\t\t\t\tif (Env.ie && Env.ie < 9 && parentBlock && parentBlock.firstChild) {\n
\t\t\t\t\tif (parentBlock.firstChild == parentBlock.lastChild && parentBlock.firstChild.tagName == \'BR\') {\n
\t\t\t\t\t\tdom.remove(parentBlock.firstChild);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (/^(LI|DT|DD)$/.test(root.nodeName)) {\n
\t\t\t\t\tvar firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n
\n
\t\t\t\t\tif (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n
\t\t\t\t\t\troot.insertBefore(dom.doc.createTextNode(\'\\u00a0\'), root.firstChild);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\trng = dom.createRng();\n
\n
\t\t\t\t// Normalize whitespace to remove empty text nodes. Fix for: #6904\n
\t\t\t\t// Gecko will be able to place the caret in empty text nodes but it won\'t render propery\n
\t\t\t\t// Older IE versions will sometimes crash so for now ignore all IE versions\n
\t\t\t\tif (!Env.ie) {\n
\t\t\t\t\troot.normalize();\n
\t\t\t\t}\n
\n
\t\t\t\tif (root.hasChildNodes()) {\n
\t\t\t\t\twalker = new TreeWalker(root, root);\n
\n
\t\t\t\t\twhile ((node = walker.current())) {\n
\t\t\t\t\t\tif (node.nodeType == 3) {\n
\t\t\t\t\t\t\trng.setStart(node, 0);\n
\t\t\t\t\t\t\trng.setEnd(node, 0);\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n
\t\t\t\t\t\t\trng.setStartBefore(node);\n
\t\t\t\t\t\t\trng.setEndBefore(node);\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tlastNode = node;\n
\t\t\t\t\t\tnode = walker.next();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!node) {\n
\t\t\t\t\t\trng.setStart(lastNode, 0);\n
\t\t\t\t\t\trng.setEnd(lastNode, 0);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (root.nodeName == \'BR\') {\n
\t\t\t\t\t\tif (root.nextSibling && dom.isBlock(root.nextSibling)) {\n
\t\t\t\t\t\t\t// Trick on older IE versions to render the caret before the BR between two lists\n
\t\t\t\t\t\t\tif (!documentMode || documentMode < 9) {\n
\t\t\t\t\t\t\t\ttempElm = dom.create(\'br\');\n
\t\t\t\t\t\t\t\troot.parentNode.insertBefore(tempElm, root);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\trng.setStartBefore(root);\n
\t\t\t\t\t\t\trng.setEndBefore(root);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setStartAfter(root);\n
\t\t\t\t\t\t\trng.setEndAfter(root);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setStart(root, 0);\n
\t\t\t\t\t\trng.setEnd(root, 0);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tselection.setRng(rng);\n
\n
\t\t\t\t// Remove tempElm created for old IE:s\n
\t\t\t\tdom.remove(tempElm);\n
\t\t\t\tselection.scrollIntoView(root);\n
\t\t\t}\n
\n
\t\t\tfunction setForcedBlockAttrs(node) {\n
\t\t\t\tvar forcedRootBlockName = settings.forced_root_block;\n
\n
\t\t\t\tif (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n
\t\t\t\t\tdom.setAttribs(node, settings.forced_root_block_attrs);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Creates a new block element by cloning the current one or creating a new one if the name is specified\n
\t\t\t// This function will also copy any text formatting from the parent block and add it to the new one\n
\t\t\tfunction createNewBlock(name) {\n
\t\t\t\tvar node = container, block, clonedNode, caretNode, textInlineElements = schema.getTextInlineElements();\n
\n
\t\t\t\tif (name || parentBlockName == "TABLE") {\n
\t\t\t\t\tblock = dom.create(name || newBlockName);\n
\t\t\t\t\tsetForcedBlockAttrs(block);\n
\t\t\t\t} else {\n
\t\t\t\t\tblock = parentBlock.cloneNode(false);\n
\t\t\t\t}\n
\n
\t\t\t\tcaretNode = block;\n
\n
\t\t\t\t// Clone any parent styles\n
\t\t\t\tif (settings.keep_styles !== false) {\n
\t\t\t\t\tdo {\n
\t\t\t\t\t\tif (textInlineElements[node.nodeName]) {\n
\t\t\t\t\t\t\t// Never clone a caret containers\n
\t\t\t\t\t\t\tif (node.id == \'_mce_caret\') {\n
\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tclonedNode = node.cloneNode(false);\n
\t\t\t\t\t\t\tdom.setAttrib(clonedNode, \'id\', \'\'); // Remove ID since it needs to be document unique\n
\n
\t\t\t\t\t\t\tif (block.hasChildNodes()) {\n
\t\t\t\t\t\t\t\tclonedNode.appendChild(block.firstChild);\n
\t\t\t\t\t\t\t\tblock.appendChild(clonedNode);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tcaretNode = clonedNode;\n
\t\t\t\t\t\t\t\tblock.appendChild(clonedNode);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} while ((node = node.parentNode));\n
\t\t\t\t}\n
\n
\t\t\t\t// BR is needed in empty blocks on non IE browsers\n
\t\t\t\tif (!isIE) {\n
\t\t\t\t\tcaretNode.innerHTML = \'<br data-mce-bogus="1">\';\n
\t\t\t\t}\n
\n
\t\t\t\treturn block;\n
\t\t\t}\n
\n
\t\t\t// Returns true/false if the caret is at the start/end of the parent block element\n
\t\t\tfunction isCaretAtStartOrEndOfBlock(start) {\n
\t\t\t\tvar walker, node, name;\n
\n
\t\t\t\t// Caret is in the middle of a text node like "a|b"\n
\t\t\t\tif (container.nodeType == 3 && (start ? offset > 0 : offset < container.nodeValue.length)) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\t// If after the last element in block node edge case for #5091\n
\t\t\t\tif (container.parentNode == parentBlock && isAfterLastNodeInContainer && !start) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t// If the caret if before the first element in parentBlock\n
\t\t\t\tif (start && container.nodeType == 1 && container == parentBlock.firstChild) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Caret can be before/after a table\n
\t\t\t\tif (container.nodeName === "TABLE" || (container.previousSibling && container.previousSibling.nodeName == "TABLE")) {\n
\t\t\t\t\treturn (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);\n
\t\t\t\t}\n
\n
\t\t\t\t// Walk the DOM and look for text nodes or non empty elements\n
\t\t\t\twalker = new TreeWalker(container, parentBlock);\n
\n
\t\t\t\t// If caret is in beginning or end of a text block then jump to the next/previous node\n
\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\tif (start && offset === 0) {\n
\t\t\t\t\t\twalker.prev();\n
\t\t\t\t\t} else if (!start && offset == container.nodeValue.length) {\n
\t\t\t\t\t\twalker.next();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\twhile ((node = walker.current())) {\n
\t\t\t\t\tif (node.nodeType === 1) {\n
\t\t\t\t\t\t// Ignore bogus elements\n
\t\t\t\t\t\tif (!node.getAttribute(\'data-mce-bogus\')) {\n
\t\t\t\t\t\t\t// Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>\n
\t\t\t\t\t\t\tname = node.nodeName.toLowerCase();\n
\t\t\t\t\t\t\tif (nonEmptyElementsMap[name] && name !== \'br\') {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else if (node.nodeType === 3 && !/^[ \\t\\r\\n]*$/.test(node.nodeValue)) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (start) {\n
\t\t\t\t\t\twalker.prev();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\twalker.next();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Wraps any text nodes or inline elements in the specified forced root block name\n
\t\t\tfunction wrapSelfAndSiblingsInDefaultBlock(container, offset) {\n
\t\t\t\tvar newBlock, parentBlock, startNode, node, next, rootBlockName, blockName = newBlockName || \'P\';\n
\n
\t\t\t\t// Not in a block element or in a table cell or caption\n
\t\t\t\tparentBlock = dom.getParent(container, dom.isBlock);\n
\t\t\t\trootBlockName = editor.getBody().nodeName.toLowerCase();\n
\t\t\t\tif (!parentBlock || !canSplitBlock(parentBlock)) {\n
\t\t\t\t\tparentBlock = parentBlock || editableRoot;\n
\n
\t\t\t\t\tif (!parentBlock.hasChildNodes()) {\n
\t\t\t\t\t\tnewBlock = dom.create(blockName);\n
\t\t\t\t\t\tsetForcedBlockAttrs(newBlock);\n
\t\t\t\t\t\tparentBlock.appendChild(newBlock);\n
\t\t\t\t\t\trng.setStart(newBlock, 0);\n
\t\t\t\t\t\trng.setEnd(newBlock, 0);\n
\t\t\t\t\t\treturn newBlock;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Find parent that is the first child of parentBlock\n
\t\t\t\t\tnode = container;\n
\t\t\t\t\twhile (node.parentNode != parentBlock) {\n
\t\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Loop left to find start node start wrapping at\n
\t\t\t\t\twhile (node && !dom.isBlock(node)) {\n
\t\t\t\t\t\tstartNode = node;\n
\t\t\t\t\t\tnode = node.previousSibling;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (startNode && schema.isValidChild(rootBlockName, blockName.toLowerCase())) {\n
\t\t\t\t\t\tnewBlock = dom.create(blockName);\n
\t\t\t\t\t\tsetForcedBlockAttrs(newBlock);\n
\t\t\t\t\t\tstartNode.parentNode.insertBefore(newBlock, startNode);\n
\n
\t\t\t\t\t\t// Start wrapping until we hit a block\n
\t\t\t\t\t\tnode = startNode;\n
\t\t\t\t\t\twhile (node && !dom.isBlock(node)) {\n
\t\t\t\t\t\t\tnext = node.nextSibling;\n
\t\t\t\t\t\t\tnewBlock.appendChild(node);\n
\t\t\t\t\t\t\tnode = next;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Restore range to it\'s past location\n
\t\t\t\t\t\trng.setStart(container, offset);\n
\t\t\t\t\t\trng.setEnd(container, offset);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn container;\n
\t\t\t}\n
\n
\t\t\t// Inserts a block or br before/after or in the middle of a split list of the LI is empty\n
\t\t\tfunction handleEmptyListItem() {\n
\t\t\t\tfunction isFirstOrLastLi(first) {\n
\t\t\t\t\tvar node = containerBlock[first ? \'firstChild\' : \'lastChild\'];\n
\n
\t\t\t\t\t// Find first/last element since there might be whitespace there\n
\t\t\t\t\twhile (node) {\n
\t\t\t\t\t\tif (node.nodeType == 1) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = node[first ? \'nextSibling\' : \'previousSibling\'];\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn node === parentBlock;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction getContainerBlock() {\n
\t\t\t\t\tvar containerBlockParent = containerBlock.parentNode;\n
\n
\t\t\t\t\tif (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {\n
\t\t\t\t\t\treturn containerBlockParent;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn containerBlock;\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if we are in an nested list\n
\t\t\t\tvar containerBlockParentName = containerBlock.parentNode.nodeName;\n
\t\t\t\tif (/^(OL|UL|LI)$/.test(containerBlockParentName)) {\n
\t\t\t\t\tnewBlockName = \'LI\';\n
\t\t\t\t}\n
\n
\t\t\t\tnewBlock = newBlockName ? createNewBlock(newBlockName) : dom.create(\'BR\');\n
\n
\t\t\t\tif (isFirstOrLastLi(true) && isFirstOrLastLi()) {\n
\t\t\t\t\tif (containerBlockParentName == \'LI\') {\n
\t\t\t\t\t\t// Nested list is inside a LI\n
\t\t\t\t\t\tdom.insertAfter(newBlock, getContainerBlock());\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Is first and last list item then replace the OL/UL with a text block\n
\t\t\t\t\t\tdom.replace(newBlock, containerBlock);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (isFirstOrLastLi(true)) {\n
\t\t\t\t\tif (containerBlockParentName == \'LI\') {\n
\t\t\t\t\t\t// List nested in an LI then move the list to a new sibling LI\n
\t\t\t\t\t\tdom.insertAfter(newBlock, getContainerBlock());\n
\t\t\t\t\t\tnewBlock.appendChild(dom.doc.createTextNode(\' \')); // Needed for IE so the caret can be placed\n
\t\t\t\t\t\tnewBlock.appendChild(containerBlock);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// First LI in list then remove LI and add text block before list\n
\t\t\t\t\t\tcontainerBlock.parentNode.insertBefore(newBlock, containerBlock);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (isFirstOrLastLi()) {\n
\t\t\t\t\t// Last LI in list then remove LI and add text block after list\n
\t\t\t\t\tdom.insertAfter(newBlock, getContainerBlock());\n
\t\t\t\t\trenderBlockOnIE(newBlock);\n
\t\t\t\t} else {\n
\t\t\t\t\t// Middle LI in list the split the list and insert a text block in the middle\n
\t\t\t\t\t// Extract after fragment and insert it after the current block\n
\t\t\t\t\tcontainerBlock = getContainerBlock();\n
\t\t\t\t\ttmpRng = rng.cloneRange();\n
\t\t\t\t\ttmpRng.setStartAfter(parentBlock);\n
\t\t\t\t\ttmpRng.setEndAfter(containerBlock);\n
\t\t\t\t\tfragment = tmpRng.extractContents();\n
\n
\t\t\t\t\tif (newBlockName == \'LI\' && fragment.firstChild.nodeName == \'LI\') {\n
\t\t\t\t\t\tnewBlock = fragment.firstChild;\n
\t\t\t\t\t\tdom.insertAfter(fragment, containerBlock);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tdom.insertAfter(fragment, containerBlock);\n
\t\t\t\t\t\tdom.insertAfter(newBlock, containerBlock);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tdom.remove(parentBlock);\n
\t\t\t\tmoveToCaretPosition(newBlock);\n
\t\t\t\tundoManager.add();\n
\t\t\t}\n
\n
\t\t\t// Inserts a BR element if the forced_root_block option is set to false or empty string\n
\t\t\tfunction insertBr() {\n
\t\t\t\teditor.execCommand("InsertLineBreak", false, evt);\n
\t\t\t}\n
\n
\t\t\t// Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element\n
\t\t\tfunction trimLeadingLineBreaks(node) {\n
\t\t\t\tdo {\n
\t\t\t\t\tif (node.nodeType === 3) {\n
\t\t\t\t\t\tnode.nodeValue = node.nodeValue.replace(/^[\\r\\n]+/, \'\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tnode = node.firstChild;\n
\t\t\t\t} while (node);\n
\t\t\t}\n
\n
\t\t\tfunction getEditableRoot(node) {\n
\t\t\t\tvar root = dom.getRoot(), parent, editableRoot;\n
\n
\t\t\t\t// Get all parents until we hit a non editable parent or the root\n
\t\t\t\tparent = node;\n
\t\t\t\twhile (parent !== root && dom.getContentEditable(parent) !== "false") {\n
\t\t\t\t\tif (dom.getContentEditable(parent) === "true") {\n
\t\t\t\t\t\teditableRoot = parent;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparent = parent.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\treturn parent !== root ? editableRoot : root;\n
\t\t\t}\n
\n
\t\t\t// Adds a BR at the end of blocks that only contains an IMG or INPUT since\n
\t\t\t// these might be floated and then they won\'t expand the block\n
\t\t\tfunction addBrToBlockIfNeeded(block) {\n
\t\t\t\tvar lastChild;\n
\n
\t\t\t\t// IE will render the blocks correctly other browsers needs a BR\n
\t\t\t\tif (!isIE) {\n
\t\t\t\t\tblock.normalize(); // Remove empty text nodes that got left behind by the extract\n
\n
\t\t\t\t\t// Check if the block is empty or contains a floated last child\n
\t\t\t\t\tlastChild = block.lastChild;\n
\t\t\t\t\tif (!lastChild || (/^(left|right)$/gi.test(dom.getStyle(lastChild, \'float\', true)))) {\n
\t\t\t\t\t\tdom.add(block, \'br\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction insertNewBlockAfter() {\n
\t\t\t\t// If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup\n
\t\t\t\tif (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName != \'HGROUP\') {\n
\t\t\t\t\tnewBlock = createNewBlock(newBlockName);\n
\t\t\t\t} else {\n
\t\t\t\t\tnewBlock = createNewBlock();\n
\t\t\t\t}\n
\n
\t\t\t\t// Split the current container block element if enter is pressed inside an empty inner block element\n
\t\t\t\tif (settings.end_container_on_empty_block && canSplitBlock(containerBlock) && dom.isEmpty(parentBlock)) {\n
\t\t\t\t\t// Split container block for example a BLOCKQUOTE at the current blockParent location for example a P\n
\t\t\t\t\tnewBlock = dom.split(containerBlock, parentBlock);\n
\t\t\t\t} else {\n
\t\t\t\t\tdom.insertAfter(newBlock, parentBlock);\n
\t\t\t\t}\n
\n
\t\t\t\tmoveToCaretPosition(newBlock);\n
\t\t\t}\n
\n
\t\t\trng = selection.getRng(true);\n
\n
\t\t\t// Event is blocked by some other handler for example the lists plugin\n
\t\t\tif (evt.isDefaultPrevented()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Delete any selected contents\n
\t\t\tif (!rng.collapsed) {\n
\t\t\t\teditor.execCommand(\'Delete\');\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Setup range items and newBlockName\n
\t\t\tnew RangeUtils(dom).normalize(rng);\n
\t\t\tcontainer = rng.startContainer;\n
\t\t\toffset = rng.startOffset;\n
\t\t\tnewBlockName = (settings.force_p_newlines ? \'p\' : \'\') || settings.forced_root_block;\n
\t\t\tnewBlockName = newBlockName ? newBlockName.toUpperCase() : \'\';\n
\t\t\tdocumentMode = dom.doc.documentMode;\n
\t\t\tshiftKey = evt.shiftKey;\n
\n
\t\t\t// Resolve node index\n
\t\t\tif (container.nodeType == 1 && container.hasChildNodes()) {\n
\t\t\t\tisAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n
\n
\t\t\t\tcontainer = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n
\t\t\t\tif (isAfterLastNodeInContainer && container.nodeType == 3) {\n
\t\t\t\t\toffset = container.nodeValue.length;\n
\t\t\t\t} else {\n
\t\t\t\t\toffset = 0;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Get editable root node normaly the body element but sometimes a div or span\n
\t\t\teditableRoot = getEditableRoot(container);\n
\n
\t\t\t// If there is no editable root then enter is done inside a contentEditable false element\n
\t\t\tif (!editableRoot) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tundoManager.beforeChange();\n
\n
\t\t\t// If editable root isn\'t block nor the root of the editor\n
\t\t\tif (!dom.isBlock(editableRoot) && editableRoot != dom.getRoot()) {\n
\t\t\t\tif (!newBlockName || shiftKey) {\n
\t\t\t\t\tinsertBr();\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Wrap the current node and it\'s sibling in a default block if it\'s needed.\n
\t\t\t// for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>\n
\t\t\t// This won\'t happen if root blocks are disabled or the shiftKey is pressed\n
\t\t\tif ((newBlockName && !shiftKey) || (!newBlockName && shiftKey)) {\n
\t\t\t\tcontainer = wrapSelfAndSiblingsInDefaultBlock(container, offset);\n
\t\t\t}\n
\n
\t\t\t// Find parent block and setup empty block paddings\n
\t\t\tparentBlock = dom.getParent(container, dom.isBlock);\n
\t\t\tcontainerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n
\n
\t\t\t// Setup block names\n
\t\t\tparentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : \'\'; // IE < 9 & HTML5\n
\t\t\tcontainerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : \'\'; // IE < 9 & HTML5\n
\n
\t\t\t// Enter inside block contained within a LI then split or insert before/after LI\n
\t\t\tif (containerBlockName == \'LI\' && !evt.ctrlKey) {\n
\t\t\t\tparentBlock = containerBlock;\n
\t\t\t\tparentBlockName = containerBlockName;\n
\t\t\t}\n
\n
\t\t\t// Handle enter in list item\n
\t\t\tif (/^(LI|DT|DD)$/.test(parentBlockName)) {\n
\t\t\t\tif (!newBlockName && shiftKey) {\n
\t\t\t\t\tinsertBr();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Handle enter inside an empty list item\n
\t\t\t\tif (dom.isEmpty(parentBlock)) {\n
\t\t\t\t\thandleEmptyListItem();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Don\'t split PRE tags but insert a BR instead easier when writing code samples etc\n
\t\t\tif (parentBlockName == \'PRE\' && settings.br_in_pre !== false) {\n
\t\t\t\tif (!shiftKey) {\n
\t\t\t\t\tinsertBr();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// If no root block is configured then insert a BR by default or if the shiftKey is pressed\n
\t\t\t\tif ((!newBlockName && !shiftKey && parentBlockName != \'LI\') || (newBlockName && shiftKey)) {\n
\t\t\t\t\tinsertBr();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// If parent block i

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAk=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="9" aka="AAAAAAAAAAk=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

s root then never insert new blocks\n
\t\t\tif (newBlockName && parentBlock === editor.getBody()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Default block name if it\'s not configured\n
\t\t\tnewBlockName = newBlockName || \'P\';\n
\n
\t\t\t// Insert new block before/after the parent block depending on caret location\n
\t\t\tif (isCaretAtStartOrEndOfBlock()) {\n
\t\t\t\tinsertNewBlockAfter();\n
\t\t\t} else if (isCaretAtStartOrEndOfBlock(true)) {\n
\t\t\t\t// Insert new block before\n
\t\t\t\tnewBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);\n
\t\t\t\trenderBlockOnIE(newBlock);\n
\t\t\t\tmoveToCaretPosition(parentBlock);\n
\t\t\t} else {\n
\t\t\t\t// Extract after fragment and insert it after the current block\n
\t\t\t\ttmpRng = rng.cloneRange();\n
\t\t\t\ttmpRng.setEndAfter(parentBlock);\n
\t\t\t\tfragment = tmpRng.extractContents();\n
\t\t\t\ttrimLeadingLineBreaks(fragment);\n
\t\t\t\tnewBlock = fragment.firstChild;\n
\t\t\t\tdom.insertAfter(fragment, parentBlock);\n
\t\t\t\ttrimInlineElementsOnLeftSideOfBlock(newBlock);\n
\t\t\t\taddBrToBlockIfNeeded(parentBlock);\n
\n
\t\t\t\t// New block might become empty if it\'s <p><b>a |</b></p>\n
\t\t\t\tif (dom.isEmpty(newBlock)) {\n
\t\t\t\t\tdom.remove(newBlock);\n
\t\t\t\t\tinsertNewBlockAfter();\n
\t\t\t\t} else {\n
\t\t\t\t\tmoveToCaretPosition(newBlock);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tdom.setAttrib(newBlock, \'id\', \'\'); // Remove ID since it needs to be document unique\n
\n
\t\t\t// Allow custom handling of new blocks\n
\t\t\teditor.fire(\'NewBlock\', {newBlock: newBlock});\n
\n
\t\t\tundoManager.add();\n
\t\t}\n
\n
\t\teditor.on(\'keydown\', function(evt) {\n
\t\t\tif (evt.keyCode == 13) {\n
\t\t\t\tif (handleEnterKey(evt) !== false) {\n
\t\t\t\t\tevt.preventDefault();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t});\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ForceBlocks.js\n
\n
/**\n
 * ForceBlocks.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
define("tinymce/ForceBlocks", [], function() {\n
\treturn function(editor) {\n
\t\tvar settings = editor.settings, dom = editor.dom, selection = editor.selection;\n
\t\tvar schema = editor.schema, blockElements = schema.getBlockElements();\n
\n
\t\tfunction addRootBlocks() {\n
\t\t\tvar node = selection.getStart(), rootNode = editor.getBody(), rng;\n
\t\t\tvar startContainer, startOffset, endContainer, endOffset, rootBlockNode;\n
\t\t\tvar tempNode, offset = -0xFFFFFF, wrapped, restoreSelection;\n
\t\t\tvar tmpRng, rootNodeName, forcedRootBlock;\n
\n
\t\t\tforcedRootBlock = settings.forced_root_block;\n
\n
\t\t\tif (!node || node.nodeType !== 1 || !forcedRootBlock) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Check if node is wrapped in block\n
\t\t\twhile (node && node != rootNode) {\n
\t\t\t\tif (blockElements[node.nodeName]) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tnode = node.parentNode;\n
\t\t\t}\n
\n
\t\t\t// Get current selection\n
\t\t\trng = selection.getRng();\n
\t\t\tif (rng.setStart) {\n
\t\t\t\tstartContainer = rng.startContainer;\n
\t\t\t\tstartOffset = rng.startOffset;\n
\t\t\t\tendContainer = rng.endContainer;\n
\t\t\t\tendOffset = rng.endOffset;\n
\n
\t\t\t\ttry {\n
\t\t\t\t\trestoreSelection = editor.getDoc().activeElement === rootNode;\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// IE throws unspecified error here sometimes\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\t// Force control range into text range\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\tnode = rng.item(0);\n
\t\t\t\t\trng = editor.getDoc().body.createTextRange();\n
\t\t\t\t\trng.moveToElementText(node);\n
\t\t\t\t}\n
\n
\t\t\t\trestoreSelection = rng.parentElement().ownerDocument === editor.getDoc();\n
\t\t\t\ttmpRng = rng.duplicate();\n
\t\t\t\ttmpRng.collapse(true);\n
\t\t\t\tstartOffset = tmpRng.move(\'character\', offset) * -1;\n
\n
\t\t\t\tif (!tmpRng.collapsed) {\n
\t\t\t\t\ttmpRng = rng.duplicate();\n
\t\t\t\t\ttmpRng.collapse(false);\n
\t\t\t\t\tendOffset = (tmpRng.move(\'character\', offset) * -1) - startOffset;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Wrap non block elements and text nodes\n
\t\t\tnode = rootNode.firstChild;\n
\t\t\trootNodeName = rootNode.nodeName.toLowerCase();\n
\t\t\twhile (node) {\n
\t\t\t\t// TODO: Break this up, too complex\n
\t\t\t\tif (((node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName]))) &&\n
\t\t\t\t\tschema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase())) {\n
\t\t\t\t\t// Remove empty text nodes\n
\t\t\t\t\tif (node.nodeType === 3 && node.nodeValue.length === 0) {\n
\t\t\t\t\t\ttempNode = node;\n
\t\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t\t\tdom.remove(tempNode);\n
\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!rootBlockNode) {\n
\t\t\t\t\t\trootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);\n
\t\t\t\t\t\tnode.parentNode.insertBefore(rootBlockNode, node);\n
\t\t\t\t\t\twrapped = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\ttempNode = node;\n
\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t\trootBlockNode.appendChild(tempNode);\n
\t\t\t\t} else {\n
\t\t\t\t\trootBlockNode = null;\n
\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (wrapped && restoreSelection) {\n
\t\t\t\tif (rng.setStart) {\n
\t\t\t\t\trng.setStart(startContainer, startOffset);\n
\t\t\t\t\trng.setEnd(endContainer, endOffset);\n
\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t} else {\n
\t\t\t\t\t// Only select if the previous selection was inside the document to prevent auto focus in quirks mode\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\trng = editor.getDoc().body.createTextRange();\n
\t\t\t\t\t\trng.moveToElementText(rootNode);\n
\t\t\t\t\t\trng.collapse(true);\n
\t\t\t\t\t\trng.moveStart(\'character\', startOffset);\n
\n
\t\t\t\t\t\tif (endOffset > 0) {\n
\t\t\t\t\t\t\trng.moveEnd(\'character\', endOffset);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\trng.select();\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Ignore\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Force root blocks\n
\t\tif (settings.forced_root_block) {\n
\t\t\teditor.on(\'NodeChange\', addRootBlocks);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/EditorCommands.js\n
\n
/**\n
 * EditorCommands.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class enables you to add custom editor commands and it contains\n
 * overrides for native browser commands to address various bugs and issues.\n
 *\n
 * @class tinymce.EditorCommands\n
 */\n
define("tinymce/EditorCommands", [\n
\t"tinymce/html/Serializer",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/ElementUtils",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/dom/TreeWalker"\n
], function(Serializer, Env, Tools, ElementUtils, RangeUtils, TreeWalker) {\n
\t// Added for compression purposes\n
\tvar each = Tools.each, extend = Tools.extend;\n
\tvar map = Tools.map, inArray = Tools.inArray, explode = Tools.explode;\n
\tvar isGecko = Env.gecko, isIE = Env.ie, isOldIE = Env.ie && Env.ie < 11;\n
\tvar TRUE = true, FALSE = false;\n
\n
\treturn function(editor) {\n
\t\tvar dom, selection, formatter,\n
\t\t\tcommands = {state: {}, exec: {}, value: {}},\n
\t\t\tsettings = editor.settings,\n
\t\t\tbookmark;\n
\n
\t\teditor.on(\'PreInit\', function() {\n
\t\t\tdom = editor.dom;\n
\t\t\tselection = editor.selection;\n
\t\t\tsettings = editor.settings;\n
\t\t\tformatter = editor.formatter;\n
\t\t});\n
\n
\t\t/**\n
\t\t * Executes the specified command.\n
\t\t *\n
\t\t * @method execCommand\n
\t\t * @param {String} command Command to execute.\n
\t\t * @param {Boolean} ui Optional user interface state.\n
\t\t * @param {Object} value Optional value for command.\n
\t\t * @return {Boolean} true/false if the command was found or not.\n
\t\t */\n
\t\tfunction execCommand(command, ui, value, args) {\n
\t\t\tvar func, customCommand, state = 0;\n
\n
\t\t\tif (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {\n
\t\t\t\teditor.focus();\n
\t\t\t}\n
\n
\t\t\targs = extend({}, args);\n
\t\t\targs = editor.fire(\'BeforeExecCommand\', {command: command, ui: ui, value: value});\n
\t\t\tif (args.isDefaultPrevented()) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tcustomCommand = command.toLowerCase();\n
\t\t\tif ((func = commands.exec[customCommand])) {\n
\t\t\t\tfunc(customCommand, ui, value);\n
\t\t\t\teditor.fire(\'ExecCommand\', {command: command, ui: ui, value: value});\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Plugin commands\n
\t\t\teach(editor.plugins, function(p) {\n
\t\t\t\tif (p.execCommand && p.execCommand(command, ui, value)) {\n
\t\t\t\t\teditor.fire(\'ExecCommand\', {command: command, ui: ui, value: value});\n
\t\t\t\t\tstate = true;\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (state) {\n
\t\t\t\treturn state;\n
\t\t\t}\n
\n
\t\t\t// Theme commands\n
\t\t\tif (editor.theme && editor.theme.execCommand && editor.theme.execCommand(command, ui, value)) {\n
\t\t\t\teditor.fire(\'ExecCommand\', {command: command, ui: ui, value: value});\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Browser commands\n
\t\t\ttry {\n
\t\t\t\tstate = editor.getDoc().execCommand(command, ui, value);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore old IE errors\n
\t\t\t}\n
\n
\t\t\tif (state) {\n
\t\t\t\teditor.fire(\'ExecCommand\', {command: command, ui: ui, value: value});\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Queries the current state for a command for example if the current selection is "bold".\n
\t\t *\n
\t\t * @method queryCommandState\n
\t\t * @param {String} command Command to check the state of.\n
\t\t * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it\'s not found.\n
\t\t */\n
\t\tfunction queryCommandState(command) {\n
\t\t\tvar func;\n
\n
\t\t\t// Is hidden then return undefined\n
\t\t\tif (editor._isHidden()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\tif ((func = commands.state[command])) {\n
\t\t\t\treturn func(command);\n
\t\t\t}\n
\n
\t\t\t// Browser commands\n
\t\t\ttry {\n
\t\t\t\treturn editor.getDoc().queryCommandState(command);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Fails sometimes see bug: 1896577\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Queries the command value for example the current fontsize.\n
\t\t *\n
\t\t * @method queryCommandValue\n
\t\t * @param {String} command Command to check the value of.\n
\t\t * @return {Object} Command value of false if it\'s not found.\n
\t\t */\n
\t\tfunction queryCommandValue(command) {\n
\t\t\tvar func;\n
\n
\t\t\t// Is hidden then return undefined\n
\t\t\tif (editor._isHidden()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\tif ((func = commands.value[command])) {\n
\t\t\t\treturn func(command);\n
\t\t\t}\n
\n
\t\t\t// Browser commands\n
\t\t\ttry {\n
\t\t\t\treturn editor.getDoc().queryCommandValue(command);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Fails sometimes see bug: 1896577\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Adds commands to the command collection.\n
\t\t *\n
\t\t * @method addCommands\n
\t\t * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.\n
\t\t * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.\n
\t\t */\n
\t\tfunction addCommands(command_list, type) {\n
\t\t\ttype = type || \'exec\';\n
\n
\t\t\teach(command_list, function(callback, command) {\n
\t\t\t\teach(command.toLowerCase().split(\',\'), function(command) {\n
\t\t\t\t\tcommands[type][command] = callback;\n
\t\t\t\t});\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction addCommand(command, callback, scope) {\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\tcommands.exec[command] = function(command, ui, value, args) {\n
\t\t\t\treturn callback.call(scope || editor, ui, value, args);\n
\t\t\t};\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if the command is supported or not.\n
\t\t *\n
\t\t * @method queryCommandSupported\n
\t\t * @param {String} cmd Command that we check support for.\n
\t\t * @return {Boolean} true/false if the command is supported or not.\n
\t\t */\n
\t\tfunction queryCommandSupported(command) {\n
\t\t\tcommand = command.toLowerCase();\n
\n
\t\t\tif (commands.exec[command]) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Browser commands\n
\t\t\ttry {\n
\t\t\t\treturn editor.getDoc().queryCommandSupported(command);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Fails sometimes see bug: 1896577\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\tfunction addQueryStateHandler(command, callback, scope) {\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\tcommands.state[command] = function() {\n
\t\t\t\treturn callback.call(scope || editor);\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction addQueryValueHandler(command, callback, scope) {\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\tcommands.value[command] = function() {\n
\t\t\t\treturn callback.call(scope || editor);\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction hasCustomCommand(command) {\n
\t\t\tcommand = command.toLowerCase();\n
\t\t\treturn !!commands.exec[command];\n
\t\t}\n
\n
\t\t// Expose public methods\n
\t\textend(this, {\n
\t\t\texecCommand: execCommand,\n
\t\t\tqueryCommandState: queryCommandState,\n
\t\t\tqueryCommandValue: queryCommandValue,\n
\t\t\tqueryCommandSupported: queryCommandSupported,\n
\t\t\taddCommands: addCommands,\n
\t\t\taddCommand: addCommand,\n
\t\t\taddQueryStateHandler: addQueryStateHandler,\n
\t\t\taddQueryValueHandler: addQueryValueHandler,\n
\t\t\thasCustomCommand: hasCustomCommand\n
\t\t});\n
\n
\t\t// Private methods\n
\n
\t\tfunction execNativeCommand(command, ui, value) {\n
\t\t\tif (ui === undefined) {\n
\t\t\t\tui = FALSE;\n
\t\t\t}\n
\n
\t\t\tif (value === undefined) {\n
\t\t\t\tvalue = null;\n
\t\t\t}\n
\n
\t\t\treturn editor.getDoc().execCommand(command, ui, value);\n
\t\t}\n
\n
\t\tfunction isFormatMatch(name) {\n
\t\t\treturn formatter.match(name);\n
\t\t}\n
\n
\t\tfunction toggleFormat(name, value) {\n
\t\t\tformatter.toggle(name, value ? {value: value} : undefined);\n
\t\t\teditor.nodeChanged();\n
\t\t}\n
\n
\t\tfunction storeSelection(type) {\n
\t\t\tbookmark = selection.getBookmark(type);\n
\t\t}\n
\n
\t\tfunction restoreSelection() {\n
\t\t\tselection.moveToBookmark(bookmark);\n
\t\t}\n
\n
\t\t// Add execCommand overrides\n
\t\taddCommands({\n
\t\t\t// Ignore these, added for compatibility\n
\t\t\t\'mceResetDesignMode,mceBeginUndoLevel\': function() {},\n
\n
\t\t\t// Add undo manager logic\n
\t\t\t\'mceEndUndoLevel,mceAddUndoLevel\': function() {\n
\t\t\t\teditor.undoManager.add();\n
\t\t\t},\n
\n
\t\t\t\'Cut,Copy,Paste\': function(command) {\n
\t\t\t\tvar doc = editor.getDoc(), failed;\n
\n
\t\t\t\t// Try executing the native command\n
\t\t\t\ttry {\n
\t\t\t\t\texecNativeCommand(command);\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Command failed\n
\t\t\t\t\tfailed = TRUE;\n
\t\t\t\t}\n
\n
\t\t\t\t// Present alert message about clipboard access not being available\n
\t\t\t\tif (failed || !doc.queryCommandSupported(command)) {\n
\t\t\t\t\tvar msg = editor.translate(\n
\t\t\t\t\t\t"Your browser doesn\'t support direct access to the clipboard. " +\n
\t\t\t\t\t\t"Please use the Ctrl+X/C/V keyboard shortcuts instead."\n
\t\t\t\t\t);\n
\n
\t\t\t\t\tif (Env.mac) {\n
\t\t\t\t\t\tmsg = msg.replace(/Ctrl\\+/g, \'\\u2318+\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teditor.windowManager.alert(msg);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t// Override unlink command\n
\t\t\tunlink: function() {\n
\t\t\t\tif (selection.isCollapsed()) {\n
\t\t\t\t\tvar elm = selection.getNode();\n
\t\t\t\t\tif (elm.tagName == \'A\') {\n
\t\t\t\t\t\teditor.dom.remove(elm, true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tformatter.remove("link");\n
\t\t\t},\n
\n
\t\t\t// Override justify commands to use the text formatter engine\n
\t\t\t\'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone\': function(command) {\n
\t\t\t\tvar align = command.substring(7);\n
\n
\t\t\t\tif (align == \'full\') {\n
\t\t\t\t\talign = \'justify\';\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove all other alignments first\n
\t\t\t\teach(\'left,center,right,justify\'.split(\',\'), function(name) {\n
\t\t\t\t\tif (align != name) {\n
\t\t\t\t\t\tformatter.remove(\'align\' + name);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tif (align != \'none\') {\n
\t\t\t\t\ttoggleFormat(\'align\' + align);\n
\t\t\t\t\texecCommand(\'mceRepaint\');\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t// Override list commands to fix WebKit bug\n
\t\t\t\'InsertUnorderedList,InsertOrderedList\': function(command) {\n
\t\t\t\tvar listElm, listParent;\n
\n
\t\t\t\texecNativeCommand(command);\n
\n
\t\t\t\t// WebKit produces lists within block elements so we need to split them\n
\t\t\t\t// we will replace the native list creation logic to custom logic later on\n
\t\t\t\t// TODO: Remove this when the list creation logic is removed\n
\t\t\t\tlistElm = dom.getParent(selection.getNode(), \'ol,ul\');\n
\t\t\t\tif (listElm) {\n
\t\t\t\t\tlistParent = listElm.parentNode;\n
\n
\t\t\t\t\t// If list is within a text block then split that block\n
\t\t\t\t\tif (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n
\t\t\t\t\t\tstoreSelection();\n
\t\t\t\t\t\tdom.split(listParent, listElm);\n
\t\t\t\t\t\trestoreSelection();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t// Override commands to use the text formatter engine\n
\t\t\t\'Bold,Italic,Underline,Strikethrough,Superscript,Subscript\': function(command) {\n
\t\t\t\ttoggleFormat(command);\n
\t\t\t},\n
\n
\t\t\t// Override commands to use the text formatter engine\n
\t\t\t\'ForeColor,HiliteColor,FontName\': function(command, ui, value) {\n
\t\t\t\ttoggleFormat(command, value);\n
\t\t\t},\n
\n
\t\t\tFontSize: function(command, ui, value) {\n
\t\t\t\tvar fontClasses, fontSizes;\n
\n
\t\t\t\t// Convert font size 1-7 to styles\n
\t\t\t\tif (value >= 1 && value <= 7) {\n
\t\t\t\t\tfontSizes = explode(settings.font_size_style_values);\n
\t\t\t\t\tfontClasses = explode(settings.font_size_classes);\n
\n
\t\t\t\t\tif (fontClasses) {\n
\t\t\t\t\t\tvalue = fontClasses[value - 1] || value;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tvalue = fontSizes[value - 1] || value;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\ttoggleFormat(command, value);\n
\t\t\t},\n
\n
\t\t\tRemoveFormat: function(command) {\n
\t\t\t\tformatter.remove(command);\n
\t\t\t},\n
\n
\t\t\tmceBlockQuote: function() {\n
\t\t\t\ttoggleFormat(\'blockquote\');\n
\t\t\t},\n
\n
\t\t\tFormatBlock: function(command, ui, value) {\n
\t\t\t\treturn toggleFormat(value || \'p\');\n
\t\t\t},\n
\n
\t\t\tmceCleanup: function() {\n
\t\t\t\tvar bookmark = selection.getBookmark();\n
\n
\t\t\t\teditor.setContent(editor.getContent({cleanup: TRUE}), {cleanup: TRUE});\n
\n
\t\t\t\tselection.moveToBookmark(bookmark);\n
\t\t\t},\n
\n
\t\t\tmceRemoveNode: function(command, ui, value) {\n
\t\t\t\tvar node = value || selection.getNode();\n
\n
\t\t\t\t// Make sure that the body node isn\'t removed\n
\t\t\t\tif (node != editor.getBody()) {\n
\t\t\t\t\tstoreSelection();\n
\t\t\t\t\teditor.dom.remove(node, TRUE);\n
\t\t\t\t\trestoreSelection();\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tmceSelectNodeDepth: function(command, ui, value) {\n
\t\t\t\tvar counter = 0;\n
\n
\t\t\t\tdom.getParent(selection.getNode(), function(node) {\n
\t\t\t\t\tif (node.nodeType == 1 && counter++ == value) {\n
\t\t\t\t\t\tselection.select(node);\n
\t\t\t\t\t\treturn FALSE;\n
\t\t\t\t\t}\n
\t\t\t\t}, editor.getBody());\n
\t\t\t},\n
\n
\t\t\tmceSelectNode: function(command, ui, value) {\n
\t\t\t\tselection.select(value);\n
\t\t\t},\n
\n
\t\t\tmceInsertContent: function(command, ui, value) {\n
\t\t\t\tvar parser, serializer, parentNode, rootNode, fragment, args;\n
\t\t\t\tvar marker, rng, node, node2, bookmarkHtml, merge, data;\n
\t\t\t\tvar textInlineElements = editor.schema.getTextInlineElements();\n
\n
\t\t\t\tfunction trimOrPaddLeftRight(html) {\n
\t\t\t\t\tvar rng, container, offset;\n
\n
\t\t\t\t\trng = selection.getRng(true);\n
\t\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\t\toffset = rng.startOffset;\n
\n
\t\t\t\t\tfunction hasSiblingText(siblingName) {\n
\t\t\t\t\t\treturn container[siblingName] && container[siblingName].nodeType == 3;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\t\tif (offset > 0) {\n
\t\t\t\t\t\t\thtml = html.replace(/^&nbsp;/, \' \');\n
\t\t\t\t\t\t} else if (!hasSiblingText(\'previousSibling\')) {\n
\t\t\t\t\t\t\thtml = html.replace(/^ /, \'&nbsp;\');\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (offset < container.length) {\n
\t\t\t\t\t\t\thtml = html.replace(/&nbsp;(<br>|)$/, \' \');\n
\t\t\t\t\t\t} else if (!hasSiblingText(\'nextSibling\')) {\n
\t\t\t\t\t\t\thtml = html.replace(/(&nbsp;| )(<br>|)$/, \'&nbsp;\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn html;\n
\t\t\t\t}\n
\n
\t\t\t\t// Removes &nbsp; from a [b] c -> a &nbsp;c -> a c\n
\t\t\t\tfunction trimNbspAfterDeleteAndPaddValue() {\n
\t\t\t\t\tvar rng, container, offset;\n
\n
\t\t\t\t\trng = selection.getRng(true);\n
\t\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\t\toffset = rng.startOffset;\n
\n
\t\t\t\t\tif (container.nodeType == 3 && rng.collapsed) {\n
\t\t\t\t\t\tif (container.data[offset] === \'\\u00a0\') {\n
\t\t\t\t\t\t\tcontainer.deleteData(offset, 1);\n
\n
\t\t\t\t\t\t\tif (!/[\\u00a0| ]$/.test(value)) {\n
\t\t\t\t\t\t\t\tvalue += \' \';\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} else if (container.data[offset - 1] === \'\\u00a0\') {\n
\t\t\t\t\t\t\tcontainer.deleteData(offset - 1, 1);\n
\n
\t\t\t\t\t\t\tif (!/[\\u00a0| ]$/.test(value)) {\n
\t\t\t\t\t\t\t\tvalue = \' \' + value;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction markInlineFormatElements(fragment) {\n
\t\t\t\t\tif (merge) {\n
\t\t\t\t\t\tfor (node = fragment.firstChild; node; node = node.walk(true)) {\n
\t\t\t\t\t\t\tif (textInlineElements[node.name]) {\n
\t\t\t\t\t\t\t\tnode.attr(\'data-mce-new\', "true");\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction reduceInlineTextElements() {\n
\t\t\t\t\tif (merge) {\n
\t\t\t\t\t\tvar root = editor.getBody(), elementUtils = new ElementUtils(dom);\n
\n
\t\t\t\t\t\teach(dom.select(\'*[data-mce-new]\'), function(node) {\n
\t\t\t\t\t\t\tnode.removeAttribute(\'data-mce-new\');\n
\n
\t\t\t\t\t\t\tfor (var testNode = node.parentNode; testNode && testNode != root; testNode = testNode.parentNode) {\n
\t\t\t\t\t\t\t\tif (elementUtils.compare(testNode, node)) {\n
\t\t\t\t\t\t\t\t\tdom.remove(node, true);\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (typeof value != \'string\') {\n
\t\t\t\t\tmerge = value.merge;\n
\t\t\t\t\tdata = value.data;\n
\t\t\t\t\tvalue = value.content;\n
\t\t\t\t}\n
\n
\t\t\t\t// Check for whitespace before/after value\n
\t\t\t\tif (/^ | $/.test(value)) {\n
\t\t\t\t\tvalue = trimOrPaddLeftRight(value);\n
\t\t\t\t}\n
\n
\t\t\t\t// Setup parser and serializer\n
\t\t\t\tparser = editor.parser;\n
\t\t\t\tserializer = new Serializer({}, editor.schema);\n
\t\t\t\tbookmarkHtml = \'<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>\';\n
\n
\t\t\t\t// Run beforeSetContent handlers on the HTML to be inserted\n
\t\t\t\targs = {content: value, format: \'html\', selection: true};\n
\t\t\t\teditor.fire(\'BeforeSetContent\', args);\n
\t\t\t\tvalue = args.content;\n
\n
\t\t\t\t// Add caret at end of contents if it\'s missing\n
\t\t\t\tif (value.indexOf(\'{$caret}\') == -1) {\n
\t\t\t\t\tvalue += \'{$caret}\';\n
\t\t\t\t}\n
\n
\t\t\t\t// Replace the caret marker with a span bookmark element\n
\t\t\t\tvalue = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n
\n
\t\t\t\t// If selection is at <body>|<p></p> then move it into <body><p>|</p>\n
\t\t\t\trng = selection.getRng();\n
\t\t\t\tvar caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);\n
\t\t\t\tvar body = editor.getBody();\n
\t\t\t\tif (caretElement === body && selection.isCollapsed()) {\n
\t\t\t\t\tif (dom.isBlock(body.firstChild) && dom.isEmpty(body.firstChild)) {\n
\t\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\t\trng.setStart(body.firstChild, 0);\n
\t\t\t\t\t\trng.setEnd(body.firstChild, 0);\n
\t\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Insert node maker where we will insert the new HTML and get it\'s parent\n
\t\t\t\tif (!selection.isCollapsed()) {\n
\t\t\t\t\teditor.getDoc().execCommand(\'Delete\', false, null);\n
\t\t\t\t\ttrimNbspAfterDeleteAndPaddValue();\n
\t\t\t\t}\n
\n
\t\t\t\tparentNode = selection.getNode();\n
\n
\t\t\t\t// Parse the fragment within the context of the parent node\n
\t\t\t\tvar parserArgs = {context: parentNode.nodeName.toLowerCase(), data: data};\n
\t\t\t\tfragment = parser.parse(value, parserArgs);\n
\n
\t\t\t\tmarkInlineFormatElements(fragment);\n
\n
\t\t\t\t// Move the caret to a more suitable location\n
\t\t\t\tnode = fragment.lastChild;\n
\t\t\t\tif (node.attr(\'id\') == \'mce_marker\') {\n
\t\t\t\t\tmarker = node;\n
\n
\t\t\t\t\tfor (node = node.prev; node; node = node.walk(true)) {\n
\t\t\t\t\t\tif (node.type == 3 || !dom.isBlock(node.name)) {\n
\t\t\t\t\t\t\tif (editor.schema.isValidChild(node.parent.name, \'span\')) {\n
\t\t\t\t\t\t\t\tnode.parent.insert(marker, node, node.name === \'br\');\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// If parser says valid we can insert the contents into that parent\n
\t\t\t\tif (!parserArgs.invalid) {\n
\t\t\t\t\tvalue = serializer.serialize(fragment);\n
\n
\t\t\t\t\t// Check if parent is empty or only has one BR element then set the innerHTML of that parent\n
\t\t\t\t\tnode = parentNode.firstChild;\n
\t\t\t\t\tnode2 = parentNode.lastChild;\n
\t\t\t\t\tif (!node || (node === node2 && node.nodeName === \'BR\')) {\n
\t\t\t\t\t\tdom.setHTML(parentNode, value);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tselection.setContent(value);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// If the fragment was invalid within that context then we need\n
\t\t\t\t\t// to parse and process the parent it\'s inserted into\n
\n
\t\t\t\t\t// Insert bookmark node and get the parent\n
\t\t\t\t\tselection.setContent(bookmarkHtml);\n
\t\t\t\t\tparentNode = selection.getNode();\n
\t\t\t\t\trootNode = editor.getBody();\n
\n
\t\t\t\t\t// Opera will return the document node when selection is in root\n
\t\t\t\t\tif (parentNode.nodeType == 9) {\n
\t\t\t\t\t\tparentNode = node = rootNode;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tnode = parentNode;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Find the ancestor just before the root element\n
\t\t\t\t\twhile (node !== rootNode) {\n
\t\t\t\t\t\tparentNode = node;\n
\t\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Get the outer/inner HTML depending on if we are in the root and parser and serialize that\n
\t\t\t\t\tvalue = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n
\t\t\t\t\tvalue = serializer.serialize(\n
\t\t\t\t\t\tparser.parse(\n
\t\t\t\t\t\t\t// Need to replace by using a function since $ in the contents would otherwise be a problem\n
\t\t\t\t\t\t\tvalue.replace(/<span (id="mce_marker"|id=mce_marker).+?<\\/span>/i, function() {\n
\t\t\t\t\t\t\t\treturn serializer.serialize(fragment);\n
\t\t\t\t\t\t\t})\n
\t\t\t\t\t\t)\n
\t\t\t\t\t);\n
\n
\t\t\t\t\t// Set the inner/outer HTML depending on if we are in the root or not\n
\t\t\t\t\tif (parentNode == rootNode) {\n
\t\t\t\t\t\tdom.setHTML(rootNode, value);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tdom.setOuterHTML(parentNode, value);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treduceInlineTextElements();\n
\n
\t\t\t\tmarker = dom.get(\'mce_marker\');\n
\t\t\t\tselection.scrollIntoView(marker);\n
\n
\t\t\t\t// Move selection before marker and remove it\n
\t\t\t\trng = dom.createRng();\n
\n
\t\t\t\t// If previous sibling is a text node set the selection to the end of that node\n
\t\t\t\tnode = marker.previousSibling;\n
\t\t\t\tif (node && node.nodeType == 3) {\n
\t\t\t\t\trng.setStart(node, node.nodeValue.length);\n
\n
\t\t\t\t\t// TODO: Why can\'t we normalize on IE\n
\t\t\t\t\tif (!isIE) {\n
\t\t\t\t\t\tnode2 = marker.nextSibling;\n
\t\t\t\t\t\tif (node2 && node2.nodeType == 3) {\n
\t\t\t\t\t\t\tnode.appendData(node2.data);\n
\t\t\t\t\t\t\tnode2.parentNode.removeChild(node2);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\t// If the previous sibling isn\'t a text node or doesn\'t exist set the selection before the marker node\n
\t\t\t\t\trng.setStartBefore(marker);\n
\t\t\t\t\trng.setEndBefore(marker);\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove the marker node and set the new range\n
\t\t\t\tdom.remove(marker);\n
\t\t\t\tselection.setRng(rng);\n
\n
\t\t\t\t// Dispatch after event and add any visual elements needed\n
\t\t\t\teditor.fire(\'SetContent\', args);\n
\t\t\t\teditor.addVisual();\n
\t\t\t},\n
\n
\t\t\tmceInsertRawHTML: function(command, ui, value) {\n
\t\t\t\tselection.setContent(\'tiny_mce_marker\');\n
\t\t\t\teditor.setContent(\n
\t\t\t\t\teditor.getContent().replace(/tiny_mce_marker/g, function() {\n
\t\t\t\t\t\treturn value;\n
\t\t\t\t\t})\n
\t\t\t\t);\n
\t\t\t},\n
\n
\t\t\tmceToggleFormat: function(command, ui, value) {\n
\t\t\t\ttoggleFormat(value);\n
\t\t\t},\n
\n
\t\t\tmceSetContent: function(command, ui, value) {\n
\t\t\t\teditor.setContent(value);\n
\t\t\t},\n
\n
\t\t\t\'Indent,Outdent\': function(command) {\n
\t\t\t\tvar intentValue, indentUnit, value;\n
\n
\t\t\t\t// Setup indent level\n
\t\t\t\tintentValue = settings.indentation;\n
\t\t\t\tindentUnit = /[a-z%]+$/i.exec(intentValue);\n
\t\t\t\tintentValue = parseInt(intentValue, 10);\n
\n
\t\t\t\tif (!queryCommandState(\'InsertUnorderedList\') && !queryCommandState(\'InsertOrderedList\')) {\n
\t\t\t\t\t// If forced_root_blocks is set to false we don\'t have a block to indent so lets create a div\n
\t\t\t\t\tif (!settings.forced_root_block && !dom.getParent(selection.getNode(), dom.isBlock)) {\n
\t\t\t\t\t\tformatter.apply(\'div\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teach(selection.getSelectedBlocks(), function(element) {\n
\t\t\t\t\t\tif (element.nodeName != "LI") {\n
\t\t\t\t\t\t\tvar indentStyleName = editor.getParam(\'indent_use_margin\', false) ? \'margin\' : \'padding\';\n
\n
\t\t\t\t\t\t\tindentStyleName += dom.getStyle(element, \'direction\', true) == \'rtl\' ? \'Right\' : \'Left\';\n
\n
\t\t\t\t\t\t\tif (command == \'outdent\') {\n
\t\t\t\t\t\t\t\tvalue = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - intentValue);\n
\t\t\t\t\t\t\t\tdom.setStyle(element, indentStyleName, value ? value + indentUnit : \'\');\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tvalue = (parseInt(element.style[indentStyleName] || 0, 10) + intentValue) + indentUnit;\n
\t\t\t\t\t\t\t\tdom.setStyle(element, indentStyleName, value);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\texecNativeCommand(command);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tmceRepaint: function() {\n
\t\t\t\tif (isGecko) {\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\tstoreSelection(TRUE);\n
\n
\t\t\t\t\t\tif (selection.getSel()) {\n
\t\t\t\t\t\t\tselection.getSel().selectAllChildren(editor.getBody());\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tselection.collapse(TRUE);\n
\t\t\t\t\t\trestoreSelection();\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Ignore\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tInsertHorizontalRule: function() {\n
\t\t\t\teditor.execCommand(\'mceInsertContent\', false, \'<hr />\');\n
\t\t\t},\n
\n
\t\t\tmceToggleVisualAid: function() {\n
\t\t\t\teditor.hasVisual = !editor.hasVisual;\n
\t\t\t\teditor.addVisual();\n
\t\t\t},\n
\n
\t\t\tmceReplaceContent: function(command, ui, value) {\n
\t\t\t\teditor.execCommand(\'mceInsertContent\', false, value.replace(/\\{\\$selection\\}/g, selection.getContent({format: \'text\'})));\n
\t\t\t},\n
\n
\t\t\tmceInsertLink: function(command, ui, value) {\n
\t\t\t\tvar anchor;\n
\n
\t\t\t\tif (typeof value == \'string\') {\n
\t\t\t\t\tvalue = {href: value};\n
\t\t\t\t}\n
\n
\t\t\t\tanchor = dom.getParent(selection.getNode(), \'a\');\n
\n
\t\t\t\t// Spaces are never valid in URLs and it\'s a very common mistake for people to make so we fix it here.\n
\t\t\t\tvalue.href = value.href.replace(\' \', \'%20\');\n
\n
\t\t\t\t// Remove existing links if there could be child links or that the href isn\'t specified\n
\t\t\t\tif (!anchor || !value.href) {\n
\t\t\t\t\tformatter.remove(\'link\');\n
\t\t\t\t}\n
\n
\t\t\t\t// Apply new link to selection\n
\t\t\t\tif (value.href) {\n
\t\t\t\t\tformatter.apply(\'link\', value, anchor);\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tselectAll: function() {\n
\t\t\t\tvar root = dom.getRoot(), rng;\n
\n
\t\t\t\tif (selection.getRng().setStart) {\n
\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\trng.setStart(root, 0);\n
\t\t\t\t\trng.setEnd(root, root.childNodes.length);\n
\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t} else {\n
\t\t\t\t\t// IE will render it\'s own root level block elements and sometimes\n
\t\t\t\t\t// even put font elements in them when the user starts typing. So we need to\n
\t\t\t\t\t// move the selection to a more suitable element from this:\n
\t\t\t\t\t// <body>|<p></p></body> to this: <body><p>|</p></body>\n
\t\t\t\t\trng = selection.getRng();\n
\t\t\t\t\tif (!rng.item) {\n
\t\t\t\t\t\trng.moveToElementText(root);\n
\t\t\t\t\t\trng.select();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\t"delete": function() {\n
\t\t\t\texecNativeCommand("Delete");\n
\n
\t\t\t\t// Check if body is empty after the delete call if so then set the contents\n
\t\t\t\t// to an empty string and move the caret to any block produced by that operation\n
\t\t\t\t// this fixes the issue with root blocks not being properly produced after a delete call on IE\n
\t\t\t\tvar body = editor.getBody();\n
\n
\t\t\t\tif (dom.isEmpty(body)) {\n
\t\t\t\t\teditor.setContent(\'\');\n
\n
\t\t\t\t\tif (body.firstChild && dom.isBlock(body.firstChild)) {\n
\t\t\t\t\t\teditor.selection.setCursorLocation(body.firstChild, 0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.selection.setCursorLocation(body, 0);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t},\n
\n
\t\t\tmceNewDocument: function() {\n
\t\t\t\teditor.setContent(\'\');\n
\t\t\t},\n
\n
\t\t\tInsertLineBreak: function(command, ui, value) {\n
\t\t\t\t// We load the current event in from EnterKey.js when appropriate to heed\n
\t\t\t\t// certain event-specific variations such as ctrl-enter in a list\n
\t\t\t\tvar evt = value;\n
\t\t\t\tvar brElm, extraBr, marker;\n
\t\t\t\tvar rng = selection.getRng(true);\n
\t\t\t\tnew RangeUtils(dom).normalize(rng);\n
\n
\t\t\t\tvar offset = rng.startOffset;\n
\t\t\t\tvar container = rng.startContainer;\n
\n
\t\t\t\t// Resolve node index\n
\t\t\t\tif (container.nodeType == 1 && container.hasChildNodes()) {\n
\t\t\t\t\tvar isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n
\n
\t\t\t\t\tcontainer = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n
\t\t\t\t\tif (isAfterLastNodeInContainer && container.nodeType == 3) {\n
\t\t\t\t\t\toffset = container.nodeValue.length;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\toffset = 0;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tvar parentBlock = dom.getParent(container, dom.isBlock);\n
\t\t\t\tvar parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : \'\'; // IE < 9 & HTML5\n
\t\t\t\tvar containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n
\t\t\t\tvar containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : \'\'; // IE < 9 & HTML5\n
\n
\t\t\t\t// Enter inside block contained within a LI then split or insert before/after LI\n
\t\t\t\tvar isControlKey = evt && evt.ctrlKey;\n
\t\t\t\tif (containerBlockName == \'LI\' && !isControlKey) {\n
\t\t\t\t\tparentBlock = containerBlock;\n
\t\t\t\t\tparentBlockName = containerBlockName;\n
\t\t\t\t}\n
\n
\t\t\t\t// Walks the parent block to the right and look for BR elements\n
\t\t\t\tfunction hasRightSideContent() {\n
\t\t\t\t\tvar walker = new TreeWalker(container, parentBlock), node;\n
\t\t\t\t\tvar nonEmptyElementsMap = editor.schema.getNonEmptyElements();\n
\n
\t\t\t\t\twhile ((node = walker.next())) {\n
\t\t\t\t\t\tif (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (container && container.nodeType == 3 && offset >= container.nodeValue.length) {\n
\t\t\t\t\t// Insert extra BR element at the end block elements\n
\t\t\t\t\tif (!isOldIE && !hasRightSideContent()) {\n
\t\t\t\t\t\tbrElm = dom.create(\'br\');\n
\t\t\t\t\t\trng.insertNode(brElm);\n
\t\t\t\t\t\trng.setStartAfter(brElm);\n
\t\t\t\t\t\trng.setEndAfter(brElm);\n
\t\t\t\t\t\textraBr = true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tbrElm = dom.create(\'br\');\n
\t\t\t\trng.insertNode(brElm);\n
\n
\t\t\t\t// Rendering modes below IE8 doesn\'t display BR elements in PRE unless we have a \\n before it\n
\t\t\t\tvar documentMode = dom.doc.documentMode;\n
\t\t\t\tif (isOldIE && parentBlockName == \'PRE\' && (!documentMode || documentMode < 8)) {\n
\t\t\t\t\tbrElm.parentNode.insertBefore(dom.doc.createTextNode(\'\\r\'), brElm);\n
\t\t\t\t}\n
\n
\t\t\t\t// Insert temp marker and scroll to that\n
\t\t\t\tmarker = dom.create(\'span\', {}, \'&nbsp;\');\n
\t\t\t\tbrElm.parentNode.insertBefore(marker, brElm);\n
\t\t\t\tselection.scrollIntoView(marker);\n
\t\t\t\tdom.remove(marker);\n
\n
\t\t\t\tif (!extraBr) {\n
\t\t\t\t\trng.setStartAfter(brElm);\n
\t\t\t\t\trng.setEndAfter(brElm);\n
\t\t\t\t} else {\n
\t\t\t\t\trng.setStartBefore(brElm);\n
\t\t\t\t\trng.setEndBefore(brElm);\n
\t\t\t\t}\n
\n
\t\t\t\tselection.setRng(rng);\n
\t\t\t\teditor.undoManager.add();\n
\n
\t\t\t\treturn TRUE;\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Add queryCommandState overrides\n
\t\taddCommands({\n
\t\t\t// Override justify commands\n
\t\t\t\'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull\': function(command) {\n
\t\t\t\tvar name = \'align\' + command.substring(7);\n
\t\t\t\tvar nodes = selection.isCollapsed() ? [dom.getParent(selection.getNode(), dom.isBlock)] : selection.getSelectedBlocks();\n
\t\t\t\tvar matches = map(nodes, function(node) {\n
\t\t\t\t\treturn !!formatter.matchNode(node, name);\n
\t\t\t\t});\n
\t\t\t\treturn inArray(matches, TRUE) !== -1;\n
\t\t\t},\n
\n
\t\t\t\'Bold,Italic,Underline,Strikethrough,Superscript,Subscript\': function(command) {\n
\t\t\t\treturn isFormatMatch(command);\n
\t\t\t},\n
\n
\t\t\tmceBlockQuote: function() {\n
\t\t\t\treturn isFormatMatch(\'blockquote\');\n
\t\t\t},\n
\n
\t\t\tOutdent: function() {\n
\t\t\t\tvar node;\n
\n
\t\t\t\tif (settings.inline_styles) {\n
\t\t\t\t\tif ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {\n
\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {\n
\t\t\t\t\t\treturn TRUE;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn (\n
\t\t\t\t\tqueryCommandState(\'InsertUnorderedList\') ||\n
\t\t\t\t\tqueryCommandState(\'InsertOrderedList\') ||\n
\t\t\t\t\t(!settings.inline_styles && !!dom.getParent(selection.getNode(), \'BLOCKQUOTE\'))\n
\t\t\t\t);\n
\t\t\t},\n
\n
\t\t\t\'InsertUnorderedList,InsertOrderedList\': function(command) {\n
\t\t\t\tvar list = dom.getParent(selection.getNode(), \'ul,ol\');\n
\n
\t\t\t\treturn list &&\n
\t\t\t\t\t(\n
\t\t\t\t\t\tcommand === \'insertunorderedlist\' && list.tagName === \'UL\' ||\n
\t\t\t\t\t\tcommand === \'insertorderedlist\' && list.tagName === \'OL\'\n
\t\t\t\t\t);\n
\t\t\t}\n
\t\t}, \'state\');\n
\n
\t\t// Add queryCommandValue overrides\n
\t\taddCommands({\n
\t\t\t\'FontSize,FontName\': function(command) {\n
\t\t\t\tvar value = 0, parent;\n
\n
\t\t\t\tif ((parent = dom.getParent(selection.getNode(), \'span\'))) {\n
\t\t\t\t\tif (command == \'fontsize\') {\n
\t\t\t\t\t\tvalue = parent.style.fontSize;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tvalue = parent.style.fontFamily.replace(/, /g, \',\').replace(/[\\\'\\"]/g, \'\').toLowerCase();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t}\n
\t\t}, \'value\');\n
\n
\t\t// Add undo manager logic\n
\t\taddCommands({\n
\t\t\tUndo: function() {\n
\t\t\t\teditor.undoManager.undo();\n
\t\t\t},\n
\n
\t\t\tRedo: function() {\n
\t\t\t\teditor.undoManager.redo();\n
\t\t\t}\n
\t\t});\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/URI.js\n
\n
/**\n
 * URI.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles parsing, modification and serialization of URI/URL strings.\n
 * @class tinymce.util.URI\n
 */\n
define("tinymce/util/URI", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar each = Tools.each, trim = Tools.trim;\n
\tvar queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(\' \');\n
\tvar DEFAULT_PORTS = {\n
\t\t\'ftp\': 21,\n
\t\t\'http\': 80,\n
\t\t\'https\': 443,\n
\t\t\'mailto\': 25\n
\t};\n
\n
\t/**\n
\t * Constructs a new URI instance.\n
\t *\n
\t * @constructor\n
\t * @method URI\n
\t * @param {String} url URI string to parse.\n
\t * @param {Object} settings Optional settings object.\n
\t */\n
\tfunction URI(url, settings) {\n
\t\tvar self = this, baseUri, base_url;\n
\n
\t\turl = trim(url);\n
\t\tsettings = self.settings = settings || {};\n
\t\tbaseUri = settings.base_uri;\n
\n
\t\t// Strange app protocol that isn\'t http/https or local anchor\n
\t\t// For example: mailto,skype,tel etc.\n
\t\tif (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n
\t\t\tself.source = url;\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tvar isProtocolRelative = url.indexOf(\'//\') === 0;\n
\n
\t\t// Absolute path with no host, fake host and protocol\n
\t\tif (url.indexOf(\'/\') === 0 && !isProtocolRelative) {\n
\t\t\turl = (baseUri ? baseUri.protocol || \'http\' : \'http\') + \'://mce_host\' + url;\n
\t\t}\n
\n
\t\t// Relative path http:// or protocol relative //path\n
\t\tif (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n
\t\t\tbase_url = settings.base_uri ? settings.base_uri.path : new URI(location.href).directory;\n
\t\t\tif (settings.base_uri.protocol === "") {\n
\t\t\t\turl = \'//mce_host\' + self.toAbsPath(base_url, url);\n
\t\t\t} else {\n
\t\t\t\turl = /([^#?]*)([#?]?.*)/.exec(url);\n
\t\t\t\turl = ((baseUri && baseUri.protocol) || \'http\') + \'://mce_host\' + self.toAbsPath(base_url, url[1]) + url[2];\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)\n
\t\turl = url.replace(/@@/g, \'(mce_at)\'); // Zope 3 workaround, they use @@something\n
\n
\t\t/*jshint maxlen: 255 */\n
\t\t/*eslint max-len: 0 */\n
\t\turl = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n
\n
\t\teach(queryParts, function(v, i) {\n
\t\t\tvar part = url[i];\n
\n
\t\t\t// Zope 3 workaround, they use @@something\n
\t\t\tif (part) {\n
\t\t\t\tpart = part.replace(/\\(mce_at\\)/g, \'@@\');\n
\t\t\t}\n
\n
\t\t\tself[v] = part;\n
\t\t});\n
\n
\t\tif (baseUri) {\n
\t\t\tif (!self.protocol) {\n
\t\t\t\tself.protocol = baseUri.protocol;\n
\t\t\t}\n
\n
\t\t\tif (!self.userInfo) {\n
\t\t\t\tself.userInfo = baseUri.userInfo;\n
\t\t\t}\n
\n
\t\t\tif (!self.port && self.host === \'mce_host\') {\n
\t\t\t\tself.port = baseUri.port;\n
\t\t\t}\n
\n
\t\t\tif (!self.host || self.host === \'mce_host\') {\n
\t\t\t\tself.host = baseUri.host;\n
\t\t\t}\n
\n
\t\t\tself.source = \'\';\n
\t\t}\n
\n
\t\tif (isProtocolRelative) {\n
\t\t\tself.protocol = \'\';\n
\t\t}\n
\n
\t\t//t.path = t.path || \'/\';\n
\t}\n
\n
\tURI.prototype = {\n
\t\t/**\n
\t\t * Sets the internal path part of the URI.\n
\t\t *\n
\t\t * @method setPath\n
\t\t * @param {string} path Path string to set.\n
\t\t */\n
\t\tsetPath: function(path) {\n
\t\t\tvar self = this;\n
\n
\t\t\tpath = /^(.*?)\\/?(\\w+)?$/.exec(path);\n
\n
\t\t\t// Update path parts\n
\t\t\tself.path = path[0];\n
\t\t\tself.directory = path[1];\n
\t\t\tself.file = path[2];\n
\n
\t\t\t// Rebuild source\n
\t\t\tself.source = \'\';\n
\t\t\tself.getURI();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Converts the specified URI into a relative URI based on the current URI instance location.\n
\t\t *\n
\t\t * @method toRelative\n
\t\t * @param {String} uri URI to convert into a relative path/URI.\n
\t\t * @return {String} Relative URI from the point specified in the current URI instance.\n
\t\t * @example\n
\t\t * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm\n
\t\t * var url = new tinymce.util.URI(\'http://www.site.com/dir/\').toRelative(\'http://www.site.com/dir/somedir/somefile.htm\');\n
\t\t */\n
\t\ttoRelative: function(uri) {\n
\t\t\tvar self = this, output;\n
\n
\t\t\tif (uri === "./") {\n
\t\t\t\treturn uri;\n
\t\t\t}\n
\n
\t\t\turi = new URI(uri, {base_uri: self});\n
\n
\t\t\t// Not on same domain/port or protocol\n
\t\t\tif ((uri.host != \'mce_host\' && self.host != uri.host && uri.host) || self.port != uri.port ||\n
\t\t\t\t(self.protocol != uri.protocol && uri.protocol !== "")) {\n
\t\t\t\treturn uri.getURI();\n
\t\t\t}\n
\n
\t\t\tvar tu = self.getURI(), uu = uri.getURI();\n
\n
\t\t\t// Allow usage of the base_uri when relative_urls = true\n
\t\t\tif (tu == uu || (tu.charAt(tu.length - 1) == "/" && tu.substr(0, tu.length - 1) == uu)) {\n
\t\t\t\treturn tu;\n
\t\t\t}\n
\n
\t\t\toutput = self.toRelPath(self.path, uri.path);\n
\n
\t\t\t// Add query\n
\t\t\tif (uri.query) {\n
\t\t\t\toutput += \'?\' + uri.query;\n
\t\t\t}\n
\n
\t\t\t// Add anchor\n
\t\t\tif (uri.anchor) {\n
\t\t\t\toutput += \'#\' + uri.anchor;\n
\t\t\t}\n
\n
\t\t\treturn output;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Converts the specified URI into a absolute URI based on the current URI instance location.\n
\t\t *\n
\t\t * @method toAbsolute\n
\t\t * @param {String} uri URI to convert into a relative path/URI.\n
\t\t * @param {Boolean} noHost No host and protocol prefix.\n
\t\t * @return {String} Absolute URI from the point specified in the current URI instance.\n
\t\t * @example\n
\t\t * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm\n
\t\t * var url = new tinymce.util.URI(\'http://www.site.com/dir/\').toAbsolute(\'somedir/somefile.htm\');\n
\t\t */\n
\t\ttoAbsolute: function(uri, noHost) {\n
\t\t\turi = new URI(uri, {base_uri: this});\n
\n
\t\t\treturn uri.getURI(noHost && this.isSameOrigin(uri));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.\n
\t\t * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they\n
\t\t * won\'t match, if the port specifications differ.\n
\t\t *\n
\t\t * @method isSameOrigin\n
\t\t * @param {tinymce.util.URI} uri Uri instance to compare.\n
\t\t * @returns {Boolean} True if the origins are the same.\n
\t\t */\n
\t\tisSameOrigin: function(uri) {\n
\t\t\tif (this.host == uri.host && this.protocol == uri.protocol) {\n
\t\t\t\tif (this.port == uri.port) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\tvar defaultPort = DEFAULT_PORTS[this.protocol];\n
\t\t\t\tif (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Converts a absolute path into a relative path.\n
\t\t *\n
\t\t * @method toRelPath\n
\t\t * @param {String} base Base point to convert the path from.\n
\t\t * @param {String} path Absolute path to convert into a relative path.\n
\t\t */\n
\t\ttoRelPath: function(base, path) {\n
\t\t\tvar items, breakPoint = 0, out = \'\', i, l;\n
\n
\t\t\t// Split the paths\n
\t\t\tbase = base.substring(0, base.lastIndexOf(\'/\'));\n
\t\t\tbase = base.split(\'/\');\n
\t\t\titems = path.split(\'/\');\n
\n
\t\t\tif (base.length >= items.length) {\n
\t\t\t\tfor (i = 0, l = base.length; i < l; i++) {\n
\t\t\t\t\tif (i >= items.length || base[i] != items[i]) {\n
\t\t\t\t\t\tbreakPoint = i + 1;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (base.length < items.length) {\n
\t\t\t\tfor (i = 0, l = items.length; i < l; i++) {\n
\t\t\t\t\tif (i >= base.length || base[i] != items[i]) {\n
\t\t\t\t\t\tbreakPoint = i + 1;\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (breakPoint === 1) {\n
\t\t\t\treturn path;\n
\t\t\t}\n
\n
\t\t\tfor (i = 0, l = base.length - (breakPoint - 1); i < l; i++) {\n
\t\t\t\tout += "../";\n
\t\t\t}\n
\n
\t\t\tfor (i = breakPoint - 1, l = items.length; i < l; i++) {\n
\t\t\t\tif (i != breakPoint - 1) {\n
\t\t\t\t\tout += "/" + items[i];\n
\t\t\t\t} else {\n
\t\t\t\t\tout += items[i];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn out;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Converts a relative path into a absolute path.\n
\t\t *\n
\t\t * @method toAbsPath\n
\t\t * @param {String} base Base point to convert the path from.\n
\t\t * @param {String} path Relative path to convert into an absolute path.\n
\t\t */\n
\t\ttoAbsPath: function(base, path) {\n
\t\t\tvar i, nb = 0, o = [], tr, outPath;\n
\n
\t\t\t// Split paths\n
\t\t\ttr = /\\/$/.test(path) ? \'/\' : \'\';\n
\t\t\tbase = base.split(\'/\');\n
\t\t\tpath = path.split(\'/\');\n
\n
\t\t\t// Remove empty chunks\n
\t\t\teach(base, function(k) {\n
\t\t\t\tif (k) {\n
\t\t\t\t\to.push(k);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tbase = o;\n
\n
\t\t\t// Merge relURLParts chunks\n
\t\t\tfor (i = path.length - 1, o = []; i >= 0; i--) {\n
\t\t\t\t// Ignore empty or .\n
\t\t\t\tif (path[i].length === 0 || path[i] === ".") {\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// Is parent\n
\t\t\t\tif (path[i] === \'..\') {\n
\t\t\t\t\tnb++;\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// Move up\n
\t\t\t\tif (nb > 0) {\n
\t\t\t\t\tnb--;\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\to.push(path[i]);\n
\t\t\t}\n
\n
\t\t\ti = base.length - nb;\n
\n
\t\t\t// If /a/b/c or /\n
\t\t\tif (i <= 0) {\n
\t\t\t\toutPath = o.reverse().join(\'/\');\n
\t\t\t} else {\n
\t\t\t\toutPath = base.slice(0, i).join(\'/\') + \'/\' + o.reverse().join(\'/\');\n
\t\t\t}\n
\n
\t\t\t// Add front / if it\'s needed\n
\t\t\tif (outPath.indexOf(\'/\') !== 0) {\n
\t\t\t\toutPath = \'/\' + outPath;\n
\t\t\t}\n
\n
\t\t\t// Add traling / if it\'s needed\n
\t\t\tif (tr && outPath.lastIndexOf(\'/\') !== outPath.length - 1) {\n
\t\t\t\toutPath += tr;\n
\t\t\t}\n
\n
\t\t\treturn outPath;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the full URI of the internal structure.\n
\t\t *\n
\t\t * @method getURI\n
\t\t * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.\n
\t\t */\n
\t\tgetURI: function(noProtoHost) {\n
\t\t\tvar s, self = this;\n
\n
\t\t\t// Rebuild source\n
\t\t\tif (!self.source || noProtoHost) {\n
\t\t\t\ts = \'\';\n
\n
\t\t\t\tif (!noProtoHost) {\n
\t\t\t\t\tif (self.protocol) {\n
\t\t\t\t\t\ts += self.protocol + \'://\';\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\ts += \'//\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (self.userInfo) {\n
\t\t\t\t\t\ts += self.userInfo + \'@\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (self.host) {\n
\t\t\t\t\t\ts += self.host;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (self.port) {\n
\t\t\t\t\t\ts += \':\' + self.port;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (self.path) {\n
\t\t\t\t\ts += self.path;\n
\t\t\t\t}\n
\n
\t\t\t\tif (self.query) {\n
\t\t\t\t\ts += \'?\' + self.query;\n
\t\t\t\t}\n
\n
\t\t\t\tif (self.anchor) {\n
\t\t\t\t\ts += \'#\' + self.anchor;\n
\t\t\t\t}\n
\n
\t\t\t\tself.source = s;\n
\t\t\t}\n
\n
\t\t\treturn self.source;\n
\t\t}\n
\t};\n
\n
\tURI.parseDataUri = function(uri) {\n
\t\tvar type, matches;\n
\n
\t\turi = decodeURIComponent(uri).split(\',\');\n
\n
\t\tmatches = /data:([^;]+)/.exec(uri[0]);\n
\t\tif (matches) {\n
\t\t\ttype = matches[1];\n
\t\t}\n
\n
\t\treturn {\n
\t\t\ttype: type,\n
\t\t\tdata: uri[1]\n
\t\t};\n
\t};\n
\n
\treturn URI;\n
});\n
\n
// Included from: js/tinymce/classes/util/Class.js\n
\n
/**\n
 * Class.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This utilitiy class is used for easier inheritage.\n
 *\n
 * Features:\n
 * * Exposed super functions: this._super();\n
 * * Mixins\n
 * * Dummy functions\n
 * * Property functions: var value = object.value(); and object.value(newValue);\n
 * * Static functions\n
 * * Defaults settings\n
 */\n
define("tinymce/util/Class", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar each = Tools.each, extend = Tools.extend;\n
\n
\tvar extendClass, initializing;\n
\n
\tfunction Class() {\n
\t}\n
\n
\t// Provides classical inheritance, based on code made by John Resig\n
\tClass.extend = extendClass = function(prop) {\n
\t\tvar self = this, _super = self.prototype, prototype, name, member;\n
\n
\t\t// The dummy class constructor\n
\t\tfunction Class() {\n
\t\t\tvar i, mixins, mixin, self = this;\n
\n
\t\t\t// All construction is actually done in the init method\n
\t\t\tif (!initializing) {\n
\t\t\t\t// Run class constuctor\n
\t\t\t\tif (self.init) {\n
\t\t\t\t\tself.init.apply(self, arguments);\n
\t\t\t\t}\n
\n
\t\t\t\t// Run mixin constructors\n
\t\t\t\tmixins = self.Mixins;\n
\t\t\t\tif (mixins) {\n
\t\t\t\t\ti = mixins.length;\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tmixin = mixins[i];\n
\t\t\t\t\t\tif (mixin.init) {\n
\t\t\t\t\t\t\tmixin.init.apply(self, arguments);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Dummy function, needs to be extended in order to provide functionality\n
\t\tfunction dummy() {\n
\t\t\treturn this;\n
\t\t}\n
\n
\t\t// Creates a overloaded method for the class\n
\t\t// this enables you to use this._super(); to call the super function\n
\t\tfunction createMethod(name, fn) {\n
\t\t\treturn function() {\n
\t\t\t\tvar self = this, tmp = self._super, ret;\n
\n
\t\t\t\tself._super = _super[name];\n
\t\t\t\tret = fn.apply(self, arguments);\n
\t\t\t\tself._super = tmp;\n
\n
\t\t\t\treturn ret;\n
\t\t\t};\n
\t\t}\n
\n
\t\t// Instantiate a base class (but only create the instance,\n
\t\t// don\'t run the init constructor)\n
\t\tinitializing = true;\n
\n
\t\t/*eslint new-cap:0 */\n
\t\tprototype = new self();\n
\t\tinitializing = false;\n
\n
\t\t// Add mixins\n
\t\tif (prop.Mixins) {\n
\t\t\teach(prop.Mixins, function(mixin) {\n
\t\t\t\tmixin = mixin;\n
\n
\t\t\t\tfor (var name in mixin) {\n
\t\t\t\t\tif (name !== "init") {\n
\t\t\t\t\t\tprop[name] = mixin[name];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (_super.Mixins) {\n
\t\t\t\tprop.Mixins = _super.Mixins.concat(prop.Mixins);\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Generate dummy methods\n
\t\tif (prop.Methods) {\n
\t\t\teach(prop.Methods.split(\',\'), function(name) {\n
\t\t\t\tprop[name] = dummy;\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Generate property methods\n
\t\tif (prop.Properties) {\n
\t\t\teach(prop.Properties.split(\',\'), function(name) {\n
\t\t\t\tvar fieldName = \'_\' + name;\n
\n
\t\t\t\tprop[name] = function(value) {\n
\t\t\t\t\tvar self = this, undef;\n
\n
\t\t\t\t\t// Set value\n
\t\t\t\t\tif (value !== undef) {\n
\t\t\t\t\t\tself[fieldName] = value;\n
\n
\t\t\t\t\t\treturn self;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Get value\n
\t\t\t\t\treturn self[fieldName];\n
\t\t\t\t};\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Static functions\n
\t\tif (prop.Statics) {\n
\t\t\teach(prop.Statics, function(func, name) {\n
\t\t\t\tClass[name] = func;\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Default settings\n
\t\tif (prop.Defaults && _super.Defaults) {\n
\t\t\tprop.Defaults = extend({}, _super.Defaults, prop.Defaults);\n
\t\t}\n
\n
\t\t// Copy the properties over onto the new prototype\n
\t\tfor (name in prop) {\n
\t\t\tmember = prop[name];\n
\n
\t\t\tif (typeof member == "function" && _super[name]) {\n
\t\t\t\tprototype[name] = createMethod(name, member);\n
\t\t\t} else {\n
\t\t\t\tprototype[name] = member;\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Populate our constructed prototype object\n
\t\tClass.prototype = prototype;\n
\n
\t\t// Enforce the constructor to be what we expect\n
\t\tClass.constructor = Class;\n
\n
\t\t// And make this class extendible\n
\t\tClass.extend = extendClass;\n
\n
\t\treturn Class;\n
\t};\n
\n
\treturn Class;\n
});\n
\n
// Included from: js/tinymce/classes/util/EventDispatcher.js\n
\n
/**\n
 * EventDispatcher.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class lets you add/remove and fire events by name on the specified scope. This makes\n
 * it easy to add event listener logic to any class.\n
 *\n
 * @class tinymce.util.EventDispatcher\n
 * @example\n
 *  var eventDispatcher = new EventDispatcher();\n
 *\n
 *  eventDispatcher.on(\'click\', function() {console.log(\'data\');});\n
 *  eventDispatcher.fire(\'click\', {data: 123});\n
 */\n
define("tinymce/util/EventDispatcher", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\tvar nativeEvents = Tools.makeMap(\n
\t\t"focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange " +\n
\t\t"mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover " +\n
\t\t"draggesture dragdrop drop drag submit " +\n
\t\t"compositionstart compositionend compositionupdate touchstart touchend",\n
\t\t\' \'\n
\t);\n
\n
\tfunction Dispatcher(settings) {\n
\t\tvar self = this, scope, bindings = {}, toggleEvent;\n
\n
\t\tfunction returnFalse() {\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\tfunction returnTrue() {\n
\t\t\treturn true;\n
\t\t}\n
\n
\t\tsettings = settings || {};\n
\t\tscope = settings.scope || self;\n
\t\ttoggleEvent = settings.toggleEvent || returnFalse;\n
\n
\t\t/**\n
\t\t * Fires the specified event by name.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {String} name Name of the event to fire.\n
\t\t * @param {Object?} args Event arguments.\n
\t\t * @return {Object} Event args instance passed in.\n
\t\t * @example\n
\t\t * instance.fire(\'event\', {...});\n
\t\t */\n
\t\tfunction fire(name, args) {\n
\t\t\tvar handlers, i, l, callback;\n
\n
\t\t\tname = name.toLowerCase();\n
\t\t\targs = args || {};\n
\t\t\targs.type = name;\n
\n
\t\t\t// Setup target is there isn\'t one\n
\t\t\tif (!args.target) {\n
\t\t\t\targs.target = scope;\n
\t\t\t}\n
\n
\t\t\t// Add event delegation methods if they are missing\n
\t\t\tif (!args.preventDefault) {\n
\t\t\t\t// Add preventDefault method\n
\t\t\t\targs.preventDefault = function() {\n
\t\t\t\t\targs.isDefaultPrevented = returnTrue;\n
\t\t\t\t};\n
\n
\t\t\t\t// Add stopPropagation\n
\t\t\t\targs.stopPropagation = function() {\n
\t\t\t\t\targs.isPropagationStopped = returnTrue;\n
\t\t\t\t};\n
\n
\t\t\t\t// Add stopImmediatePropagation\n
\t\t\t\targs.stopImmediatePropagation = function() {\n
\t\t\t\t\targs.isImmediatePropagationStopped = returnTrue;\n
\t\t\t\t};\n
\n
\t\t\t\t// Add event delegation states\n
\t\t\t\targs.isDefaultPrevented = returnFalse;\n
\t\t\t\targs.isPropagationStopped = returnFalse;\n
\t\t\t\targs.isImmediatePropagationStopped = returnFalse;\n
\t\t\t}\n
\n
\t\t\tif (settings.beforeFire) {\n
\t\t\t\tsettings.beforeFire(args);\n
\t\t\t}\n
\n
\t\t\thandlers = bindings[name];\n
\t\t\tif (handlers) {\n
\t\t\t\tfor (i = 0, l = handlers.length; i < l; i++) {\n
\t\t\t\t\tcallback = handlers[i];\n
\n
\t\t\t\t\t// Unbind handlers marked with "once"\n
\t\t\t\t\tif (callback.once) {\n
\t\t\t\t\t\toff(name, callback.func);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Stop immediate propagation if needed\n
\t\t\t\t\tif (args.isImmediatePropagationStopped()) {\n
\t\t\t\t\t\targs.stopPropagation();\n
\t\t\t\t\t\treturn args;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// If callback returns false then prevent default and stop all propagation\n
\t\t\t\t\tif (callback.func.call(scope, args) === false) {\n
\t\t\t\t\t\targs.preventDefault();\n
\t\t\t\t\t\treturn args;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn args;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Binds an event listener to a specific event by name.\n
\t\t *\n
\t\t * @method on\n
\t\t * @param {String} name Event name or space separated list of events to bind.\n
\t\t * @param {callback} callback Callback to be executed when the event occurs.\n
\t\t * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.\n
\t\t * @return {Object} Current class instance.\n
\t\t * @example\n
\t\t * instance.on(\'event\', function(e) {\n
\t\t *     // Callback logic\n
\t\t * });\n
\t\t */\n
\t\tfunction on(name, callback, prepend, extra) {\n
\t\t\tvar handlers, names, i;\n
\n
\t\t\tif (callback === false) {\n
\t\t\t\tcallback = returnFalse;\n
\t\t\t}\n
\n
\t\t\tif (callback) {\n
\t\t\t\tcallback = {\n
\t\t\t\t\tfunc: callback\n
\t\t\t\t};\n
\n
\t\t\t\tif (extra) {\n
\t\t\t\t\tTools.extend(callback, extra);\n
\t\t\t\t}\n
\n
\t\t\t\tnames = name.toLowerCase().split(\' \');\n
\t\t\t\ti = names.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tname = names[i];\n
\t\t\t\t\thandlers = bindings[name];\n
\t\t\t\t\tif (!handlers) {\n
\t\t\t\t\t\thandlers = bindings[name] = [];\n
\t\t\t\t\t\ttoggleEvent(name, true);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (prepend) {\n
\t\t\t\t\t\thandlers.unshift(callback);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\thandlers.push(callback);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Unbinds an event listener to a specific event by name.\n
\t\t *\n
\t\t * @method off\n
\t\t * @param {String?} name Name of the event to unbind.\n
\t\t * @param {callback?} callback Callback to unbind.\n
\t\t * @return {Object} Current class instance.\n
\t\t * @example\n
\t\t * // Unbind specific callback\n
\t\t * instance.off(\'event\', handler);\n
\t\t *\n
\t\t * // Unbind all listeners by name\n
\t\t * instance.off(\'event\');\n
\t\t *\n
\t\t * // Unbind all events\n
\t\t * instance.off();\n
\t\t */\n
\t\tfunction off(name, callback) {\n
\t\t\tvar i, handlers, bindingName, names, hi;\n
\n
\t\t\tif (name) {\n
\t\t\t\tnames = name.toLowerCase().split(\' \');\n
\t\t\t\ti = names.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tname = names[i];\n
\t\t\t\t\thandlers = bindings[name];\n
\n
\t\t\t\t\t// Unbind all handlers\n
\t\t\t\t\tif (!name) {\n
\t\t\t\t\t\tfor (bindingName in bindings) {\n
\t\t\t\t\t\t\ttoggleEvent(bindingName, false);\n
\t\t\t\t\t\t\tdelete bindings[bindingName];\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn self;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (handlers) {\n
\t\t\t\t\t\t// Unbind all by name\n
\t\t\t\t\t\tif (!callback) {\n
\t\t\t\t\t\t\thandlers.length = 0;\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Unbind specific ones\n
\t\t\t\t\t\t\thi = handlers.length;\n
\t\t\t\t\t\t\twhile (hi--) {\n
\t\t\t\t\t\t\t\tif (handlers[hi].func === callback) {\n
\t\t\t\t\t\t\t\t\thandlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));\n
\t\t\t\t\t\t\t\t\tbindings[name] = handlers;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (!handlers.length) {\n
\t\t\t\t\t\t\ttoggleEvent(name, false);\n
\t\t\t\t\t\t\tdelete bindings[name];\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tfor (name in bindings) {\n
\t\t\t\t\ttoggleEvent(name, false);\n
\t\t\t\t}\n
\n
\t\t\t\tbindings = {};\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Binds an event listener to a specific event by name\n
\t\t * and automatically unbind the event once the callback fires.\n
\t\t *\n
\t\t * @method once\n
\t\t * @param {String} name Event name or space separated list of events to bind.\n
\t\t * @param {callback} callback Callback to be executed when the event occurs.\n
\t\t * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.\n
\t\t * @return {Object} Current class instance.\n
\t\t * @example\n
\t\t * instance.once(\'event\', function(e) {\n
\t\t *     // Callback logic\n
\t\t * });\n
\t\t */\n
\t\tfunction once(name, callback, prepend) {\n
\t\t\treturn on(name, callback, prepend, {once: true});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if the dispatcher has a event of the specified name.\n
\t\t *\n
\t\t * @method has\n
\t\t * @param {String} name Name of the event to check for.\n
\t\t * @return {Boolean} true/false if the event exists or not.\n
\t\t */\n
\t\tfunction has(name) {\n
\t\t\tname = name.toLowerCase();\n
\t\t\treturn !(!bindings[name] || bindings[name].length === 0);\n
\t\t}\n
\n
\t\t// Expose\n
\t\tself.fire = fire;\n
\t\tself.on = on;\n
\t\tself.off = off;\n
\t\tself.once = once;\n
\t\tself.has = has;\n
\t}\n
\n
\t/**\n
\t * Returns true/false if the specified event name is a native browser event or not.\n
\t *\n
\t * @method isNative\n
\t * @param {String} name Name to check if it\'s native.\n
\t * @return {Boolean} true/false if the event is native or not.\n
\t * @static\n
\t */\n
\tDispatcher.isNative = function(name) {\n
\t\treturn !!nativeEvents[name.toLowerCase()];\n
\t};\n
\n
\treturn Dispatcher;\n
});\n
\n
// Included from: js/tinymce/classes/data/Binding.js\n
\n
/**\n
 * Binding.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class gets dynamically extended to provide a binding between two models. This makes it possible to\n
 * sync the state of two properties in two models by a layer of abstraction.\n
 *\n
 * @class tinymce.data.Binding\n
 */\n
define("tinymce/data/Binding", [], function() {\n
\t/**\n
\t * Constructs a new bidning.\n
\t *\n
\t * @constructor\n
\t * @method Binding\n
\t * @param {Object} settings Settings to the binding.\n
\t */\n
\tfunction Binding(settings) {\n
\t\tthis.create = settings.create;\n
\t}\n
\n
\t/**\n
\t * Creates a binding for a property on a model.\n
\t *\n
\t * @method create\n
\t * @param {tinymce.data.ObservableObject} model Model to create binding to.\n
\t * @param {String} name Name of property to bind.\n
\t * @return {tinymce.data.Binding} Binding instance.\n
\t */\n
\tBinding.create = function(model, name) {\n
\t\treturn new Binding({\n
\t\t\tcreate: function(otherModel, otherName) {\n
\t\t\t\tvar bindings;\n
\n
\t\t\t\tfunction fromSelfToOther(e) {\n
\t\t\t\t\totherModel.set(otherName, e.value);\n
\t\t\t\t}\n
\n
\t\t\t\tfunction fromOtherToSelf(e) {\n
\t\t\t\t\tmodel.set(name, e.value);\n
\t\t\t\t}\n
\n
\t\t\t\totherModel.on(\'change:\' + otherName, fromOtherToSelf);\n
\t\t\t\tmodel.on(\'change:\' + name, fromSelfToOther);\n
\n
\t\t\t\t// Keep track of the bindings\n
\t\t\t\tbindings = otherModel._bindings;\n
\n
\t\t\t\tif (!bindings) {\n
\t\t\t\t\tbindings = otherModel._bindings = [];\n
\n
\t\t\t\t\totherModel.on(\'destroy\', function() {\n
\t\t\t\t\t\tvar i = bindings.length;\n
\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tbindings[i]();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\tbindings.push(function() {\n
\t\t\t\t\tmodel.off(\'change:\' + name, fromSelfToOther);\n
\t\t\t\t});\n
\n
\t\t\t\treturn model.get(name);\n
\t\t\t}\n
\t\t});\n
\t};\n
\n
\treturn Binding;\n
});\n
\n
// Included from: js/tinymce/classes/util/Observable.js\n
\n
/**\n
 * Observable.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This mixin will add event binding logic to classes.\n
 *\n
 * @mixin tinymce.util.Observable\n
 */\n
define("tinymce/util/Observable", [\n
\t"tinymce/util/EventDispatcher"\n
], function(EventDispatcher) {\n
\tfunction getEventDispatcher(obj) {\n
\t\tif (!obj._eventDispatcher) {\n
\t\t\tobj._eventDispatcher = new EventDispatcher({\n
\t\t\t\tscope: obj,\n
\t\t\t\ttoggleEvent: function(name, state) {\n
\t\t\t\t\tif (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n
\t\t\t\t\t\tobj.toggleNativeEvent(name, state);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\treturn obj._eventDispatcher;\n
\t}\n
\n
\treturn {\n
\t\t/**\n
\t\t * Fires the specified event by name.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {String} name Name of the event to fire.\n
\t\t * @param {Object?} args Event arguments.\n
\t\t * @param {Boolean?} bubble True/false if the event is to be bubbled.\n
\t\t * @return {Object} Event args instance passed in.\n
\t\t * @example\n
\t\t * instance.fire(\'event\', {...});\n
\t\t */\n
\t\tfire: function(name, args, bubble) {\n
\t\t\tvar self = this;\n
\n
\t\t\t// Prevent all events except the remove event after the instance has been removed\n
\t\t\tif (self.removed && name !== "remove") {\n
\t\t\t\treturn args;\n
\t\t\t}\n
\n
\t\t\targs = getEventDispatcher(self).fire(name, args, bubble);\n
\n
\t\t\t// Bubble event up to parents\n
\t\t\tif (bubble !== false && self.parent) {\n
\t\t\t\tvar parent = self.parent();\n
\t\t\t\twhile (parent && !args.isPropagationStopped()) {\n
\t\t\t\t\tparent.fire(name, args, false);\n
\t\t\t\t\tparent = parent.parent();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn args;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Binds an event listener to a specific event by name.\n
\t\t *\n
\t\t * @method on\n
\t\t * @param {String} name Event name or space separated list of events to bind.\n
\t\t * @param {callback} callback Callback to be executed when the event occurs.\n
\t\t * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.\n
\t\t * @return {Object} Current class instance.\n
\t\t * @example\n
\t\t * instance.on(\'event\', function(e) {\n
\t\t *     // Callback logic\n
\t\t * });\n
\t\t */\n
\t\ton: function(name, callback, prepend) {\n
\t\t\treturn getEventDispatcher(this).on(name, callback, prepend);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unbinds an event listener to a specific event by name.\n
\t\t *\n
\t\t * @method off\n
\t\t * @param {String?} name Name of the event to unbind.\n
\t\t * @param {callback?} callback Callback to unbind.\n
\t\t * @return {Object} Current class instance.\n
\t\t * @example\n
\t\t * // Unbind specific callback\n
\t\t * instance.off(\'event\', handler);\n
\t\t *\n
\t\t * // Unbind all listeners by name\n
\t\t * instance.off(\'event\');\n
\t\t *\n
\t\t * // Unbind all events\n
\t\t * instance.off();\n
\t\t */\n
\t\toff: function(name, callback) {\n
\t\t\treturn getEventDispatcher(this).off(name, callback);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Bind the event callback and once it fires the callback is removed.\n
\t\t *\n
\t\t * @method once\n
\t\t * @param {String} name Name of the event to bind.\n
\t\t * @param {callback} callback Callback to bind only once.\n
\t\t * @return {Object} Current class instance.\n
\t\t */\n
\t\tonce: function(name, callback) {\n
\t\t\treturn getEventDispatcher(this).once(name, callback);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the object has a event of the specified name.\n
\t\t *\n
\t\t * @method hasEventListeners\n
\t\t * @param {String} name Name of the event to check for.\n
\t\t * @return {Boolean} true/false if the event exists or not.\n
\t\t */\n
\t\thasEventListeners: function(name) {\n
\t\t\treturn getEventDispatcher(this).has(name);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/data/ObservableObject.js\n
\n
/**\n
 * ObservableObject.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is a object that is observable when properties changes a change event gets emitted.\n
 *\n
 * @class tinymce.data.ObservableObject\n
 */\n
define("tinymce/data/ObservableObject", [\n
\t"tinymce/data/Binding",\n
\t"tinymce/util/Observable",\n
\t"tinymce/util/Class",\n
\t"tinymce/util/Tools"\n
], function(Binding, Observable, Class, Tools) {\n
\tfunction isEqual(a, b) {\n
\t\tvar k, checked;\n
\n
\t\t// Strict equals\n
\t\tif (a === b) {\n
\t\t\treturn true;\n
\t\t}\n
\n
\t\t// Compare null\n
\t\tif (a === null || b === null) {\n
\t\t\treturn a === b;\n
\t\t}\n
\n
\t\t// Compare number, boolean, string, undefined\n
\t\tif (typeof a !== "object" || typeof b !== "object") {\n
\t\t\treturn a === b;\n
\t\t}\n
\n
\t\t// Compare arrays\n
\t\tif (Tools.isArray(b)) {\n
\t\t\tif (a.length !== b.length) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tk = a.length;\n
\t\t\twhile (k--) {\n
\t\t\t\tif (!isEqual(a[k], b[k])) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Compare objects\n
\t\tchecked = {};\n
\t\tfor (k in b) {\n
\t\t\tif (!isEqual(a[k], b[k])) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tchecked[k] = true;\n
\t\t}\n
\n
\t\tfor (k in a) {\n
\t\t\tif (!checked[k] && !isEqual(a[k], b[k])) {\n
\t\t\t\treturn false;\n
\t\t\t}\n
\t\t}\n
\n
\t\treturn true;\n
\t}\n
\n
\treturn Class.extend({\n
\t\tMixins: [Observable],\n
\n
\t\t/**\n
\t\t * Constructs a new observable object instance.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} data Initial data for the object.\n
\t\t */\n
\t\tinit: function(data) {\n
\t\t\tvar name, value;\n
\n
\t\t\tdata = data || {};\n
\n
\t\t\tfor (name in data) {\n
\t\t\t\tvalue = data[name];\n
\n
\t\t\t\tif (value instanceof Binding) {\n
\t\t\t\t\tdata[name] = value.create(this, name);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tthis.data = data;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets a property on the value this will call\n
\t\t * observers if the value is a change from the current value.\n
\t\t *\n
\t\t * @method set\n
\t\t * @param {String/object} name Name of the property to set or a object of items to set.\n
\t\t * @param {Object} value Value to set for the property.\n
\t\t * @return {tinymce.data.ObservableObject} Observable object instance.\n
\t\t */\n
\t\tset: function(name, value) {\n
\t\t\tvar key, args, oldValue = this.data[name];\n
\n
\t\t\tif (value instanceof Binding) {\n
\t\t\t\tvalue = value.create(this, name);\n
\t\t\t}\n
\n
\t\t\tif (typeof name === "object") {\n
\t\t\t\tfor (key in name) {\n
\t\t\t\t\tthis.set(key, name[key]);\n
\t\t\t\t}\n
\n
\t\t\t\treturn this;\n
\t\t\t}\n
\n
\t\t\tif (!isEqual(oldValue, value)) {\n
\t\t\t\tthis.data[name] = value;\n
\n
\t\t\t\targs = {\n
\t\t\t\t\ttarget: this,\n
\t\t\t\t\tname: name,\n
\t\t\t\t\tvalue: value,\n
\t\t\t\t\toldValue: oldValue\n
\t\t\t\t};\n
\n
\t\t\t\tthis.fire(\'change:\' + name, args);\n
\t\t\t\tthis.fire(\'change\', args);\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets a property by name.\n
\t\t *\n
\t\t * @method get\n
\t\t * @param {String} name Name of the property to get.\n
\t\t * @return {Object} Object value of propery.\n
\t\t */\n
\t\tget: function(name) {\n
\t\t\treturn this.data[name];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified property exists.\n
\t\t *\n
\t\t * @method has\n
\t\t * @param {String} name Name of the property to check for.\n
\t\t * @return {Boolean} true/false if the item exists.\n
\t\t */\n
\t\thas: function(name) {\n
\t\t\treturn name in this.data;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a dynamic property binding for the specified property name. This makes\n
\t\t * it possible to sync the state of two properties in two ObservableObject instances.\n
\t\t *\n
\t\t * @method bind\n
\t\t * @param {String} name Name of the property to sync with the property it\'s inserted to.\n
\t\t * @return {tinymce.data.Binding} Data binding instance.\n
\t\t */\n
\t\tbind: function(name) {\n
\t\t\treturn Binding.create(this, name);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Destroys the observable object and fires the "destroy"\n
\t\t * event and clean up any internal resources.\n
\t\t *\n
\t\t * @method destroy\n
\t\t */\n
\t\tdestroy: function() {\n
\t\t\tthis.fire(\'destroy\');\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Selector.js\n
\n
/**\n
 * Selector.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*eslint no-nested-ternary:0 */\n
\n
/**\n
 * Selector engine, enables you to select controls by using CSS like expressions.\n
 * We currently only support basic CSS expressions to reduce the size of the core\n
 * and the ones we support should be enough for most cases.\n
 *\n
 * @example\n
 * Supported expressions:\n
 *  element\n
 *  element#name\n
 *  element.class\n
 *  element[attr]\n
 *  element[attr*=value]\n
 *  element[attr~=value]\n
 *  element[attr!=value]\n
 *  element[attr^=value]\n
 *  element[attr$=value]\n
 *  element:<state>\n
 *  element:not(<expression>)\n
 *  element:first\n
 *  element:last\n
 *  element:odd\n
 *  element:even\n
 *  element element\n
 *  element > element\n
 *\n
 * @class tinymce.ui.Selector\n
 */\n
define("tinymce/ui/Selector", [\n
\t"tinymce/util/Class"\n
], function(Class) {\n
\t"use strict";\n
\n
\t/**\n
\t * Produces an array with a unique set of objects. It will not compare the values\n
\t * but the references of the objects.\n
\t *\n
\t * @private\n
\t * @method unqiue\n
\t * @param {Array} array Array to make into an array wit

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAo=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="10" aka="AAAAAAAAAAo=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

h unique items.\n
\t * @return {Array} Array with unique items.\n
\t */\n
\tfunction unique(array) {\n
\t\tvar uniqueItems = [], i = array.length, item;\n
\n
\t\twhile (i--) {\n
\t\t\titem = array[i];\n
\n
\t\t\tif (!item.__checked) {\n
\t\t\t\tuniqueItems.push(item);\n
\t\t\t\titem.__checked = 1;\n
\t\t\t}\n
\t\t}\n
\n
\t\ti = uniqueItems.length;\n
\t\twhile (i--) {\n
\t\t\tdelete uniqueItems[i].__checked;\n
\t\t}\n
\n
\t\treturn uniqueItems;\n
\t}\n
\n
\tvar expression = /^([\\w\\\\*]+)?(?:#([\\w\\\\]+))?(?:\\.([\\w\\\\\\.]+))?(?:\\[\\@?([\\w\\\\]+)([\\^\\$\\*!~]?=)([\\w\\\\]+)\\])?(?:\\:(.+))?/i;\n
\n
\t/*jshint maxlen:255 */\n
\t/*eslint max-len:0 */\n
\tvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|[\'"][^\'"]*[\'"]|[^\\[\\]\'"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n
\t\twhiteSpace = /^\\s*|\\s*$/g,\n
\t\tCollection;\n
\n
\tvar Selector = Class.extend({\n
\t\t/**\n
\t\t * Constructs a new Selector instance.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @method init\n
\t\t * @param {String} selector CSS like selector expression.\n
\t\t */\n
\t\tinit: function(selector) {\n
\t\t\tvar match = this.match;\n
\n
\t\t\tfunction compileNameFilter(name) {\n
\t\t\t\tif (name) {\n
\t\t\t\t\tname = name.toLowerCase();\n
\n
\t\t\t\t\treturn function(item) {\n
\t\t\t\t\t\treturn name === \'*\' || item.type === name;\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction compileIdFilter(id) {\n
\t\t\t\tif (id) {\n
\t\t\t\t\treturn function(item) {\n
\t\t\t\t\t\treturn item._name === id;\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction compileClassesFilter(classes) {\n
\t\t\t\tif (classes) {\n
\t\t\t\t\tclasses = classes.split(\'.\');\n
\n
\t\t\t\t\treturn function(item) {\n
\t\t\t\t\t\tvar i = classes.length;\n
\n
\t\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\t\tif (!item.classes.contains(classes[i])) {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction compileAttrFilter(name, cmp, check) {\n
\t\t\t\tif (name) {\n
\t\t\t\t\treturn function(item) {\n
\t\t\t\t\t\tvar value = item[name] ? item[name]() : \'\';\n
\n
\t\t\t\t\t\treturn !cmp ? !!check :\n
\t\t\t\t\t\t\tcmp === "=" ? value === check :\n
\t\t\t\t\t\t\tcmp === "*=" ? value.indexOf(check) >= 0 :\n
\t\t\t\t\t\t\tcmp === "~=" ? (" " + value + " ").indexOf(" " + check + " ") >= 0 :\n
\t\t\t\t\t\t\tcmp === "!=" ? value != check :\n
\t\t\t\t\t\t\tcmp === "^=" ? value.indexOf(check) === 0 :\n
\t\t\t\t\t\t\tcmp === "$=" ? value.substr(value.length - check.length) === check :\n
\t\t\t\t\t\t\tfalse;\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction compilePsuedoFilter(name) {\n
\t\t\t\tvar notSelectors;\n
\n
\t\t\t\tif (name) {\n
\t\t\t\t\tname = /(?:not\\((.+)\\))|(.+)/i.exec(name);\n
\n
\t\t\t\t\tif (!name[1]) {\n
\t\t\t\t\t\tname = name[2];\n
\n
\t\t\t\t\t\treturn function(item, index, length) {\n
\t\t\t\t\t\t\treturn name === \'first\' ? index === 0 :\n
\t\t\t\t\t\t\t\tname === \'last\' ? index === length - 1 :\n
\t\t\t\t\t\t\t\tname === \'even\' ? index % 2 === 0 :\n
\t\t\t\t\t\t\t\tname === \'odd\' ? index % 2 === 1 :\n
\t\t\t\t\t\t\t\titem[name] ? item[name]() :\n
\t\t\t\t\t\t\t\tfalse;\n
\t\t\t\t\t\t};\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Compile not expression\n
\t\t\t\t\tnotSelectors = parseChunks(name[1], []);\n
\n
\t\t\t\t\treturn function(item) {\n
\t\t\t\t\t\treturn !match(item, notSelectors);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction compile(selector, filters, direct) {\n
\t\t\t\tvar parts;\n
\n
\t\t\t\tfunction add(filter) {\n
\t\t\t\t\tif (filter) {\n
\t\t\t\t\t\tfilters.push(filter);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Parse expression into parts\n
\t\t\t\tparts = expression.exec(selector.replace(whiteSpace, \'\'));\n
\n
\t\t\t\tadd(compileNameFilter(parts[1]));\n
\t\t\t\tadd(compileIdFilter(parts[2]));\n
\t\t\t\tadd(compileClassesFilter(parts[3]));\n
\t\t\t\tadd(compileAttrFilter(parts[4], parts[5], parts[6]));\n
\t\t\t\tadd(compilePsuedoFilter(parts[7]));\n
\n
\t\t\t\t// Mark the filter with psuedo for performance\n
\t\t\t\tfilters.psuedo = !!parts[7];\n
\t\t\t\tfilters.direct = direct;\n
\n
\t\t\t\treturn filters;\n
\t\t\t}\n
\n
\t\t\t// Parser logic based on Sizzle by John Resig\n
\t\t\tfunction parseChunks(selector, selectors) {\n
\t\t\t\tvar parts = [], extra, matches, i;\n
\n
\t\t\t\tdo {\n
\t\t\t\t\tchunker.exec("");\n
\t\t\t\t\tmatches = chunker.exec(selector);\n
\n
\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\tselector = matches[3];\n
\t\t\t\t\t\tparts.push(matches[1]);\n
\n
\t\t\t\t\t\tif (matches[2]) {\n
\t\t\t\t\t\t\textra = matches[3];\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} while (matches);\n
\n
\t\t\t\tif (extra) {\n
\t\t\t\t\tparseChunks(extra, selectors);\n
\t\t\t\t}\n
\n
\t\t\t\tselector = [];\n
\t\t\t\tfor (i = 0; i < parts.length; i++) {\n
\t\t\t\t\tif (parts[i] != \'>\') {\n
\t\t\t\t\t\tselector.push(compile(parts[i], [], parts[i - 1] === \'>\'));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tselectors.push(selector);\n
\n
\t\t\t\treturn selectors;\n
\t\t\t}\n
\n
\t\t\tthis._selectors = parseChunks(selector, []);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the selector matches the specified control.\n
\t\t *\n
\t\t * @method match\n
\t\t * @param {tinymce.ui.Control} control Control to match agains the selector.\n
\t\t * @param {Array} selectors Optional array of selectors, mostly used internally.\n
\t\t * @return {Boolean} true/false state if the control matches or not.\n
\t\t */\n
\t\tmatch: function(control, selectors) {\n
\t\t\tvar i, l, si, sl, selector, fi, fl, filters, index, length, siblings, count, item;\n
\n
\t\t\tselectors = selectors || this._selectors;\n
\t\t\tfor (i = 0, l = selectors.length; i < l; i++) {\n
\t\t\t\tselector = selectors[i];\n
\t\t\t\tsl = selector.length;\n
\t\t\t\titem = control;\n
\t\t\t\tcount = 0;\n
\n
\t\t\t\tfor (si = sl - 1; si >= 0; si--) {\n
\t\t\t\t\tfilters = selector[si];\n
\n
\t\t\t\t\twhile (item) {\n
\t\t\t\t\t\t// Find the index and length since a psuedo filter like :first needs it\n
\t\t\t\t\t\tif (filters.psuedo) {\n
\t\t\t\t\t\t\tsiblings = item.parent().items();\n
\t\t\t\t\t\t\tindex = length = siblings.length;\n
\t\t\t\t\t\t\twhile (index--) {\n
\t\t\t\t\t\t\t\tif (siblings[index] === item) {\n
\t\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tfor (fi = 0, fl = filters.length; fi < fl; fi++) {\n
\t\t\t\t\t\t\tif (!filters[fi](item, index, length)) {\n
\t\t\t\t\t\t\t\tfi = fl + 1;\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (fi === fl) {\n
\t\t\t\t\t\t\tcount++;\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// If it didn\'t match the right most expression then\n
\t\t\t\t\t\t\t// break since it\'s no point looking at the parents\n
\t\t\t\t\t\t\tif (si === sl - 1) {\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\titem = item.parent();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// If we found all selectors then return true otherwise continue looking\n
\t\t\t\tif (count === sl) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a tinymce.ui.Collection with matches of the specified selector inside the specified container.\n
\t\t *\n
\t\t * @method find\n
\t\t * @param {tinymce.ui.Control} container Container to look for items in.\n
\t\t * @return {tinymce.ui.Collection} Collection with matched elements.\n
\t\t */\n
\t\tfind: function(container) {\n
\t\t\tvar matches = [], i, l, selectors = this._selectors;\n
\n
\t\t\tfunction collect(items, selector, index) {\n
\t\t\t\tvar i, l, fi, fl, item, filters = selector[index];\n
\n
\t\t\t\tfor (i = 0, l = items.length; i < l; i++) {\n
\t\t\t\t\titem = items[i];\n
\n
\t\t\t\t\t// Run each filter agains the item\n
\t\t\t\t\tfor (fi = 0, fl = filters.length; fi < fl; fi++) {\n
\t\t\t\t\t\tif (!filters[fi](item, i, l)) {\n
\t\t\t\t\t\t\tfi = fl + 1;\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// All filters matched the item\n
\t\t\t\t\tif (fi === fl) {\n
\t\t\t\t\t\t// Matched item is on the last expression like: panel toolbar [button]\n
\t\t\t\t\t\tif (index == selector.length - 1) {\n
\t\t\t\t\t\t\tmatches.push(item);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Collect next expression type\n
\t\t\t\t\t\t\tif (item.items) {\n
\t\t\t\t\t\t\t\tcollect(item.items(), selector, index + 1);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else if (filters.direct) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Collect child items\n
\t\t\t\t\tif (item.items) {\n
\t\t\t\t\t\tcollect(item.items(), selector, index);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (container.items) {\n
\t\t\t\tfor (i = 0, l = selectors.length; i < l; i++) {\n
\t\t\t\t\tcollect(container.items(), selectors[i], 0);\n
\t\t\t\t}\n
\n
\t\t\t\t// Unique the matches if needed\n
\t\t\t\tif (l > 1) {\n
\t\t\t\t\tmatches = unique(matches);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Fix for circular reference\n
\t\t\tif (!Collection) {\n
\t\t\t\t// TODO: Fix me!\n
\t\t\t\tCollection = Selector.Collection;\n
\t\t\t}\n
\n
\t\t\treturn new Collection(matches);\n
\t\t}\n
\t});\n
\n
\treturn Selector;\n
});\n
\n
// Included from: js/tinymce/classes/ui/Collection.js\n
\n
/**\n
 * Collection.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Control collection, this class contains control instances and it enables you to\n
 * perform actions on all the contained items. This is very similar to how jQuery works.\n
 *\n
 * @example\n
 * someCollection.show().disabled(true);\n
 *\n
 * @class tinymce.ui.Collection\n
 */\n
define("tinymce/ui/Collection", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/ui/Selector",\n
\t"tinymce/util/Class"\n
], function(Tools, Selector, Class) {\n
\t"use strict";\n
\n
\tvar Collection, proto, push = Array.prototype.push, slice = Array.prototype.slice;\n
\n
\tproto = {\n
\t\t/**\n
\t\t * Current number of contained control instances.\n
\t\t *\n
\t\t * @field length\n
\t\t * @type Number\n
\t\t */\n
\t\tlength: 0,\n
\n
\t\t/**\n
\t\t * Constructor for the collection.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @method init\n
\t\t * @param {Array} items Optional array with items to add.\n
\t\t */\n
\t\tinit: function(items) {\n
\t\t\tif (items) {\n
\t\t\t\tthis.add(items);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds new items to the control collection.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {Array} items Array if items to add to collection.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\tadd: function(items) {\n
\t\t\tvar self = this;\n
\n
\t\t\t// Force single item into array\n
\t\t\tif (!Tools.isArray(items)) {\n
\t\t\t\tif (items instanceof Collection) {\n
\t\t\t\t\tself.add(items.toArray());\n
\t\t\t\t} else {\n
\t\t\t\t\tpush.call(self, items);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tpush.apply(self, items);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the contents of the collection. This will remove any existing items\n
\t\t * and replace them with the ones specified in the input array.\n
\t\t *\n
\t\t * @method set\n
\t\t * @param {Array} items Array with items to set into the Collection.\n
\t\t * @return {tinymce.ui.Collection} Collection instance.\n
\t\t */\n
\t\tset: function(items) {\n
\t\t\tvar self = this, len = self.length, i;\n
\n
\t\t\tself.length = 0;\n
\t\t\tself.add(items);\n
\n
\t\t\t// Remove old entries\n
\t\t\tfor (i = self.length; i < len; i++) {\n
\t\t\t\tdelete self[i];\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Filters the collection item based on the specified selector expression or selector function.\n
\t\t *\n
\t\t * @method filter\n
\t\t * @param {String} selector Selector expression to filter items by.\n
\t\t * @return {tinymce.ui.Collection} Collection containing the filtered items.\n
\t\t */\n
\t\tfilter: function(selector) {\n
\t\t\tvar self = this, i, l, matches = [], item, match;\n
\n
\t\t\t// Compile string into selector expression\n
\t\t\tif (typeof selector === "string") {\n
\t\t\t\tselector = new Selector(selector);\n
\n
\t\t\t\tmatch = function(item) {\n
\t\t\t\t\treturn selector.match(item);\n
\t\t\t\t};\n
\t\t\t} else {\n
\t\t\t\t// Use selector as matching function\n
\t\t\t\tmatch = selector;\n
\t\t\t}\n
\n
\t\t\tfor (i = 0, l = self.length; i < l; i++) {\n
\t\t\t\titem = self[i];\n
\n
\t\t\t\tif (match(item)) {\n
\t\t\t\t\tmatches.push(item);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn new Collection(matches);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Slices the items within the collection.\n
\t\t *\n
\t\t * @method slice\n
\t\t * @param {Number} index Index to slice at.\n
\t\t * @param {Number} len Optional length to slice.\n
\t\t * @return {tinymce.ui.Collection} Current collection.\n
\t\t */\n
\t\tslice: function() {\n
\t\t\treturn new Collection(slice.apply(this, arguments));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Makes the current collection equal to the specified index.\n
\t\t *\n
\t\t * @method eq\n
\t\t * @param {Number} index Index of the item to set the collection to.\n
\t\t * @return {tinymce.ui.Collection} Current collection.\n
\t\t */\n
\t\teq: function(index) {\n
\t\t\treturn index === -1 ? this.slice(index) : this.slice(index, +index + 1);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes the specified callback on each item in collection.\n
\t\t *\n
\t\t * @method each\n
\t\t * @param {function} callback Callback to execute for each item in collection.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\teach: function(callback) {\n
\t\t\tTools.each(this, callback);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns an JavaScript array object of the contents inside the collection.\n
\t\t *\n
\t\t * @method toArray\n
\t\t * @return {Array} Array with all items from collection.\n
\t\t */\n
\t\ttoArray: function() {\n
\t\t\treturn Tools.toArray(this);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Finds the index of the specified control or return -1 if it isn\'t in the collection.\n
\t\t *\n
\t\t * @method indexOf\n
\t\t * @param {Control} ctrl Control instance to look for.\n
\t\t * @return {Number} Index of the specified control or -1.\n
\t\t */\n
\t\tindexOf: function(ctrl) {\n
\t\t\tvar self = this, i = self.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tif (self[i] === ctrl) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn i;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a new collection of the contents in reverse order.\n
\t\t *\n
\t\t * @method reverse\n
\t\t * @return {tinymce.ui.Collection} Collection instance with reversed items.\n
\t\t */\n
\t\treverse: function() {\n
\t\t\treturn new Collection(Tools.toArray(this).reverse());\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the class exists or not.\n
\t\t *\n
\t\t * @method hasClass\n
\t\t * @param {String} cls Class to check for.\n
\t\t * @return {Boolean} true/false state if the class exists or not.\n
\t\t */\n
\t\thasClass: function(cls) {\n
\t\t\treturn this[0] ? this[0].classes.contains(cls) : false;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets the specific property on the items in the collection. The same as executing control.<property>(<value>);\n
\t\t *\n
\t\t * @method prop\n
\t\t * @param {String} name Property name to get/set.\n
\t\t * @param {Object} value Optional object value to set.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or value of the first item on a get operation.\n
\t\t */\n
\t\tprop: function(name, value) {\n
\t\t\tvar self = this, undef, item;\n
\n
\t\t\tif (value !== undef) {\n
\t\t\t\tself.each(function(item) {\n
\t\t\t\t\tif (item[name]) {\n
\t\t\t\t\t\titem[name](value);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\titem = self[0];\n
\n
\t\t\tif (item && item[name]) {\n
\t\t\t\treturn item[name]();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes the specific function name with optional arguments an all items in collection if it exists.\n
\t\t *\n
\t\t * @example collection.exec("myMethod", arg1, arg2, arg3);\n
\t\t * @method exec\n
\t\t * @param {String} name Name of the function to execute.\n
\t\t * @param {Object} ... Multiple arguments to pass to each function.\n
\t\t * @return {tinymce.ui.Collection} Current collection.\n
\t\t */\n
\t\texec: function(name) {\n
\t\t\tvar self = this, args = Tools.toArray(arguments).slice(1);\n
\n
\t\t\tself.each(function(item) {\n
\t\t\t\tif (item[name]) {\n
\t\t\t\t\titem[name].apply(item, args);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Remove all items from collection and DOM.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.ui.Collection} Current collection.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar i = this.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tthis[i].remove();\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a class to all items in the collection.\n
\t\t *\n
\t\t * @method addClass\n
\t\t * @param {String} cls Class to add to each item.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\taddClass: function(cls) {\n
\t\t\treturn this.each(function(item) {\n
\t\t\t\titem.classes.add(cls);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified class from all items in collection.\n
\t\t *\n
\t\t * @method removeClass\n
\t\t * @param {String} cls Class to remove from each item.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\tremoveClass: function(cls) {\n
\t\t\treturn this.each(function(item) {\n
\t\t\t\titem.classes.remove(cls);\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Fires the specified event by name and arguments on the control. This will execute all\n
\t\t * bound event handlers.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {String} name Name of the event to fire.\n
\t\t * @param {Object} args Optional arguments to pass to the event.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\t// fire: function(event, args) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Binds a callback to the specified event. This event can both be\n
\t\t * native browser events like "click" or custom ones like PostRender.\n
\t\t *\n
\t\t * The callback function will have two parameters the first one being the control that received the event\n
\t\t * the second one will be the event object either the browsers native event object or a custom JS object.\n
\t\t *\n
\t\t * @method on\n
\t\t * @param {String} name Name of the event to bind. For example "click".\n
\t\t * @param {String/function} callback Callback function to execute ones the event occurs.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\t// on: function(name, callback) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Unbinds the specified event and optionally a specific callback. If you omit the name\n
\t\t * parameter all event handlers will be removed. If you omit the callback all event handles\n
\t\t * by the specified name will be removed.\n
\t\t *\n
\t\t * @method off\n
\t\t * @param {String} name Optional name for the event to unbind.\n
\t\t * @param {function} callback Optional callback function to unbind.\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\t// off: function(name, callback) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Shows the items in the current collection.\n
\t\t *\n
\t\t * @method show\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\t// show: function() {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Hides the items in the current collection.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @return {tinymce.ui.Collection} Current collection instance.\n
\t\t */\n
\t\t// hide: function() {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the text contents of the items in the current collection.\n
\t\t *\n
\t\t * @method text\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or text value of the first item on a get operation.\n
\t\t */\n
\t\t// text: function(value) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the name contents of the items in the current collection.\n
\t\t *\n
\t\t * @method name\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or name value of the first item on a get operation.\n
\t\t */\n
\t\t// name: function(value) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the disabled state on the items in the current collection.\n
\t\t *\n
\t\t * @method disabled\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or disabled state of the first item on a get operation.\n
\t\t */\n
\t\t// disabled: function(state) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the active state on the items in the current collection.\n
\t\t *\n
\t\t * @method active\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or active state of the first item on a get operation.\n
\t\t */\n
\t\t// active: function(state) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the selected state on the items in the current collection.\n
\t\t *\n
\t\t * @method selected\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or selected state of the first item on a get operation.\n
\t\t */\n
\t\t// selected: function(state) {}, -- Generated by code below\n
\n
\t\t/**\n
\t\t * Sets/gets the selected state on the items in the current collection.\n
\t\t *\n
\t\t * @method visible\n
\t\t * @return {tinymce.ui.Collection} Current collection instance or visible state of the first item on a get operation.\n
\t\t */\n
\t\t// visible: function(state) {}, -- Generated by code below\n
\t};\n
\n
\t// Extend tinymce.ui.Collection prototype with some generated control specific methods\n
\tTools.each(\'fire on off show hide append prepend before after reflow\'.split(\' \'), function(name) {\n
\t\tproto[name] = function() {\n
\t\t\tvar args = Tools.toArray(arguments);\n
\n
\t\t\tthis.each(function(ctrl) {\n
\t\t\t\tif (name in ctrl) {\n
\t\t\t\t\tctrl[name].apply(ctrl, args);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn this;\n
\t\t};\n
\t});\n
\n
\t// Extend tinymce.ui.Collection prototype with some property methods\n
\tTools.each(\'text name disabled active selected checked visible parent value data\'.split(\' \'), function(name) {\n
\t\tproto[name] = function(value) {\n
\t\t\treturn this.prop(name, value);\n
\t\t};\n
\t});\n
\n
\t// Create class based on the new prototype\n
\tCollection = Class.extend(proto);\n
\n
\t// Stick Collection into Selector to prevent circual references\n
\tSelector.Collection = Collection;\n
\n
\treturn Collection;\n
});\n
\n
// Included from: js/tinymce/classes/ui/DomUtils.js\n
\n
/**\n
 * DomUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
define("tinymce/ui/DomUtils", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/DOMUtils"\n
], function(Tools, DOMUtils) {\n
\t"use strict";\n
\n
\tvar count = 0;\n
\n
\treturn {\n
\t\tid: function() {\n
\t\t\treturn \'mceu_\' + (count++);\n
\t\t},\n
\n
\t\tcreateFragment: function(html) {\n
\t\t\treturn DOMUtils.DOM.createFragment(html);\n
\t\t},\n
\n
\t\tgetWindowSize: function() {\n
\t\t\treturn DOMUtils.DOM.getViewPort();\n
\t\t},\n
\n
\t\tgetSize: function(elm) {\n
\t\t\tvar width, height;\n
\n
\t\t\tif (elm.getBoundingClientRect) {\n
\t\t\t\tvar rect = elm.getBoundingClientRect();\n
\n
\t\t\t\twidth = Math.max(rect.width || (rect.right - rect.left), elm.offsetWidth);\n
\t\t\t\theight = Math.max(rect.height || (rect.bottom - rect.bottom), elm.offsetHeight);\n
\t\t\t} else {\n
\t\t\t\twidth = elm.offsetWidth;\n
\t\t\t\theight = elm.offsetHeight;\n
\t\t\t}\n
\n
\t\t\treturn {width: width, height: height};\n
\t\t},\n
\n
\t\tgetPos: function(elm, root) {\n
\t\t\treturn DOMUtils.DOM.getPos(elm, root);\n
\t\t},\n
\n
\t\tgetViewPort: function(win) {\n
\t\t\treturn DOMUtils.DOM.getViewPort(win);\n
\t\t},\n
\n
\t\tget: function(id) {\n
\t\t\treturn document.getElementById(id);\n
\t\t},\n
\n
\t\taddClass: function(elm, cls) {\n
\t\t\treturn DOMUtils.DOM.addClass(elm, cls);\n
\t\t},\n
\n
\t\tremoveClass: function(elm, cls) {\n
\t\t\treturn DOMUtils.DOM.removeClass(elm, cls);\n
\t\t},\n
\n
\t\thasClass: function(elm, cls) {\n
\t\t\treturn DOMUtils.DOM.hasClass(elm, cls);\n
\t\t},\n
\n
\t\ttoggleClass: function(elm, cls, state) {\n
\t\t\treturn DOMUtils.DOM.toggleClass(elm, cls, state);\n
\t\t},\n
\n
\t\tcss: function(elm, name, value) {\n
\t\t\treturn DOMUtils.DOM.setStyle(elm, name, value);\n
\t\t},\n
\n
\t\tgetRuntimeStyle: function(elm, name) {\n
\t\t\treturn DOMUtils.DOM.getStyle(elm, name, true);\n
\t\t},\n
\n
\t\ton: function(target, name, callback, scope) {\n
\t\t\treturn DOMUtils.DOM.bind(target, name, callback, scope);\n
\t\t},\n
\n
\t\toff: function(target, name, callback) {\n
\t\t\treturn DOMUtils.DOM.unbind(target, name, callback);\n
\t\t},\n
\n
\t\tfire: function(target, name, args) {\n
\t\t\treturn DOMUtils.DOM.fire(target, name, args);\n
\t\t},\n
\n
\t\tinnerHtml: function(elm, html) {\n
\t\t\t// Workaround for <div> in <p> bug on IE 8 #6178\n
\t\t\tDOMUtils.DOM.setHTML(elm, html);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/BoxUtils.js\n
\n
/**\n
 * BoxUtils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Utility class for box parsing and measuing.\n
 *\n
 * @class tinymce.ui.BoxUtils\n
 */\n
define("tinymce/ui/BoxUtils", [\n
], function() {\n
\t"use strict";\n
\n
\treturn {\n
\t\t/**\n
\t\t * Parses the specified box value. A box value contains 1-4 properties in clockwise order.\n
\t\t *\n
\t\t * @method parseBox\n
\t\t * @param {String/Number} value Box value "0 1 2 3" or "0" etc.\n
\t\t * @return {Object} Object with top/right/bottom/left properties.\n
\t\t * @private\n
\t\t */\n
\t\tparseBox: function(value) {\n
\t\t\tvar len, radix = 10;\n
\n
\t\t\tif (!value) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (typeof value === "number") {\n
\t\t\t\tvalue = value || 0;\n
\n
\t\t\t\treturn {\n
\t\t\t\t\ttop: value,\n
\t\t\t\t\tleft: value,\n
\t\t\t\t\tbottom: value,\n
\t\t\t\t\tright: value\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tvalue = value.split(\' \');\n
\t\t\tlen = value.length;\n
\n
\t\t\tif (len === 1) {\n
\t\t\t\tvalue[1] = value[2] = value[3] = value[0];\n
\t\t\t} else if (len === 2) {\n
\t\t\t\tvalue[2] = value[0];\n
\t\t\t\tvalue[3] = value[1];\n
\t\t\t} else if (len === 3) {\n
\t\t\t\tvalue[3] = value[1];\n
\t\t\t}\n
\n
\t\t\treturn {\n
\t\t\t\ttop: parseInt(value[0], radix) || 0,\n
\t\t\t\tright: parseInt(value[1], radix) || 0,\n
\t\t\t\tbottom: parseInt(value[2], radix) || 0,\n
\t\t\t\tleft: parseInt(value[3], radix) || 0\n
\t\t\t};\n
\t\t},\n
\n
\t\tmeasureBox: function(elm, prefix) {\n
\t\t\tfunction getStyle(name) {\n
\t\t\t\tvar defaultView = document.defaultView;\n
\n
\t\t\t\tif (defaultView) {\n
\t\t\t\t\t// Remove camelcase\n
\t\t\t\t\tname = name.replace(/[A-Z]/g, function(a) {\n
\t\t\t\t\t\treturn \'-\' + a;\n
\t\t\t\t\t});\n
\n
\t\t\t\t\treturn defaultView.getComputedStyle(elm, null).getPropertyValue(name);\n
\t\t\t\t}\n
\n
\t\t\t\treturn elm.currentStyle[name];\n
\t\t\t}\n
\n
\t\t\tfunction getSide(name) {\n
\t\t\t\tvar val = parseFloat(getStyle(name), 10);\n
\n
\t\t\t\treturn isNaN(val) ? 0 : val;\n
\t\t\t}\n
\n
\t\t\treturn {\n
\t\t\t\ttop: getSide(prefix + "TopWidth"),\n
\t\t\t\tright: getSide(prefix + "RightWidth"),\n
\t\t\t\tbottom: getSide(prefix + "BottomWidth"),\n
\t\t\t\tleft: getSide(prefix + "LeftWidth")\n
\t\t\t};\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/ClassList.js\n
\n
/**\n
 * ClassList.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Handles adding and removal of classes.\n
 *\n
 * @class tinymce.ui.ClassList\n
 */\n
define("tinymce/ui/ClassList", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\t"use strict";\n
\n
\tfunction noop() {\n
\t}\n
\n
\t/**\n
\t * Constructs a new class list the specified onchange\n
\t * callback will be executed when the class list gets modifed.\n
\t *\n
\t * @constructor ClassList\n
\t * @param {function} onchange Onchange callback to be executed.\n
\t */\n
\tfunction ClassList(onchange) {\n
\t\tthis.cls = [];\n
\t\tthis.cls._map = {};\n
\t\tthis.onchange = onchange || noop;\n
\t\tthis.prefix = \'\';\n
\t}\n
\n
\tTools.extend(ClassList.prototype, {\n
\t\t/**\n
\t\t * Adds a new class to the class list.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String} cls Class to be added.\n
\t\t * @return {tinymce.ui.ClassList} Current class list instance.\n
\t\t */\n
\t\tadd: function(cls) {\n
\t\t\tif (cls && !this.contains(cls)) {\n
\t\t\t\tthis.cls._map[cls] = true;\n
\t\t\t\tthis.cls.push(cls);\n
\t\t\t\tthis._change();\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified class from the class list.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {String} cls Class to be removed.\n
\t\t * @return {tinymce.ui.ClassList} Current class list instance.\n
\t\t */\n
\t\tremove: function(cls) {\n
\t\t\tif (this.contains(cls)) {\n
\t\t\t\tfor (var i = 0; i < this.cls.length; i++) {\n
\t\t\t\t\tif (this.cls[i] === cls) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tthis.cls.splice(i, 1);\n
\t\t\t\tdelete this.cls._map[cls];\n
\t\t\t\tthis._change();\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Toggles a class in the class list.\n
\t\t *\n
\t\t * @method toggle\n
\t\t * @param {String} cls Class to be added/removed.\n
\t\t * @param {Boolean} state Optional state if it should be added/removed.\n
\t\t * @return {tinymce.ui.ClassList} Current class list instance.\n
\t\t */\n
\t\ttoggle: function(cls, state) {\n
\t\t\tvar curState = this.contains(cls);\n
\n
\t\t\tif (curState !== state) {\n
\t\t\t\tif (curState) {\n
\t\t\t\t\tthis.remove(cls);\n
\t\t\t\t} else {\n
\t\t\t\t\tthis.add(cls);\n
\t\t\t\t}\n
\n
\t\t\t\tthis._change();\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true if the class list has the specified class.\n
\t\t *\n
\t\t * @method contains\n
\t\t * @param {String} cls Class to look for.\n
\t\t * @return {Boolean} true/false if the class exists or not.\n
\t\t */\n
\t\tcontains: function(cls) {\n
\t\t\treturn !!this.cls._map[cls];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a space separated list of classes.\n
\t\t *\n
\t\t * @method toString\n
\t\t * @return {String} Space separated list of classes.\n
\t\t */\n
\n
\t\t_change: function() {\n
\t\t\tdelete this.clsValue;\n
\t\t\tthis.onchange.call(this);\n
\t\t}\n
\t});\n
\n
\t// IE 8 compatibility\n
\tClassList.prototype.toString = function() {\n
\t\tvar value;\n
\n
\t\tif (this.clsValue) {\n
\t\t\treturn this.clsValue;\n
\t\t}\n
\n
\t\tvalue = \'\';\n
\t\tfor (var i = 0; i < this.cls.length; i++) {\n
\t\t\tif (i > 0) {\n
\t\t\t\tvalue += \' \';\n
\t\t\t}\n
\n
\t\t\tvalue += this.prefix + this.cls[i];\n
\t\t}\n
\n
\t\treturn value;\n
\t};\n
\n
\treturn ClassList;\n
});\n
\n
// Included from: js/tinymce/classes/ui/ReflowQueue.js\n
\n
/**\n
 * ReflowQueue.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class will automatically reflow controls on the next animation frame within a few milliseconds on older browsers.\n
 * If the user manually reflows then the automatic reflow will be cancelled. This class is unsed internally when various control states\n
 * changes that triggers a reflow.\n
 *\n
 * @class tinymce.ui.ReflowQueue\n
 * @static\n
 */\n
define("tinymce/ui/ReflowQueue", [\n
], function() {\n
\tvar dirtyCtrls = {}, animationFrameRequested;\n
\n
\tfunction requestAnimationFrame(callback, element) {\n
\t\tvar i, requestAnimationFrameFunc = window.requestAnimationFrame, vendors = [\'ms\', \'moz\', \'webkit\'];\n
\n
\t\tfunction featurefill(callback) {\n
\t\t\twindow.setTimeout(callback, 0);\n
\t\t}\n
\n
\t\tfor (i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {\n
\t\t\trequestAnimationFrameFunc = window[vendors[i] + \'RequestAnimationFrame\'];\n
\t\t}\n
\n
\t\tif (!requestAnimationFrameFunc) {\n
\t\t\trequestAnimationFrameFunc = featurefill;\n
\t\t}\n
\n
\t\trequestAnimationFrameFunc(callback, element);\n
\t}\n
\n
\treturn {\n
\t\t/**\n
\t\t * Adds a control to the next automatic reflow call. This is the control that had a state\n
\t\t * change for example if the control was hidden/shown.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {tinymce.ui.Control} ctrl Control to add to queue.\n
\t\t */\n
\t\tadd: function(ctrl) {\n
\t\t\tvar parent = ctrl.parent();\n
\n
\t\t\tif (parent) {\n
\t\t\t\tif (!parent._layout || parent._layout.isNative()) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!dirtyCtrls[parent._id]) {\n
\t\t\t\t\tdirtyCtrls[parent._id] = parent;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!animationFrameRequested) {\n
\t\t\t\t\tanimationFrameRequested = true;\n
\n
\t\t\t\t\trequestAnimationFrame(function() {\n
\t\t\t\t\t\tvar id, ctrl;\n
\n
\t\t\t\t\t\tanimationFrameRequested = false;\n
\n
\t\t\t\t\t\tfor (id in dirtyCtrls) {\n
\t\t\t\t\t\t\tctrl = dirtyCtrls[id];\n
\n
\t\t\t\t\t\t\tif (ctrl.state.get(\'rendered\')) {\n
\t\t\t\t\t\t\t\tctrl.reflow();\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tdirtyCtrls = {};\n
\t\t\t\t\t}, document.body);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified control from the automatic reflow. This will happen when for example the user\n
\t\t * manually triggers a reflow.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {tinymce.ui.Control} ctrl Control to remove from queue.\n
\t\t */\n
\t\tremove: function(ctrl) {\n
\t\t\tif (dirtyCtrls[ctrl._id]) {\n
\t\t\t\tdelete dirtyCtrls[ctrl._id];\n
\t\t\t}\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/Control.js\n
\n
/**\n
 * Control.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*eslint consistent-this:0 */\n
\n
/**\n
 * This is the base class for all controls and containers. All UI control instances inherit\n
 * from this one as it has the base logic needed by all of them.\n
 *\n
 * @class tinymce.ui.Control\n
 */\n
define("tinymce/ui/Control", [\n
\t"tinymce/util/Class",\n
\t"tinymce/util/Tools",\n
\t"tinymce/util/EventDispatcher",\n
\t"tinymce/data/ObservableObject",\n
\t"tinymce/ui/Collection",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/BoxUtils",\n
\t"tinymce/ui/ClassList",\n
\t"tinymce/ui/ReflowQueue"\n
], function(Class, Tools, EventDispatcher, ObservableObject, Collection, DomUtils, $, BoxUtils, ClassList, ReflowQueue) {\n
\t"use strict";\n
\n
\tvar hasMouseWheelEventSupport = "onmousewheel" in document;\n
\tvar hasWheelEventSupport = false;\n
\tvar classPrefix = "mce-";\n
\tvar Control, idCounter = 0;\n
\n
\tvar proto = {\n
\t\tStatics: {\n
\t\t\tclassPrefix: classPrefix\n
\t\t},\n
\n
\t\tisRtl: function() {\n
\t\t\treturn Control.rtl;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Class/id prefix to use for all controls.\n
\t\t *\n
\t\t * @final\n
\t\t * @field {String} classPrefix\n
\t\t */\n
\t\tclassPrefix: classPrefix,\n
\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} style Style CSS properties to add.\n
\t\t * @setting {String} border Border box values example: 1 1 1 1\n
\t\t * @setting {String} padding Padding box values example: 1 1 1 1\n
\t\t * @setting {String} margin Margin box values example: 1 1 1 1\n
\t\t * @setting {Number} minWidth Minimal width for the control.\n
\t\t * @setting {Number} minHeight Minimal height for the control.\n
\t\t * @setting {String} classes Space separated list of classes to add.\n
\t\t * @setting {String} role WAI-ARIA role to use for control.\n
\t\t * @setting {Boolean} hidden Is the control hidden by default.\n
\t\t * @setting {Boolean} disabled Is the control disabled by default.\n
\t\t * @setting {String} name Name of the control instance.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, classes, defaultClasses;\n
\n
\t\t\tfunction applyClasses(classes) {\n
\t\t\t\tvar i;\n
\n
\t\t\t\tclasses = classes.split(\' \');\n
\t\t\t\tfor (i = 0; i < classes.length; i++) {\n
\t\t\t\t\tself.classes.add(classes[i]);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.settings = settings = Tools.extend({}, self.Defaults, settings);\n
\n
\t\t\t// Initial states\n
\t\t\tself._id = settings.id || (\'mceu_\' + (idCounter++));\n
\t\t\tself._aria = {role: settings.role};\n
\t\t\tself._elmCache = {};\n
\t\t\tself.$ = $;\n
\n
\t\t\tself.state = new ObservableObject({\n
\t\t\t\tvisible: true,\n
\t\t\t\tactive: false,\n
\t\t\t\tdisabled: false,\n
\t\t\t\tvalue: \'\'\n
\t\t\t});\n
\n
\t\t\tself.data = new ObservableObject(settings.data);\n
\n
\t\t\tself.classes = new ClassList(function() {\n
\t\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\t\tself.getEl().className = this.toString();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t\tself.classes.prefix = self.classPrefix;\n
\n
\t\t\t// Setup classes\n
\t\t\tclasses = settings.classes;\n
\t\t\tif (classes) {\n
\t\t\t\tif (self.Defaults) {\n
\t\t\t\t\tdefaultClasses = self.Defaults.classes;\n
\n
\t\t\t\t\tif (defaultClasses && classes != defaultClasses) {\n
\t\t\t\t\t\tapplyClasses(defaultClasses);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tapplyClasses(classes);\n
\t\t\t}\n
\n
\t\t\tTools.each(\'title text name visible disabled active value\'.split(\' \'), function(name) {\n
\t\t\t\tif (name in settings) {\n
\t\t\t\t\tself[name](settings[name]);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'click\', function() {\n
\t\t\t\tif (self.disabled()) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t/**\n
\t\t\t * Name/value object with settings for the current control.\n
\t\t\t *\n
\t\t\t * @field {Object} settings\n
\t\t\t */\n
\t\t\tself.settings = settings;\n
\n
\t\t\tself.borderBox = BoxUtils.parseBox(settings.border);\n
\t\t\tself.paddingBox = BoxUtils.parseBox(settings.padding);\n
\t\t\tself.marginBox = BoxUtils.parseBox(settings.margin);\n
\n
\t\t\tif (settings.hidden) {\n
\t\t\t\tself.hide();\n
\t\t\t}\n
\t\t},\n
\n
\t\t// Will generate getter/setter methods for these properties\n
\t\tProperties: \'parent,name\',\n
\n
\t\t/**\n
\t\t * Returns the root element to render controls into.\n
\t\t *\n
\t\t * @method getContainerElm\n
\t\t * @return {Element} HTML DOM element to render into.\n
\t\t */\n
\t\tgetContainerElm: function() {\n
\t\t\treturn document.body;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a control instance for the current DOM element.\n
\t\t *\n
\t\t * @method getParentCtrl\n
\t\t * @param {Element} elm HTML dom element to get parent control from.\n
\t\t * @return {tinymce.ui.Control} Control instance or undefined.\n
\t\t */\n
\t\tgetParentCtrl: function(elm) {\n
\t\t\tvar ctrl, lookup = this.getRoot().controlIdLookup;\n
\n
\t\t\twhile (elm && lookup) {\n
\t\t\t\tctrl = lookup[elm.id];\n
\t\t\t\tif (ctrl) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\telm = elm.parentNode;\n
\t\t\t}\n
\n
\t\t\treturn ctrl;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the current controls layout rect.\n
\t\t * This will be executed by the layout managers to determine the\n
\t\t * default minWidth/minHeight etc.\n
\t\t *\n
\t\t * @method initLayoutRect\n
\t\t * @return {Object} Layout rect instance.\n
\t\t */\n
\t\tinitLayoutRect: function() {\n
\t\t\tvar self = this, settings = self.settings, borderBox, layoutRect;\n
\t\t\tvar elm = self.getEl(), width, height, minWidth, minHeight, autoResize;\n
\t\t\tvar startMinWidth, startMinHeight, initialSize;\n
\n
\t\t\t// Measure the current element\n
\t\t\tborderBox = self.borderBox = self.borderBox || BoxUtils.measureBox(elm, \'border\');\n
\t\t\tself.paddingBox = self.paddingBox || BoxUtils.measureBox(elm, \'padding\');\n
\t\t\tself.marginBox = self.marginBox || BoxUtils.measureBox(elm, \'margin\');\n
\t\t\tinitialSize = DomUtils.getSize(elm);\n
\n
\t\t\t// Setup minWidth/minHeight and width/height\n
\t\t\tstartMinWidth = settings.minWidth;\n
\t\t\tstartMinHeight = settings.minHeight;\n
\t\t\tminWidth = startMinWidth || initialSize.width;\n
\t\t\tminHeight = startMinHeight || initialSize.height;\n
\t\t\twidth = settings.width;\n
\t\t\theight = settings.height;\n
\t\t\tautoResize = settings.autoResize;\n
\t\t\tautoResize = typeof autoResize != "undefined" ? autoResize : !width && !height;\n
\n
\t\t\twidth = width || minWidth;\n
\t\t\theight = height || minHeight;\n
\n
\t\t\tvar deltaW = borderBox.left + borderBox.right;\n
\t\t\tvar deltaH = borderBox.top + borderBox.bottom;\n
\n
\t\t\tvar maxW = settings.maxWidth || 0xFFFF;\n
\t\t\tvar maxH = settings.maxHeight || 0xFFFF;\n
\n
\t\t\t// Setup initial layout rect\n
\t\t\tself._layoutRect = layoutRect = {\n
\t\t\t\tx: settings.x || 0,\n
\t\t\t\ty: settings.y || 0,\n
\t\t\t\tw: width,\n
\t\t\t\th: height,\n
\t\t\t\tdeltaW: deltaW,\n
\t\t\t\tdeltaH: deltaH,\n
\t\t\t\tcontentW: width - deltaW,\n
\t\t\t\tcontentH: height - deltaH,\n
\t\t\t\tinnerW: width - deltaW,\n
\t\t\t\tinnerH: height - deltaH,\n
\t\t\t\tstartMinWidth: startMinWidth || 0,\n
\t\t\t\tstartMinHeight: startMinHeight || 0,\n
\t\t\t\tminW: Math.min(minWidth, maxW),\n
\t\t\t\tminH: Math.min(minHeight, maxH),\n
\t\t\t\tmaxW: maxW,\n
\t\t\t\tmaxH: maxH,\n
\t\t\t\tautoResize: autoResize,\n
\t\t\t\tscrollW: 0\n
\t\t\t};\n
\n
\t\t\tself._lastLayoutRect = {};\n
\n
\t\t\treturn layoutRect;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Getter/setter for the current layout rect.\n
\t\t *\n
\t\t * @method layoutRect\n
\t\t * @param {Object} [newRect] Optional new layout rect.\n
\t\t * @return {tinymce.ui.Control/Object} Current control or rect object.\n
\t\t */\n
\t\tlayoutRect: function(newRect) {\n
\t\t\tvar self = this, curRect = self._layoutRect, lastLayoutRect, size, deltaWidth, deltaHeight, undef, repaintControls;\n
\n
\t\t\t// Initialize default layout rect\n
\t\t\tif (!curRect) {\n
\t\t\t\tcurRect = self.initLayoutRect();\n
\t\t\t}\n
\n
\t\t\t// Set new rect values\n
\t\t\tif (newRect) {\n
\t\t\t\t// Calc deltas between inner and outer sizes\n
\t\t\t\tdeltaWidth = curRect.deltaW;\n
\t\t\t\tdeltaHeight = curRect.deltaH;\n
\n
\t\t\t\t// Set x position\n
\t\t\t\tif (newRect.x !== undef) {\n
\t\t\t\t\tcurRect.x = newRect.x;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set y position\n
\t\t\t\tif (newRect.y !== undef) {\n
\t\t\t\t\tcurRect.y = newRect.y;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set minW\n
\t\t\t\tif (newRect.minW !== undef) {\n
\t\t\t\t\tcurRect.minW = newRect.minW;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set minH\n
\t\t\t\tif (newRect.minH !== undef) {\n
\t\t\t\t\tcurRect.minH = newRect.minH;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new width and calculate inner width\n
\t\t\t\tsize = newRect.w;\n
\t\t\t\tif (size !== undef) {\n
\t\t\t\t\tsize = size < curRect.minW ? curRect.minW : size;\n
\t\t\t\t\tsize = size > curRect.maxW ? curRect.maxW : size;\n
\t\t\t\t\tcurRect.w = size;\n
\t\t\t\t\tcurRect.innerW = size - deltaWidth;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new height and calculate inner height\n
\t\t\t\tsize = newRect.h;\n
\t\t\t\tif (size !== undef) {\n
\t\t\t\t\tsize = size < curRect.minH ? curRect.minH : size;\n
\t\t\t\t\tsize = size > curRect.maxH ? curRect.maxH : size;\n
\t\t\t\t\tcurRect.h = size;\n
\t\t\t\t\tcurRect.innerH = size - deltaHeight;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new inner width and calculate width\n
\t\t\t\tsize = newRect.innerW;\n
\t\t\t\tif (size !== undef) {\n
\t\t\t\t\tsize = size < curRect.minW - deltaWidth ? curRect.minW - deltaWidth : size;\n
\t\t\t\t\tsize = size > curRect.maxW - deltaWidth ? curRect.maxW - deltaWidth : size;\n
\t\t\t\t\tcurRect.innerW = size;\n
\t\t\t\t\tcurRect.w = size + deltaWidth;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new height and calculate inner height\n
\t\t\t\tsize = newRect.innerH;\n
\t\t\t\tif (size !== undef) {\n
\t\t\t\t\tsize = size < curRect.minH - deltaHeight ? curRect.minH - deltaHeight : size;\n
\t\t\t\t\tsize = size > curRect.maxH - deltaHeight ? curRect.maxH - deltaHeight : size;\n
\t\t\t\t\tcurRect.innerH = size;\n
\t\t\t\t\tcurRect.h = size + deltaHeight;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new contentW\n
\t\t\t\tif (newRect.contentW !== undef) {\n
\t\t\t\t\tcurRect.contentW = newRect.contentW;\n
\t\t\t\t}\n
\n
\t\t\t\t// Set new contentH\n
\t\t\t\tif (newRect.contentH !== undef) {\n
\t\t\t\t\tcurRect.contentH = newRect.contentH;\n
\t\t\t\t}\n
\n
\t\t\t\t// Compare last layout rect with the current one to see if we need to repaint or not\n
\t\t\t\tlastLayoutRect = self._lastLayoutRect;\n
\t\t\t\tif (lastLayoutRect.x !== curRect.x || lastLayoutRect.y !== curRect.y ||\n
\t\t\t\t\tlastLayoutRect.w !== curRect.w || lastLayoutRect.h !== curRect.h) {\n
\t\t\t\t\trepaintControls = Control.repaintControls;\n
\n
\t\t\t\t\tif (repaintControls) {\n
\t\t\t\t\t\tif (repaintControls.map && !repaintControls.map[self._id]) {\n
\t\t\t\t\t\t\trepaintControls.push(self);\n
\t\t\t\t\t\t\trepaintControls.map[self._id] = true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tlastLayoutRect.x = curRect.x;\n
\t\t\t\t\tlastLayoutRect.y = curRect.y;\n
\t\t\t\t\tlastLayoutRect.w = curRect.w;\n
\t\t\t\t\tlastLayoutRect.h = curRect.h;\n
\t\t\t\t}\n
\n
\t\t\t\treturn self;\n
\t\t\t}\n
\n
\t\t\treturn curRect;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this, style, bodyStyle, bodyElm, rect, borderBox;\n
\t\t\tvar borderW = 0, borderH = 0, lastRepaintRect, round, value;\n
\n
\t\t\t// Use Math.round on all values on IE < 9\n
\t\t\tround = !document.createRange ? Math.round : function(value) {\n
\t\t\t\treturn value;\n
\t\t\t};\n
\n
\t\t\tstyle = self.getEl().style;\n
\t\t\trect = self._layoutRect;\n
\t\t\tlastRepaintRect = self._lastRepaintRect || {};\n
\n
\t\t\tborderBox = self.borderBox;\n
\t\t\tborderW = borderBox.left + borderBox.right;\n
\t\t\tborderH = borderBox.top + borderBox.bottom;\n
\n
\t\t\tif (rect.x !== lastRepaintRect.x) {\n
\t\t\t\tstyle.left = round(rect.x) + \'px\';\n
\t\t\t\tlastRepaintRect.x = rect.x;\n
\t\t\t}\n
\n
\t\t\tif (rect.y !== lastRepaintRect.y) {\n
\t\t\t\tstyle.top = round(rect.y) + \'px\';\n
\t\t\t\tlastRepaintRect.y = rect.y;\n
\t\t\t}\n
\n
\t\t\tif (rect.w !== lastRepaintRect.w) {\n
\t\t\t\tvalue = round(rect.w - borderW);\n
\t\t\t\tstyle.width = (value >= 0 ? value : 0) + \'px\';\n
\t\t\t\tlastRepaintRect.w = rect.w;\n
\t\t\t}\n
\n
\t\t\tif (rect.h !== lastRepaintRect.h) {\n
\t\t\t\tvalue = round(rect.h - borderH);\n
\t\t\t\tstyle.height = (value >= 0 ? value : 0) + \'px\';\n
\t\t\t\tlastRepaintRect.h = rect.h;\n
\t\t\t}\n
\n
\t\t\t// Update body if needed\n
\t\t\tif (self._hasBody && rect.innerW !== lastRepaintRect.innerW) {\n
\t\t\t\tvalue = round(rect.innerW);\n
\n
\t\t\t\tbodyElm = self.getEl(\'body\');\n
\t\t\t\tif (bodyElm) {\n
\t\t\t\t\tbodyStyle = bodyElm.style;\n
\t\t\t\t\tbodyStyle.width = (value >= 0 ? value : 0) + \'px\';\n
\t\t\t\t}\n
\n
\t\t\t\tlastRepaintRect.innerW = rect.innerW;\n
\t\t\t}\n
\n
\t\t\tif (self._hasBody && rect.innerH !== lastRepaintRect.innerH) {\n
\t\t\t\tvalue = round(rect.innerH);\n
\n
\t\t\t\tbodyElm = bodyElm || self.getEl(\'body\');\n
\t\t\t\tif (bodyElm) {\n
\t\t\t\t\tbodyStyle = bodyStyle || bodyElm.style;\n
\t\t\t\t\tbodyStyle.height = (value >= 0 ? value : 0) + \'px\';\n
\t\t\t\t}\n
\n
\t\t\t\tlastRepaintRect.innerH = rect.innerH;\n
\t\t\t}\n
\n
\t\t\tself._lastRepaintRect = lastRepaintRect;\n
\t\t\tself.fire(\'repaint\', {}, false);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Binds a callback to the specified event. This event can both be\n
\t\t * native browser events like "click" or custom ones like PostRender.\n
\t\t *\n
\t\t * The callback function will be passed a DOM event like object that enables yout do stop propagation.\n
\t\t *\n
\t\t * @method on\n
\t\t * @param {String} name Name of the event to bind. For example "click".\n
\t\t * @param {String/function} callback Callback function to execute ones the event occurs.\n
\t\t * @return {tinymce.ui.Control} Current control object.\n
\t\t */\n
\t\ton: function(name, callback) {\n
\t\t\tvar self = this;\n
\n
\t\t\tfunction resolveCallbackName(name) {\n
\t\t\t\tvar callback, scope;\n
\n
\t\t\t\tif (typeof name != \'string\') {\n
\t\t\t\t\treturn name;\n
\t\t\t\t}\n
\n
\t\t\t\treturn function(e) {\n
\t\t\t\t\tif (!callback) {\n
\t\t\t\t\t\tself.parentsAndSelf().each(function(ctrl) {\n
\t\t\t\t\t\t\tvar callbacks = ctrl.settings.callbacks;\n
\n
\t\t\t\t\t\t\tif (callbacks && (callback = callbacks[name])) {\n
\t\t\t\t\t\t\t\tscope = ctrl;\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!callback) {\n
\t\t\t\t\t\te.action = name;\n
\t\t\t\t\t\tthis.fire(\'execute\', e);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn callback.call(scope, e);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tgetEventDispatcher(self).on(name, resolveCallbackName(callback));\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unbinds the specified event and optionally a specific callback. If you omit the name\n
\t\t * parameter all event handlers will be removed. If you omit the callback all event handles\n
\t\t * by the specified name will be removed.\n
\t\t *\n
\t\t * @method off\n
\t\t * @param {String} [name] Name for the event to unbind.\n
\t\t * @param {function} [callback] Callback function to unbind.\n
\t\t * @return {mxex.ui.Control} Current control object.\n
\t\t */\n
\t\toff: function(name, callback) {\n
\t\t\tgetEventDispatcher(this).off(name, callback);\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Fires the specified event by name and arguments on the control. This will execute all\n
\t\t * bound event handlers.\n
\t\t *\n
\t\t * @method fire\n
\t\t * @param {String} name Name of the event to fire.\n
\t\t * @param {Object} [args] Arguments to pass to the event.\n
\t\t * @param {Boolean} [bubble] Value to control bubbeling. Defaults to true.\n
\t\t * @return {Object} Current arguments object.\n
\t\t */\n
\t\tfire: function(name, args, bubble) {\n
\t\t\tvar self = this;\n
\n
\t\t\targs = args || {};\n
\n
\t\t\tif (!args.control) {\n
\t\t\t\targs.control = self;\n
\t\t\t}\n
\n
\t\t\targs = getEventDispatcher(self).fire(name, args);\n
\n
\t\t\t// Bubble event up to parents\n
\t\t\tif (bubble !== false && self.parent) {\n
\t\t\t\tvar parent = self.parent();\n
\t\t\t\twhile (parent && !args.isPropagationStopped()) {\n
\t\t\t\t\tparent.fire(name, args, false);\n
\t\t\t\t\tparent = parent.parent();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn args;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified event has any listeners.\n
\t\t *\n
\t\t * @method hasEventListeners\n
\t\t * @param {String} name Name of the event to check for.\n
\t\t * @return {Boolean} True/false state if the event has listeners.\n
\t\t */\n
\t\thasEventListeners: function(name) {\n
\t\t\treturn getEventDispatcher(this).has(name);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a control collection with all parent controls.\n
\t\t *\n
\t\t * @method parents\n
\t\t * @param {String} selector Optional selector expression to find parents.\n
\t\t * @return {tinymce.ui.Collection} Collection with all parent controls.\n
\t\t */\n
\t\tparents: function(selector) {\n
\t\t\tvar self = this, ctrl, parents = new Collection();\n
\n
\t\t\t// Add each parent to collection\n
\t\t\tfor (ctrl = self.parent(); ctrl; ctrl = ctrl.parent()) {\n
\t\t\t\tparents.add(ctrl);\n
\t\t\t}\n
\n
\t\t\t// Filter away everything that doesn\'t match the selector\n
\t\t\tif (selector) {\n
\t\t\t\tparents = parents.filter(selector);\n
\t\t\t}\n
\n
\t\t\treturn parents;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the current control and it\'s parents.\n
\t\t *\n
\t\t * @method parentsAndSelf\n
\t\t * @param {String} selector Optional selector expression to find parents.\n
\t\t * @return {tinymce.ui.Collection} Collection with all parent controls.\n
\t\t */\n
\t\tparentsAndSelf: function(selector) {\n
\t\t\treturn new Collection(this).add(this.parents(selector));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the control next to the current control.\n
\t\t *\n
\t\t * @method next\n
\t\t * @return {tinymce.ui.Control} Next control instance.\n
\t\t */\n
\t\tnext: function() {\n
\t\t\tvar parentControls = this.parent().items();\n
\n
\t\t\treturn parentControls[parentControls.indexOf(this) + 1];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the control previous to the current control.\n
\t\t *\n
\t\t * @method prev\n
\t\t * @return {tinymce.ui.Control} Previous control instance.\n
\t\t */\n
\t\tprev: function() {\n
\t\t\tvar parentControls = this.parent().items();\n
\n
\t\t\treturn parentControls[parentControls.indexOf(this) - 1];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the inner HTML of the control element.\n
\t\t *\n
\t\t * @method innerHtml\n
\t\t * @param {String} html Html string to set as inner html.\n
\t\t * @return {tinymce.ui.Control} Current control object.\n
\t\t */\n
\t\tinnerHtml: function(html) {\n
\t\t\tthis.$el.html(html);\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the control DOM element or sub element.\n
\t\t *\n
\t\t * @method getEl\n
\t\t * @param {String} [suffix] Suffix to get element by.\n
\t\t * @return {Element} HTML DOM element for the current control or it\'s children.\n
\t\t */\n
\t\tgetEl: function(suffix) {\n
\t\t\tvar id = suffix ? this._id + \'-\' + suffix : this._id;\n
\n
\t\t\tif (!this._elmCache[id]) {\n
\t\t\t\tthis._elmCache[id] = $(\'#\' + id)[0];\n
\t\t\t}\n
\n
\t\t\treturn this._elmCache[id];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the visible state to true.\n
\t\t *\n
\t\t * @method show\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tshow: function() {\n
\t\t\treturn this.visible(true);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the visible state to false.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\thide: function() {\n
\t\t\treturn this.visible(false);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses the current control.\n
\t\t *\n
\t\t * @method focus\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tfocus: function() {\n
\t\t\ttry {\n
\t\t\t\tthis.getEl().focus();\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore IE error\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Blurs the current control.\n
\t\t *\n
\t\t * @method blur\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tblur: function() {\n
\t\t\tthis.getEl().blur();\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified aria property.\n
\t\t *\n
\t\t * @method aria\n
\t\t * @param {String} name Name of the aria property to set.\n
\t\t * @param {String} value Value of the aria property.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\taria: function(name, value) {\n
\t\t\tvar self = this, elm = self.getEl(self.ariaTarget);\n
\n
\t\t\tif (typeof value === "undefined") {\n
\t\t\t\treturn self._aria[name];\n
\t\t\t}\n
\n
\t\t\tself._aria[name] = value;\n
\n
\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\telm.setAttribute(name == \'role\' ? name : \'aria-\' + name, value);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Encodes the specified string with HTML entities. It will also\n
\t\t * translate the string to different languages.\n
\t\t *\n
\t\t * @method encode\n
\t\t * @param {String/Object/Array} text Text to entity encode.\n
\t\t * @param {Boolean} [translate=true] False if the contents shouldn\'t be translated.\n
\t\t * @return {String} Encoded and possible traslated string.\n
\t\t */\n
\t\tencode: function(text, translate) {\n
\t\t\tif (translate !== false) {\n
\t\t\t\ttext = this.translate(text);\n
\t\t\t}\n
\n
\t\t\treturn (text || \'\').replace(/[&<>"]/g, function(match) {\n
\t\t\t\treturn \'&#\' + match.charCodeAt(0) + \';\';\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the translated string.\n
\t\t *\n
\t\t * @method translate\n
\t\t * @param {String} text Text to translate.\n
\t\t * @return {String} Translated string or the same as the input.\n
\t\t */\n
\t\ttranslate: function(text) {\n
\t\t\treturn Control.translate ? Control.translate(text) : text;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds items before the current control.\n
\t\t *\n
\t\t * @method before\n
\t\t * @param {Array/tinymce.ui.Collection} items Array of items to prepend before this control.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tbefore: function(items) {\n
\t\t\tvar self = this, parent = self.parent();\n
\n
\t\t\tif (parent) {\n
\t\t\t\tparent.insert(items, parent.items().indexOf(self), true);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds items after the current control.\n
\t\t *\n
\t\t * @method after\n
\t\t * @param {Array/tinymce.ui.Collection} items Array of items to append after this control.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tafter: function(items) {\n
\t\t\tvar self = this, parent = self.parent();\n
\n
\t\t\tif (parent) {\n
\t\t\t\tparent.insert(items, parent.items().indexOf(self));\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the current control from DOM and from UI collections.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this, elm = self.getEl(), parent = self.parent(), newItems, i;\n
\n
\t\t\tif (self.items) {\n
\t\t\t\tvar controls = self.items().toArray();\n
\t\t\t\ti = controls.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tcontrols[i].remove();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (parent && parent.items) {\n
\t\t\t\tnewItems = [];\n
\n
\t\t\t\tparent.items().each(function(item) {\n
\t\t\t\t\tif (item !== self) {\n
\t\t\t\t\t\tnewItems.push(item);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tparent.items().set(newItems);\n
\t\t\t\tparent._lastRect = null;\n
\t\t\t}\n
\n
\t\t\tif (self._eventsRoot && self._eventsRoot == self) {\n
\t\t\t\t$(elm).off();\n
\t\t\t}\n
\n
\t\t\tvar lookup = self.getRoot().controlIdLookup;\n
\t\t\tif (lookup) {\n
\t\t\t\tdelete lookup[self._id];\n
\t\t\t}\n
\n
\t\t\tif (elm && elm.parentNode) {\n
\t\t\t\telm.parentNode.removeChild(elm);\n
\t\t\t}\n
\n
\t\t\tself.state.set(\'rendered\', false);\n
\t\t\tself.state.destroy();\n
\n
\t\t\tself.fire(\'remove\');\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control before the specified element.\n
\t\t *\n
\t\t * @method renderBefore\n
\t\t * @param {Element} elm Element to render before.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\trenderBefore: function(elm) {\n
\t\t\t$(elm).before(this.renderHtml());\n
\t\t\tthis.postRender();\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control to the specified element.\n
\t\t *\n
\t\t * @method renderBefore\n
\t\t * @param {Element} elm Element to render to.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\trenderTo: function(elm) {\n
\t\t\t$(elm || this.getContainerElm()).append(this.renderHtml());\n
\t\t\tthis.postRender();\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\tpreRender: function() {\n
\t\t},\n
\n
\t\trender: function() {\n
\t\t},\n
\n
\t\trenderHtml: function() {\n
\t\t\treturn \'<div id="\' + this._id + \'" class="\' + this.classes + \'"></div>\';\n
\t\t},\n
\n
\t\t/**\n
\t\t * Post render method. Called after the control has been rendered to the target.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, settings = self.settings, elm, box, parent, name, parentEventsRoot;\n
\n
\t\t\tself.$el = $(self.getEl());\n
\t\t\tself.state.set(\'rendered\', true);\n
\n
\t\t\t// Bind on<event> settings\n
\t\t\tfor (name in settings) {\n
\t\t\t\tif (name.indexOf("on") === 0) {\n
\t\t\t\t\tself.on(name.substr(2), settings[name]);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (self._eventsRoot) {\n
\t\t\t\tfor (parent = self.parent(); !parentEventsRoot && parent; parent = parent.parent()) {\n
\t\t\t\t\tparentEventsRoot = parent._eventsRoot;\n
\t\t\t\t}\n
\n
\t\t\t\tif (parentEventsRoot) {\n
\t\t\t\t\tfor (name in parentEventsRoot._nativeEvents) {\n
\t\t\t\t\t\tself._nativeEvents[name] = true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tbindPendingEvents(self);\n
\n
\t\t\tif (settings.style) {\n
\t\t\t\telm = self.getEl();\n
\t\t\t\tif (elm) {\n
\t\t\t\t\telm.setAttribute(\'style\', settings.style);\n
\t\t\t\t\telm.style.cssText = settings.style;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (self.settings.border) {\n
\t\t\t\tbox = self.borderBox;\n
\t\t\t\tself.$el.css({\n
\t\t\t\t\t\'border-top-width\': box.top,\n
\t\t\t\t\t\'border-right-width\': box.right,\n
\t\t\t\t\t\'border-bottom-width\': box.bottom,\n
\t\t\t\t\t\'border-left-width\': box.left\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Add instance to lookup\n
\t\t\tvar root = self.getRoot();\n
\t\t\tif (!root.controlIdLookup) {\n
\t\t\t\troot.controlIdLookup = {};\n
\t\t\t}\n
\n
\t\t\troot.controlIdLookup[self._id] = self;\n
\n
\t\t\tfor (var key in self._aria) {\n
\t\t\t\tself.aria(key, self._aria[key]);\n
\t\t\t}\n
\n
\t\t\tif (self.state.get(\'visible\') === false) {\n
\t\t\t\tself.getEl().style.display = \'none\';\n
\t\t\t}\n
\n
\t\t\tself.bindStates();\n
\n
\t\t\tself.state.on(\'change:visible\', function(e) {\n
\t\t\t\tvar state = e.value, parentCtrl;\n
\n
\t\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\t\tself.getEl().style.display = state === false ? \'none\' : \'\';\n
\n
\t\t\t\t\t// Need to force a reflow here on IE 8\n
\t\t\t\t\tself.getEl().getBoundingClientRect();\n
\t\t\t\t}\n
\n
\t\t\t\t// Parent container needs to reflow\n
\t\t\t\tparentCtrl = self.parent();\n
\t\t\t\tif (parentCtrl) {\n
\t\t\t\t\tparentCtrl._lastRect = null;\n
\t\t\t\t}\n
\n
\t\t\t\tself.fire(state ? \'show\' : \'hide\');\n
\n
\t\t\t\tReflowQueue.add(self);\n
\t\t\t});\n
\n
\t\t\tself.fire(\'postrender\', {}, false);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t},\n
\n
\t\t/**\n
\t\t * Scrolls the current control into view.\n
\t\t *\n
\t\t * @method scrollIntoView\n
\t\t * @param {String} align Alignment in view top|center|bottom.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tscrollIntoView: function(align) {\n
\t\t\tfunction getOffset(elm, rootElm) {\n
\t\t\t\tvar x, y, parent = elm;\n
\n
\t\t\t\tx = y = 0;\n
\t\t\t\twhile (parent && parent != rootElm && parent.nodeType) {\n
\t\t\t\t\tx += parent.offsetLeft || 0;\n
\t\t\t\t\ty += parent.offsetTop || 0;\n
\t\t\t\t\tparent = parent.offsetParent;\n
\t\t\t\t}\n
\n
\t\t\t\treturn {x: x, y: y};\n
\t\t\t}\n
\n
\t\t\tvar elm = this.getEl(), parentElm = elm.parentNode;\n
\t\t\tvar x, y, width, height, parentWidth, parentHeight;\n
\t\t\tvar pos = getOffset(elm, parentElm);\n
\n
\t\t\tx = pos.x;\n
\t\t\ty = pos.y;\n
\t\t\twidth = elm.offsetWidth;\n
\t\t\theight = elm.offsetHeight;\n
\t\t\tparentWidth = parentElm.clientWidth;\n
\t\t\tparentHeight = parentElm.clientHeight;\n
\n
\t\t\tif (align == "end") {\n
\t\t\t\tx -= parentWidth - width;\n
\t\t\t\ty -= parentHeight - height;\n
\t\t\t} else if (align == "center") {\n
\t\t\t\tx -= (parentWidth / 2) - (width / 2);\n
\t\t\t\ty -= (parentHeight / 2) - (height / 2);\n
\t\t\t}\n
\n
\t\t\tparentElm.scrollLeft = x;\n
\t\t\tparentElm.scrollTop = y;\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\tgetRoot: function() {\n
\t\t\tvar ctrl = this, rootControl, parents = [];\n
\n
\t\t\twhile (ctrl) {\n
\t\t\t\tif (ctrl.rootControl) {\n
\t\t\t\t\trootControl = ctrl.rootControl;\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tparents.push(ctrl);\n
\t\t\t\trootControl = ctrl;\n
\t\t\t\tctrl = ctrl.parent();\n
\t\t\t}\n
\n
\t\t\tif (!rootControl) {\n
\t\t\t\trootControl = this;\n
\t\t\t}\n
\n
\t\t\tvar i = parents.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tparents[i].rootControl = rootControl;\n
\t\t\t}\n
\n
\t\t\treturn rootControl;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Reflows the current control and it\'s parents.\n
\t\t * This should be used after you for example append children to the current control so\n
\t\t * that the layout managers know that they need to reposition everything.\n
\t\t *\n
\t\t * @example\n
\t\t * container.append({type: \'button\', text: \'My button\'}).reflow();\n
\t\t *\n
\t\t * @method reflow\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\treflow: function() {\n
\t\t\tReflowQueue.remove(this);\n
\n
\t\t\tvar parent = this.parent();\n
\t\t\tif (parent._layout && !parent._layout.isNative()) {\n
\t\t\t\tparent.reflow();\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Sets/gets the parent container for the control.\n
\t\t *\n
\t\t * @method parent\n
\t\t * @param {tinymce.ui.Container} parent Optional parent to set.\n
\t\t * @return {tinymce.ui.Control} Parent control or the current control on a set action.\n
\t\t */\n
\t\t// parent: function(parent) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the text for the control.\n
\t\t *\n
\t\t * @method text\n
\t\t * @param {String} value Value to set to control.\n
\t\t * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.\n
\t\t */\n
\t\t// text: function(value) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the disabled state on the control.\n
\t\t *\n
\t\t * @method disabled\n
\t\t * @param {Boolean} state Value to set to control.\n
\t\t * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.\n
\t\t */\n
\t\t// disabled: function(state) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the active for the control.\n
\t\t *\n
\t\t * @method active\n
\t\t * @param {Boolean} state Value to set to control.\n
\t\t * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.\n
\t\t */\n
\t\t// active: function(state) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the name for the control.\n
\t\t *\n
\t\t * @method name\n
\t\t * @param {String} value Value to set to control.\n
\t\t * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.\n
\t\t */\n
\t\t// name: function(value) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the title for the control.\n
\t\t *\n
\t\t * @method title\n
\t\t * @param {String} value Value to set to control.\n
\t\t * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.\n
\t\t */\n
\t\t// title: function(value) {} -- Generated\n
\n
\t\t/**\n
\t\t * Sets/gets the visible for the control.\n
\t\t *\n
\t\t * @method visible\n
\t\t * @param {Boolean} state Value to set to control.\n
\t\t * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.\n
\t\t */\n
\t\t// visible: function(value) {} -- Generated\n
\t};\n
\n
\t/**\n
\t * Setup state properties.\n
\t */\n
\tTools.each(\'text title visible disabled active value\'.split(\' \'), function(name) {\n
\t\tproto[name] = function(value) {\n
\t\t\tif (arguments.length === 0) {\n
\t\t\t\treturn this.state.get(name);\n
\t\t\t}\n
\n
\t\t\tif (typeof value != "undefined") {\n
\t\t\t\tthis.state.set(name, value);\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t};\n
\t});\n
\n
\tControl = Class.extend(proto);\n
\n
\tfunction getEventDispatcher(obj) {\n
\t\tif (!obj._eventDispatcher) {\n
\t\t\tobj._eventDispatcher = new EventDispatcher({\n
\t\t\t\tscope: obj,\n
\t\t\t\ttoggleEvent: function(name, state) {\n
\t\t\t\t\tif (state && EventDispatcher.isNative(name)) {\n
\t\t\t\t\t\tif (!obj._nativeEvents) {\n
\t\t\t\t\t\t\tobj._nativeEvents = {};\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tobj._nativeEvents[name] = true;\n
\n
\t\t\t\t\t\tif (obj.state.get(\'rendered\')) {\n
\t\t\t\t\t\t\tbindPendingEvents(obj);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\treturn obj._eventDispatcher;\n
\t}\n
\n
\tfunction bindPendingEvents(eventCtrl) {\n
\t\tvar i, l, parents, eventRootCtrl, nativeEvents, name;\n
\n
\t\tfunction delegate(e) {\n
\t\t\tvar control = eventCtrl.getParentCtrl(e.target);\n
\n
\t\t\tif (control) {\n
\t\t\t\tcontrol.fire(e.type, e);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction mouseLeaveHandler() {\n
\t\t\tvar ctrl = eventRootCtrl._lastHoverCtrl;\n
\n
\t\t\tif (ctrl) {\n
\t\t\t\tctrl.fire("mouseleave", {target: ctrl.getEl()});\n
\n
\t\t\t\tctrl.parents().each(function(ctrl) {\n
\t\t\t\t\tctrl.fire("mouseleave", {target: ctrl.getEl()});\n
\t\t\t\t});\n
\n
\t\t\t\teventRootCtrl._lastHoverCtrl = null;\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction mouseEnterHandler(e) {\n
\t\t\tvar ctrl = eventCtrl.getParentCtrl(e.target), lastCtrl = eventRootCtrl._lastHoverCtrl, idx = 0, i, parents, lastParents;\n
\n
\t\t\t// Over on a new control\n
\t\t\tif (ctrl !== lastCtrl) {\n
\t\t\t\teventRootCtrl._lastHoverCtrl = ctrl;\n
\n
\t\t\t\tparents = ctrl.parents().toArray().reverse();\n
\t\t\t\tparents.push(ctrl);\n
\n
\t\t\t\tif (lastCtrl) {\n
\t\t\t\t\tlastParents = lastCtrl.parents().toArray().reverse();\n
\t\t\t\t\tlastParents.push(lastCtrl);\n
\n
\t\t\t\t\tfor (idx = 0; idx < lastParents.length; idx++) {\n
\t\t\t\t\t\tif (parents[idx] !== lastParents[idx]) {\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfor (i = lastParents.length - 1; i >= idx; i--) {\n
\t\t\t\t\t\tlastCtrl = lastParents[i];\n
\t\t\t\t\t\tlastCtrl.fire("mouseleave", {\n
\t\t\t\t\t\t\ttarget: lastCtrl.getEl()\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfor (i = idx; i < parents.length; i++) {\n
\t\t\t\t\tctrl = parents[i];\n
\t\t\t\t\tctrl.fire("mouseenter", {\n
\t\t\t\t\t\ttarget: ctrl.getEl()\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction fixWheelEvent(e) {\n
\t\t\te.preventDefault();\n
\n
\t\t\tif (e.type == "mousewheel") {\n
\t\t\t\te.deltaY = -1 / 40 * e.wheelDelta;\n
\n
\t\t\t\tif (e.wheelDeltaX) {\n
\t\t\t\t\te.deltaX = -1 / 40 * e.wheelDeltaX;\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\te.deltaX = 0;\n
\t\t\t\te.deltaY = e.detail;\n
\t\t\t}\n
\n
\t\t\te = eventCtrl.fire("wheel", e);\n
\t\t}\n
\n
\t\tnativeEvents = eventCtrl._nativeEvents;\n
\t\tif (nativeEvents) {\n
\t\t\t// Find event root element if it exists\n
\t\t\tparents = eventCtrl.parents().toArray();\n
\t\t\tparents.unshift(eventCtrl);\n
\t\t\tfor (i = 0, l = parents.length; !eventRootCtrl && i < l; i++) {\n
\t\t\t\teventRootCtrl = parents[i]._eventsRoot;\n
\t\t\t}\n
\n
\t\t\t// Event root wasn\'t found the use the root control\n
\t\t\tif (!eventRootCtrl) {\n
\t\t\t\teventRootCtrl = parents[parents.length - 1] || eventCtrl;\n
\t\t\t}\n
\n
\t\t\t// Set the eventsRoot property on children that didn\'t have it\n
\t\t\teventCtrl._eventsRoot = eventRootCtrl;\n
\t\t\tfor (l = i, i = 0; i < l; i++) {\n
\t\t\t\tparents[i]._eventsRoot = eventRootCtrl;\n
\t\t\t}\n
\n
\t\t\tvar eventRootDelegates = eventRootCtrl._delegates;\n
\t\t\tif (!eventRootDelegates) {\n
\t\t\t\teventRootDelegates = eventRootCtrl._delegates = {};\n
\t\t\t}\n
\n
\t\t\t// Bind native event delegates\n
\t\t\tfor (name in nativeEvents) {\n
\t\t\t\tif (!nativeEvents) {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\tif (name === "wheel" && !hasWheelEventSupport) {\n
\t\t\t\t\tif (hasMouseWheelEventSupport) {\n
\t\t\t\t\t\t$(eventCtrl.getEl()).on("mousewheel", fixWheelEvent);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t$(eventCtrl.getEl()).on("DOMMouseScroll", fixWheelEvent);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tcontinue;\n
\t\t\t\t}\n
\n
\t\t\t\t// Special treatment for mousenter/mouseleave since these doesn\'t bubble\n
\t\t\t\tif (name === "mouseenter" || name === "mouseleave") {\n
\t\t\t\t\t// Fake mousenter/mouseleave\n
\t\t\t\t\tif (!eventRootCtrl._hasMouseEnter) {\n
\t\t\t\t\t\t$(eventRootCtrl.getEl()).on("mouseleave", mouseLeaveHandler).on("mouseover", mouseEnterHandler);\n
\t\t\t\t\t\teventRootCtrl._hasMouseEnter = 1;\n
\t\t\t\t\t}\n
\t\t\t\t} else if (!eventRootDelegates[name]) {\n
\t\t\t\t\t$(eventRootCtrl.getEl()).on(name, delegate);\n
\t\t\t\t\teventRootDelegates[name] = true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove the event once it\'s bound\n
\t\t\t\tnativeEvents[name] = false;\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\treturn Control;\n
});\n
\n
// Included from: js/tinymce/classes/ui/Factory.js\n
\n
/**\n
 * Factory.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*global tinymce:true */\n
\n
/**\n
 * This class is a factory for control instances. This enables you\n
 * to create instances of controls without having to require the UI controls directly.\n
 *\n
 * It also allow you to override or add new control types.\n
 *\n
 * @class tinymce.ui.Factory\n
 */\n
define("tinymce/ui/Factory", [], function() {\n
\t"use strict";\n
\n
\tvar types = {}, namespaceInit;\n
\n
\treturn {\n
\t\t/**\n
\t\t * Adds a new control instance type to the factory.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String} type Type name for example "button".\n
\t\t * @param {function} typeClass Class type function.\n
\t\t */\n
\t\tadd: function(type, typeClass) {\n
\t\t\ttypes[type.toLowerCase()] = typeClass;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified type exists or not.\n
\t\t *\n
\t\t * @method has\n
\t\t * @param {String} type Type to look for.\n
\t\t * @return {Boolean} true/false if the control by name exists.\n
\t\t */\n
\t\thas: function(type) {\n
\t\t\treturn !!types[type.toLowerCase()];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates a new control instance based on the settings provided. The instance created will be\n
\t\t * based on the specified type property it can also create whole structures of components out of\n
\t\t * the specified JSON object.\n
\t\t *\n
\t\t * @example\n
\t\t * tinymce.ui.Factory.create({\n
\t\t *     type: \'button\',\n
\t\t *     text: \'Hello world!\'\n
\t\t * });\n
\t\t *\n
\t\t * @method create\n
\t\t * @param {Object/String} settings Name/Value object with items used to create the type.\n
\t\t * @return {tinymce.ui.Control} Control instance based on the specified type.\n
\t\t */\n
\t\tcreate: function(type, settings) {\n
\t\t\tvar ControlType, name, namespace;\n
\n
\t\t\t// Build type lookup\n
\t\t\tif (!namespaceInit) {\n
\t\t\t\tnamespace = tinymce.ui;\n
\n
\t\t\t\tfor (name in namespace) {\n
\t\t\t\t\ttypes[name.toLowerCase()] = namespace[name];\n
\t\t\t\t}\n
\n
\t\t\t\tnamespaceInit = true;\n
\t\t\t}\n
\n
\t\t\t// If string is specified then use it as the type\n
\t\t\tif (typeof type == \'string\') {\n
\t\t\t\tsettings = settings || {};\n
\t\t\t\tsettings.type = type;\n
\t\t\t} else {\n
\t\t\t\tsettings = type;\n
\t\t\t\ttype = settings.type;\n
\t\t\t}\n
\n
\t\t\t// Find control type\n
\t\t\ttype = type.toLowerCase();\n
\t\t\tControlType = types[type];\n
\n
\t\t\t// #if debug\n
\n
\t\t\tif (!ControlType) {\n
\t\t\t\tthrow new Error("Could not find control by type: " + type);\n
\t\t\t}\n
\n
\t\t\t// #endif\n
\n
\t\t\tControlType = new ControlType(settings);\n
\t\t\tControlType.type = type; // Set the type on the instance, this will be used by the Selector engine\n
\n
\t\t\treturn ControlType;\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/KeyboardNavigation.js\n
\n
/**\n
 * KeyboardNavigation.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles keyboard navigation of controls and elements.\n
 *\n
 * @class tinymce.ui.KeyboardNavigation\n
 */\n
define("tinymce/ui/KeyboardNavigation", [\n
], function() {\n
\t"use strict";\n
\n
\t/**\n
\t * This class handles all keyboard navigation for WAI-ARIA support. Each root container\n
\t * gets an instance of this class.\n
\t *\n
\t * @constructor\n
\t */\n
\treturn function(settings) {\n
\t\tvar root = settings.root, focusedElement, focusedControl;\n
\n
\t\tfunction isElement(node) {\n
\t\t\treturn node && node.nodeType === 1;\n
\t\t}\n
\n
\t\ttry {\n
\t\t\tfocusedElement = document.activeElement;\n
\t\t} catch (ex) {\n
\t\t\t// IE sometimes fails to return a proper element\n
\t\t\tfocusedElement = document.body;\n
\t\t}\n
\n
\t\tfocusedControl = root.getParentCtrl(focusedE

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAs=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="11" aka="AAAAAAAAAAs=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

lement);\n
\n
\t\t/**\n
\t\t * Returns the currently focused elements wai aria role of the currently\n
\t\t * focused element or specified element.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Element} elm Optional element to get role from.\n
\t\t * @return {String} Role of specified element.\n
\t\t */\n
\t\tfunction getRole(elm) {\n
\t\t\telm = elm || focusedElement;\n
\n
\t\t\tif (isElement(elm)) {\n
\t\t\t\treturn elm.getAttribute(\'role\');\n
\t\t\t}\n
\n
\t\t\treturn null;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the wai role of the parent element of the currently\n
\t\t * focused element or specified element.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Element} elm Optional element to get parent role from.\n
\t\t * @return {String} Role of the first parent that has a role.\n
\t\t */\n
\t\tfunction getParentRole(elm) {\n
\t\t\tvar role, parent = elm || focusedElement;\n
\n
\t\t\twhile ((parent = parent.parentNode)) {\n
\t\t\t\tif ((role = getRole(parent))) {\n
\t\t\t\t\treturn role;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns a wai aria property by name for example aria-selected.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {String} name Name of the aria property to get for example "disabled".\n
\t\t * @return {String} Aria property value.\n
\t\t */\n
\t\tfunction getAriaProp(name) {\n
\t\t\tvar elm = focusedElement;\n
\n
\t\t\tif (isElement(elm)) {\n
\t\t\t\treturn elm.getAttribute(\'aria-\' + name);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Is the element a text input element or not.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Element} elm Element to check if it\'s an text input element or not.\n
\t\t * @return {Boolean} True/false if the element is a text element or not.\n
\t\t */\n
\t\tfunction isTextInputElement(elm) {\n
\t\t\tvar tagName = elm.tagName.toUpperCase();\n
\n
\t\t\t// Notice: since type can be "email" etc we don\'t check the type\n
\t\t\t// So all input elements gets treated as text input elements\n
\t\t\treturn tagName == "INPUT" || tagName == "TEXTAREA";\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if the specified element can be focused or not.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Element} elm DOM element to check if it can be focused or not.\n
\t\t * @return {Boolean} True/false if the element can have focus.\n
\t\t */\n
\t\tfunction canFocus(elm) {\n
\t\t\tif (isTextInputElement(elm) && !elm.hidden) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tif (/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell)$/.test(getRole(elm))) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns an array of focusable visible elements within the specified container element.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Element} elm DOM element to find focusable elements within.\n
\t\t * @return {Array} Array of focusable elements.\n
\t\t */\n
\t\tfunction getFocusElements(elm) {\n
\t\t\tvar elements = [];\n
\n
\t\t\tfunction collect(elm) {\n
\t\t\t\tif (elm.nodeType != 1 || elm.style.display == \'none\') {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (canFocus(elm)) {\n
\t\t\t\t\telements.push(elm);\n
\t\t\t\t}\n
\n
\t\t\t\tfor (var i = 0; i < elm.childNodes.length; i++) {\n
\t\t\t\t\tcollect(elm.childNodes[i]);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tcollect(elm || root.getEl());\n
\n
\t\t\treturn elements;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the navigation root control for the specified control. The navigation root\n
\t\t * is the control that the keyboard navigation gets scoped to for example a menubar or toolbar group.\n
\t\t * It will look for parents of the specified target control or the currently focused control if this option is omitted.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {tinymce.ui.Control} targetControl Optional target control to find root of.\n
\t\t * @return {tinymce.ui.Control} Navigation root control.\n
\t\t */\n
\t\tfunction getNavigationRoot(targetControl) {\n
\t\t\tvar navigationRoot, controls;\n
\n
\t\t\ttargetControl = targetControl || focusedControl;\n
\t\t\tcontrols = targetControl.parents().toArray();\n
\t\t\tcontrols.unshift(targetControl);\n
\n
\t\t\tfor (var i = 0; i < controls.length; i++) {\n
\t\t\t\tnavigationRoot = controls[i];\n
\n
\t\t\t\tif (navigationRoot.settings.ariaRoot) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn navigationRoot;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Focuses the first item in the specified targetControl element or the last aria index if the\n
\t\t * navigation root has the ariaRemember option enabled.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {tinymce.ui.Control} targetControl Target control to focus the first item in.\n
\t\t */\n
\t\tfunction focusFirst(targetControl) {\n
\t\t\tvar navigationRoot = getNavigationRoot(targetControl);\n
\t\t\tvar focusElements = getFocusElements(navigationRoot.getEl());\n
\n
\t\t\tif (navigationRoot.settings.ariaRemember && "lastAriaIndex" in navigationRoot) {\n
\t\t\t\tmoveFocusToIndex(navigationRoot.lastAriaIndex, focusElements);\n
\t\t\t} else {\n
\t\t\t\tmoveFocusToIndex(0, focusElements);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the specified index within the elements list.\n
\t\t * This will scope the index to the size of the element list if it changed.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Number} idx Specified index to move to.\n
\t\t * @param {Array} elements Array with dom elements to move focus within.\n
\t\t * @return {Number} Input index or a changed index if it was out of range.\n
\t\t */\n
\t\tfunction moveFocusToIndex(idx, elements) {\n
\t\t\tif (idx < 0) {\n
\t\t\t\tidx = elements.length - 1;\n
\t\t\t} else if (idx >= elements.length) {\n
\t\t\t\tidx = 0;\n
\t\t\t}\n
\n
\t\t\tif (elements[idx]) {\n
\t\t\t\telements[idx].focus();\n
\t\t\t}\n
\n
\t\t\treturn idx;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus forwards or backwards.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Number} dir Direction to move in positive means forward, negative means backwards.\n
\t\t * @param {Array} elements Optional array of elements to move within defaults to the current navigation roots elements.\n
\t\t */\n
\t\tfunction moveFocus(dir, elements) {\n
\t\t\tvar idx = -1, navigationRoot = getNavigationRoot();\n
\n
\t\t\telements = elements || getFocusElements(navigationRoot.getEl());\n
\n
\t\t\tfor (var i = 0; i < elements.length; i++) {\n
\t\t\t\tif (elements[i] === focusedElement) {\n
\t\t\t\t\tidx = i;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tidx += dir;\n
\t\t\tnavigationRoot.lastAriaIndex = moveFocusToIndex(idx, elements);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the left this is called by the left key.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tfunction left() {\n
\t\t\tvar parentRole = getParentRole();\n
\n
\t\t\tif (parentRole == "tablist") {\n
\t\t\t\tmoveFocus(-1, getFocusElements(focusedElement.parentNode));\n
\t\t\t} else if (focusedControl.parent().submenu) {\n
\t\t\t\tcancel();\n
\t\t\t} else {\n
\t\t\t\tmoveFocus(-1);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the right this is called by the right key.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tfunction right() {\n
\t\t\tvar role = getRole(), parentRole = getParentRole();\n
\n
\t\t\tif (parentRole == "tablist") {\n
\t\t\t\tmoveFocus(1, getFocusElements(focusedElement.parentNode));\n
\t\t\t} else if (role == "menuitem" && parentRole == "menu" && getAriaProp(\'haspopup\')) {\n
\t\t\t\tenter();\n
\t\t\t} else {\n
\t\t\t\tmoveFocus(1);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the up this is called by the up key.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tfunction up() {\n
\t\t\tmoveFocus(-1);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the up this is called by the down key.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tfunction down() {\n
\t\t\tvar role = getRole(), parentRole = getParentRole();\n
\n
\t\t\tif (role == "menuitem" && parentRole == "menubar") {\n
\t\t\t\tenter();\n
\t\t\t} else if (role == "button" && getAriaProp(\'haspopup\')) {\n
\t\t\t\tenter({key: \'down\'});\n
\t\t\t} else {\n
\t\t\t\tmoveFocus(1);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves the focus to the next item or previous item depending on shift key.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {DOMEvent} e DOM event object.\n
\t\t */\n
\t\tfunction tab(e) {\n
\t\t\tvar parentRole = getParentRole();\n
\n
\t\t\tif (parentRole == "tablist") {\n
\t\t\t\tvar elm = getFocusElements(focusedControl.getEl(\'body\'))[0];\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\telm.focus();\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tmoveFocus(e.shiftKey ? -1 : 1);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Calls the cancel event on the currently focused control. This is normally done using the Esc key.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tfunction cancel() {\n
\t\t\tfocusedControl.fire(\'cancel\');\n
\t\t}\n
\n
\t\t/**\n
\t\t * Calls the click event on the currently focused control. This is normally done using the Enter/Space keys.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Object} aria Optional aria data to pass along with the enter event.\n
\t\t */\n
\t\tfunction enter(aria) {\n
\t\t\taria = aria || {};\n
\t\t\tfocusedControl.fire(\'click\', {target: focusedElement, aria: aria});\n
\t\t}\n
\n
\t\troot.on(\'keydown\', function(e) {\n
\t\t\tfunction handleNonTabOrEscEvent(e, handler) {\n
\t\t\t\t// Ignore non tab keys for text elements\n
\t\t\t\tif (isTextInputElement(focusedElement)) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (handler(e) !== false) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (e.isDefaultPrevented()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tswitch (e.keyCode) {\n
\t\t\t\tcase 37: // DOM_VK_LEFT\n
\t\t\t\t\thandleNonTabOrEscEvent(e, left);\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 39: // DOM_VK_RIGHT\n
\t\t\t\t\thandleNonTabOrEscEvent(e, right);\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 38: // DOM_VK_UP\n
\t\t\t\t\thandleNonTabOrEscEvent(e, up);\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 40: // DOM_VK_DOWN\n
\t\t\t\t\thandleNonTabOrEscEvent(e, down);\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 27: // DOM_VK_ESCAPE\n
\t\t\t\t\tcancel();\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 14: // DOM_VK_ENTER\n
\t\t\t\tcase 13: // DOM_VK_RETURN\n
\t\t\t\tcase 32: // DOM_VK_SPACE\n
\t\t\t\t\thandleNonTabOrEscEvent(e, enter);\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 9: // DOM_VK_TAB\n
\t\t\t\t\tif (tab(e) !== false) {\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t}\n
\t\t\t\t\tbreak;\n
\t\t\t}\n
\t\t});\n
\n
\t\troot.on(\'focusin\', function(e) {\n
\t\t\tfocusedElement = e.target;\n
\t\t\tfocusedControl = e.control;\n
\t\t});\n
\n
\t\treturn {\n
\t\t\tfocusFirst: focusFirst\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/Container.js\n
\n
/**\n
 * Container.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Container control. This is extended by all controls that can have\n
 * children such as panels etc. You can also use this class directly as an\n
 * generic container instance. The container doesn\'t have any specific role or style.\n
 *\n
 * @-x-less Container.less\n
 * @class tinymce.ui.Container\n
 * @extends tinymce.ui.Control\n
 */\n
define("tinymce/ui/Container", [\n
\t"tinymce/ui/Control",\n
\t"tinymce/ui/Collection",\n
\t"tinymce/ui/Selector",\n
\t"tinymce/ui/Factory",\n
\t"tinymce/ui/KeyboardNavigation",\n
\t"tinymce/util/Tools",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/ClassList",\n
\t"tinymce/ui/ReflowQueue"\n
], function(Control, Collection, Selector, Factory, KeyboardNavigation, Tools, $, ClassList, ReflowQueue) {\n
\t"use strict";\n
\n
\tvar selectorCache = {};\n
\n
\treturn Control.extend({\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Array} items Items to add to container in JSON format or control instances.\n
\t\t * @setting {String} layout Layout manager by name to use.\n
\t\t * @setting {Object} defaults Default settings to apply to all items.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tif (settings.fixed) {\n
\t\t\t\tself.state.set(\'fixed\', true);\n
\t\t\t}\n
\n
\t\t\tself._items = new Collection();\n
\n
\t\t\tif (self.isRtl()) {\n
\t\t\t\tself.classes.add(\'rtl\');\n
\t\t\t}\n
\n
\t\t\tself.bodyClasses = new ClassList(function() {\n
\t\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\t\tself.getEl(\'body\').className = this.toString();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t\tself.bodyClasses.prefix = self.classPrefix;\n
\n
\t\t\tself.classes.add(\'container\');\n
\t\t\tself.bodyClasses.add(\'container-body\');\n
\n
\t\t\tif (settings.containerCls) {\n
\t\t\t\tself.classes.add(settings.containerCls);\n
\t\t\t}\n
\n
\t\t\tself._layout = Factory.create((settings.layout || \'\') + \'layout\');\n
\n
\t\t\tif (self.settings.items) {\n
\t\t\t\tself.add(self.settings.items);\n
\t\t\t} else {\n
\t\t\t\tself.add(self.render());\n
\t\t\t}\n
\n
\t\t\t// TODO: Fix this!\n
\t\t\tself._hasBody = true;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a collection of child items that the container currently have.\n
\t\t *\n
\t\t * @method items\n
\t\t * @return {tinymce.ui.Collection} Control collection direct child controls.\n
\t\t */\n
\t\titems: function() {\n
\t\t\treturn this._items;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Find child controls by selector.\n
\t\t *\n
\t\t * @method find\n
\t\t * @param {String} selector Selector CSS pattern to find children by.\n
\t\t * @return {tinymce.ui.Collection} Control collection with child controls.\n
\t\t */\n
\t\tfind: function(selector) {\n
\t\t\tselector = selectorCache[selector] = selectorCache[selector] || new Selector(selector);\n
\n
\t\t\treturn selector.find(this);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds one or many items to the current container. This will create instances of\n
\t\t * the object representations if needed.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {Array/Object/tinymce.ui.Control} items Array or item that will be added to the container.\n
\t\t * @return {tinymce.ui.Collection} Current collection control.\n
\t\t */\n
\t\tadd: function(items) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.items().add(self.create(items)).parent(self);\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses the current container instance. This will look\n
\t\t * for the first control in the container and focus that.\n
\t\t *\n
\t\t * @method focus\n
\t\t * @param {Boolean} keyboard Optional true/false if the focus was a keyboard focus or not.\n
\t\t * @return {tinymce.ui.Collection} Current instance.\n
\t\t */\n
\t\tfocus: function(keyboard) {\n
\t\t\tvar self = this, focusCtrl, keyboardNav, items;\n
\n
\t\t\tif (keyboard) {\n
\t\t\t\tkeyboardNav = self.keyboardNav || self.parents().eq(-1)[0].keyboardNav;\n
\n
\t\t\t\tif (keyboardNav) {\n
\t\t\t\t\tkeyboardNav.focusFirst(self);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\titems = self.find(\'*\');\n
\n
\t\t\t// TODO: Figure out a better way to auto focus alert dialog buttons\n
\t\t\tif (self.statusbar) {\n
\t\t\t\titems.add(self.statusbar.items());\n
\t\t\t}\n
\n
\t\t\titems.each(function(ctrl) {\n
\t\t\t\tif (ctrl.settings.autofocus) {\n
\t\t\t\t\tfocusCtrl = null;\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\tif (ctrl.canFocus) {\n
\t\t\t\t\tfocusCtrl = focusCtrl || ctrl;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (focusCtrl) {\n
\t\t\t\tfocusCtrl.focus();\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Replaces the specified child control with a new control.\n
\t\t *\n
\t\t * @method replace\n
\t\t * @param {tinymce.ui.Control} oldItem Old item to be replaced.\n
\t\t * @param {tinymce.ui.Control} newItem New item to be inserted.\n
\t\t */\n
\t\treplace: function(oldItem, newItem) {\n
\t\t\tvar ctrlElm, items = this.items(), i = items.length;\n
\n
\t\t\t// Replace the item in collection\n
\t\t\twhile (i--) {\n
\t\t\t\tif (items[i] === oldItem) {\n
\t\t\t\t\titems[i] = newItem;\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (i >= 0) {\n
\t\t\t\t// Remove new item from DOM\n
\t\t\t\tctrlElm = newItem.getEl();\n
\t\t\t\tif (ctrlElm) {\n
\t\t\t\t\tctrlElm.parentNode.removeChild(ctrlElm);\n
\t\t\t\t}\n
\n
\t\t\t\t// Remove old item from DOM\n
\t\t\t\tctrlElm = oldItem.getEl();\n
\t\t\t\tif (ctrlElm) {\n
\t\t\t\t\tctrlElm.parentNode.removeChild(ctrlElm);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Adopt the item\n
\t\t\tnewItem.parent(this);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates the specified items. If any of the items is plain JSON style objects\n
\t\t * it will convert these into real tinymce.ui.Control instances.\n
\t\t *\n
\t\t * @method create\n
\t\t * @param {Array} items Array of items to convert into control instances.\n
\t\t * @return {Array} Array with control instances.\n
\t\t */\n
\t\tcreate: function(items) {\n
\t\t\tvar self = this, settings, ctrlItems = [];\n
\n
\t\t\t// Non array structure, then force it into an array\n
\t\t\tif (!Tools.isArray(items)) {\n
\t\t\t\titems = [items];\n
\t\t\t}\n
\n
\t\t\t// Add default type to each child control\n
\t\t\tTools.each(items, function(item) {\n
\t\t\t\tif (item) {\n
\t\t\t\t\t// Construct item if needed\n
\t\t\t\t\tif (!(item instanceof Control)) {\n
\t\t\t\t\t\t// Name only then convert it to an object\n
\t\t\t\t\t\tif (typeof item == "string") {\n
\t\t\t\t\t\t\titem = {type: item};\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Create control instance based on input settings and default settings\n
\t\t\t\t\t\tsettings = Tools.extend({}, self.settings.defaults, item);\n
\t\t\t\t\t\titem.type = settings.type = settings.type || item.type || self.settings.defaultType ||\n
\t\t\t\t\t\t\t(settings.defaults ? settings.defaults.type : null);\n
\t\t\t\t\t\titem = Factory.create(settings);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrlItems.push(item);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn ctrlItems;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders new control instances.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\trenderNew: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\t// Render any new items\n
\t\t\tself.items().each(function(ctrl, index) {\n
\t\t\t\tvar containerElm;\n
\n
\t\t\t\tctrl.parent(self);\n
\n
\t\t\t\tif (!ctrl.state.get(\'rendered\')) {\n
\t\t\t\t\tcontainerElm = self.getEl(\'body\');\n
\n
\t\t\t\t\t// Insert or append the item\n
\t\t\t\t\tif (containerElm.hasChildNodes() && index <= containerElm.childNodes.length - 1) {\n
\t\t\t\t\t\t$(containerElm.childNodes[index]).before(ctrl.renderHtml());\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t$(containerElm).append(ctrl.renderHtml());\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrl.postRender();\n
\t\t\t\t\tReflowQueue.add(ctrl);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself._layout.applyClasses(self.items().filter(\':visible\'));\n
\t\t\tself._lastRect = null;\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Appends new instances to the current container.\n
\t\t *\n
\t\t * @method append\n
\t\t * @param {Array/tinymce.ui.Collection} items Array if controls to append.\n
\t\t * @return {tinymce.ui.Container} Current container instance.\n
\t\t */\n
\t\tappend: function(items) {\n
\t\t\treturn this.add(items).renderNew();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Prepends new instances to the current container.\n
\t\t *\n
\t\t * @method prepend\n
\t\t * @param {Array/tinymce.ui.Collection} items Array if controls to prepend.\n
\t\t * @return {tinymce.ui.Container} Current container instance.\n
\t\t */\n
\t\tprepend: function(items) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.items().set(self.create(items).concat(self.items().toArray()));\n
\n
\t\t\treturn self.renderNew();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Inserts an control at a specific index.\n
\t\t *\n
\t\t * @method insert\n
\t\t * @param {Array/tinymce.ui.Collection} items Array if controls to insert.\n
\t\t * @param {Number} index Index to insert controls at.\n
\t\t * @param {Boolean} [before=false] Inserts controls before the index.\n
\t\t */\n
\t\tinsert: function(items, index, before) {\n
\t\t\tvar self = this, curItems, beforeItems, afterItems;\n
\n
\t\t\titems = self.create(items);\n
\t\t\tcurItems = self.items();\n
\n
\t\t\tif (!before && index < curItems.length - 1) {\n
\t\t\t\tindex += 1;\n
\t\t\t}\n
\n
\t\t\tif (index >= 0 && index < curItems.length) {\n
\t\t\t\tbeforeItems = curItems.slice(0, index).toArray();\n
\t\t\t\tafterItems = curItems.slice(index).toArray();\n
\t\t\t\tcurItems.set(beforeItems.concat(items, afterItems));\n
\t\t\t}\n
\n
\t\t\treturn self.renderNew();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Populates the form fields from the specified JSON data object.\n
\t\t *\n
\t\t * Control items in the form that matches the data will have it\'s value set.\n
\t\t *\n
\t\t * @method fromJSON\n
\t\t * @param {Object} data JSON data object to set control values by.\n
\t\t * @return {tinymce.ui.Container} Current form instance.\n
\t\t */\n
\t\tfromJSON: function(data) {\n
\t\t\tvar self = this;\n
\n
\t\t\tfor (var name in data) {\n
\t\t\t\tself.find(\'#\' + name).value(data[name]);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Serializes the form into a JSON object by getting all items\n
\t\t * that has a name and a value.\n
\t\t *\n
\t\t * @method toJSON\n
\t\t * @return {Object} JSON object with form data.\n
\t\t */\n
\t\ttoJSON: function() {\n
\t\t\tvar self = this, data = {};\n
\n
\t\t\tself.find(\'*\').each(function(ctrl) {\n
\t\t\t\tvar name = ctrl.name(), value = ctrl.value();\n
\n
\t\t\t\tif (name && typeof value != "undefined") {\n
\t\t\t\t\tdata[name] = value;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn data;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, role = this.settings.role;\n
\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'"\' + (role ? \' role="\' + this.settings.role + \'"\' : \'\') + \'>\' +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\t(self.settings.html || \'\') + layout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Post render method. Called after the control has been rendered to the target.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @return {tinymce.ui.Container} Current combobox instance.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, box;\n
\n
\t\t\tself.items().exec(\'postRender\');\n
\t\t\tself._super();\n
\n
\t\t\tself._layout.postRender(self);\n
\t\t\tself.state.set(\'rendered\', true);\n
\n
\t\t\tif (self.settings.style) {\n
\t\t\t\tself.$el.css(self.settings.style);\n
\t\t\t}\n
\n
\t\t\tif (self.settings.border) {\n
\t\t\t\tbox = self.borderBox;\n
\t\t\t\tself.$el.css({\n
\t\t\t\t\t\'border-top-width\': box.top,\n
\t\t\t\t\t\'border-right-width\': box.right,\n
\t\t\t\t\t\'border-bottom-width\': box.bottom,\n
\t\t\t\t\t\'border-left-width\': box.left\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (!self.parent()) {\n
\t\t\t\tself.keyboardNav = new KeyboardNavigation({\n
\t\t\t\t\troot: self\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the current controls layout rect.\n
\t\t * This will be executed by the layout managers to determine the\n
\t\t * default minWidth/minHeight etc.\n
\t\t *\n
\t\t * @method initLayoutRect\n
\t\t * @return {Object} Layout rect instance.\n
\t\t */\n
\t\tinitLayoutRect: function() {\n
\t\t\tvar self = this, layoutRect = self._super();\n
\n
\t\t\t// Recalc container size by asking layout manager\n
\t\t\tself._layout.recalc(self);\n
\n
\t\t\treturn layoutRect;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the current container.\n
\t\t * This is invoked by the reflow method and shouldn\'t be called directly.\n
\t\t *\n
\t\t * @method recalc\n
\t\t */\n
\t\trecalc: function() {\n
\t\t\tvar self = this, rect = self._layoutRect, lastRect = self._lastRect;\n
\n
\t\t\tif (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {\n
\t\t\t\tself._layout.recalc(self);\n
\t\t\t\trect = self.layoutRect();\n
\t\t\t\tself._lastRect = {x: rect.x, y: rect.y, w: rect.w, h: rect.h};\n
\t\t\t\treturn true;\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Reflows the current container and it\'s children and possible parents.\n
\t\t * This should be used after you for example append children to the current control so\n
\t\t * that the layout managers know that they need to reposition everything.\n
\t\t *\n
\t\t * @example\n
\t\t * container.append({type: \'button\', text: \'My button\'}).reflow();\n
\t\t *\n
\t\t * @method reflow\n
\t\t * @return {tinymce.ui.Container} Current container instance.\n
\t\t */\n
\t\treflow: function() {\n
\t\t\tvar i;\n
\n
\t\t\tReflowQueue.remove(this);\n
\n
\t\t\tif (this.visible()) {\n
\t\t\t\tControl.repaintControls = [];\n
\t\t\t\tControl.repaintControls.map = {};\n
\n
\t\t\t\tthis.recalc();\n
\t\t\t\ti = Control.repaintControls.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tControl.repaintControls[i].repaint();\n
\t\t\t\t}\n
\n
\t\t\t\t// TODO: Fix me!\n
\t\t\t\tif (this.settings.layout !== "flow" && this.settings.layout !== "stack") {\n
\t\t\t\t\tthis.repaint();\n
\t\t\t\t}\n
\n
\t\t\t\tControl.repaintControls = [];\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/DragHelper.js\n
\n
/**\n
 * DragHelper.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Drag/drop helper class.\n
 *\n
 * @example\n
 * var dragHelper = new tinymce.ui.DragHelper(\'mydiv\', {\n
 *     start: function(evt) {\n
 *     },\n
 *\n
 *     drag: function(evt) {\n
 *     },\n
 *\n
 *     end: function(evt) {\n
 *     }\n
 * });\n
 *\n
 * @class tinymce.ui.DragHelper\n
 */\n
define("tinymce/ui/DragHelper", [\n
\t"tinymce/dom/DomQuery"\n
], function($) {\n
\t"use strict";\n
\n
\tfunction getDocumentSize(doc) {\n
\t\tvar documentElement, body, scrollWidth, clientWidth;\n
\t\tvar offsetWidth, scrollHeight, clientHeight, offsetHeight, max = Math.max;\n
\n
\t\tdocumentElement = doc.documentElement;\n
\t\tbody = doc.body;\n
\n
\t\tscrollWidth = max(documentElement.scrollWidth, body.scrollWidth);\n
\t\tclientWidth = max(documentElement.clientWidth, body.clientWidth);\n
\t\toffsetWidth = max(documentElement.offsetWidth, body.offsetWidth);\n
\n
\t\tscrollHeight = max(documentElement.scrollHeight, body.scrollHeight);\n
\t\tclientHeight = max(documentElement.clientHeight, body.clientHeight);\n
\t\toffsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\n
\n
\t\treturn {\n
\t\t\twidth: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\n
\t\t\theight: scrollHeight < offsetHeight ? clientHeight : scrollHeight\n
\t\t};\n
\t}\n
\n
\tfunction updateWithTouchData(e) {\n
\t\tvar keys, i;\n
\n
\t\tif (e.changedTouches) {\n
\t\t\tkeys = "screenX screenY pageX pageY clientX clientY".split(\' \');\n
\t\t\tfor (i = 0; i < keys.length; i++) {\n
\t\t\t\te[keys[i]] = e.changedTouches[0][keys[i]];\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\treturn function(id, settings) {\n
\t\tvar $eventOverlay, doc = settings.document || document, downButton, start, stop, drag, startX, startY;\n
\n
\t\tsettings = settings || {};\n
\n
\t\tfunction getHandleElm() {\n
\t\t\treturn doc.getElementById(settings.handle || id);\n
\t\t}\n
\n
\t\tstart = function(e) {\n
\t\t\tvar docSize = getDocumentSize(doc), handleElm, cursor;\n
\n
\t\t\tupdateWithTouchData(e);\n
\n
\t\t\te.preventDefault();\n
\t\t\tdownButton = e.button;\n
\t\t\thandleElm = getHandleElm();\n
\t\t\tstartX = e.screenX;\n
\t\t\tstartY = e.screenY;\n
\n
\t\t\t// Grab cursor from handle so we can place it on overlay\n
\t\t\tif (window.getComputedStyle) {\n
\t\t\t\tcursor = window.getComputedStyle(handleElm, null).getPropertyValue("cursor");\n
\t\t\t} else {\n
\t\t\t\tcursor = handleElm.runtimeStyle.cursor;\n
\t\t\t}\n
\n
\t\t\t$eventOverlay = $(\'<div>\').css({\n
\t\t\t\tposition: "absolute",\n
\t\t\t\ttop: 0, left: 0,\n
\t\t\t\twidth: docSize.width,\n
\t\t\t\theight: docSize.height,\n
\t\t\t\tzIndex: 0x7FFFFFFF,\n
\t\t\t\topacity: 0.0001,\n
\t\t\t\tcursor: cursor\n
\t\t\t}).appendTo(doc.body);\n
\n
\t\t\t$(doc).on(\'mousemove touchmove\', drag).on(\'mouseup touchend\', stop);\n
\n
\t\t\tsettings.start(e);\n
\t\t};\n
\n
\t\tdrag = function(e) {\n
\t\t\tupdateWithTouchData(e);\n
\n
\t\t\tif (e.button !== downButton) {\n
\t\t\t\treturn stop(e);\n
\t\t\t}\n
\n
\t\t\te.deltaX = e.screenX - startX;\n
\t\t\te.deltaY = e.screenY - startY;\n
\n
\t\t\te.preventDefault();\n
\t\t\tsettings.drag(e);\n
\t\t};\n
\n
\t\tstop = function(e) {\n
\t\t\tupdateWithTouchData(e);\n
\n
\t\t\t$(doc).off(\'mousemove touchmove\', drag).off(\'mouseup touchend\', stop);\n
\n
\t\t\t$eventOverlay.remove();\n
\n
\t\t\tif (settings.stop) {\n
\t\t\t\tsettings.stop(e);\n
\t\t\t}\n
\t\t};\n
\n
\t\t/**\n
\t\t * Destroys the drag/drop helper instance.\n
\t\t *\n
\t\t * @method destroy\n
\t\t */\n
\t\tthis.destroy = function() {\n
\t\t\t$(getHandleElm()).off();\n
\t\t};\n
\n
\t\t$(getHandleElm()).on(\'mousedown touchstart\', start);\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/Scrollable.js\n
\n
/**\n
 * Scrollable.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This mixin makes controls scrollable using custom scrollbars.\n
 *\n
 * @-x-less Scrollable.less\n
 * @mixin tinymce.ui.Scrollable\n
 */\n
define("tinymce/ui/Scrollable", [\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/DragHelper"\n
], function($, DragHelper) {\n
\t"use strict";\n
\n
\treturn {\n
\t\tinit: function() {\n
\t\t\tvar self = this;\n
\t\t\tself.on(\'repaint\', self.renderScroll);\n
\t\t},\n
\n
\t\trenderScroll: function() {\n
\t\t\tvar self = this, margin = 2;\n
\n
\t\t\tfunction repaintScroll() {\n
\t\t\t\tvar hasScrollH, hasScrollV, bodyElm;\n
\n
\t\t\t\tfunction repaintAxis(axisName, posName, sizeName, contentSizeName, hasScroll, ax) {\n
\t\t\t\t\tvar containerElm, scrollBarElm, scrollThumbElm;\n
\t\t\t\t\tvar containerSize, scrollSize, ratio, rect;\n
\t\t\t\t\tvar posNameLower, sizeNameLower;\n
\n
\t\t\t\t\tscrollBarElm = self.getEl(\'scroll\' + axisName);\n
\t\t\t\t\tif (scrollBarElm) {\n
\t\t\t\t\t\tposNameLower = posName.toLowerCase();\n
\t\t\t\t\t\tsizeNameLower = sizeName.toLowerCase();\n
\n
\t\t\t\t\t\t$(self.getEl(\'absend\')).css(posNameLower, self.layoutRect()[contentSizeName] - 1);\n
\n
\t\t\t\t\t\tif (!hasScroll) {\n
\t\t\t\t\t\t\t$(scrollBarElm).css(\'display\', \'none\');\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t$(scrollBarElm).css(\'display\', \'block\');\n
\t\t\t\t\t\tcontainerElm = self.getEl(\'body\');\n
\t\t\t\t\t\tscrollThumbElm = self.getEl(\'scroll\' + axisName + "t");\n
\t\t\t\t\t\tcontainerSize = containerElm["client" + sizeName] - (margin * 2);\n
\t\t\t\t\t\tcontainerSize -= hasScrollH && hasScrollV ? scrollBarElm["client" + ax] : 0;\n
\t\t\t\t\t\tscrollSize = containerElm["scroll" + sizeName];\n
\t\t\t\t\t\tratio = containerSize / scrollSize;\n
\n
\t\t\t\t\t\trect = {};\n
\t\t\t\t\t\trect[posNameLower] = containerElm["offset" + posName] + margin;\n
\t\t\t\t\t\trect[sizeNameLower] = containerSize;\n
\t\t\t\t\t\t$(scrollBarElm).css(rect);\n
\n
\t\t\t\t\t\trect = {};\n
\t\t\t\t\t\trect[posNameLower] = containerElm["scroll" + posName] * ratio;\n
\t\t\t\t\t\trect[sizeNameLower] = containerSize * ratio;\n
\t\t\t\t\t\t$(scrollThumbElm).css(rect);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tbodyElm = self.getEl(\'body\');\n
\t\t\t\thasScrollH = bodyElm.scrollWidth > bodyElm.clientWidth;\n
\t\t\t\thasScrollV = bodyElm.scrollHeight > bodyElm.clientHeight;\n
\n
\t\t\t\trepaintAxis("h", "Left", "Width", "contentW", hasScrollH, "Height");\n
\t\t\t\trepaintAxis("v", "Top", "Height", "contentH", hasScrollV, "Width");\n
\t\t\t}\n
\n
\t\t\tfunction addScroll() {\n
\t\t\t\tfunction addScrollAxis(axisName, posName, sizeName, deltaPosName, ax) {\n
\t\t\t\t\tvar scrollStart, axisId = self._id + \'-scroll\' + axisName, prefix = self.classPrefix;\n
\n
\t\t\t\t\t$(self.getEl()).append(\n
\t\t\t\t\t\t\'<div id="\' + axisId + \'" class="\' + prefix + \'scrollbar \' + prefix + \'scrollbar-\' + axisName + \'">\' +\n
\t\t\t\t\t\t\t\'<div id="\' + axisId + \'t" class="\' + prefix + \'scrollbar-thumb"></div>\' +\n
\t\t\t\t\t\t\'</div>\'\n
\t\t\t\t\t);\n
\n
\t\t\t\t\tself.draghelper = new DragHelper(axisId + \'t\', {\n
\t\t\t\t\t\tstart: function() {\n
\t\t\t\t\t\t\tscrollStart = self.getEl(\'body\')["scroll" + posName];\n
\t\t\t\t\t\t\t$(\'#\' + axisId).addClass(prefix + \'active\');\n
\t\t\t\t\t\t},\n
\n
\t\t\t\t\t\tdrag: function(e) {\n
\t\t\t\t\t\t\tvar ratio, hasScrollH, hasScrollV, containerSize, layoutRect = self.layoutRect();\n
\n
\t\t\t\t\t\t\thasScrollH = layoutRect.contentW > layoutRect.innerW;\n
\t\t\t\t\t\t\thasScrollV = layoutRect.contentH > layoutRect.innerH;\n
\t\t\t\t\t\t\tcontainerSize = self.getEl(\'body\')["client" + sizeName] - (margin * 2);\n
\t\t\t\t\t\t\tcontainerSize -= hasScrollH && hasScrollV ? self.getEl(\'scroll\' + axisName)["client" + ax] : 0;\n
\n
\t\t\t\t\t\t\tratio = containerSize / self.getEl(\'body\')["scroll" + sizeName];\n
\t\t\t\t\t\t\tself.getEl(\'body\')["scroll" + posName] = scrollStart + (e["delta" + deltaPosName] / ratio);\n
\t\t\t\t\t\t},\n
\n
\t\t\t\t\t\tstop: function() {\n
\t\t\t\t\t\t\t$(\'#\' + axisId).removeClass(prefix + \'active\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\tself.classes.add(\'scroll\');\n
\n
\t\t\t\taddScrollAxis("v", "Top", "Height", "Y", "Width");\n
\t\t\t\taddScrollAxis("h", "Left", "Width", "X", "Height");\n
\t\t\t}\n
\n
\t\t\tif (self.settings.autoScroll) {\n
\t\t\t\tif (!self._hasScroll) {\n
\t\t\t\t\tself._hasScroll = true;\n
\t\t\t\t\taddScroll();\n
\n
\t\t\t\t\tself.on(\'wheel\', function(e) {\n
\t\t\t\t\t\tvar bodyEl = self.getEl(\'body\');\n
\n
\t\t\t\t\t\tbodyEl.scrollLeft += (e.deltaX || 0) * 10;\n
\t\t\t\t\t\tbodyEl.scrollTop += e.deltaY * 10;\n
\n
\t\t\t\t\t\trepaintScroll();\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t$(self.getEl(\'body\')).on("scroll", repaintScroll);\n
\t\t\t\t}\n
\n
\t\t\t\trepaintScroll();\n
\t\t\t}\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/Panel.js\n
\n
/**\n
 * Panel.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new panel.\n
 *\n
 * @-x-less Panel.less\n
 * @class tinymce.ui.Panel\n
 * @extends tinymce.ui.Container\n
 * @mixes tinymce.ui.Scrollable\n
 */\n
define("tinymce/ui/Panel", [\n
\t"tinymce/ui/Container",\n
\t"tinymce/ui/Scrollable"\n
], function(Container, Scrollable) {\n
\t"use strict";\n
\n
\treturn Container.extend({\n
\t\tDefaults: {\n
\t\t\tlayout: \'fit\',\n
\t\t\tcontainerCls: \'panel\'\n
\t\t},\n
\n
\t\tMixins: [Scrollable],\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, innerHtml = self.settings.html;\n
\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\tif (typeof innerHtml == "undefined") {\n
\t\t\t\tinnerHtml = (\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\tlayout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\'\n
\t\t\t\t);\n
\t\t\t} else {\n
\t\t\t\tif (typeof innerHtml == \'function\') {\n
\t\t\t\t\tinnerHtml = innerHtml.call(self);\n
\t\t\t\t}\n
\n
\t\t\t\tself._hasBody = false;\n
\t\t\t}\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'" hidefocus="1" tabindex="-1" role="group">\' +\n
\t\t\t\t\t(self._preBodyHtml || \'\') +\n
\t\t\t\t\tinnerHtml +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Movable.js\n
\n
/**\n
 * Movable.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Movable mixin. Makes controls movable absolute and relative to other elements.\n
 *\n
 * @mixin tinymce.ui.Movable\n
 */\n
define("tinymce/ui/Movable", [\n
\t"tinymce/ui/DomUtils"\n
], function(DomUtils) {\n
\t"use strict";\n
\n
\tfunction calculateRelativePosition(ctrl, targetElm, rel) {\n
\t\tvar ctrlElm, pos, x, y, selfW, selfH, targetW, targetH, viewport, size;\n
\n
\t\tviewport = DomUtils.getViewPort();\n
\n
\t\t// Get pos of target\n
\t\tpos = DomUtils.getPos(targetElm);\n
\t\tx = pos.x;\n
\t\ty = pos.y;\n
\n
\t\tif (ctrl.state.get(\'fixed\') && DomUtils.getRuntimeStyle(document.body, \'position\') == \'static\') {\n
\t\t\tx -= viewport.x;\n
\t\t\ty -= viewport.y;\n
\t\t}\n
\n
\t\t// Get size of self\n
\t\tctrlElm = ctrl.getEl();\n
\t\tsize = DomUtils.getSize(ctrlElm);\n
\t\tselfW = size.width;\n
\t\tselfH = size.height;\n
\n
\t\t// Get size of target\n
\t\tsize = DomUtils.getSize(targetElm);\n
\t\ttargetW = size.width;\n
\t\ttargetH = size.height;\n
\n
\t\t// Parse align string\n
\t\trel = (rel || \'\').split(\'\');\n
\n
\t\t// Target corners\n
\t\tif (rel[0] === \'b\') {\n
\t\t\ty += targetH;\n
\t\t}\n
\n
\t\tif (rel[1] === \'r\') {\n
\t\t\tx += targetW;\n
\t\t}\n
\n
\t\tif (rel[0] === \'c\') {\n
\t\t\ty += Math.round(targetH / 2);\n
\t\t}\n
\n
\t\tif (rel[1] === \'c\') {\n
\t\t\tx += Math.round(targetW / 2);\n
\t\t}\n
\n
\t\t// Self corners\n
\t\tif (rel[3] === \'b\') {\n
\t\t\ty -= selfH;\n
\t\t}\n
\n
\t\tif (rel[4] === \'r\') {\n
\t\t\tx -= selfW;\n
\t\t}\n
\n
\t\tif (rel[3] === \'c\') {\n
\t\t\ty -= Math.round(selfH / 2);\n
\t\t}\n
\n
\t\tif (rel[4] === \'c\') {\n
\t\t\tx -= Math.round(selfW / 2);\n
\t\t}\n
\n
\t\treturn {\n
\t\t\tx: x,\n
\t\t\ty: y,\n
\t\t\tw: selfW,\n
\t\t\th: selfH\n
\t\t};\n
\t}\n
\n
\treturn {\n
\t\t/**\n
\t\t * Tests various positions to get the most suitable one.\n
\t\t *\n
\t\t * @method testMoveRel\n
\t\t * @param {DOMElement} elm Element to position against.\n
\t\t * @param {Array} rels Array with relative positions.\n
\t\t * @return {String} Best suitable relative position.\n
\t\t */\n
\t\ttestMoveRel: function(elm, rels) {\n
\t\t\tvar viewPortRect = DomUtils.getViewPort();\n
\n
\t\t\tfor (var i = 0; i < rels.length; i++) {\n
\t\t\t\tvar pos = calculateRelativePosition(this, elm, rels[i]);\n
\n
\t\t\t\tif (this.state.get(\'fixed\')) {\n
\t\t\t\t\tif (pos.x > 0 && pos.x + pos.w < viewPortRect.w && pos.y > 0 && pos.y + pos.h < viewPortRect.h) {\n
\t\t\t\t\t\treturn rels[i];\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tif (pos.x > viewPortRect.x && pos.x + pos.w < viewPortRect.w + viewPortRect.x &&\n
\t\t\t\t\t\tpos.y > viewPortRect.y && pos.y + pos.h < viewPortRect.h + viewPortRect.y) {\n
\t\t\t\t\t\treturn rels[i];\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn rels[0];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Move relative to the specified element.\n
\t\t *\n
\t\t * @method moveRel\n
\t\t * @param {Element} elm Element to move relative to.\n
\t\t * @param {String} rel Relative mode. For example: br-tl.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tmoveRel: function(elm, rel) {\n
\t\t\tif (typeof rel != \'string\') {\n
\t\t\t\trel = this.testMoveRel(elm, rel);\n
\t\t\t}\n
\n
\t\t\tvar pos = calculateRelativePosition(this, elm, rel);\n
\t\t\treturn this.moveTo(pos.x, pos.y);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Move by a relative x, y values.\n
\t\t *\n
\t\t * @method moveBy\n
\t\t * @param {Number} dx Relative x position.\n
\t\t * @param {Number} dy Relative y position.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tmoveBy: function(dx, dy) {\n
\t\t\tvar self = this, rect = self.layoutRect();\n
\n
\t\t\tself.moveTo(rect.x + dx, rect.y + dy);\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Move to absolute position.\n
\t\t *\n
\t\t * @method moveTo\n
\t\t * @param {Number} x Absolute x position.\n
\t\t * @param {Number} y Absolute y position.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tmoveTo: function(x, y) {\n
\t\t\tvar self = this;\n
\n
\t\t\t// TODO: Move this to some global class\n
\t\t\tfunction constrain(value, max, size) {\n
\t\t\t\tif (value < 0) {\n
\t\t\t\t\treturn 0;\n
\t\t\t\t}\n
\n
\t\t\t\tif (value + size > max) {\n
\t\t\t\t\tvalue = max - size;\n
\t\t\t\t\treturn value < 0 ? 0 : value;\n
\t\t\t\t}\n
\n
\t\t\t\treturn value;\n
\t\t\t}\n
\n
\t\t\tif (self.settings.constrainToViewport) {\n
\t\t\t\tvar viewPortRect = DomUtils.getViewPort(window);\n
\t\t\t\tvar layoutRect = self.layoutRect();\n
\n
\t\t\t\tx = constrain(x, viewPortRect.w + viewPortRect.x, layoutRect.w);\n
\t\t\t\ty = constrain(y, viewPortRect.h + viewPortRect.y, layoutRect.h);\n
\t\t\t}\n
\n
\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\tself.layoutRect({x: x, y: y}).repaint();\n
\t\t\t} else {\n
\t\t\t\tself.settings.x = x;\n
\t\t\t\tself.settings.y = y;\n
\t\t\t}\n
\n
\t\t\tself.fire(\'move\', {x: x, y: y});\n
\n
\t\t\treturn self;\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/Resizable.js\n
\n
/**\n
 * Resizable.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Resizable mixin. Enables controls to be resized.\n
 *\n
 * @mixin tinymce.ui.Resizable\n
 */\n
define("tinymce/ui/Resizable", [\n
\t"tinymce/ui/DomUtils"\n
], function(DomUtils) {\n
\t"use strict";\n
\n
\treturn {\n
\t\t/**\n
\t\t * Resizes the control to contents.\n
\t\t *\n
\t\t * @method resizeToContent\n
\t\t */\n
\t\tresizeToContent: function() {\n
\t\t\tthis._layoutRect.autoResize = true;\n
\t\t\tthis._lastRect = null;\n
\t\t\tthis.reflow();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Resizes the control to a specific width/height.\n
\t\t *\n
\t\t * @method resizeTo\n
\t\t * @param {Number} w Control width.\n
\t\t * @param {Number} h Control height.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tresizeTo: function(w, h) {\n
\t\t\t// TODO: Fix hack\n
\t\t\tif (w <= 1 || h <= 1) {\n
\t\t\t\tvar rect = DomUtils.getWindowSize();\n
\n
\t\t\t\tw = w <= 1 ? w * rect.w : w;\n
\t\t\t\th = h <= 1 ? h * rect.h : h;\n
\t\t\t}\n
\n
\t\t\tthis._layoutRect.autoResize = false;\n
\t\t\treturn this.layoutRect({minW: w, minH: h, w: w, h: h}).reflow();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Resizes the control to a specific relative width/height.\n
\t\t *\n
\t\t * @method resizeBy\n
\t\t * @param {Number} dw Relative control width.\n
\t\t * @param {Number} dh Relative control height.\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tresizeBy: function(dw, dh) {\n
\t\t\tvar self = this, rect = self.layoutRect();\n
\n
\t\t\treturn self.resizeTo(rect.w + dw, rect.h + dh);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/FloatPanel.js\n
\n
/**\n
 * FloatPanel.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates a floating panel.\n
 *\n
 * @-x-less FloatPanel.less\n
 * @class tinymce.ui.FloatPanel\n
 * @extends tinymce.ui.Panel\n
 * @mixes tinymce.ui.Movable\n
 * @mixes tinymce.ui.Resizable\n
 */\n
define("tinymce/ui/FloatPanel", [\n
\t"tinymce/ui/Panel",\n
\t"tinymce/ui/Movable",\n
\t"tinymce/ui/Resizable",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/dom/DomQuery"\n
], function(Panel, Movable, Resizable, DomUtils, $) {\n
\t"use strict";\n
\n
\tvar documentClickHandler, documentScrollHandler, windowResizeHandler, visiblePanels = [];\n
\tvar zOrder = [], hasModal;\n
\n
\tfunction isChildOf(ctrl, parent) {\n
\t\twhile (ctrl) {\n
\t\t\tif (ctrl == parent) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tctrl = ctrl.parent();\n
\t\t}\n
\t}\n
\n
\tfunction skipOrHidePanels(e) {\n
\t\t// Hide any float panel when a click/focus out is out side that float panel and the\n
\t\t// float panels direct parent for example a click on a menu button\n
\t\tvar i = visiblePanels.length;\n
\n
\t\twhile (i--) {\n
\t\t\tvar panel = visiblePanels[i], clickCtrl = panel.getParentCtrl(e.target);\n
\n
\t\t\tif (panel.settings.autohide) {\n
\t\t\t\tif (clickCtrl) {\n
\t\t\t\t\tif (isChildOf(clickCtrl, panel) || panel.parent() === clickCtrl) {\n
\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\te = panel.fire(\'autohide\', {target: e.target});\n
\t\t\t\tif (!e.isDefaultPrevented()) {\n
\t\t\t\t\tpanel.hide();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction bindDocumentClickHandler() {\n
\n
\t\tif (!documentClickHandler) {\n
\t\t\tdocumentClickHandler = function(e) {\n
\t\t\t\t// Gecko fires click event and in the wrong order on Mac so lets normalize\n
\t\t\t\tif (e.button == 2) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tskipOrHidePanels(e);\n
\t\t\t};\n
\n
\t\t\t$(document).on(\'click touchstart\', documentClickHandler);\n
\t\t}\n
\t}\n
\n
\tfunction bindDocumentScrollHandler() {\n
\t\tif (!documentScrollHandler) {\n
\t\t\tdocumentScrollHandler = function() {\n
\t\t\t\tvar i;\n
\n
\t\t\t\ti = visiblePanels.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\trepositionPanel(visiblePanels[i]);\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\t$(window).on(\'scroll\', documentScrollHandler);\n
\t\t}\n
\t}\n
\n
\tfunction bindWindowResizeHandler() {\n
\t\tif (!windowResizeHandler) {\n
\t\t\tvar docElm = document.documentElement, clientWidth = docElm.clientWidth, clientHeight = docElm.clientHeight;\n
\n
\t\t\twindowResizeHandler = function() {\n
\t\t\t\t// Workaround for #7065 IE 7 fires resize events event though the window wasn\'t resized\n
\t\t\t\tif (!document.all || clientWidth != docElm.clientWidth || clientHeight != docElm.clientHeight) {\n
\t\t\t\t\tclientWidth = docElm.clientWidth;\n
\t\t\t\t\tclientHeight = docElm.clientHeight;\n
\t\t\t\t\tFloatPanel.hideAll();\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\t$(window).on(\'resize\', windowResizeHandler);\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Repositions the panel to the top of page if the panel is outside of the visual viewport. It will\n
\t * also reposition all child panels of the current panel.\n
\t */\n
\tfunction repositionPanel(panel) {\n
\t\tvar scrollY = DomUtils.getViewPort().y;\n
\n
\t\tfunction toggleFixedChildPanels(fixed, deltaY) {\n
\t\t\tvar parent;\n
\n
\t\t\tfor (var i = 0; i < visiblePanels.length; i++) {\n
\t\t\t\tif (visiblePanels[i] != panel) {\n
\t\t\t\t\tparent = visiblePanels[i].parent();\n
\n
\t\t\t\t\twhile (parent && (parent = parent.parent())) {\n
\t\t\t\t\t\tif (parent == panel) {\n
\t\t\t\t\t\t\tvisiblePanels[i].fixed(fixed).moveBy(0, deltaY).repaint();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (panel.settings.autofix) {\n
\t\t\tif (!panel.state.get(\'fixed\')) {\n
\t\t\t\tpanel._autoFixY = panel.layoutRect().y;\n
\n
\t\t\t\tif (panel._autoFixY < scrollY) {\n
\t\t\t\t\tpanel.fixed(true).layoutRect({y: 0}).repaint();\n
\t\t\t\t\ttoggleFixedChildPanels(true, scrollY - panel._autoFixY);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tif (panel._autoFixY > scrollY) {\n
\t\t\t\t\tpanel.fixed(false).layoutRect({y: panel._autoFixY}).repaint();\n
\t\t\t\t\ttoggleFixedChildPanels(false, panel._autoFixY - scrollY);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\tfunction addRemove(add, ctrl) {\n
\t\tvar i, zIndex = FloatPanel.zIndex || 0xFFFF, topModal;\n
\n
\t\tif (add) {\n
\t\t\tzOrder.push(ctrl);\n
\t\t} else {\n
\t\t\ti = zOrder.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\tif (zOrder[i] === ctrl) {\n
\t\t\t\t\tzOrder.splice(i, 1);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (zOrder.length) {\n
\t\t\tfor (i = 0; i < zOrder.length; i++) {\n
\t\t\t\tif (zOrder[i].modal) {\n
\t\t\t\t\tzIndex++;\n
\t\t\t\t\ttopModal = zOrder[i];\n
\t\t\t\t}\n
\n
\t\t\t\tzOrder[i].getEl().style.zIndex = zIndex;\n
\t\t\t\tzOrder[i].zIndex = zIndex;\n
\t\t\t\tzIndex++;\n
\t\t\t}\n
\t\t}\n
\n
\t\tvar modalBlockEl = document.getElementById(ctrl.classPrefix + \'modal-block\');\n
\n
\t\tif (topModal) {\n
\t\t\t$(modalBlockEl).css(\'z-index\', topModal.zIndex - 1);\n
\t\t} else if (modalBlockEl) {\n
\t\t\tmodalBlockEl.parentNode.removeChild(modalBlockEl);\n
\t\t\thasModal = false;\n
\t\t}\n
\n
\t\tFloatPanel.currentZIndex = zIndex;\n
\t}\n
\n
\tvar FloatPanel = Panel.extend({\n
\t\tMixins: [Movable, Resizable],\n
\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Boolean} autohide Automatically hide the panel.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tself._eventsRoot = self;\n
\n
\t\t\tself.classes.add(\'floatpanel\');\n
\n
\t\t\t// Hide floatpanes on click out side the root button\n
\t\t\tif (settings.autohide) {\n
\t\t\t\tbindDocumentClickHandler();\n
\t\t\t\tbindWindowResizeHandler();\n
\t\t\t\tvisiblePanels.push(self);\n
\t\t\t}\n
\n
\t\t\tif (settings.autofix) {\n
\t\t\t\tbindDocumentScrollHandler();\n
\n
\t\t\t\tself.on(\'move\', function() {\n
\t\t\t\t\trepositionPanel(this);\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.on(\'postrender show\', function(e) {\n
\t\t\t\tif (e.control == self) {\n
\t\t\t\t\tvar $modalBlockEl, prefix = self.classPrefix;\n
\n
\t\t\t\t\tif (self.modal && !hasModal) {\n
\t\t\t\t\t\t$modalBlockEl = $(\'#\' + prefix + \'modal-block\');\n
\t\t\t\t\t\tif (!$modalBlockEl[0]) {\n
\t\t\t\t\t\t\t$modalBlockEl = $(\n
\t\t\t\t\t\t\t\t\'<div id="\' + prefix + \'modal-block" class="\' + prefix + \'reset \' + prefix + \'fade"></div>\'\n
\t\t\t\t\t\t\t).appendTo(self.getContainerElm());\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\t\t\t$modalBlockEl.addClass(prefix + \'in\');\n
\t\t\t\t\t\t\t$(self.getEl()).addClass(prefix + \'in\');\n
\t\t\t\t\t\t}, 0);\n
\n
\t\t\t\t\t\thasModal = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\taddRemove(true, self);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'show\', function() {\n
\t\t\t\tself.parents().each(function(ctrl) {\n
\t\t\t\t\tif (ctrl.state.get(\'fixed\')) {\n
\t\t\t\t\t\tself.fixed(true);\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t});\n
\n
\t\t\tif (settings.popover) {\n
\t\t\t\tself._preBodyHtml = \'<div class="\' + self.classPrefix + \'arrow"></div>\';\n
\t\t\t\tself.classes.add(\'popover\').add(\'bottom\').add(self.isRtl() ? \'end\' : \'start\');\n
\t\t\t}\n
\t\t},\n
\n
\t\tfixed: function(state) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.state.get(\'fixed\') != state) {\n
\t\t\t\tif (self.state.get(\'rendered\')) {\n
\t\t\t\t\tvar viewport = DomUtils.getViewPort();\n
\n
\t\t\t\t\tif (state) {\n
\t\t\t\t\t\tself.layoutRect().y -= viewport.y;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself.layoutRect().y += viewport.y;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tself.classes.toggle(\'fixed\', state);\n
\t\t\t\tself.state.set(\'fixed\', state);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the current float panel.\n
\t\t *\n
\t\t * @method show\n
\t\t * @return {tinymce.ui.FloatPanel} Current floatpanel instance.\n
\t\t */\n
\t\tshow: function() {\n
\t\t\tvar self = this, i, state = self._super();\n
\n
\t\t\ti = visiblePanels.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tif (visiblePanels[i] === self) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (i === -1) {\n
\t\t\t\tvisiblePanels.push(self);\n
\t\t\t}\n
\n
\t\t\treturn state;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the current float panel.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @return {tinymce.ui.FloatPanel} Current floatpanel instance.\n
\t\t */\n
\t\thide: function() {\n
\t\t\tremoveVisiblePanel(this);\n
\t\t\taddRemove(false, this);\n
\n
\t\t\treturn this._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hide all visible float panels with he autohide setting enabled. This is for\n
\t\t * manually hiding floating menus or panels.\n
\t\t *\n
\t\t * @method hideAll\n
\t\t */\n
\t\thideAll: function() {\n
\t\t\tFloatPanel.hideAll();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Closes the float panel. This will remove the float panel from page and fire the close event.\n
\t\t *\n
\t\t * @method close\n
\t\t */\n
\t\tclose: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.fire(\'close\').isDefaultPrevented()) {\n
\t\t\t\tself.remove();\n
\t\t\t\taddRemove(false, self);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the float panel from page.\n
\t\t *\n
\t\t * @method remove\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tremoveVisiblePanel(this);\n
\t\t\tthis._super();\n
\t\t},\n
\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.settings.bodyRole) {\n
\t\t\t\tthis.getEl(\'body\').setAttribute(\'role\', self.settings.bodyRole);\n
\t\t\t}\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
\n
\t/**\n
\t * Hide all visible float panels with he autohide setting enabled. This is for\n
\t * manually hiding floating menus or panels.\n
\t *\n
\t * @static\n
\t * @method hideAll\n
\t */\n
\tFloatPanel.hideAll = function() {\n
\t\tvar i = visiblePanels.length;\n
\n
\t\twhile (i--) {\n
\t\t\tvar panel = visiblePanels[i];\n
\n
\t\t\tif (panel && panel.settings.autohide) {\n
\t\t\t\tpanel.hide();\n
\t\t\t\tvisiblePanels.splice(i, 1);\n
\t\t\t}\n
\t\t}\n
\t};\n
\n
\tfunction removeVisiblePanel(panel) {\n
\t\tvar i;\n
\n
\t\ti = visiblePanels.length;\n
\t\twhile (i--) {\n
\t\t\tif (visiblePanels[i] === panel) {\n
\t\t\t\tvisiblePanels.splice(i, 1);\n
\t\t\t}\n
\t\t}\n
\n
\t\ti = zOrder.length;\n
\t\twhile (i--) {\n
\t\t\tif (zOrder[i] === panel) {\n
\t\t\t\tzOrder.splice(i, 1);\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\treturn FloatPanel;\n
});\n
\n
// Included from: js/tinymce/classes/ui/Window.js\n
\n
/**\n
 * Window.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new window.\n
 *\n
 * @-x-less Window.less\n
 * @class tinymce.ui.Window\n
 * @extends tinymce.ui.FloatPanel\n
 */\n
define("tinymce/ui/Window", [\n
\t"tinymce/ui/FloatPanel",\n
\t"tinymce/ui/Panel",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/DragHelper",\n
\t"tinymce/ui/BoxUtils",\n
\t"tinymce/Env"\n
], function(FloatPanel, Panel, DomUtils, $, DragHelper, BoxUtils, Env) {\n
\t"use strict";\n
\n
\tvar windows = [], oldMetaValue = \'\';\n
\n
\tfunction toggleFullScreenState(state) {\n
\t\tvar noScaleMetaValue = \'width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0\',\n
\t\t\tviewport = $("meta[name=viewport]")[0],\n
\t\t\tcontentValue;\n
\n
\t\tif (Env.overrideViewPort === false) {\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tif (!viewport) {\n
\t\t\tviewport = document.createElement(\'meta\');\n
\t\t\tviewport.setAttribute(\'name\', \'viewport\');\n
\t\t\tdocument.getElementsByTagName(\'head\')[0].appendChild(viewport);\n
\t\t}\n
\n
\t\tcontentValue = viewport.getAttribute(\'content\');\n
\t\tif (contentValue && typeof oldMetaValue != \'undefined\') {\n
\t\t\toldMetaValue = contentValue;\n
\t\t}\n
\n
\t\tviewport.setAttribute(\'content\', state ? noScaleMetaValue : oldMetaValue);\n
\t}\n
\n
\tfunction toggleBodyFullScreenClasses(classPrefix) {\n
\t\tfor (var i = 0; i < windows.length; i++) {\n
\t\t\tif (windows[i]._fullscreen) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t}\n
\n
\t\t$([document.documentElement, document.body]).removeClass(classPrefix + \'fullscreen\');\n
\t}\n
\n
\tfunction handleWindowResize() {\n
\t\tvar lastSize = {\n
\t\t\tw: window.innerWidth,\n
\t\t\th: window.innerHeight\n
\t\t};\n
\n
\t\twindow.setInterval(function() {\n
\t\t\tvar w = window.innerWidth,\n
\t\t\t\th = window.innerHeight;\n
\n
\t\t\tif (lastSize.w != w || lastSize.h != h) {\n
\t\t\t\tlastSize = {\n
\t\t\t\t\tw: w,\n
\t\t\t\t\th: h\n
\t\t\t\t};\n
\n
\t\t\t\t$(window).trigger(\'resize\');\n
\t\t\t}\n
\t\t}, 0);\n
\n
\t\tfunction reposition() {\n
\t\t\tvar i, rect = DomUtils.getWindowSize(), layoutRect;\n
\n
\t\t\tfor (i = 0; i < windows.length; i++) {\n
\t\t\t\tlayoutRect = windows[i].layoutRect();\n
\n
\t\t\t\twindows[i].moveTo(\n
\t\t\t\t\twindows[i].settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2),\n
\t\t\t\t\twindows[i].settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2)\n
\t\t\t\t);\n
\t\t\t}\n
\t\t}\n
\n
\t\t$(window).on(\'resize\', reposition);\n
\t}\n
\n
\tvar Window = FloatPanel.extend({\n
\t\tmodal: true,\n
\n
\t\tDefaults: {\n
\t\t\tborder: 1,\n
\t\t\tlayout: \'flex\',\n
\t\t\tcontainerCls: \'panel\',\n
\t\t\trole: \'dialog\',\n
\t\t\tcallbacks: {\n
\t\t\t\tsubmit: function() {\n
\t\t\t\t\tthis.fire(\'submit\', {data: this.toJSON()});\n
\t\t\t\t},\n
\n
\t\t\t\tclose: function() {\n
\t\t\t\t\tthis.close();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\n
\t\t\tif (self.isRtl()) {\n
\t\t\t\tself.classes.add(\'rtl\');\n
\t\t\t}\n
\n
\t\t\tself.classes.add(\'window\');\n
\t\t\tself.bodyClasses.add(\'window-body\');\n
\t\t\tself.state.set(\'fixed\', true);\n
\n
\t\t\t// Create statusbar\n
\t\t\tif (settings.buttons) {\n
\t\t\t\tself.statusbar = new Panel({\n
\t\t\t\t\tlayout: \'flex\',\n
\t\t\t\t\tborder: \'1 0 0 0\',\n
\t\t\t\t\tspacing: 3,\n
\t\t\t\t\tpadding: 10,\n
\t\t\t\t\talign: \'center\',\n
\t\t\t\t\tpack: self.isRtl() ? \'start\' : \'end\',\n
\t\t\t\t\tdefaults: {\n
\t\t\t\t\t\ttype: \'button\'\n
\t\t\t\t\t},\n
\t\t\t\t\titems: settings.buttons\n
\t\t\t\t});\n
\n
\t\t\t\tself.statusbar.classes.add(\'foot\');\n
\t\t\t\tself.statusbar.parent(self);\n
\t\t\t}\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tif (e.target.className.indexOf(self.classPrefix + \'close\') != -1) {\n
\t\t\t\t\tself.close();\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'cancel\', function() {\n
\t\t\t\tself.close();\n
\t\t\t});\n
\n
\t\t\tself.aria(\'describedby\', self.describedBy || self._id + \'-none\');\n
\t\t\tself.aria(\'label\', settings.title);\n
\t\t\tself._fullscreen = false;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the current container.\n
\t\t * This is invoked by the reflow method and shouldn\'t be called directly.\n
\t\t *\n
\t\t * @method recalc\n
\t\t */\n
\t\trecalc: function() {\n
\t\t\tvar self = this, statusbar = self.statusbar, layoutRect, width, x, needsRecalc;\n
\n
\t\t\tif (self._fullscreen) {\n
\t\t\t\tself.layoutRect(DomUtils.getWindowSize());\n
\t\t\t\tself.layoutRect().contentH = self.layoutRect().innerH;\n
\t\t\t}\n
\n
\t\t\tself._super();\n
\n
\t\t\tlayoutRect = self.layoutRect();\n
\n
\t\t\t// Resize window based on title width\n
\t\t\tif (self.settings.title && !self._fullscreen) {\n
\t\t\t\twidth = layoutRect.headerW;\n
\t\t\t\tif (width > layoutRect.w) {\n
\t\t\t\t\tx = layoutRect.x - Math.max(0, width / 2);\n
\t\t\t\t\tself.layoutRect({w: width, x: x});\n
\t\t\t\t\tneedsRecalc = true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Resize window based on statusbar width\n
\t\t\tif (statusbar) {\n
\t\t\t\tstatusbar.layoutRect({w: self.layoutRect().innerW}).recalc();\n
\n
\t\t\t\twidth = statusbar.layoutRect().minW + layoutRect.deltaW;\n
\t\t\t\tif (width > layoutRect.w) {\n
\t\t\t\t\tx = layoutRect.x - Math.max(0, width - layoutRect.w);\n
\t\t\t\t\tself.layoutRect({w: width, x: x});\n
\t\t\t\t\tneedsRecalc = true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Recalc body and disable auto resize\n
\t\t\tif (needsRecalc) {\n
\t\t\t\tself.recalc();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the current controls layout rect.\n
\t\t * This will be executed by the layout managers to determine the\n
\t\t * default minWidth/minHeight etc.\n
\t\t *\n
\t\t * @method initLayoutRect\n
\t\t * @return {Object} Layout rect instance.\n
\t\t */\n
\t\tinitLayoutRect: function() {\n
\t\t\tvar self = this, layoutRect = self._super(), deltaH = 0, headEl;\n
\n
\t\t\t// Reserve vertical space for title\n
\t\t\tif (self.settings.title && !self._fullscreen) {\n
\t\t\t\theadEl = self.getEl(\'head\');\n
\n
\t\t\t\tvar size = DomUtils.getSize(headEl);\n
\n
\t\t\t\tlayoutRect.headerW = size.width;\n
\t\t\t\tlayoutRect.headerH = size.height;\n
\n
\t\t\t\tdeltaH += layoutRect.headerH;\n
\t\t\t}\n
\n
\t\t\t// Reserve vertical space for statusbar\n
\t\t\tif (self.statusbar) {\n
\t\t\t\tdeltaH += self.statusbar.layoutRect().h;\n
\t\t\t}\n
\n
\t\t\tlayoutRect.deltaH += deltaH;\n
\t\t\tlayoutRect.minH += deltaH;\n
\t\t\t//layoutRect.innerH -= deltaH;\n
\t\t\tlayoutRect.h += deltaH;\n
\n
\t\t\tvar rect = DomUtils.getWindowSize();\n
\n
\t\t\tlayoutRect.x = self.settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2);\n
\t\t\tlayoutRect.y = self.settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2);\n
\n
\t\t\treturn layoutRect;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, id = self._id, prefix = self.classPrefix;\n
\t\t\tvar settings = self.settings, headerHtml = \'\', footerHtml = \'\', html = settings.html;\n
\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\tif (settings.title) {\n
\t\t\t\theaderHtml = (\n
\t\t\t\t\t\'<div id="\' + id + \'-head" class="\' + prefix + \'window-head">\' +\n
\t\t\t\t\t\t\'<div id="\' + id + \'-title" class="\' + prefix + \'title">\' + self.encode(settings.title) + \'</div>\' +\n
\t\t\t\t\t\t\'<button type="button" class="\' + prefix + \'close" aria-hidden="true">\\u00d7</button>\' +\n
\t\t\t\t\t\t\'<div id="\' + id + \'-dragh" class="\' + prefix + \'dragh"></div>\' +\n
\t\t\t\t\t\'</div>\'\n
\t\t\t\t);\n
\t\t\t}\n
\n
\t\t\tif (settings.url) {\n
\t\t\t\thtml = \'<iframe src="\' + settings.url + \'" tabindex="-1"></iframe>\';\n
\t\t\t}\n
\n
\t\t\tif (typeof html == "undefined") {\n
\t\t\t\thtml = layout.renderHtml(self);\n
\t\t\t}\n
\n
\t\t\tif (self.statusbar) {\n
\t\t\t\tfooterHtml = self.statusbar.renderHtml();\n
\t\t\t}\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" hidefocus="1">\' +\n
\t\t\t\t\t\'<div class="\' + self.classPrefix + \'reset" role="application">\' +\n
\t\t\t\t\t\theaderHtml +\n
\t\t\t\t\t\t\'<div id="\' + id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\t\thtml +\n
\t\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\t\tfooterHtml +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Switches the window fullscreen mode.\n
\t\t *\n
\t\t * @method fullscreen\n
\t\t * @param {Boolean} state True/false state.\n
\t\t * @return {tinymce.ui.Window} Current window instance.\n
\t\t */\n
\t\tfullscreen: function(state) {\n
\t\t\tvar self = this, documentElement = document.documentElement, slowRendering, prefix = self.classPrefix, layoutRect;\n
\n
\t\t\tif (state != self._fullscreen) {\n
\t\t\t\t$(window).on(\'resize\', function() {\n
\t\t\t\t\tvar time;\n
\n
\t\t\t\t\tif (self._fullscreen) {\n
\t\t\t\t\t\t// Time the layout time if it\'s to slow use a timeout to not hog the CPU\n
\t\t\t\t\t\tif (!slowRendering) {\n
\t\t\t\t\t\t\ttime = new Date().getTime();\n
\n
\t\t\t\t\t\t\tvar rect = DomUtils.getWindowSize();\n
\t\t\t\t\t\t\tself.moveTo(0, 0).resizeTo(rect.w, rect.h);\n
\n
\t\t\t\t\t\t\tif ((new Date().getTime()) - time > 50) {\n
\t\t\t\t\t\t\t\tslowRendering = true;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tif (!self._timer) {\n
\t\t\t\t\t\t\t\tself._timer = setTimeout(function() {\n
\t\t\t\t\t\t\t\t\tvar rect = DomUtils.getWindowSize();\n
\t\t\t\t\t\t\t\t\tself.moveTo(0, 0).resizeTo(rect.w, rect.h);\n
\n
\t\t\t\t\t\t\t\t\tself._timer = 0;\n
\t\t\t\t\t\t\t\t}, 50);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tlayoutRect = self.layoutRect();\n
\t\t\t\tself._fullscreen = state;\n
\n
\t\t\t\tif (!state) {\n
\t\t\t\t\tself.borderBox = BoxUtils.parseBox(self.settings.border);\n
\t\t\t\t\tself.getEl(\'head\').style.display = \'\';\n
\t\t\t\t\tlayoutRect.deltaH += layoutRect.headerH;\n
\t\t\t\t\t$([documentElement, document.body]).removeClass(prefix + \'fullscreen\');\n
\t\t\t\t\tself.classes.remove(\'fullscreen\');\n
\t\t\t\t\tself.moveTo(self._initial.x, self._initial.y).resizeTo(self._initial.w, self._initial.h);\n
\t\t\t\t} else {\n
\t\t\t\t\tself._initial = {x: layoutRect.x, y: layoutRect.y, w: layoutRect.w, h: layoutRect.h};\n
\n
\t\t\t\t\tself.borderBox = BoxUtils.parseBox(\'0\');\n
\t\t\t\t\tself.getEl(\'head\').style.display = \'none\';\n
\t\t\t\t\tlayoutRect.deltaH -= layoutRect.headerH + 2;\n
\t\t\t\t\t$([documentElement, document.body]).addClass(prefix + \'fullscreen\');\n
\t\t\t\t\tself.classes.add(\'fullscreen\');\n
\n
\t\t\t\t\tvar rect = DomUtils.getWindowSize();\n
\t\t\t\t\tself.moveTo(0, 0).resizeTo(rect.w, rect.h);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self.reflow();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, startPos;\n
\n
\t\t\tsetTimeout(function() {\n
\t\t\t\tself.classes.add(\'in\');\n
\t\t\t}, 0);\n
\n
\t\t\tself._super();\n
\n
\t\t\tif (self.statusbar) {\n
\t\t\t\tself.statusbar.postRender();\n
\t\t\t}\n
\n
\t\t\tself.focus();\n
\n
\t\t\tthis.dragHelper = new DragHelper(self._id + \'-dragh\', {\n
\t\t\t\tstart: function() {\n
\t\t\t\t\tstartPos = {\n
\t\t\t\t\t\tx: self.layoutRect().x,\n
\t\t\t\t\t\ty: self.layoutRect().y\n
\t\t\t\t\t};\n
\t\t\t\t},\n
\n
\t\t\t\tdrag: function(e) {\n
\t\t\t\t\tself.moveTo(startPos.x + e.deltaX, startPos.y + e.deltaY);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'submit\', function(e) {\n
\t\t\t\tif (!e.isDefaultPrevented()) {\n
\t\t\t\t\tself.close();\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\twindows.push(self);\n
\t\t\ttoggleFullScreenState(true);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Fires a submit event with the serialized form.\n
\t\t *\n
\t\t * @method submit\n
\t\t * @return {Object} Event arguments object.\n
\t\t */\n
\t\tsubmit: function() {\n
\t\t\treturn this.fire(\'submit\', {data: this.toJSON()});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the current control from DOM and from UI collections.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this, i;\n
\n
\t\t\tself.dragHelper.destroy();\n
\t\t\tself._super();\n
\n
\t\t\tif (self.statusbar) {\n
\t\t\t\tthis.statusbar.remove();\n
\t\t\t}\n
\n
\t\t\ti = windows.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tif (windows[i] === self) {\n
\t\t\t\t\twindows.splice(i, 1);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\ttoggleFullScreenState(windows.length > 0);\n
\t\t\ttoggleBodyFullScreenClasses(self.classPrefix);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the contentWindow object of the iframe if it exists.\n
\t\t *\n
\t\t * @method getContentWindow\n
\t\t * @return {Window} window object or null.\n
\t\t */\n
\t\tgetContentWindow: function() {\n
\t\t\tvar ifr = this.getEl().getElementsByTagName(\'iframe\')[0];\n
\t\t\treturn ifr ? ifr.contentWindow : null;\n
\t\t}\n
\t});\n
\n
\tif (!Env.desktop) {\n
\t\thandleWindowResize();\n
\t}\n
\n
\treturn Window;\n
});\n
\n
// Included from: js/tinymce/classes/ui/MessageBox.js\n
\n
/**\n
 * MessageBox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to create MessageBoxes like alerts/confirms etc.\n
 *\n
 * @class tinymce.ui.MessageBox\n
 * @extends tinymce.ui.FloatPanel\n
 */\n
define("tinymce/ui/MessageBox", [\n
\t"tinymce/ui/Window"\n
], function(Window) {\n
\t"use strict";\n
\n
\tvar MessageBox = Window.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tsettings = {\n
\t\t\t\tborder: 1,\n
\t\t\t\tpadding: 20,\n
\t\t\t\tlayout: \'flex\',\n
\t\t\t\tpack: "center",\n
\t\t\t\talign: "center",\n
\t\t\t\tcontainerCls: \'panel\',\n
\t\t\t\tautoScroll: true,\n
\t\t\t\tbuttons: {type: "button", text: "Ok", action: "ok"},\n
\t\t\t\titems: {\n
\t\t\t\t\ttype: "label",\n
\t\t\t\t\tmultiline: true,\n
\t\t\t\t\tmaxWidth: 500,\n
\t\t\t\t\tmaxHeight: 200\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\tthis._super(settings);\n
\t\t},\n
\n
\t\tStatics: {\n
\t\t\t/**\n
\t\t\t * Ok buttons constant.\n
\t\t\t *\n
\t\t\t * @static\n
\t\t\t * @final\n
\t\t\t * @field {Number} OK\n
\t\t\t */\n
\t\t\tOK: 1,\n
\n
\t\t\t/**\n
\t\t\t * Ok/cancel buttons constant.\n
\t\t\t *\n
\t\t\t * @static\n
\t\t\t * @final\n
\t\t\t * @field {Number} OK_CANCEL\n
\t\t\t */\n
\t\t\tOK_CANCEL: 2,\n
\n
\t\t\t/**\n
\t\t\t * yes/no buttons constant.\n
\t\t\t *\n
\t\t\t * @static\n
\t\t\t * @final\n
\t\t\t * @field {Number} YES_NO\n
\t\t\t */\n
\t\t\tYES_NO: 3,\n
\n
\t\t\t/**\n
\t\t\t * yes/no/cancel buttons constant.\n
\t\t\t *\n
\t\t\t * @static\n
\t\t\t * @final\n
\t\t\t * @field {Number} YES_NO_CANCEL\n
\t\t\t */\n
\t\t\tYES_NO_CANCEL: 4,\n
\n
\t\t\t/**\n
\t\t\t * Constructs a new message box and renders it to the body element.\n
\t\t\t *\n
\t\t\t * @static\n
\t\t\t * @method msgBox\n
\t\t\t * @param {Object} settings Name/value object with settings.\n
\t\t\t */\n
\t\t\tmsgBox: function(settings) {\n
\t\t\t\tvar buttons, callback = settings.callback || function() {};\n
\n
\t\t\t\tfunction createButton(text, status, primary) {\n
\t\t\t\t\treturn {\n
\t\t\t\t\t\ttype: "button",\n
\t\t\t\t\t\ttext: text,\n
\t\t\t\t\t\tsubtype: primary ? \'primary\' : \'\',\n
\t\t\t\t\t\tonClick: function(e) {\n
\t\t\t\t\t\t\te.control.parents()[1].close();\n
\t\t\t\t\t\t\tcallback(status);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\tswitch (settings.buttons) {\n
\t\t\t\t\tcase MessageBox.OK_CANCEL:\n
\t\t\t\t\t\tbuttons = [\n
\t\t\t\t\t\t\tcreateButton(\'Ok\', true, true),\n
\t\t\t\t\t\t\tcreateButton(\'Cancel\', false)\n
\t\t\t\t\t\t];\n
\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\tcase MessageBox.YES_NO:\n
\t\t\t\t\tcase MessageBox.YES_NO_CANCEL:\n
\t\t\t\t\t\tbuttons = [\n
\t\t\t\t\t\t\tcreateButton(\'Yes\', 1, true),\n
\t\t\t\t\t\t\tcreateButton(\'No\', 0)\n
\t\t\t\t\t\t];\n
\n
\t\t\t\t\t\tif (settings.buttons == MessageBox.YES_NO_CANCEL) {\n
\t\t\t\t\t\t\tbuttons.push(createButton(\'Cancel\', -1));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\tdefault:\n
\t\t\t\t\t\tbuttons = [\n
\t\t\t\t\t\t\tcreateButton(\'Ok\', true, true)\n
\t\t\t\t\t\t];\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\treturn new Window({\n
\t\t\t\t\tpadding: 20,\n
\t\t\t\t\tx: settings.x,\n
\t\t\t\t\ty: settings.y,\n
\t\t\t\t\tminWidth: 300,\n
\t\t\t\t\tminHeight: 100,\n
\t\t\t\t\tlayout: "flex",\n
\t\t\t\t\tpack: "center",\n
\t\t\t\t\talign: "center",\n
\t\t\t\t\tbuttons: buttons,\n
\t\t\t\t\ttitle: settings.title,\n
\t\t\t\t\trole: \'alertdialog\',\n
\t\t\t\t\titems: {\n
\t\t\t\t\t\ttype: "label",\n
\t\t\t\t\t\tmultiline: true,\n
\t\t\t\t\t\tmaxWidth: 500,\n
\t\t\t\t\t\tmaxHeight: 200,\n
\t\t\t\t\t\ttext: settings.text\n
\t\t\t\t\t},\n
\t\t\t\t\tonPostRender: function() {\n
\t\t\t\t\t\tthis.aria(\'describedby\', this.items()[0]._id);\n
\t\t\t\t\t},\n
\t\t\t\t\tonClose: settings.onClose,\n
\t\t\t\t\tonCancel: function() {\n
\t\t\t\t\t\tcallback(false);\n
\t\t\t\t\t}\n
\t\t\t\t}).renderTo(document.body).reflow();\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Creates a new alert dialog.\n
\t\t\t *\n
\t\t\t * @method alert\n
\t\t\t * @param {Object} settings Settings for the alert dialog.\n
\t\t\t * @param {function} [callback] Callback to execute when the user makes a choice.\n
\t\t\t */\n
\t\t\talert: function(settings, callback) {\n
\t\t\t\tif (typeof settings == "string") {\n
\t\t\t\t\tsettings = {text: settings};\n
\t\t\t\t}\n
\n
\t\t\t\tsettings.callback = callback;\n
\t\t\t\treturn MessageBox.msgBox(settings);\n
\t\t\t},\n
\n
\t\t\t/**\n
\t\t\t * Creates a new confirm dialog.\n
\t\t\t *\n
\t\t\t * @method confirm\n
\t\t\t * @param {Object} settings Settings for the confirm dialog.\n
\t\t\t * @param {function} [callback] Callback to execute when the user makes a choice.\n
\t\t\t */\n
\t\t\tconfirm: function(settings, callback) {\n
\t\t\t\tif (typeof settings == "string") {\n
\t\t\t\t\tsettings = {text: settings};\n
\t\t\t\t}\n
\n
\t\t\t\tsettings.callback = callback;\n
\t\t\t\tsettings.buttons = MessageBox.OK_CANCEL;\n
\n
\t\t\t\treturn MessageBox.msgBox(settings);\n
\t\t\t}\n
\t\t}\n
\t});\n
\n
\treturn MessageBox;\n
});\n
\n
// Included from: js/tinymce/classes/WindowManager.js\n
\n
/**\n
 * WindowManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.\n
 *\n
 * @class tinymce.WindowManager\n
 * @example\n
 * // Opens a new dialog with the file.htm file and the size 320x240\n
 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.\n
 * tinymce.activeEditor.windowManager.open({\n
 *    url: \'file.htm\',\n
 *    width: 320,\n
 *    height: 240\n
 * }, {\n
 *    custom_param: 1\n
 * });\n
 *\n
 * // Displays an alert box using the active editors window manager instance\n
 * tinymce.activeEditor.windowManager.alert(\'Hello world!\');\n
 *\n
 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm\n
 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {\n
 *    if (s)\n
 *       tinymce.activeEditor.windowManager.alert("Ok");\n
 *    else\n
 *       tinymce.activeEditor.windowManager.alert("Cancel");\n
 * });\n
 */\n
define("tinymce/WindowManager", [\n
\t"tinymce/ui/Window",\n
\t"tinymce/ui/MessageBox"\n
], function(Window, MessageBox) {\n
\treturn function(editor) {\n
\t\tvar self = this, windows = [];\n
\n
\t\tfunction getTopMostWindow() {\n
\t\t\tif (windows.length) {\n
\t\t\t\treturn windows[windows.length - 1];\n
\t\t\t}\n
\t\t}\n
\n
\t\tself.windows = windows;\n
\n
\t\teditor.on(\'remove\', function() {\n
\t\t\tvar i = windows.length;\n
\n
\t\t\twhile (i--) {\n
\t\t\t\twindows[i].close();\n
\t\t\t}\n
\t\t});\n
\n
\t\t/**\n
\t\t * Opens a new window.\n
\t\t *\n
\t\t * @method open\n
\t\t * @param {Object} args Optional name/value settings collection contains things like width/height/url etc.\n
\t\t * @option {String} title Window title.\n
\t\t * @option {String} file URL of the file to open in the window.\n
\t\t * @option {Number} width Width in pixels.\n
\t\t * @option {Number} height Height in pixels.\n
\t\t * @option {Boolean} autoScroll Specifies whether the popup window can have scrollbars if required (i.e. content\n
\t\t * larger than the popup size specified).\n
\t\t */\n
\t\tself.open = function(args, params) {\n
\t\t\tvar win;\n
\n
\t\t\teditor.editorManager.setActive(editor);\n
\n
\t\t\targs.title = args.title || \' \';\n
\n
\t\t\t// Handle URL\n
\t\t\targs.url = args.url || args.file; // Legacy\n
\t\t\tif (args.url) {\n
\t\t\t\targs.width = parseInt(args.width || 320, 10);\n
\t\t\t\targs.height = parseInt(args.height || 240, 10);\n
\t\t\t}\n
\n
\t\t\t// Handle body\n
\t\t\tif (args.body) {\n
\t\t\t\targs.items = {\n
\t\t\t\t\tdefaults: args.defaults,\n
\t\t\t\t\ttype: args.bodyType || \'form\',\n
\t\t\t\t\titems: args.body\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tif (!args.url && !args.buttons) {\n
\t\t\t\targs.buttons = [\n
\t\t\t\t\t{text: \'Ok\', subtype: \'primary\', onclick: function() {\n
\t\t\t\t\t\twin.find(\'form\')[0].submit();\n
\t\t\t\t\t}},\n
\n
\t\t\t\t\t{text: \'Cancel\', onclick: function() {\n
\t\t\t\t\t\twin.close();\n
\t\t\t\t\t}}\n
\t\t\t\t];\n
\t\t\t}\n
\n
\t\t\twin = new Window(args);\n
\t\t\twindows.push(win);\n
\n
\t\t\twin.on(\'close\', function() {\n
\t\t\t\tvar i = windows.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tif (windows[i] === win) {\n
\t\t\t\t\t\twindows.splice(i, 1);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (!windows.length) {\n
\t\t\t\t\teditor.focus();\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Handle data\n
\t\t\tif (args.data) {\n
\t\t\t\twin.on(\'postRender\', function() {\n
\t\t\t\t\tthis.find(\'*\').each(function(ctrl) {\n
\t\t\t\t\t\tvar name = ctrl.name();\n
\n
\t\t\t\t\t\tif (name in args.data) {\n
\t\t\t\t\t\t\tctrl.value(args.data[name]);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// store args and parameters\n
\t\t\twin.features = args || {};\n
\t\t\twin.params = params || {};\n
\n
\t\t\t// Takes a snapshot in the FocusManager of the selection before focus is lost to dialog\n
\t\t\tif (windows.length === 1) {\n
\t\t\t\teditor.nodeChanged();\n
\t\t\t}\n
\n
\t\t\treturn win.renderTo().reflow();\n
\t\t};\n
\n
\t\t/**\n
\t\t * Creates a alert dialog. Please don\'t use the blo

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAw=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="12" aka="AAAAAAAAAAw=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

cking behavior of this\n
\t\t * native version use the callback method instead then it can be extended.\n
\t\t *\n
\t\t * @method alert\n
\t\t * @param {String} message Text to display in the new alert dialog.\n
\t\t * @param {function} callback Callback function to be executed after the user has selected ok.\n
\t\t * @param {Object} scope Optional scope to execute the callback in.\n
\t\t * @example\n
\t\t * // Displays an alert box using the active editors window manager instance\n
\t\t * tinymce.activeEditor.windowManager.alert(\'Hello world!\');\n
\t\t */\n
\t\tself.alert = function(message, callback, scope) {\n
\t\t\tMessageBox.alert(message, function() {\n
\t\t\t\tif (callback) {\n
\t\t\t\t\tcallback.call(scope || this);\n
\t\t\t\t} else {\n
\t\t\t\t\teditor.focus();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t};\n
\n
\t\t/**\n
\t\t * Creates a confirm dialog. Please don\'t use the blocking behavior of this\n
\t\t * native version use the callback method instead then it can be extended.\n
\t\t *\n
\t\t * @method confirm\n
\t\t * @param {String} messageText to display in the new confirm dialog.\n
\t\t * @param {function} callback Callback function to be executed after the user has selected ok or cancel.\n
\t\t * @param {Object} scope Optional scope to execute the callback in.\n
\t\t * @example\n
\t\t * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm\n
\t\t * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {\n
\t\t *    if (s)\n
\t\t *       tinymce.activeEditor.windowManager.alert("Ok");\n
\t\t *    else\n
\t\t *       tinymce.activeEditor.windowManager.alert("Cancel");\n
\t\t * });\n
\t\t */\n
\t\tself.confirm = function(message, callback, scope) {\n
\t\t\tMessageBox.confirm(message, function(state) {\n
\t\t\t\tcallback.call(scope || this, state);\n
\t\t\t});\n
\t\t};\n
\n
\t\t/**\n
\t\t * Closes the top most window.\n
\t\t *\n
\t\t * @method close\n
\t\t */\n
\t\tself.close = function() {\n
\t\t\tif (getTopMostWindow()) {\n
\t\t\t\tgetTopMostWindow().close();\n
\t\t\t}\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns the params of the last window open call. This can be used in iframe based\n
\t\t * dialog to get params passed from the tinymce plugin.\n
\t\t *\n
\t\t * @example\n
\t\t * var dialogArguments = top.tinymce.activeEditor.windowManager.getParams();\n
\t\t *\n
\t\t * @method getParams\n
\t\t * @return {Object} Name/value object with parameters passed from windowManager.open call.\n
\t\t */\n
\t\tself.getParams = function() {\n
\t\t\treturn getTopMostWindow() ? getTopMostWindow().params : null;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Sets the params of the last opened window.\n
\t\t *\n
\t\t * @method setParams\n
\t\t * @param {Object} params Params object to set for the last opened window.\n
\t\t */\n
\t\tself.setParams = function(params) {\n
\t\t\tif (getTopMostWindow()) {\n
\t\t\t\tgetTopMostWindow().params = params;\n
\t\t\t}\n
\t\t};\n
\n
\t\t/**\n
\t\t * Returns the currently opened window objects.\n
\t\t *\n
\t\t * @method getWindows\n
\t\t * @return {Array} Array of the currently opened windows.\n
\t\t */\n
\t\tself.getWindows = function() {\n
\t\t\treturn windows;\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/Quirks.js\n
\n
/**\n
 * Quirks.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 *\n
 * @ignore-file\n
 */\n
\n
/**\n
 * This file includes fixes for various browser quirks it\'s made to make it easy to add/remove browser specific fixes.\n
 *\n
 * @class tinymce.util.Quirks\n
 */\n
define("tinymce/util/Quirks", [\n
\t"tinymce/util/VK",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/dom/TreeWalker",\n
\t"tinymce/html/Node",\n
\t"tinymce/html/Entities",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools"\n
], function(VK, RangeUtils, TreeWalker, Node, Entities, Env, Tools) {\n
\treturn function(editor) {\n
\t\tvar each = Tools.each, $ = editor.$;\n
\t\tvar BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection,\n
\t\t\tsettings = editor.settings, parser = editor.parser, serializer = editor.serializer;\n
\t\tvar isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;\n
\t\tvar mceInternalUrlPrefix = \'data:text/mce-internal,\';\n
\t\tvar mceInternalDataType = isIE ? \'Text\' : \'URL\';\n
\n
\t\t/**\n
\t\t * Executes a command with a specific state this can be to enable/disable browser editing features.\n
\t\t */\n
\t\tfunction setEditorCommandState(cmd, state) {\n
\t\t\ttry {\n
\t\t\t\teditor.getDoc().execCommand(cmd, false, state);\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns current IE document mode.\n
\t\t */\n
\t\tfunction getDocumentMode() {\n
\t\t\tvar documentMode = editor.getDoc().documentMode;\n
\n
\t\t\treturn documentMode ? documentMode : 6;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns true/false if the event is prevented or not.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {Event} e Event object.\n
\t\t * @return {Boolean} true/false if the event is prevented or not.\n
\t\t */\n
\t\tfunction isDefaultPrevented(e) {\n
\t\t\treturn e.isDefaultPrevented();\n
\t\t}\n
\n
\t\t/**\n
\t\t * Sets Text/URL data on the event\'s dataTransfer object to a special data:text/mce-internal url.\n
\t\t * This is to workaround the inability to set custom contentType on IE and Safari.\n
\t\t * The editor\'s selected content is encoded into this url so drag and drop between editors will work.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {DragEvent} e Event object\n
\t\t */\n
\t\tfunction setMceInteralContent(e) {\n
\t\t\tvar selectionHtml, internalContent;\n
\n
\t\t\tif (e.dataTransfer) {\n
\t\t\t\tif (editor.selection.isCollapsed() && e.target.tagName == \'IMG\') {\n
\t\t\t\t\tselection.select(e.target);\n
\t\t\t\t}\n
\n
\t\t\t\tselectionHtml = editor.selection.getContent();\n
\n
\t\t\t\t// Safari/IE doesn\'t support custom dataTransfer items so we can only use URL and Text\n
\t\t\t\tif (selectionHtml.length > 0) {\n
\t\t\t\t\tinternalContent = mceInternalUrlPrefix + escape(editor.id) + \',\' + escape(selectionHtml);\n
\t\t\t\t\te.dataTransfer.setData(mceInternalDataType, internalContent);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Gets content of special data:text/mce-internal url on the event\'s dataTransfer object.\n
\t\t * This is to workaround the inability to set custom contentType on IE and Safari.\n
\t\t * The editor\'s selected content is encoded into this url so drag and drop between editors will work.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {DragEvent} e Event object\n
\t\t * @returns {String} mce-internal content\n
\t\t */\n
\t\tfunction getMceInternalContent(e) {\n
\t\t\tvar internalContent;\n
\n
\t\t\tif (e.dataTransfer) {\n
\t\t\t\tinternalContent = e.dataTransfer.getData(mceInternalDataType);\n
\n
\t\t\t\tif (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {\n
\t\t\t\t\tinternalContent = internalContent.substr(mceInternalUrlPrefix.length).split(\',\');\n
\n
\t\t\t\t\treturn {\n
\t\t\t\t\t\tid: unescape(internalContent[0]),\n
\t\t\t\t\t\thtml: unescape(internalContent[1])\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn null;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Inserts contents using the paste clipboard command if it\'s available if it isn\'t it will fallback\n
\t\t * to the core command.\n
\t\t *\n
\t\t * @private\n
\t\t * @param {String} content Content to insert at selection.\n
\t\t */\n
\t\tfunction insertClipboardContents(content) {\n
\t\t\tif (editor.queryCommandSupported(\'mceInsertClipboardContent\')) {\n
\t\t\t\teditor.execCommand(\'mceInsertClipboardContent\', false, {content: content});\n
\t\t\t} else {\n
\t\t\t\teditor.execCommand(\'mceInsertContent\', false, content);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Fixes a WebKit bug when deleting contents using backspace or delete key.\n
\t\t * WebKit will produce a span element if you delete across two block elements.\n
\t\t *\n
\t\t * Example:\n
\t\t * <h1>a</h1><p>|b</p>\n
\t\t *\n
\t\t * Will produce this on backspace:\n
\t\t * <h1>a<span style="<all runtime styles>">b</span></p>\n
\t\t *\n
\t\t * This fixes the backspace to produce:\n
\t\t * <h1>a|b</p>\n
\t\t *\n
\t\t * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784\n
\t\t *\n
\t\t * This fixes the following delete scenarios:\n
\t\t *  1. Delete by pressing backspace key.\n
\t\t *  2. Delete by pressing delete key.\n
\t\t *  3. Delete by pressing backspace key with ctrl/cmd (Word delete).\n
\t\t *  4. Delete by pressing delete key with ctrl/cmd (Word delete).\n
\t\t *  5. Delete by drag/dropping contents inside the editor.\n
\t\t *  6. Delete by using Cut Ctrl+X/Cmd+X.\n
\t\t *  7. Delete by selecting contents and writing a character.\n
\t\t *\n
\t\t * This code is a ugly hack since writing full custom delete logic for just this bug\n
\t\t * fix seemed like a huge task. I hope we can remove this before the year 2030.\n
\t\t */\n
\t\tfunction cleanupStylesWhenDeleting() {\n
\t\t\tvar doc = editor.getDoc(), dom = editor.dom, selection = editor.selection;\n
\t\t\tvar MutationObserver = window.MutationObserver, olderWebKit, dragStartRng;\n
\n
\t\t\t// Add mini polyfill for older WebKits\n
\t\t\t// TODO: Remove this when old Safari versions gets updated\n
\t\t\tif (!MutationObserver) {\n
\t\t\t\tolderWebKit = true;\n
\n
\t\t\t\tMutationObserver = function() {\n
\t\t\t\t\tvar records = [], target;\n
\n
\t\t\t\t\tfunction nodeInsert(e) {\n
\t\t\t\t\t\tvar target = e.relatedNode || e.target;\n
\t\t\t\t\t\trecords.push({target: target, addedNodes: [target]});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfunction attrModified(e) {\n
\t\t\t\t\t\tvar target = e.relatedNode || e.target;\n
\t\t\t\t\t\trecords.push({target: target, attributeName: e.attrName});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tthis.observe = function(node) {\n
\t\t\t\t\t\ttarget = node;\n
\t\t\t\t\t\ttarget.addEventListener(\'DOMSubtreeModified\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.addEventListener(\'DOMNodeInsertedIntoDocument\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.addEventListener(\'DOMNodeInserted\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.addEventListener(\'DOMAttrModified\', attrModified, false);\n
\t\t\t\t\t};\n
\n
\t\t\t\t\tthis.disconnect = function() {\n
\t\t\t\t\t\ttarget.removeEventListener(\'DOMSubtreeModified\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.removeEventListener(\'DOMNodeInsertedIntoDocument\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.removeEventListener(\'DOMNodeInserted\', nodeInsert, false);\n
\t\t\t\t\t\ttarget.removeEventListener(\'DOMAttrModified\', attrModified, false);\n
\t\t\t\t\t};\n
\n
\t\t\t\t\tthis.takeRecords = function() {\n
\t\t\t\t\t\treturn records;\n
\t\t\t\t\t};\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tfunction isTrailingBr(node) {\n
\t\t\t\tvar blockElements = dom.schema.getBlockElements(), rootNode = editor.getBody();\n
\n
\t\t\t\tif (node.nodeName != \'BR\') {\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\n
\t\t\t\tfor (node = node; node != rootNode && !blockElements[node.nodeName]; node = node.parentNode) {\n
\t\t\t\t\tif (node.nextSibling) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tfunction isSiblingsIgnoreWhiteSpace(node1, node2) {\n
\t\t\t\tvar node;\n
\n
\t\t\t\tfor (node = node1.nextSibling; node && node != node2; node = node.nextSibling) {\n
\t\t\t\t\tif (node.nodeType == 3 && $.trim(node.data).length === 0) {\n
\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (node !== node2) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn node === node2;\n
\t\t\t}\n
\n
\t\t\tfunction findCaretNode(node, forward, startNode) {\n
\t\t\t\tvar walker, current, nonEmptyElements;\n
\n
\t\t\t\tnonEmptyElements = dom.schema.getNonEmptyElements();\n
\n
\t\t\t\twalker = new TreeWalker(startNode || node, node);\n
\n
\t\t\t\twhile ((current = walker[forward ? \'next\' : \'prev\']())) {\n
\t\t\t\t\tif (nonEmptyElements[current.nodeName] && !isTrailingBr(current)) {\n
\t\t\t\t\t\treturn current;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (current.nodeType == 3 && current.data.length > 0) {\n
\t\t\t\t\t\treturn current;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction deleteRangeBetweenTextBlocks(rng) {\n
\t\t\t\tvar startBlock, endBlock, caretNodeBefore, caretNodeAfter, textBlockElements;\n
\n
\t\t\t\tif (rng.collapsed) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tstartBlock = dom.getParent(RangeUtils.getNode(rng.startContainer, rng.startOffset), dom.isBlock);\n
\t\t\t\tendBlock = dom.getParent(RangeUtils.getNode(rng.endContainer, rng.endOffset), dom.isBlock);\n
\t\t\t\ttextBlockElements = editor.schema.getTextBlockElements();\n
\n
\t\t\t\tif (startBlock == endBlock) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!textBlockElements[startBlock.nodeName] || !textBlockElements[endBlock.nodeName]) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (dom.getContentEditable(startBlock) === "false" || dom.getContentEditable(endBlock) === "false") {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\trng.deleteContents();\n
\n
\t\t\t\tcaretNodeBefore = findCaretNode(startBlock, false);\n
\t\t\t\tcaretNodeAfter = findCaretNode(endBlock, true);\n
\n
\t\t\t\tif (!dom.isEmpty(endBlock)) {\n
\t\t\t\t\t$(startBlock).append(endBlock.childNodes);\n
\t\t\t\t}\n
\n
\t\t\t\t$(endBlock).remove();\n
\n
\t\t\t\tif (caretNodeBefore) {\n
\t\t\t\t\tif (caretNodeBefore.nodeType == 1) {\n
\t\t\t\t\t\tif (caretNodeBefore.nodeName == "BR") {\n
\t\t\t\t\t\t\trng.setStartBefore(caretNodeBefore);\n
\t\t\t\t\t\t\trng.setEndBefore(caretNodeBefore);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setStartAfter(caretNodeBefore);\n
\t\t\t\t\t\t\trng.setEndAfter(caretNodeBefore);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setStart(caretNodeBefore, caretNodeBefore.data.length);\n
\t\t\t\t\t\trng.setEnd(caretNodeBefore, caretNodeBefore.data.length);\n
\t\t\t\t\t}\n
\t\t\t\t} else if (caretNodeAfter) {\n
\t\t\t\t\tif (caretNodeAfter.nodeType == 1) {\n
\t\t\t\t\t\trng.setStartBefore(caretNodeAfter);\n
\t\t\t\t\t\trng.setEndBefore(caretNodeAfter);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\trng.setStart(caretNodeAfter, 0);\n
\t\t\t\t\t\trng.setEnd(caretNodeAfter, 0);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tselection.setRng(rng);\n
\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tfunction expandBetweenBlocks(rng, isForward) {\n
\t\t\t\tvar caretNode, targetCaretNode, textBlock, targetTextBlock, container, offset;\n
\n
\t\t\t\tif (!rng.collapsed) {\n
\t\t\t\t\treturn rng;\n
\t\t\t\t}\n
\n
\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\toffset = rng.startOffset;\n
\n
\t\t\t\tif (container.nodeType == 3) {\n
\t\t\t\t\tif (isForward) {\n
\t\t\t\t\t\tif (offset < container.data.length) {\n
\t\t\t\t\t\t\treturn rng;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tif (offset > 0) {\n
\t\t\t\t\t\t\treturn rng;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tcaretNode = RangeUtils.getNode(rng.startContainer, rng.startOffset);\n
\t\t\t\ttextBlock = dom.getParent(caretNode, dom.isBlock);\n
\t\t\t\ttargetCaretNode = findCaretNode(editor.getBody(), isForward, caretNode);\n
\t\t\t\ttargetTextBlock = dom.getParent(targetCaretNode, dom.isBlock);\n
\n
\t\t\t\tif (!caretNode || !targetCaretNode) {\n
\t\t\t\t\treturn rng;\n
\t\t\t\t}\n
\n
\t\t\t\tif (targetTextBlock && textBlock != targetTextBlock) {\n
\t\t\t\t\tif (!isForward) {\n
\t\t\t\t\t\tif (!isSiblingsIgnoreWhiteSpace(targetTextBlock, textBlock)) {\n
\t\t\t\t\t\t\treturn rng;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (targetCaretNode.nodeType == 1) {\n
\t\t\t\t\t\t\tif (targetCaretNode.nodeName == "BR") {\n
\t\t\t\t\t\t\t\trng.setStartBefore(targetCaretNode);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\trng.setStartAfter(targetCaretNode);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setStart(targetCaretNode, targetCaretNode.data.length);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (caretNode.nodeType == 1) {\n
\t\t\t\t\t\t\trng.setEnd(caretNode, 0);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setEndBefore(caretNode);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tif (!isSiblingsIgnoreWhiteSpace(textBlock, targetTextBlock)) {\n
\t\t\t\t\t\t\treturn rng;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (caretNode.nodeType == 1) {\n
\t\t\t\t\t\t\tif (caretNode.nodeName == "BR") {\n
\t\t\t\t\t\t\t\trng.setStartBefore(caretNode);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\trng.setStartAfter(caretNode);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setStart(caretNode, caretNode.data.length);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (targetCaretNode.nodeType == 1) {\n
\t\t\t\t\t\t\trng.setEnd(targetCaretNode, 0);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.setEndBefore(targetCaretNode);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn rng;\n
\t\t\t}\n
\n
\t\t\tfunction handleTextBlockMergeDelete(isForward) {\n
\t\t\t\tvar rng = selection.getRng();\n
\n
\t\t\t\trng = expandBetweenBlocks(rng, isForward);\n
\n
\t\t\t\tif (deleteRangeBetweenTextBlocks(rng)) {\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction customDelete(isForward) {\n
\t\t\t\tvar mutationObserver, rng, caretElement;\n
\n
\t\t\t\tif (handleTextBlockMergeDelete(isForward)) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tTools.each(editor.getBody().getElementsByTagName(\'*\'), function(elm) {\n
\t\t\t\t\t// Mark existing spans\n
\t\t\t\t\tif (elm.tagName == \'SPAN\') {\n
\t\t\t\t\t\telm.setAttribute(\'mce-data-marked\', 1);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Make sure all elements has a data-mce-style attribute\n
\t\t\t\t\tif (!elm.hasAttribute(\'data-mce-style\') && elm.hasAttribute(\'style\')) {\n
\t\t\t\t\t\teditor.dom.setAttrib(elm, \'style\', editor.dom.getAttrib(elm, \'style\'));\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Observe added nodes and style attribute changes\n
\t\t\t\tmutationObserver = new MutationObserver(function() {});\n
\t\t\t\tmutationObserver.observe(editor.getDoc(), {\n
\t\t\t\t\tchildList: true,\n
\t\t\t\t\tattributes: true,\n
\t\t\t\t\tsubtree: true,\n
\t\t\t\t\tattributeFilter: [\'style\']\n
\t\t\t\t});\n
\n
\t\t\t\teditor.getDoc().execCommand(isForward ? \'ForwardDelete\' : \'Delete\', false, null);\n
\n
\t\t\t\trng = editor.selection.getRng();\n
\t\t\t\tcaretElement = rng.startContainer.parentNode;\n
\n
\t\t\t\tTools.each(mutationObserver.takeRecords(), function(record) {\n
\t\t\t\t\tif (!dom.isChildOf(record.target, editor.getBody())) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Restore style attribute to previous value\n
\t\t\t\t\tif (record.attributeName == "style") {\n
\t\t\t\t\t\tvar oldValue = record.target.getAttribute(\'data-mce-style\');\n
\n
\t\t\t\t\t\tif (oldValue) {\n
\t\t\t\t\t\t\trecord.target.setAttribute("style", oldValue);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trecord.target.removeAttribute("style");\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Remove all spans that isn\'t maked and retain selection\n
\t\t\t\t\tTools.each(record.addedNodes, function(node) {\n
\t\t\t\t\t\tif (node.nodeName == "SPAN" && !node.getAttribute(\'mce-data-marked\')) {\n
\t\t\t\t\t\t\tvar offset, container;\n
\n
\t\t\t\t\t\t\tif (node == caretElement) {\n
\t\t\t\t\t\t\t\toffset = rng.startOffset;\n
\t\t\t\t\t\t\t\tcontainer = node.firstChild;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tdom.remove(node, true);\n
\n
\t\t\t\t\t\t\tif (container) {\n
\t\t\t\t\t\t\t\trng.setStart(container, offset);\n
\t\t\t\t\t\t\t\trng.setEnd(container, offset);\n
\t\t\t\t\t\t\t\teditor.selection.setRng(rng);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\n
\t\t\t\tmutationObserver.disconnect();\n
\n
\t\t\t\t// Remove any left over marks\n
\t\t\t\tTools.each(editor.dom.select(\'span[mce-data-marked]\'), function(span) {\n
\t\t\t\t\tspan.removeAttribute(\'mce-data-marked\');\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tvar isForward = e.keyCode == DELETE, isMetaOrCtrl = e.ctrlKey || e.metaKey;\n
\n
\t\t\t\tif (!isDefaultPrevented(e) && (isForward || e.keyCode == BACKSPACE)) {\n
\t\t\t\t\tvar rng = editor.selection.getRng(), container = rng.startContainer, offset = rng.startOffset;\n
\n
\t\t\t\t\t// Ignore non meta delete in the where there is text before/after the caret\n
\t\t\t\t\tif (!isMetaOrCtrl && rng.collapsed && container.nodeType == 3) {\n
\t\t\t\t\t\tif (isForward ? offset < container.data.length : offset > 0) {\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\tif (isMetaOrCtrl) {\n
\t\t\t\t\t\teditor.selection.getSel().modify("extend", isForward ? "forward" : "backward", e.metaKey ? "lineboundary" : "word");\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tcustomDelete(isForward);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Handle case where text is deleted by typing over\n
\t\t\teditor.on(\'keypress\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e) && !selection.isCollapsed() && e.charCode && !VK.metaKeyPressed(e)) {\n
\t\t\t\t\tvar rng, currentFormatNodes, fragmentNode, blockParent, caretNode, charText;\n
\n
\t\t\t\t\trng = editor.selection.getRng();\n
\t\t\t\t\tcharText = String.fromCharCode(e.charCode);\n
\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t// Keep track of current format nodes\n
\t\t\t\t\tcurrentFormatNodes = $(rng.startContainer).parents().filter(function(idx, node) {\n
\t\t\t\t\t\treturn !!editor.schema.getTextInlineElements()[node.nodeName];\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tcustomDelete(true);\n
\n
\t\t\t\t\t// Check if the browser removed them\n
\t\t\t\t\tcurrentFormatNodes = currentFormatNodes.filter(function(idx, node) {\n
\t\t\t\t\t\treturn !$.contains(editor.getBody(), node);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Then re-add them\n
\t\t\t\t\tif (currentFormatNodes.length) {\n
\t\t\t\t\t\tfragmentNode = dom.createFragment();\n
\n
\t\t\t\t\t\tcurrentFormatNodes.each(function(idx, formatNode) {\n
\t\t\t\t\t\t\tformatNode = formatNode.cloneNode(false);\n
\n
\t\t\t\t\t\t\tif (fragmentNode.hasChildNodes()) {\n
\t\t\t\t\t\t\t\tformatNode.appendChild(fragmentNode.firstChild);\n
\t\t\t\t\t\t\t\tfragmentNode.appendChild(formatNode);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tcaretNode = formatNode;\n
\t\t\t\t\t\t\t\tfragmentNode.appendChild(formatNode);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tfragmentNode.appendChild(formatNode);\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\tcaretNode.appendChild(editor.getDoc().createTextNode(charText));\n
\n
\t\t\t\t\t\t// Prevent edge case where older WebKit would add an extra BR element\n
\t\t\t\t\t\tblockParent = dom.getParent(rng.startContainer, dom.isBlock);\n
\t\t\t\t\t\tif (dom.isEmpty(blockParent)) {\n
\t\t\t\t\t\t\t$(blockParent).empty().append(fragmentNode);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\trng.insertNode(fragmentNode);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\trng.setStart(caretNode.firstChild, 1);\n
\t\t\t\t\t\trng.setEnd(caretNode.firstChild, 1);\n
\t\t\t\t\t\teditor.selection.setRng(rng);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.selection.setContent(charText);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.addCommand(\'Delete\', function() {\n
\t\t\t\tcustomDelete();\n
\t\t\t});\n
\n
\t\t\teditor.addCommand(\'ForwardDelete\', function() {\n
\t\t\t\tcustomDelete(true);\n
\t\t\t});\n
\n
\t\t\t// Older WebKits doesn\'t properly handle the clipboard so we can\'t add the rest\n
\t\t\tif (olderWebKit) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\teditor.on(\'dragstart\', function(e) {\n
\t\t\t\tdragStartRng = selection.getRng();\n
\t\t\t\tsetMceInteralContent(e);\n
\t\t\t});\n
\n
\t\t\teditor.on(\'drop\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e)) {\n
\t\t\t\t\tvar internalContent = getMceInternalContent(e);\n
\n
\t\t\t\t\tif (internalContent) {\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\t// Safari has a weird issue where drag/dropping images sometimes\n
\t\t\t\t\t\t// produces a green plus icon. When this happens the caretRangeFromPoint\n
\t\t\t\t\t\t// will return "null" even though the x, y coordinate is correct.\n
\t\t\t\t\t\t// But if we detach the insert from the drop event we will get a proper range\n
\t\t\t\t\t\twindow.setTimeout(function() {\n
\t\t\t\t\t\t\tvar pointRng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, doc);\n
\n
\t\t\t\t\t\t\tif (dragStartRng) {\n
\t\t\t\t\t\t\t\tselection.setRng(dragStartRng);\n
\t\t\t\t\t\t\t\tdragStartRng = null;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tcustomDelete();\n
\t\t\t\t\t\t\tselection.setRng(pointRng);\n
\t\t\t\t\t\t\tinsertClipboardContents(internalContent.html);\n
\t\t\t\t\t\t}, 0);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.on(\'cut\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e) && e.clipboardData && !editor.selection.isCollapsed()) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t\te.clipboardData.clearData();\n
\t\t\t\t\te.clipboardData.setData(\'text/html\', editor.selection.getContent());\n
\t\t\t\t\te.clipboardData.setData(\'text/plain\', editor.selection.getContent({format: \'text\'}));\n
\n
\t\t\t\t\t// Needed delay for https://code.google.com/p/chromium/issues/detail?id=363288#c3\n
\t\t\t\t\t// Nested delete/forwardDelete not allowed on execCommand("cut")\n
\t\t\t\t\t// This is ugly but not sure how to work around it otherwise\n
\t\t\t\t\twindow.setTimeout(function() {\n
\t\t\t\t\t\tcustomDelete(true);\n
\t\t\t\t\t}, 0);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.\n
\t\t *\n
\t\t * For example:\n
\t\t * <p><b>|</b></p>\n
\t\t *\n
\t\t * Or:\n
\t\t * <h1>|</h1>\n
\t\t *\n
\t\t * Or:\n
\t\t * [<h1></h1>]\n
\t\t */\n
\t\tfunction emptyEditorWhenDeleting() {\n
\t\t\tfunction serializeRng(rng) {\n
\t\t\t\tvar body = dom.create("body");\n
\t\t\t\tvar contents = rng.cloneContents();\n
\t\t\t\tbody.appendChild(contents);\n
\t\t\t\treturn selection.serializer.serialize(body, {format: \'html\'});\n
\t\t\t}\n
\n
\t\t\tfunction allContentsSelected(rng) {\n
\t\t\t\tif (!rng.setStart) {\n
\t\t\t\t\tif (rng.item) {\n
\t\t\t\t\t\treturn false;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tvar bodyRng = rng.duplicate();\n
\t\t\t\t\tbodyRng.moveToElementText(editor.getBody());\n
\t\t\t\t\treturn RangeUtils.compareRanges(rng, bodyRng);\n
\t\t\t\t}\n
\n
\t\t\t\tvar selection = serializeRng(rng);\n
\n
\t\t\t\tvar allRng = dom.createRng();\n
\t\t\t\tallRng.selectNode(editor.getBody());\n
\n
\t\t\t\tvar allSelection = serializeRng(allRng);\n
\t\t\t\treturn selection === allSelection;\n
\t\t\t}\n
\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tvar keyCode = e.keyCode, isCollapsed, body;\n
\n
\t\t\t\t// Empty the editor if it\'s needed for example backspace at <p><b>|</b></p>\n
\t\t\t\tif (!isDefaultPrevented(e) && (keyCode == DELETE || keyCode == BACKSPACE)) {\n
\t\t\t\t\tisCollapsed = editor.selection.isCollapsed();\n
\t\t\t\t\tbody = editor.getBody();\n
\n
\t\t\t\t\t// Selection is collapsed but the editor isn\'t empty\n
\t\t\t\t\tif (isCollapsed && !dom.isEmpty(body)) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Selection isn\'t collapsed but not all the contents is selected\n
\t\t\t\t\tif (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Manually empty the editor\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t\teditor.setContent(\'\');\n
\n
\t\t\t\t\tif (body.firstChild && dom.isBlock(body.firstChild)) {\n
\t\t\t\t\t\teditor.selection.setCursorLocation(body.firstChild, 0);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.selection.setCursorLocation(body, 0);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * WebKit doesn\'t select all the nodes in the body when you press Ctrl+A.\n
\t\t * IE selects more than the contents <body>[<p>a</p>]</body> instead of <body><p>[a]</p]</body> see bug #6438\n
\t\t * This selects the whole body so that backspace/delete logic will delete everything\n
\t\t */\n
\t\tfunction selectAll() {\n
\t\t\teditor.shortcuts.add(\'meta+a\', null, \'SelectAll\');\n
\t\t}\n
\n
\t\t/**\n
\t\t * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.\n
\t\t * The IME on Mac doesn\'t initialize when it doesn\'t fire a proper focus event.\n
\t\t *\n
\t\t * This seems to happen when the user manages to click the documentElement element then the window doesn\'t get proper focus until\n
\t\t * you enter a character into the editor.\n
\t\t *\n
\t\t * It also happens when the first focus in made to the body.\n
\t\t *\n
\t\t * See: https://bugs.webkit.org/show_bug.cgi?id=83566\n
\t\t */\n
\t\tfunction inputMethodFocus() {\n
\t\t\tif (!editor.settings.content_editable) {\n
\t\t\t\t// Case 1 IME doesn\'t initialize if you focus the document\n
\t\t\t\tdom.bind(editor.getDoc(), \'focusin\', function() {\n
\t\t\t\t\tselection.setRng(selection.getRng());\n
\t\t\t\t});\n
\n
\t\t\t\t// Case 2 IME doesn\'t initialize if you click the documentElement it also doesn\'t properly fire the focusin event\n
\t\t\t\t// Needs to be both down/up due to weird rendering bug on Chrome Windows\n
\t\t\t\tdom.bind(editor.getDoc(), \'mousedown mouseup\', function(e) {\n
\t\t\t\t\tif (e.target == editor.getDoc().documentElement) {\n
\t\t\t\t\t\teditor.getBody().focus();\n
\n
\t\t\t\t\t\tif (e.type == \'mousedown\') {\n
\t\t\t\t\t\t\t// Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret\n
\t\t\t\t\t\t\tselection.placeCaretAt(e.clientX, e.clientY);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tselection.setRng(selection.getRng());\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the\n
\t\t * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is\n
\t\t * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js\n
\t\t * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other\n
\t\t * browsers.\n
\t\t *\n
\t\t * It also fixes a bug on Firefox where it\'s impossible to delete HR elements.\n
\t\t */\n
\t\tfunction removeHrOnBackspace() {\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n
\t\t\t\t\t// Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow\n
\t\t\t\t\tif (!editor.getBody().getElementsByTagName(\'hr\').length) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {\n
\t\t\t\t\t\tvar node = selection.getNode();\n
\t\t\t\t\t\tvar previousSibling = node.previousSibling;\n
\n
\t\t\t\t\t\tif (node.nodeName == \'HR\') {\n
\t\t\t\t\t\t\tdom.remove(node);\n
\t\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {\n
\t\t\t\t\t\t\tdom.remove(previousSibling);\n
\t\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Firefox 3.x has an issue where the body element won\'t get proper focus if you click out\n
\t\t * side it\'s rectangle.\n
\t\t */\n
\t\tfunction focusBody() {\n
\t\t\t// Fix for a focus bug in FF 3.x where the body element\n
\t\t\t// wouldn\'t get proper focus if the user clicked on the HTML element\n
\t\t\tif (!window.Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4\n
\t\t\t\teditor.on(\'mousedown\', function(e) {\n
\t\t\t\t\tif (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {\n
\t\t\t\t\t\tvar body = editor.getBody();\n
\n
\t\t\t\t\t\t// Blur the body it\'s focused but not correctly focused\n
\t\t\t\t\t\tbody.blur();\n
\n
\t\t\t\t\t\t// Refocus the body after a little while\n
\t\t\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\t\t\tbody.focus();\n
\t\t\t\t\t\t}, 0);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * WebKit has a bug where it isn\'t possible to select image, hr or anchor elements\n
\t\t * by clicking on them so we need to fake that.\n
\t\t */\n
\t\tfunction selectControlElements() {\n
\t\t\teditor.on(\'click\', function(e) {\n
\t\t\t\tvar target = e.target;\n
\n
\t\t\t\t// Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250\n
\t\t\t\t// WebKit can\'t even do simple things like selecting an image\n
\t\t\t\t// Needs to be the setBaseAndExtend or it will fail to select floated images\n
\t\t\t\tif (/^(IMG|HR)$/.test(target.nodeName)) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t\tselection.getSel().setBaseAndExtent(target, 0, target, 1);\n
\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t}\n
\n
\t\t\t\tif (target.nodeName == \'A\' && dom.hasClass(target, \'mce-item-anchor\')) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t\tselection.select(target);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.\n
\t\t *\n
\t\t * Fixes do backspace/delete on this:\n
\t\t * <p>bla[ck</p><p style="color:red">r]ed</p>\n
\t\t *\n
\t\t * Would become:\n
\t\t * <p>bla|ed</p>\n
\t\t *\n
\t\t * Instead of:\n
\t\t * <p style="color:red">bla|ed</p>\n
\t\t */\n
\t\tfunction removeStylesWhenDeletingAcrossBlockElements() {\n
\t\t\tfunction getAttributeApplyFunction() {\n
\t\t\t\tvar template = dom.getAttribs(selection.getStart().cloneNode(false));\n
\n
\t\t\t\treturn function() {\n
\t\t\t\t\tvar target = selection.getStart();\n
\n
\t\t\t\t\tif (target !== editor.getBody()) {\n
\t\t\t\t\t\tdom.setAttrib(target, "style", null);\n
\n
\t\t\t\t\t\teach(template, function(attr) {\n
\t\t\t\t\t\t\ttarget.setAttributeNode(attr.cloneNode(true));\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tfunction isSelectionAcrossElements() {\n
\t\t\t\treturn !selection.isCollapsed() &&\n
\t\t\t\t\tdom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);\n
\t\t\t}\n
\n
\t\t\teditor.on(\'keypress\', function(e) {\n
\t\t\t\tvar applyAttributes;\n
\n
\t\t\t\tif (!isDefaultPrevented(e) && (e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {\n
\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\n
\t\t\t\t\teditor.getDoc().execCommand(\'delete\', false, null);\n
\t\t\t\t\tapplyAttributes();\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tdom.bind(editor.getDoc(), \'cut\', function(e) {\n
\t\t\t\tvar applyAttributes;\n
\n
\t\t\t\tif (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n
\t\t\t\t\tapplyAttributes = getAttributeApplyFunction();\n
\n
\t\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\t\tapplyAttributes();\n
\t\t\t\t\t}, 0);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Screen readers on IE needs to have the role application set on the body.\n
\t\t */\n
\t\tfunction ensureBodyHasRoleApplication() {\n
\t\t\tdocument.body.setAttribute("role", "application");\n
\t\t}\n
\n
\t\t/**\n
\t\t * Backspacing into a table behaves differently depending upon browser type.\n
\t\t * Therefore, disable Backspace when cursor immediately follows a table.\n
\t\t */\n
\t\tfunction disableBackspaceIntoATable() {\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n
\t\t\t\t\tif (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {\n
\t\t\t\t\t\tvar previousSibling = selection.getNode().previousSibling;\n
\t\t\t\t\t\tif (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {\n
\t\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Old IE versions can\'t properly render BR elements in PRE tags white in contentEditable mode. So this\n
\t\t * logic adds a \\n before the BR so that it will get rendered.\n
\t\t */\n
\t\tfunction addNewLinesBeforeBrInPre() {\n
\t\t\t// IE8+ rendering mode does the right thing with BR in PRE\n
\t\t\tif (getDocumentMode() > 7) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Enable display: none in area and add a specific class that hides all BR elements in PRE to\n
\t\t\t// avoid the caret from getting stuck at the BR elements while pressing the right arrow key\n
\t\t\tsetEditorCommandState(\'RespectVisibilityInDesign\', true);\n
\t\t\teditor.contentStyles.push(\'.mceHideBrInPre pre br {display: none}\');\n
\t\t\tdom.addClass(editor.getBody(), \'mceHideBrInPre\');\n
\n
\t\t\t// Adds a \\n before all BR elements in PRE to get them visual\n
\t\t\tparser.addNodeFilter(\'pre\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, brNodes, j, brElm, sibling;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tbrNodes = nodes[i].getAll(\'br\');\n
\t\t\t\t\tj = brNodes.length;\n
\t\t\t\t\twhile (j--) {\n
\t\t\t\t\t\tbrElm = brNodes[j];\n
\n
\t\t\t\t\t\t// Add \\n before BR in PRE elements on older IE:s so the new lines get rendered\n
\t\t\t\t\t\tsibling = brElm.prev;\n
\t\t\t\t\t\tif (sibling && sibling.type === 3 && sibling.value.charAt(sibling.value - 1) != \'\\n\') {\n
\t\t\t\t\t\t\tsibling.value += \'\\n\';\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tbrElm.parent.insert(new Node(\'#text\', 3), brElm, true).value = \'\\n\';\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Removes any \\n before BR elements in PRE since other browsers and in contentEditable=false mode they will be visible\n
\t\t\tserializer.addNodeFilter(\'pre\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, brNodes, j, brElm, sibling;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tbrNodes = nodes[i].getAll(\'br\');\n
\t\t\t\t\tj = brNodes.length;\n
\t\t\t\t\twhile (j--) {\n
\t\t\t\t\t\tbrElm = brNodes[j];\n
\t\t\t\t\t\tsibling = brElm.prev;\n
\t\t\t\t\t\tif (sibling && sibling.type == 3) {\n
\t\t\t\t\t\t\tsibling.value = sibling.value.replace(/\\r?\\n$/, \'\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Moves style width/height to attribute width/height when the user resizes an image on IE.\n
\t\t */\n
\t\tfunction removePreSerializedStylesWhenSelectingControls() {\n
\t\t\tdom.bind(editor.getBody(), \'mouseup\', function() {\n
\t\t\t\tvar value, node = selection.getNode();\n
\n
\t\t\t\t// Moved styles to attributes on IMG eements\n
\t\t\t\tif (node.nodeName == \'IMG\') {\n
\t\t\t\t\t// Convert style width to width attribute\n
\t\t\t\t\tif ((value = dom.getStyle(node, \'width\'))) {\n
\t\t\t\t\t\tdom.setAttrib(node, \'width\', value.replace(/[^0-9%]+/g, \'\'));\n
\t\t\t\t\t\tdom.setStyle(node, \'width\', \'\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Convert style height to height attribute\n
\t\t\t\t\tif ((value = dom.getStyle(node, \'height\'))) {\n
\t\t\t\t\t\tdom.setAttrib(node, \'height\', value.replace(/[^0-9%]+/g, \'\'));\n
\t\t\t\t\t\tdom.setStyle(node, \'height\', \'\');\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes a blockquote when backspace is pressed at the beginning of it.\n
\t\t *\n
\t\t * For example:\n
\t\t * <blockquote><p>|x</p></blockquote>\n
\t\t *\n
\t\t * Becomes:\n
\t\t * <p>|x</p>\n
\t\t */\n
\t\tfunction removeBlockQuoteOnBackSpace() {\n
\t\t\t// Add block quote deletion handler\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tvar rng, container, offset, root, parent;\n
\n
\t\t\t\tif (isDefaultPrevented(e) || e.keyCode != VK.BACKSPACE) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\trng = selection.getRng();\n
\t\t\t\tcontainer = rng.startContainer;\n
\t\t\t\toffset = rng.startOffset;\n
\t\t\t\troot = dom.getRoot();\n
\t\t\t\tparent = container;\n
\n
\t\t\t\tif (!rng.collapsed || offset !== 0) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\twhile (parent && parent.parentNode && parent.parentNode.firstChild == parent && parent.parentNode != root) {\n
\t\t\t\t\tparent = parent.parentNode;\n
\t\t\t\t}\n
\n
\t\t\t\t// Is the cursor at the beginning of a blockquote?\n
\t\t\t\tif (parent.tagName === \'BLOCKQUOTE\') {\n
\t\t\t\t\t// Remove the blockquote\n
\t\t\t\t\teditor.formatter.toggle(\'blockquote\', null, parent);\n
\n
\t\t\t\t\t// Move the caret to the beginning of container\n
\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\trng.setStart(container, 0);\n
\t\t\t\t\trng.setEnd(container, 0);\n
\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.\n
\t\t */\n
\t\tfunction setGeckoEditingOptions() {\n
\t\t\tfunction setOpts() {\n
\t\t\t\teditor._refreshContentEditable();\n
\n
\t\t\t\tsetEditorCommandState("StyleWithCSS", false);\n
\t\t\t\tsetEditorCommandState("enableInlineTableEditing", false);\n
\n
\t\t\t\tif (!settings.object_resizing) {\n
\t\t\t\t\tsetEditorCommandState("enableObjectResizing", false);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (!settings.readonly) {\n
\t\t\t\teditor.on(\'BeforeExecCommand MouseDown\', setOpts);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Fixes a gecko link bug, when a link is placed at the end of block elements there is\n
\t\t * no way to move the caret behind the link. This fix adds a bogus br element after the link.\n
\t\t *\n
\t\t * For example this:\n
\t\t * <p><b><a href="#">x</a></b></p>\n
\t\t *\n
\t\t * Becomes this:\n
\t\t * <p><b><a href="#">x</a></b><br></p>\n
\t\t */\n
\t\tfunction addBrAfterLastLinks() {\n
\t\t\tfunction fixLinks() {\n
\t\t\t\teach(dom.select(\'a\'), function(node) {\n
\t\t\t\t\tvar parentNode = node.parentNode, root = dom.getRoot();\n
\n
\t\t\t\t\tif (parentNode.lastChild === node) {\n
\t\t\t\t\t\twhile (parentNode && !dom.isBlock(parentNode)) {\n
\t\t\t\t\t\t\tif (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tparentNode = parentNode.parentNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tdom.add(parentNode, \'br\', {\'data-mce-bogus\': 1});\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\teditor.on(\'SetContent ExecCommand\', function(e) {\n
\t\t\t\tif (e.type == "setcontent" || e.command === \'mceInsertLink\') {\n
\t\t\t\t\tfixLinks();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by\n
\t\t * default we want to change that behavior.\n
\t\t */\n
\t\tfunction setDefaultBlockType() {\n
\t\t\tif (settings.forced_root_block) {\n
\t\t\t\teditor.on(\'init\', function() {\n
\t\t\t\t\tsetEditorCommandState(\'DefaultParagraphSeparator\', settings.forced_root_block);\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes ghost selections from images/tables on Gecko.\n
\t\t */\n
\t\tfunction removeGhostSelection() {\n
\t\t\teditor.on(\'Undo Redo SetContent\', function(e) {\n
\t\t\t\tif (!e.initial) {\n
\t\t\t\t\teditor.execCommand(\'mceRepaint\');\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Deletes the selected image on IE instead of navigating to previous page.\n
\t\t */\n
\t\tfunction deleteControlItemOnBackSpace() {\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tvar rng;\n
\n
\t\t\t\tif (!isDefaultPrevented(e) && e.keyCode == BACKSPACE) {\n
\t\t\t\t\trng = editor.getDoc().selection.createRange();\n
\t\t\t\t\tif (rng && rng.item) {\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\teditor.undoManager.beforeChange();\n
\t\t\t\t\t\tdom.remove(rng.item(0));\n
\t\t\t\t\t\teditor.undoManager.add();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * IE10 doesn\'t properly render block elements with the right height until you add contents to them.\n
\t\t * This fixes that by adding a padding-right to all empty text block elements.\n
\t\t * See: https://connect.microsoft.com/IE/feedback/details/743881\n
\t\t */\n
\t\tfunction renderEmptyBlocksFix() {\n
\t\t\tvar emptyBlocksCSS;\n
\n
\t\t\t// IE10+\n
\t\t\tif (getDocumentMode() >= 10) {\n
\t\t\t\temptyBlocksCSS = \'\';\n
\t\t\t\teach(\'p div h1 h2 h3 h4 h5 h6\'.split(\' \'), function(name, i) {\n
\t\t\t\t\temptyBlocksCSS += (i > 0 ? \',\' : \'\') + name + \':empty\';\n
\t\t\t\t});\n
\n
\t\t\t\teditor.contentStyles.push(emptyBlocksCSS + \'{padding-right: 1px !important}\');\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Old IE versions can\'t retain contents within noscript elements so this logic will store the contents\n
\t\t * as a attribute and the insert that value as it\'s raw text when the DOM is serialized.\n
\t\t */\n
\t\tfunction keepNoScriptContents() {\n
\t\t\tif (getDocumentMode() < 9) {\n
\t\t\t\tparser.addNodeFilter(\'noscript\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length, node, textNode;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\t\ttextNode = node.firstChild;\n
\n
\t\t\t\t\t\tif (textNode) {\n
\t\t\t\t\t\t\tnode.attr(\'data-mce-innertext\', textNode.value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tserializer.addNodeFilter(\'noscript\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length, node, textNode, value;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\t\ttextNode = nodes[i].firstChild;\n
\n
\t\t\t\t\t\tif (textNode) {\n
\t\t\t\t\t\t\ttextNode.value = Entities.decode(textNode.value);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Old IE can\'t retain noscript value so an attribute is used to store it\n
\t\t\t\t\t\t\tvalue = node.attributes.map[\'data-mce-innertext\'];\n
\t\t\t\t\t\t\tif (value) {\n
\t\t\t\t\t\t\t\tnode.attr(\'data-mce-innertext\', null);\n
\t\t\t\t\t\t\t\ttextNode = new Node(\'#text\', 3);\n
\t\t\t\t\t\t\t\ttextNode.value = value;\n
\t\t\t\t\t\t\t\ttextNode.raw = true;\n
\t\t\t\t\t\t\t\tnode.append(textNode);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * IE has an issue where you can\'t select/move the caret by clicking outside the body if the document is in standards mode.\n
\t\t */\n
\t\tfunction fixCaretSelectionOfDocumentElementOnIe() {\n
\t\t\tvar doc = dom.doc, body = doc.body, started, startRng, htmlElm;\n
\n
\t\t\t// Return range from point or null if it failed\n
\t\t\tfunction rngFromPoint(x, y) {\n
\t\t\t\tvar rng = body.createTextRange();\n
\n
\t\t\t\ttry {\n
\t\t\t\t\trng.moveToPoint(x, y);\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// IE sometimes throws and exception, so lets just ignore it\n
\t\t\t\t\trng = null;\n
\t\t\t\t}\n
\n
\t\t\t\treturn rng;\n
\t\t\t}\n
\n
\t\t\t// Fires while the selection is changing\n
\t\t\tfunction selectionChange(e) {\n
\t\t\t\tvar pointRng;\n
\n
\t\t\t\t// Check if the button is down or not\n
\t\t\t\tif (e.button) {\n
\t\t\t\t\t// Create range from mouse position\n
\t\t\t\t\tpointRng = rngFromPoint(e.x, e.y);\n
\n
\t\t\t\t\tif (pointRng) {\n
\t\t\t\t\t\t// Check if pointRange is before/after selection then change the endPoint\n
\t\t\t\t\t\tif (pointRng.compareEndPoints(\'StartToStart\', startRng) > 0) {\n
\t\t\t\t\t\t\tpointRng.setEndPoint(\'StartToStart\', startRng);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tpointRng.setEndPoint(\'EndToEnd\', startRng);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tpointRng.select();\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tendSelection();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Removes listeners\n
\t\t\tfunction endSelection() {\n
\t\t\t\tvar rng = doc.selection.createRange();\n
\n
\t\t\t\t// If the range is collapsed then use the last start range\n
\t\t\t\tif (startRng && !rng.item && rng.compareEndPoints(\'StartToEnd\', rng) === 0) {\n
\t\t\t\t\tstartRng.select();\n
\t\t\t\t}\n
\n
\t\t\t\tdom.unbind(doc, \'mouseup\', endSelection);\n
\t\t\t\tdom.unbind(doc, \'mousemove\', selectionChange);\n
\t\t\t\tstartRng = started = 0;\n
\t\t\t}\n
\n
\t\t\t// Make HTML element unselectable since we are going to handle selection by hand\n
\t\t\tdoc.documentElement.unselectable = true;\n
\n
\t\t\t// Detect when user selects outside BODY\n
\t\t\tdom.bind(doc, \'mousedown contextmenu\', function(e) {\n
\t\t\t\tif (e.target.nodeName === \'HTML\') {\n
\t\t\t\t\tif (started) {\n
\t\t\t\t\t\tendSelection();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML\n
\t\t\t\t\thtmlElm = doc.documentElement;\n
\t\t\t\t\tif (htmlElm.scrollHeight > htmlElm.clientHeight) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tstarted = 1;\n
\t\t\t\t\t// Setup start position\n
\t\t\t\t\tstartRng = rngFromPoint(e.x, e.y);\n
\t\t\t\t\tif (startRng) {\n
\t\t\t\t\t\t// Listen for selection change events\n
\t\t\t\t\t\tdom.bind(doc, \'mouseup\', endSelection);\n
\t\t\t\t\t\tdom.bind(doc, \'mousemove\', selectionChange);\n
\n
\t\t\t\t\t\tdom.getRoot().focus();\n
\t\t\t\t\t\tstartRng.select();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>\n
\t\t * this fix will lean the caret right into the closest inline element.\n
\t\t */\n
\t\tfunction normalizeSelection() {\n
\t\t\t// Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything\n
\t\t\teditor.on(\'keyup focusin mouseup\', function(e) {\n
\t\t\t\tif (e.keyCode != 65 || !VK.metaKeyPressed(e)) {\n
\t\t\t\t\tselection.normalize();\n
\t\t\t\t}\n
\t\t\t}, true);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Forces Gecko to render a broken image icon if it fails to load an image.\n
\t\t */\n
\t\tfunction showBrokenImageIcon() {\n
\t\t\teditor.contentStyles.push(\n
\t\t\t\t\'img:-moz-broken {\' +\n
\t\t\t\t\t\'-moz-force-broken-image-icon:1;\' +\n
\t\t\t\t\t\'min-width:24px;\' +\n
\t\t\t\t\t\'min-height:24px\' +\n
\t\t\t\t\'}\'\n
\t\t\t);\n
\t\t}\n
\n
\t\t/**\n
\t\t * iOS has a bug where it\'s impossible to type if the document has a touchstart event\n
\t\t * bound and the user touches the document while having the on screen keyboard visible.\n
\t\t *\n
\t\t * The touch event moves the focus to the parent document while having the caret inside the iframe\n
\t\t * this fix moves the focus back into the iframe document.\n
\t\t */\n
\t\tfunction restoreFocusOnKeyDown() {\n
\t\t\tif (!editor.inline) {\n
\t\t\t\teditor.on(\'keydown\', function() {\n
\t\t\t\t\tif (document.activeElement == document.body) {\n
\t\t\t\t\t\teditor.getWin().focus();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * IE 11 has an annoying issue where you can\'t move focus into the editor\n
\t\t * by clicking on the white area HTML element. We used to be able to to fix this with\n
\t\t * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection\n
\t\t * object it\'s not possible anymore. So we need to hack in a ungly CSS to force the\n
\t\t * body to be at least 150px. If the user clicks the HTML element out side this 150px region\n
\t\t * we simply move the focus into the first paragraph. Not ideal since you loose the\n
\t\t * positioning of the caret but goot enough for most cases.\n
\t\t */\n
\t\tfunction bodyHeight() {\n
\t\t\tif (!editor.inline) {\n
\t\t\t\teditor.contentStyles.push(\'body {min-height: 150px}\');\n
\t\t\t\teditor.on(\'click\', function(e) {\n
\t\t\t\t\tif (e.target.nodeName == \'HTML\') {\n
\t\t\t\t\t\tvar rng;\n
\n
\t\t\t\t\t\t// Need to store away non collapsed ranges since the focus call will mess that up see #7382\n
\t\t\t\t\t\trng = editor.selection.getRng();\n
\t\t\t\t\t\teditor.getBody().focus();\n
\t\t\t\t\t\teditor.selection.setRng(rng);\n
\t\t\t\t\t\teditor.selection.normalize();\n
\t\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.\n
\t\t * You might then loose all your work so we need to block that behavior and replace it with our own.\n
\t\t */\n
\t\tfunction blockCmdArrowNavigation() {\n
\t\t\tif (Env.mac) {\n
\t\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\t\tif (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode == 37 || e.keyCode == 39)) {\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\teditor.selection.getSel().modify(\'move\', e.keyCode == 37 ? \'backward\' : \'forward\', \'lineboundary\');\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Disables the autolinking in IE 9+ this is then re-enabled by the autolink plugin.\n
\t\t */\n
\t\tfunction disableAutoUrlDetect() {\n
\t\t\tsetEditorCommandState("AutoUrlDetect", false);\n
\t\t}\n
\n
\t\t/**\n
\t\t * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when\n
\t\t * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync\n
\t\t * with innerHTML in this case. It\'s like IE adds shadow DOM BR elements that appears on innerHTML\n
\t\t * but not as the lastChild of the body. However is we add a BR element to the body then remove it\n
\t\t * it doesn\'t seem to add these BR elements makes sence right?!\n
\t\t *\n
\t\t * Example of what happens: <body>text</body> becomes <body>text<br><br></body>\n
\t\t */\n
\t\tfunction doubleTrailingBrElements() {\n
\t\t\tif (!editor.inline) {\n
\t\t\t\teditor.on(\'focus blur beforegetcontent\', function() {\n
\t\t\t\t\tvar br = editor.dom.create(\'br\');\n
\t\t\t\t\teditor.getBody().appendChild(br);\n
\t\t\t\t\tbr.parentNode.removeChild(br);\n
\t\t\t\t}, true);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * iOS 7.1 introduced two new bugs:\n
\t\t * 1) It\'s possible to open links within a contentEditable area by clicking on them.\n
\t\t * 2) If you hold down the finger it will display the link/image touch callout menu.\n
\t\t */\n
\t\tfunction tapLinksAndImages() {\n
\t\t\teditor.on(\'click\', function(e) {\n
\t\t\t\tvar elm = e.target;\n
\n
\t\t\t\tdo {\n
\t\t\t\t\tif (elm.tagName === \'A\') {\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\t\t\t\t} while ((elm = elm.parentNode));\n
\t\t\t});\n
\n
\t\t\teditor.contentStyles.push(\'.mce-content-body {-webkit-touch-callout: none}\');\n
\t\t}\n
\n
\t\t/**\n
\t\t * iOS Safari and possible other browsers have a bug where it won\'t fire\n
\t\t * a click event when a contentEditable is focused. This function fakes click events\n
\t\t * by using touchstart/touchend and measuring the time and distance travelled.\n
\t\t */\n
\t\t/*\n
\t\tfunction touchClickEvent() {\n
\t\t\teditor.on(\'touchstart\', function(e) {\n
\t\t\t\tvar elm, time, startTouch, changedTouches;\n
\n
\t\t\t\telm = e.target;\n
\t\t\t\ttime = new Date().getTime();\n
\t\t\t\tchangedTouches = e.changedTouches;\n
\n
\t\t\t\tif (!changedTouches || changedTouches.length > 1) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tstartTouch = changedTouches[0];\n
\n
\t\t\t\teditor.once(\'touchend\', function(e) {\n
\t\t\t\t\tvar endTouch = e.changedTouches[0], args;\n
\n
\t\t\t\t\tif (new Date().getTime() - time > 500) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\targs = {\n
\t\t\t\t\t\ttarget: elm\n
\t\t\t\t\t};\n
\n
\t\t\t\t\teach(\'pageX pageY clientX clientY screenX screenY\'.split(\' \'), function(key) {\n
\t\t\t\t\t\targs[key] = endTouch[key];\n
\t\t\t\t\t});\n
\n
\t\t\t\t\targs = editor.fire(\'click\', args);\n
\n
\t\t\t\t\tif (!args.isDefaultPrevented()) {\n
\t\t\t\t\t\t// iOS WebKit can\'t place the caret properly once\n
\t\t\t\t\t\t// you bind touch events so we need to do this manually\n
\t\t\t\t\t\t// TODO: Expand to the closest word? Touble tap still works.\n
\t\t\t\t\t\teditor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);\n
\t\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t});\n
\t\t}\n
\t\t*/\n
\n
\t\t/**\n
\t\t * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.\n
\t\t * For example this: <form><button></form>\n
\t\t */\n
\t\tfunction blockFormSubmitInsideEditor() {\n
\t\t\teditor.on(\'init\', function() {\n
\t\t\t\teditor.dom.bind(editor.getBody(), \'submit\', function(e) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t});\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.\n
\t\t *\n
\t\t * Scenario:\n
\t\t *  1) Create a table 2x2.\n
\t\t *  2) Select and copy cells A2-B2.\n
\t\t *  3) Paste and it will add BR element to table cell.\n
\t\t */\n
\t\tfunction removeAppleInterchangeBrs() {\n
\t\t\tparser.addNodeFilter(\'br\', function(nodes) {\n
\t\t\t\tvar i = nodes.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tif (nodes[i].attr(\'class\') == \'Apple-interchange-newline\') {\n
\t\t\t\t\t\tnodes[i].remove();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * IE cannot set custom contentType\'s on drag events, and also does not properly drag/drop between\n
\t\t * editors. This uses a special data:text/mce-internal URL to pass data when drag/drop between editors.\n
\t\t */\n
\t\tfunction ieInternalDragAndDrop() {\n
\t\t\teditor.on(\'dragstart\', function(e) {\n
\t\t\t\tsetMceInteralContent(e);\n
\t\t\t});\n
\n
\t\t\teditor.on(\'drop\', function(e) {\n
\t\t\t\tif (!isDefaultPrevented(e)) {\n
\t\t\t\t\tvar internalContent = getMceInternalContent(e);\n
\n
\t\t\t\t\tif (internalContent && internalContent.id != editor.id) {\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\tvar rng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, editor.getDoc());\n
\t\t\t\t\t\tselection.setRng(rng);\n
\t\t\t\t\t\tinsertClipboardContents(internalContent.html);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\t// All browsers\n
\t\tremoveBlockQuoteOnBackSpace();\n
\t\temptyEditorWhenDeleting();\n
\t\tnormalizeSelection();\n
\n
\t\t// WebKit\n
\t\tif (isWebKit) {\n
\t\t\tcleanupStylesWhenDeleting();\n
\t\t\tinputMethodFocus();\n
\t\t\tselectControlElements();\n
\t\t\tsetDefaultBlockType();\n
\t\t\tblockFormSubmitInsideEditor();\n
\t\t\tdisableBackspaceIntoATable();\n
\t\t\tremoveAppleInterchangeBrs();\n
\t\t\t//touchClickEvent();\n
\n
\t\t\t// iOS\n
\t\t\tif (Env.iOS) {\n
\t\t\t\trestoreFocusOnKeyDown();\n
\t\t\t\tbodyHeight();\n
\t\t\t\ttapLinksAndImages();\n
\t\t\t} else {\n
\t\t\t\tselectAll();\n
\t\t\t}\n
\t\t}\n
\n
\t\t// IE\n
\t\tif (isIE && Env.ie < 11) {\n
\t\t\tremoveHrOnBackspace();\n
\t\t\tensureBodyHasRoleApplication();\n
\t\t\taddNewLinesBeforeBrInPre();\n
\t\t\tremovePreSerializedStylesWhenSelectingControls();\n
\t\t\tdeleteControlItemOnBackSpace();\n
\t\t\trenderEmptyBlocksFix();\n
\t\t\tkeepNoScriptContents();\n
\t\t\tfixCaretSelectionOfDocumentElementOnIe();\n
\t\t}\n
\n
\t\tif (Env.ie >= 11) {\n
\t\t\tbodyHeight();\n
\t\t\tdoubleTrailingBrElements();\n
\t\t\tdisableBackspaceIntoATable();\n
\t\t}\n
\n
\t\tif (Env.ie) {\n
\t\t\tselectAll();\n
\t\t\tdisableAutoUrlDetect();\n
\t\t\tieInternalDragAndDrop();\n
\t\t}\n
\n
\t\t// Gecko\n
\t\tif (isGecko) {\n
\t\t\tremoveHrOnBackspace();\n
\t\t\tfocusBody();\n
\t\t\tremoveStylesWhenDeletingAcrossBlockElements();\n
\t\t\tsetGeckoEditingOptions();\n
\t\t\taddBrAfterLastLinks();\n
\t\t\tremoveGhostSelection();\n
\t\t\tshowBrokenImageIcon();\n
\t\t\tblockCmdArrowNavigation();\n
\t\t\tdisableBackspaceIntoATable();\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/EditorObservable.js\n
\n
/**\n
 * EditorObservable.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This mixin contains the event logic for the tinymce.Editor class.\n
 *\n
 * @mixin tinymce.EditorObservable\n
 * @extends tinymce.util.Observable\n
 */\n
define("tinymce/EditorObservable", [\n
\t"tinymce/util/Observable",\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/util/Tools"\n
], function(Observable, DOMUtils, Tools) {\n
\tvar DOM = DOMUtils.DOM, customEventRootDelegates;\n
\n
\t/**\n
\t * Returns the event target so for the specified event. Some events fire\n
\t * only on document, some fire on documentElement etc. This also handles the\n
\t * custom event root setting where it returns that element instead of the body.\n
\t *\n
\t * @private\n
\t * @param {tinymce.Editor} editor Editor instance to get event target from.\n
\t * @param {String} eventName Name of the event for example "click".\n
\t * @return {Element/Document} HTML Element or document target to bind on.\n
\t */\n
\tfunction getEventTarget(editor, eventName) {\n
\t\tif (eventName == \'selectionchange\') {\n
\t\t\treturn editor.getDoc();\n
\t\t}\n
\n
\t\t// Need to bind mousedown/mouseup etc to document not body in iframe mode\n
\t\t// Since the user might click on the HTML element not the BODY\n
\t\tif (!editor.inline && /^mouse|click|contextmenu|drop|dragover|dragend/.test(eventName)) {\n
\t\t\treturn editor.getDoc().documentElement;\n
\t\t}\n
\n
\t\t// Bind to event root instead of body if it\'s defined\n
\t\tif (editor.settings.event_root) {\n
\t\t\tif (!editor.eventRoot) {\n
\t\t\t\teditor.eventRoot = DOM.select(editor.settings.event_root)[0];\n
\t\t\t}\n
\n
\t\t\treturn editor.eventRoot;\n
\t\t}\n
\n
\t\treturn editor.getBody();\n
\t}\n
\n
\t/**\n
\t * Binds a event delegate for the specified name this delegate will fire\n
\t * the event to the editor dispatcher.\n
\t *\n
\t * @private\n
\t * @param {tinymce.Editor} editor Editor instance to get event target from.\n
\t * @param {String} eventName Name of the event for example "click".\n
\t */\n
\tfunction bindEventDelegate(editor, eventName) {\n
\t\tvar eventRootElm = getEventTarget(editor, eventName), delegate;\n
\n
\t\tif (!editor.delegates) {\n
\t\t\teditor.delegates = {};\n
\t\t}\n
\n
\t\tif (editor.delegates[eventName]) {\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tif (editor.settings.event_root) {\n
\t\t\tif (!customEventRootDelegates) {\n
\t\t\t\tcustomEventRootDelegates = {};\n
\t\t\t\teditor.editorManager.on(\'removeEditor\', function() {\n
\t\t\t\t\tvar name;\n
\n
\t\t\t\t\tif (!editor.editorManager.activeEditor) {\n
\t\t\t\t\t\tif (customEventRootDelegates) {\n
\t\t\t\t\t\t\tfor (name in customEventRootDelegates) {\n
\t\t\t\t\t\t\t\teditor.dom.unbind(getEventTarget(editor, name));\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tcustomEventRootDelegates = null;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (customEventRootDelegates[eventName]) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tdelegate = function(e) {\n
\t\t\t\tvar target = e.target, editors = editor.editorManager.editors, i = editors.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tvar body = editors[i].getBody();\n
\n
\t\t\t\t\tif (body === target || DOM.isChildOf(target, body)) {\n
\t\t\t\t\t\tif (!editors[i].hidden) {\n
\t\t\t\t\t\t\teditors[i].fire(eventName, e);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\tcustomEventRootDelegates[eventName] = delegate;\n
\t\t\tDOM.bind(eventRootElm, eventName, delegate);\n
\t\t} else {\n
\t\t\tdelegate = function(e) {\n
\t\t\t\tif (!editor.hidden) {\n
\t\t\t\t\teditor.fire(eventName, e);\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\tDOM.bind(eventRootElm, eventName, delegate);\n
\t\t\teditor.delegates[eventName] = delegate;\n
\t\t}\n
\t}\n
\n
\tvar EditorObservable = {\n
\t\t/**\n
\t\t * Bind any pending event delegates. This gets executed after the target body/document is created.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tbindPendingEventDelegates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tTools.each(self._pendingNativeEvents, function(name) {\n
\t\t\t\tbindEventDelegate(self, name);\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Toggles a native event on/off this is called by the EventDispatcher when\n
\t\t * the first native event handler is added and when the last native event handler is removed.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\ttoggleNativeEvent: function(name, state) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.settings.readonly) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Never bind focus/blur since the FocusManager fakes those\n
\t\t\tif (name == "focus" || name == "blur") {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (state) {\n
\t\t\t\tif (self.initialized) {\n
\t\t\t\t\tbindEventDelegate(self, name);\n
\t\t\t\t} else {\n
\t\t\t\t\tif (!self._pendingNativeEvents) {\n
\t\t\t\t\t\tself._pendingNativeEvents = [name];\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself._pendingNativeEvents.push(name);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t} else if (self.initialized) {\n
\t\t\t\tself.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n
\t\t\t\tdelete self.delegates[name];\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tunbindAllNativeEvents: function() {\n
\t\t\tvar self = this, name;\n
\n
\t\t\tif (self.delegates) {\n
\t\t\t\tfor (name in self.delegates) {\n
\t\t\t\t\tself.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n
\t\t\t\t}\n
\n
\t\t\t\tdelete self.delegates;\n
\t\t\t}\n
\n
\t\t\tif (!self.inline) {\n
\t\t\t\tself.getBody().onload = null;\n
\t\t\t\tself.dom.unbind(self.getWin());\n
\t\t\t\tself.dom.unbind(self.getDoc());\n
\t\t\t}\n
\n
\t\t\tself.dom.unbind(self.getBody());\n
\t\t\tself.dom.unbind(self.getContainer());\n
\t\t}\n
\t};\n
\n
\tEditorObservable = Tools.extend({}, Observable, EditorObservable);\n
\n
\treturn EditorObservable;\n
});\n
\n
// Included from: js/tinymce/classes/Shortcuts.js\n
\n
/**\n
 * Shortcuts.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Contains all logic for handling of keyboard shortcuts.\n
 *\n
 * @class tinymce.Shortcuts\n
 * @example\n
 * editor.shortcuts.add(\'ctrl+a\', function() {});\n
 * editor.shortcuts.add(\'meta+a\', function() {}); // "meta" maps to Command on Mac and Ctrl on PC\n
 * editor.shortcuts.add(\'ctrl+alt+a\', function() {});\n
 * editor.shortcuts.add(\'access+a\', function() {}); // "access" maps to ctrl+alt on Mac and shift+alt on PC\n
 */\n
define("tinymce/Shortcuts", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/Env"\n
], function(Tools, Env) {\n
\tvar each = Tools.each, explode = Tools.explode;\n
\n
\tvar keyCodeLookup = {\n
\t\t"f9": 120,\n
\t\t"f10": 121,\n
\t\t"f11": 122\n
\t};\n
\n
\tvar modifierNames = Tools.makeMap(\'alt,ctrl,shift,meta,access\');\n
\n
\treturn function(editor) {\n
\t\tvar self = this, shortcuts = {};\n
\n
\t\tfunction createShortcut(pattern, desc, cmdFunc, scope) {\n
\t\t\tvar id, key, shortcut;\n
\n
\t\t\tshortcut = {\n
\t\t\t\tfunc: cmdFunc,\n
\t\t\t\tscope: scope || editor,\n
\t\t\t\tdesc: editor.translate(desc)\n
\t\t\t};\n
\n
\t\t\t// Parse modifiers and keys ctrl+alt+b for example\n
\t\t\teach(explode(pattern, \'+\'), function(value) {\n
\t\t\t\tif (value in modifierNames) {\n
\t\t\t\t\tshortcut[value] = true;\n
\t\t\t\t} else {\n
\t\t\t\t\t// Allow numeric keycodes like ctrl+219 for ctrl+[\n
\t\t\t\t\tif (/^[0-9]{2,}$/.test(value)) {\n
\t\t\t\t\t\tshortcut.keyCode = parseInt(value, 10);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tshortcut.charCode = value.charCodeAt(0);\n
\t\t\t\t\t\tshortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Generate unique id for modifier combination and set default state for unused modifiers\n
\t\t\tid = [shortcut.keyCode];\n
\t\t\tfor (key in modifierNames) {\n
\t\t\t\tif (shortcut[key]) {\n
\t\t\t\t\tid.push(key);\n
\t\t\t\t} else {\n
\t\t\t\t\tshortcut[key] = false;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tshortcut.id = id.join(\',\');\n
\n
\t\t\t// Handle special access modifier differently depending on Mac/Win\n
\t\t\tif (shortcut.access) {\n
\t\t\t\tshortcut.alt = true;\n
\n
\t\t\t\tif (Env.mac) {\n
\t\t\t\t\tshortcut.ctrl = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tshortcut.shift = true;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Handle special meta modifier differently depending on Mac/Win\n
\t\t\tif (shortcut.meta) {\n
\t\t\t\tif (Env.mac) {\n
\t\t\t\t\tshortcut.meta = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tshortcut.ctrl = true;\n
\t\t\t\t\tshortcut.meta = false;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn shortcut;\n
\t\t}\n
\n
\t\teditor.on(\'keyup keypress keydown\', function(e) {\n
\t\t\tif ((e.altKey || e.ctrlKey || e.metaKey) && !e.isDefaultPrevented()) {\n
\t\t\t\teach(shortcuts, function(shortcut) {\n
\t\t\t\t\tif (shortcut.ctrl != e.ctrlKey || shortcut.meta != e.metaKey) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (e.keyCode == shortcut.keyCode || (e.charCode && e.charCode == shortcut.charCode)) {\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\tif (e.type == "keydown") {\n
\t\t\t\t\t\t\tshortcut.func.call(shortcut.scope);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\t\t});\n
\n
\t\t/**\n
\t\t * Adds a keyboard shortcut for some command or function.\n
\t\t *\n
\t\t * @method addShortcut\n
\t\t * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.\n
\t\t * @param {String} desc Text description for the command.\n
\t\t * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.\n
\t\t * @param {Object} sc Optional scope to execute the function in.\n
\t\t * @return {Boolean} true/false state if the shortcut was added or not.\n
\t\t */\n
\t\tself.add = function(pattern, desc, cmdFunc, scope) {\n
\t\t\tvar cmd;\n
\n
\t\t\tcmd = cmdFunc;\n
\n
\t\t\tif (typeof cmdFunc === \'string\') {\n
\t\t\t\tcmdFunc = function() {\n
\t\t\t\t\teditor.execCommand(cmd, false, null);\n
\t\t\t\t};\n
\t\t\t} else if (Tools.isArray(cmd)) {\n
\t\t\t\tcmdFunc = function() {\n
\t\t\t\t\teditor.execCommand(cmd[0], cmd[1], cmd[2]);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\teach(explode(pattern.toLowerCase()), function(pattern) {\n
\t\t\t\tvar shortcut = createShortcut(pattern, desc, cmdFunc, scope);\n
\t\t\t\tshortcuts[shortcut.id] = shortcut;\n
\t\t\t});\n
\n
\t\t\treturn true;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Remove a keyboard shortcut by pattern.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.\n
\t\t * @return {Boolean} true/false state if the shortcut was removed or not.\n
\t\t */\n
\t\tself.remove = function(pattern) {\n
\t\t\tvar shortcut = createShortcut(pattern);\n
\n
\t\t\tif (shortcuts[shortcut.id]) {\n
\t\t\t\tdelete shortcuts[shortcut.id];\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/Promise.js\n
\n
/**\n
 * Promise.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * Promise polyfill under MIT license: https://github.com/taylorhakes/promise-polyfill\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/* eslint-disable */\n
/* jshint ignore:start */\n
\n
/**\n
 * Modifed to be a feature fill and wrapped as tinymce module.\n
 */\n
define("tinymce/util/Promise", [], function() {\n
\tif (window.Promise) {\n
\t\treturn window.Promise;\n
\t}\n
\n
\t// Use polyfill for setImmediate for performance gains\n
\tvar asap = Promise.immediateFn || (typeof setImmediate === \'function\' && setImmediate) ||\n
\t\tfunction(fn) { setTimeout(fn, 1); };\n
\n
\t// Polyfill for Function.prototype.bind\n
\tfunction bind(fn, thisArg) {\n
\t\treturn function() {\n
\t\t\tfn.apply(thisArg, arguments);\n
\t\t};\n
\t}\n
\n
\tvar isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]"; };\n
\n
\tfunction Promise(fn) {\n
\t\tif (typeof this !== \'object\') throw new TypeError(\'Promises must be constructed via new\');\n
\t\tif (typeof fn !== \'function\') throw new TypeError(\'not a function\');\n
\t\tthis._state = null;\n
\t\tthis._value = null;\n
\t\tthis._deferreds = [];\n
\n
\t\tdoResolve(fn, bind(resolve, this), bind(reject, this));\n
\t}\n
\n
\tfunction handle(deferred) {\n
\t\tvar me = this;\n
\t\tif (this._state === null) {\n
\t\t\tthis._deferreds.push(deferred);\n
\t\t\treturn;\n
\t\t}\n
\t\tasap(function() {\n
\t\t\tvar cb = me._state ? deferred.onFulfilled : deferred.onRejected;\n
\t\t\tif (cb === null) {\n
\t\t\t\t(me._state ? deferred.resolve : deferred.reject)(me._value);\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t\tvar ret;\n
\t\t\ttry {\n
\t\t\t\tret = cb(me._value);\n
\t\t\t}\n
\t\t\tcatch (e) {\n
\t\t\t\tdeferred.reject(e);\n
\t\t\t\treturn;\n
\t\t\t}\n
\t\t\tdeferred.resolve(ret);\n
\t\t});\n
\t}\n
\n
\tfunction resolve(newValue) {\n
\t\ttry { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n
\t\t\tif (newValue === this) throw new TypeError(\'A promise cannot be resolved with itself.\');\n
\t\t\tif (newValue && (typeof newValue === \'object\' || typeof newValue === \'function\')) {\n
\t\t\t\tvar then = newValue.then;\n
\t\t\t\tif (typeof then === \'function\') {\n
\t\t\t\t\tdoResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tthis._state = true;\n
\t\t\tthis._value = newValue;\n
\t\t\tfinale.call(this);\n
\t\t} catch (e) { reject.call(this, e); }\n
\t}\n
\n
\tfunction reject(newValue) {\n
\t\tthis._state = false;\n
\t\tthis._value = newValue;\n
\t\tfinale.call(this);\n
\t}\n
\n
\tfunction finale() {\n
\t\tfor (var i = 0, len = this._deferreds.length; i < len; i++) {\n
\t\t\thandle.call(this, this._deferreds[i]);\n
\t\t}\n
\t\tthis._deferreds = null;\n
\t}\n
\n
\tfunction Handler(onFulfilled, onRejected, resolve, reject){\n
\t\tthis.onFulfilled = typeof onFulfilled === \'function\' ? onFulfilled : null;\n
\t\tthis.onRejected = typeof onRejected === \'function\' ? onRejected : null;\n
\t\tthis.resolve = resolve;\n
\t\tthis.reject = reject;\n
\t}\n
\n
\t/**\n
\t * Take a potentially misbehaving resolver function and make sure\n
\t * onFulfilled and onRejected are only called once.\n
\t *\n
\t * Makes no guarantees about asynchrony.\n
\t */\n
\tfunction doResolve(fn, onFulfilled, onRejected) {\n
\t\tvar done = false;\n
\t\ttry {\n
\t\t\tfn(function (value) {\n
\t\t\t\tif (done) return;\n
\t\t\t\tdone = true;\n
\t\t\t\tonFulfilled(value);\n
\t\t\t}, function (reason) {\n
\t\t\t\tif (done) return;\n
\t\t\t\tdone = true;\n
\t\t\t\tonRejected(reason);\n
\t\t\t});\n
\t\t} catch (ex) {\n
\t\t\tif (done) return;\n
\t\t\tdone = true;\n
\t\t\tonRejected(ex);\n
\t\t}\n
\t}\n
\n
\tPromise.prototype[\'catch\'] = function (onRejected) {\n
\t\treturn this.then(null, onRejected);\n
\t};\n
\n
\tPromise.prototype.then = function(onFulfilled, onRejected) {\n
\t\tvar me = this;\n
\t\treturn new Promise(function(resolve, reject) {\n
\t\t\thandle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));\n
\t\t});\n
\t};\n
\n
\tPromise.all = function () {\n
\t\tvar args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n
\n
\t\treturn new Promise(function (resolve, reject) {\n
\t\t\tif (args.length === 0) return resolve([]);\n
\t\t\tvar remaining = args.length;\n
\t\t\tfunction res(i, val) {\n
\t\t\t\ttry {\n
\t\t\t\t\tif (val && (typeof val === \'object\' || typeof val === \'function\')) {\n
\t\t\t\t\t\tvar then = val.then;\n
\t\t\t\t\t\tif (typeof then === \'function\') {\n
\t\t\t\t\t\t\tthen.call(val, function (val) { res(i, val); }, reject);\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t\targs[i] = val;\n
\t\t\t\t\tif (--remaining === 0) {\n
\t\t\t\t\t\tresolve(args);\n
\t\t\t\t\t}\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\treject(ex);\n
\t\t\t\t}\n
\t\t\t}\n
\t\t\tfor (var i = 0; i < args.length; i++) {\n
\t\t\t\tres(i, args[i]);\n
\t\t\t}\n
\t\t});\n
\t};\n
\n
\tPromise.resolve = function (value) {\n
\t\tif (value && typeof value === \'object\' && value.constructor === Promise) {\n
\t\t\treturn value;\n
\t\t}\n
\n
\t\treturn new Promise(function (resolve) {\n
\t\t\tresolve(value);\n
\t\t});\n
\t};\n
\n
\tPromise.reject = function (value) {\n
\t\treturn new Promise(function (resolve, reject) {\n
\t\t\treject(value);\n
\t\t});\n
\t};\n
\n
\tPromise.race = function (values) {\n
\t\treturn new Promise(function (resolve, reject) {\n
\t\t\tfor(var i = 0, len = values.length; i < len; i++) {\n
\t\t\t\tvalues[i].then(resolve, reject);\n
\t\t\t}\n
\t\t});\n
\t};\n
\n
\treturn Promise;\n
});\n
\n
/* jshint ignore:end */\n
/* eslint-enable */\n
\n
// Included from: js/tinymce/classes/file/Uploader.js\n
\n
/**\n
 * Uploader.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Upload blobs or blob infos to the specified URL or handler.\n
 *\n
 * @private\n
 * @class tinymce.file.Uploader\n
 * @example\n
 * v

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAA0=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="13" aka="AAAAAAAAAA0=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

ar uploader = new Uploader({\n
 *     url: \'/upload.php\',\n
 *     basePath: \'/base/path\',\n
 *     credentials: true,\n
 *     handler: function(data, success, failure) {\n
 *         ...\n
 *     }\n
 * });\n
 *\n
 * uploader.upload(blobInfos).then(function(result) {\n
 *     ...\n
 * });\n
 */\n
define("tinymce/file/Uploader", [\n
\t"tinymce/util/Promise",\n
\t"tinymce/util/Tools"\n
], function(Promise, Tools) {\n
\treturn function(settings) {\n
\t\tfunction fileName(blobInfo) {\n
\t\t\tvar ext, extensions;\n
\n
\t\t\textensions = {\n
\t\t\t\t\'image/jpeg\': \'jpg\',\n
\t\t\t\t\'image/jpg\': \'jpg\',\n
\t\t\t\t\'image/gif\': \'gif\',\n
\t\t\t\t\'image/png\': \'png\'\n
\t\t\t};\n
\n
\t\t\text = extensions[blobInfo.blob().type.toLowerCase()] || \'dat\';\n
\n
\t\t\treturn blobInfo.id() + \'.\' + ext;\n
\t\t}\n
\n
\t\tfunction pathJoin(path1, path2) {\n
\t\t\tif (path1) {\n
\t\t\t\treturn path1.replace(/\\/$/, \'\') + \'/\' + path2.replace(/^\\//, \'\');\n
\t\t\t}\n
\n
\t\t\treturn path2;\n
\t\t}\n
\n
\t\tfunction blobInfoToData(blobInfo) {\n
\t\t\treturn {\n
\t\t\t\tid: blobInfo.id,\n
\t\t\t\tblob: blobInfo.blob,\n
\t\t\t\tbase64: blobInfo.base64,\n
\t\t\t\tfilename: Tools.constant(fileName(blobInfo))\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction defaultHandler(blobInfo, success, failure) {\n
\t\t\tvar xhr, formData;\n
\n
\t\t\txhr = new XMLHttpRequest();\n
\t\t\txhr.withCredentials = settings.credentials;\n
\t\t\txhr.open(\'POST\', settings.url);\n
\n
\t\t\txhr.onload = function() {\n
\t\t\t\tvar json;\n
\n
\t\t\t\tif (xhr.status != 200) {\n
\t\t\t\t\tfailure("HTTP Error: " + xhr.status);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tjson = JSON.parse(xhr.responseText);\n
\n
\t\t\t\tif (!json || typeof json.location != "string") {\n
\t\t\t\t\tfailure("Invalid JSON: " + xhr.responseText);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tsuccess(pathJoin(settings.basePath, json.location));\n
\t\t\t};\n
\n
\t\t\tformData = new FormData();\n
\t\t\tformData.append(\'file\', blobInfo.blob(), fileName(blobInfo));\n
\n
\t\t\txhr.send(formData);\n
\t\t}\n
\n
\t\tfunction upload(blobInfos) {\n
\t\t\treturn new Promise(function(resolve, reject) {\n
\t\t\t\tvar handler = settings.handler, queue, index = 0, uploadedIdMap = {};\n
\n
\t\t\t\t// If no url is configured then resolve\n
\t\t\t\tif (!settings.url && handler === defaultHandler) {\n
\t\t\t\t\tresolve([]);\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tqueue = Tools.map(blobInfos, function(blobInfo) {\n
\t\t\t\t\treturn {\n
\t\t\t\t\t\tstatus: false,\n
\t\t\t\t\t\tblobInfo: blobInfo,\n
\t\t\t\t\t\turl: \'\'\n
\t\t\t\t\t};\n
\t\t\t\t});\n
\n
\t\t\t\tfunction uploadNext() {\n
\t\t\t\t\tvar previousResult, queueItem = queue[index++];\n
\n
\t\t\t\t\tif (!queueItem) {\n
\t\t\t\t\t\tresolve(queue);\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Only upload unique blob once\n
\t\t\t\t\tpreviousResult = uploadedIdMap[queueItem.blobInfo.id()];\n
\t\t\t\t\tif (previousResult) {\n
\t\t\t\t\t\tqueueItem.url = previousResult;\n
\t\t\t\t\t\tqueueItem.status = true;\n
\t\t\t\t\t\tuploadNext();\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\thandler(blobInfoToData(queueItem.blobInfo), function(url) {\n
\t\t\t\t\t\tuploadedIdMap[queueItem.blobInfo.id()] = url;\n
\t\t\t\t\t\tqueueItem.url = url;\n
\t\t\t\t\t\tqueueItem.status = true;\n
\t\t\t\t\t\tuploadNext();\n
\t\t\t\t\t}, function(failure) {\n
\t\t\t\t\t\tqueueItem.status = false;\n
\t\t\t\t\t\treject(failure);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\tuploadNext();\n
\t\t\t});\n
\t\t}\n
\n
\t\tsettings = Tools.extend({\n
\t\t\tcredentials: false,\n
\t\t\thandler: defaultHandler\n
\t\t}, settings);\n
\n
\t\treturn {\n
\t\t\tupload: upload\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/file/Conversions.js\n
\n
/**\n
 * Conversions.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Converts blob/uris back and forth.\n
 */\n
define("tinymce/file/Conversions", [\n
\t"tinymce/util/Promise"\n
], function(Promise) {\n
\tfunction blobUriToBlob(url) {\n
\t\treturn new Promise(function(resolve) {\n
\t\t\tvar xhr = new XMLHttpRequest();\n
\n
\t\t\txhr.open(\'GET\', url, true);\n
\t\t\txhr.responseType = \'blob\';\n
\n
\t\t\txhr.onload = function() {\n
\t\t\t\tif (this.status == 200) {\n
\t\t\t\t\tresolve(this.response);\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\txhr.send();\n
\t\t});\n
\t}\n
\n
\tfunction parseDataUri(uri) {\n
\t\tvar type, matches;\n
\n
\t\turi = decodeURIComponent(uri).split(\',\');\n
\n
\t\tmatches = /data:([^;]+)/.exec(uri[0]);\n
\t\tif (matches) {\n
\t\t\ttype = matches[1];\n
\t\t}\n
\n
\t\treturn {\n
\t\t\ttype: type,\n
\t\t\tdata: uri[1]\n
\t\t};\n
\t}\n
\n
\tfunction dataUriToBlob(uri) {\n
\t\treturn new Promise(function(resolve) {\n
\t\t\tvar str, arr, i;\n
\n
\t\t\turi = parseDataUri(uri);\n
\n
\t\t\t// Might throw error if data isn\'t proper base64\n
\t\t\ttry {\n
\t\t\t\tstr = atob(uri.data);\n
\t\t\t} catch (e) {\n
\t\t\t\tresolve(new Blob([]));\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tarr = new Uint8Array(str.length);\n
\n
\t\t\tfor (i = 0; i < arr.length; i++) {\n
\t\t\t\tarr[i] = str.charCodeAt(i);\n
\t\t\t}\n
\n
\t\t\tresolve(new Blob([arr], {type: uri.type}));\n
\t\t});\n
\t}\n
\n
\tfunction uriToBlob(url) {\n
\t\tif (url.indexOf(\'blob:\') === 0) {\n
\t\t\treturn blobUriToBlob(url);\n
\t\t}\n
\n
\t\tif (url.indexOf(\'data:\') === 0) {\n
\t\t\treturn dataUriToBlob(url);\n
\t\t}\n
\n
\t\treturn null;\n
\t}\n
\n
\tfunction blobToDataUri(blob) {\n
\t\treturn new Promise(function(resolve) {\n
\t\t\tvar reader = new FileReader();\n
\n
\t\t\treader.onloadend = function() {\n
\t\t\t\tresolve(reader.result);\n
\t\t\t};\n
\n
\t\t\treader.readAsDataURL(blob);\n
\t\t});\n
\t}\n
\n
\treturn {\n
\t\turiToBlob: uriToBlob,\n
\t\tblobToDataUri: blobToDataUri,\n
\t\tparseDataUri: parseDataUri\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/file/ImageScanner.js\n
\n
/**\n
 * ImageScanner.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.\n
 *\n
 * @private\n
 * @class tinymce.file.ImageScanner\n
 */\n
define("tinymce/file/ImageScanner", [\n
\t"tinymce/util/Promise",\n
\t"tinymce/util/Tools",\n
\t"tinymce/file/Conversions"\n
], function(Promise, Tools, Conversions) {\n
\tvar count = 0;\n
\n
\tfunction mapAsync(array, fn) {\n
\t\treturn new Promise(function(resolve) {\n
\t\t\tvar result = [];\n
\n
\t\t\tfunction next(index) {\n
\t\t\t\tfn(array[index], function(value) {\n
\t\t\t\t\tresult.push(value);\n
\n
\t\t\t\t\tif (index < array.length - 1) {\n
\t\t\t\t\t\tnext(index + 1);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tresolve(result);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (array.length === 0) {\n
\t\t\t\tresolve(result);\n
\t\t\t} else {\n
\t\t\t\tnext(0);\n
\t\t\t}\n
\t\t});\n
\t}\n
\n
\treturn {\n
\t\tfindAll: function(elm, blobCache) {\n
\t\t\tfunction imageToBlobInfo(img, resolve) {\n
\t\t\t\tvar base64, blobInfo, blobInfoId;\n
\n
\t\t\t\tif (img.src.indexOf(\'blob:\') === 0) {\n
\t\t\t\t\tblobInfo = blobCache.getByUri(img.src);\n
\n
\t\t\t\t\tif (blobInfo) {\n
\t\t\t\t\t\tresolve({\n
\t\t\t\t\t\t\timage: img,\n
\t\t\t\t\t\t\tblobInfo: blobInfo\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tblobInfoId = \'blobid\' + (count++);\n
\t\t\t\tbase64 = Conversions.parseDataUri(img.src).data;\n
\t\t\t\tblobInfo = blobCache.findFirst(function(cachedBlobInfo) {\n
\t\t\t\t\treturn cachedBlobInfo.base64() === base64;\n
\t\t\t\t});\n
\n
\t\t\t\tif (blobInfo) {\n
\t\t\t\t\tresolve({\n
\t\t\t\t\t\timage: img,\n
\t\t\t\t\t\tblobInfo: blobInfo\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\tConversions.uriToBlob(img.src).then(function(blob) {\n
\t\t\t\t\t\tvar blobInfo = blobCache.create(blobInfoId, blob, base64);\n
\n
\t\t\t\t\t\tblobCache.add(blobInfo);\n
\n
\t\t\t\t\t\tresolve({\n
\t\t\t\t\t\t\timage: img,\n
\t\t\t\t\t\t\tblobInfo: blobInfo\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn mapAsync(Tools.filter(elm.getElementsByTagName(\'img\'), function(img) {\n
\t\t\t\treturn img.src && (img.src.indexOf(\'data:\') === 0 || img.src.indexOf(\'blob:\') === 0);\n
\t\t\t}), imageToBlobInfo);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/file/BlobCache.js\n
\n
/**\n
 * BlobCache.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Hold blob info objects where a blob has extra internal information.\n
 *\n
 * @private\n
 * @class tinymce.file.BlobCache\n
 */\n
define("tinymce/file/BlobCache", [\n
\t"tinymce/util/Tools"\n
], function(Tools) {\n
\treturn function() {\n
\t\tvar cache = [], constant = Tools.constant;\n
\n
\t\tfunction create(id, blob, base64) {\n
\t\t\treturn {\n
\t\t\t\tid: constant(id),\n
\t\t\t\tblob: constant(blob),\n
\t\t\t\tbase64: constant(base64),\n
\t\t\t\tblobUri: constant(URL.createObjectURL(blob))\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction add(blobInfo) {\n
\t\t\tif (!get(blobInfo.id())) {\n
\t\t\t\tcache.push(blobInfo);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction get(id) {\n
\t\t\treturn findFirst(function(cachedBlobInfo) {\n
\t\t\t\treturn cachedBlobInfo.id() === id;\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction findFirst(predicate) {\n
\t\t\treturn Tools.grep(cache, predicate)[0];\n
\t\t}\n
\n
\t\tfunction getByUri(blobUri) {\n
\t\t\treturn findFirst(function(blobInfo) {\n
\t\t\t\treturn blobInfo.blobUri() == blobUri;\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction destroy() {\n
\t\t\tTools.each(cache, function(cachedBlobInfo) {\n
\t\t\t\tURL.revokeObjectURL(cachedBlobInfo.blobUri());\n
\t\t\t});\n
\n
\t\t\tcache = [];\n
\t\t}\n
\n
\t\treturn {\n
\t\t\tcreate: create,\n
\t\t\tadd: add,\n
\t\t\tget: get,\n
\t\t\tgetByUri: getByUri,\n
\t\t\tfindFirst: findFirst,\n
\t\t\tdestroy: destroy\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/EditorUpload.js\n
\n
/**\n
 * EditorUpload.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Handles image uploads, updates undo stack and patches over various internal functions.\n
 *\n
 * @private\n
 * @class tinymce.EditorUpload\n
 */\n
define("tinymce/EditorUpload", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/file/Uploader",\n
\t"tinymce/file/ImageScanner",\n
\t"tinymce/file/BlobCache"\n
], function(Tools, Uploader, ImageScanner, BlobCache) {\n
\treturn function(editor) {\n
\t\tvar blobCache = new BlobCache();\n
\n
\t\t// Replaces strings without regexps to avoid FF regexp to big issue\n
\t\tfunction replaceString(content, search, replace) {\n
\t\t\tvar index = 0;\n
\n
\t\t\tdo {\n
\t\t\t\tindex = content.indexOf(search, index);\n
\n
\t\t\t\tif (index !== -1) {\n
\t\t\t\t\tcontent = content.substring(0, index) + replace + content.substr(index + search.length);\n
\t\t\t\t\tindex += replace.length - search.length + 1;\n
\t\t\t\t}\n
\t\t\t} while (index !== -1);\n
\n
\t\t\treturn content;\n
\t\t}\n
\n
\t\tfunction replaceImageUrl(content, targetUrl, replacementUrl) {\n
\t\t\tcontent = replaceString(content, \'src="\' + targetUrl + \'"\', \'src="\' + replacementUrl + \'"\');\n
\t\t\tcontent = replaceString(content, \'data-mce-src="\' + targetUrl + \'"\', \'data-mce-src="\' + replacementUrl + \'"\');\n
\n
\t\t\treturn content;\n
\t\t}\n
\n
\t\tfunction replaceUrlInUndoStack(targetUrl, replacementUrl) {\n
\t\t\tTools.each(editor.undoManager.data, function(level) {\n
\t\t\t\tlevel.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction uploadImages(callback) {\n
\t\t\tvar uploader = new Uploader({\n
\t\t\t\turl: editor.settings.images_upload_url,\n
\t\t\t\tbasePath: editor.settings.images_upload_base_path,\n
\t\t\t\tcredentials: editor.settings.images_upload_credentials,\n
\t\t\t\thandler: editor.settings.images_upload_handler\n
\t\t\t});\n
\n
\t\t\tfunction imageInfosToBlobInfos(imageInfos) {\n
\t\t\t\treturn Tools.map(imageInfos, function(imageInfo) {\n
\t\t\t\t\treturn imageInfo.blobInfo;\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn scanForImages().then(imageInfosToBlobInfos).then(uploader.upload).then(function(result) {\n
\t\t\t\tresult = Tools.map(result, function(uploadInfo) {\n
\t\t\t\t\tvar image;\n
\n
\t\t\t\t\timage = editor.dom.select(\'img[src="\' + uploadInfo.blobInfo.blobUri() + \'"]\')[0];\n
\n
\t\t\t\t\tif (image) {\n
\t\t\t\t\t\treplaceUrlInUndoStack(image.src, uploadInfo.url);\n
\n
\t\t\t\t\t\teditor.$(image).attr({\n
\t\t\t\t\t\t\tsrc: uploadInfo.url,\n
\t\t\t\t\t\t\t\'data-mce-src\': editor.convertURL(uploadInfo.url, \'src\')\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn {\n
\t\t\t\t\t\telement: image,\n
\t\t\t\t\t\tstatus: uploadInfo.status\n
\t\t\t\t\t};\n
\t\t\t\t});\n
\n
\t\t\t\tif (callback) {\n
\t\t\t\t\tcallback(result);\n
\t\t\t\t}\n
\n
\t\t\t\treturn result;\n
\t\t\t}, function() {\n
\t\t\t\t// Silent\n
\t\t\t\t// TODO: Maybe execute some failure callback here?\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction scanForImages() {\n
\t\t\treturn ImageScanner.findAll(editor.getBody(), blobCache).then(function(result) {\n
\t\t\t\tTools.each(result, function(resultItem) {\n
\t\t\t\t\treplaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n
\t\t\t\t\tresultItem.image.src = resultItem.blobInfo.blobUri();\n
\t\t\t\t});\n
\n
\t\t\t\treturn result;\n
\t\t\t});\n
\t\t}\n
\n
\t\tfunction destroy() {\n
\t\t\tblobCache.destroy();\n
\t\t}\n
\n
\t\tfunction replaceBlobWithBase64(content) {\n
\t\t\treturn content.replace(/src="(blob:[^"]+)"/g, function(match, blobUri) {\n
\t\t\t\tvar blobInfo = blobCache.getByUri(blobUri);\n
\n
\t\t\t\tif (!blobInfo) {\n
\t\t\t\t\tblobInfo = Tools.reduce(editor.editorManager.editors, function(result, editor) {\n
\t\t\t\t\t\treturn result || editor.editorUpload.blobCache.getByUri(blobUri);\n
\t\t\t\t\t}, null);\n
\t\t\t\t}\n
\n
\t\t\t\tif (blobInfo) {\n
\t\t\t\t\treturn \'src="data:\' + blobInfo.blob().type + \';base64,\' + blobInfo.base64() + \'"\';\n
\t\t\t\t}\n
\n
\t\t\t\treturn match[0];\n
\t\t\t});\n
\t\t}\n
\n
\t\teditor.on(\'setContent paste\', scanForImages);\n
\n
\t\teditor.on(\'RawSaveContent\', function(e) {\n
\t\t\te.content = replaceBlobWithBase64(e.content);\n
\t\t});\n
\n
\t\teditor.on(\'getContent\', function(e) {\n
\t\t\tif (e.source_view || e.format == \'raw\') {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\te.content = replaceBlobWithBase64(e.content);\n
\t\t});\n
\n
\t\treturn {\n
\t\t\tblobCache: blobCache,\n
\t\t\tuploadImages: uploadImages,\n
\t\t\tscanForImages: scanForImages,\n
\t\t\tdestroy: destroy\n
\t\t};\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/Editor.js\n
\n
/**\n
 * Editor.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*jshint scripturl:true */\n
\n
/**\n
 * Include the base event class documentation.\n
 *\n
 * @include ../../../tools/docs/tinymce.Event.js\n
 */\n
\n
/**\n
 * This class contains the core logic for a TinyMCE editor.\n
 *\n
 * @class tinymce.Editor\n
 * @mixes tinymce.util.Observable\n
 * @example\n
 * // Add a class to all paragraphs in the editor.\n
 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'someclass\');\n
 *\n
 * // Gets the current editors selection as text\n
 * tinymce.activeEditor.selection.getContent({format: \'text\'});\n
 *\n
 * // Creates a new editor instance\n
 * var ed = new tinymce.Editor(\'textareaid\', {\n
 *     some_setting: 1\n
 * }, tinymce.EditorManager);\n
 *\n
 * // Select each item the user clicks on\n
 * ed.on(\'click\', function(e) {\n
 *     ed.selection.select(e.target);\n
 * });\n
 *\n
 * ed.render();\n
 */\n
define("tinymce/Editor", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/AddOnManager",\n
\t"tinymce/NodeChange",\n
\t"tinymce/html/Node",\n
\t"tinymce/dom/Serializer",\n
\t"tinymce/html/Serializer",\n
\t"tinymce/dom/Selection",\n
\t"tinymce/Formatter",\n
\t"tinymce/UndoManager",\n
\t"tinymce/EnterKey",\n
\t"tinymce/ForceBlocks",\n
\t"tinymce/EditorCommands",\n
\t"tinymce/util/URI",\n
\t"tinymce/dom/ScriptLoader",\n
\t"tinymce/dom/EventUtils",\n
\t"tinymce/WindowManager",\n
\t"tinymce/html/Schema",\n
\t"tinymce/html/DomParser",\n
\t"tinymce/util/Quirks",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/EditorObservable",\n
\t"tinymce/Shortcuts",\n
\t"tinymce/EditorUpload"\n
], function(\n
\tDOMUtils, DomQuery, AddOnManager, NodeChange, Node, DomSerializer, Serializer,\n
\tSelection, Formatter, UndoManager, EnterKey, ForceBlocks, EditorCommands,\n
\tURI, ScriptLoader, EventUtils, WindowManager,\n
\tSchema, DomParser, Quirks, Env, Tools, EditorObservable, Shortcuts, EditorUpload\n
) {\n
\t// Shorten these names\n
\tvar DOM = DOMUtils.DOM, ThemeManager = AddOnManager.ThemeManager, PluginManager = AddOnManager.PluginManager;\n
\tvar extend = Tools.extend, each = Tools.each, explode = Tools.explode;\n
\tvar inArray = Tools.inArray, trim = Tools.trim, resolve = Tools.resolve;\n
\tvar Event = EventUtils.Event;\n
\tvar isGecko = Env.gecko, ie = Env.ie;\n
\n
\t/**\n
\t * Include documentation for all the events.\n
\t *\n
\t * @include ../../../tools/docs/tinymce.Editor.js\n
\t */\n
\n
\t/**\n
\t * Constructs a editor instance by id.\n
\t *\n
\t * @constructor\n
\t * @method Editor\n
\t * @param {String} id Unique id for the editor.\n
\t * @param {Object} settings Settings for the editor.\n
\t * @param {tinymce.EditorManager} editorManager EditorManager instance.\n
\t */\n
\tfunction Editor(id, settings, editorManager) {\n
\t\tvar self = this, documentBaseUrl, baseUri;\n
\n
\t\tdocumentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;\n
\t\tbaseUri = editorManager.baseURI;\n
\n
\t\t/**\n
\t\t * Name/value collection with editor settings.\n
\t\t *\n
\t\t * @property settings\n
\t\t * @type Object\n
\t\t * @example\n
\t\t * // Get the value of the theme setting\n
\t\t * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");\n
\t\t */\n
\t\tself.settings = settings = extend({\n
\t\t\tid: id,\n
\t\t\ttheme: \'modern\',\n
\t\t\tdelta_width: 0,\n
\t\t\tdelta_height: 0,\n
\t\t\tpopup_css: \'\',\n
\t\t\tplugins: \'\',\n
\t\t\tdocument_base_url: documentBaseUrl,\n
\t\t\tadd_form_submit_trigger: true,\n
\t\t\tsubmit_patch: true,\n
\t\t\tadd_unload_trigger: true,\n
\t\t\tconvert_urls: true,\n
\t\t\trelative_urls: true,\n
\t\t\tremove_script_host: true,\n
\t\t\tobject_resizing: true,\n
\t\t\tdoctype: \'<!DOCTYPE html>\',\n
\t\t\tvisual: true,\n
\t\t\tfont_size_style_values: \'xx-small,x-small,small,medium,large,x-large,xx-large\',\n
\n
\t\t\t// See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size\n
\t\t\tfont_size_legacy_values: \'xx-small,small,medium,large,x-large,xx-large,300%\',\n
\t\t\tforced_root_block: \'p\',\n
\t\t\thidden_input: true,\n
\t\t\tpadd_empty_editor: true,\n
\t\t\trender_ui: true,\n
\t\t\tindentation: \'30px\',\n
\t\t\tinline_styles: true,\n
\t\t\tconvert_fonts_to_spans: true,\n
\t\t\tindent: \'simple\',\n
\t\t\tindent_before: \'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,\' +\n
\t\t\t\t\'tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist\',\n
\t\t\tindent_after: \'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,\' +\n
\t\t\t\t\'tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist\',\n
\t\t\tvalidate: true,\n
\t\t\tentity_encoding: \'named\',\n
\t\t\turl_converter: self.convertURL,\n
\t\t\turl_converter_scope: self,\n
\t\t\tie7_compat: true\n
\t\t}, settings);\n
\n
\t\tAddOnManager.language = settings.language || \'en\';\n
\t\tAddOnManager.languageLoad = settings.language_load;\n
\n
\t\tAddOnManager.baseURL = editorManager.baseURL;\n
\n
\t\t/**\n
\t\t * Editor instance id, normally the same as the div/textarea that was replaced.\n
\t\t *\n
\t\t * @property id\n
\t\t * @type String\n
\t\t */\n
\t\tself.id = settings.id = id;\n
\n
\t\t/**\n
\t\t * State to force the editor to return false on a isDirty call.\n
\t\t *\n
\t\t * @property isNotDirty\n
\t\t * @type Boolean\n
\t\t * @example\n
\t\t * function ajaxSave() {\n
\t\t *     var ed = tinymce.get(\'elm1\');\n
\t\t *\n
\t\t *     // Save contents using some XHR call\n
\t\t *     alert(ed.getContent());\n
\t\t *\n
\t\t *     ed.isNotDirty = true; // Force not dirty state\n
\t\t * }\n
\t\t */\n
\t\tself.isNotDirty = true;\n
\n
\t\t/**\n
\t\t * Name/Value object containting plugin instances.\n
\t\t *\n
\t\t * @property plugins\n
\t\t * @type Object\n
\t\t * @example\n
\t\t * // Execute a method inside a plugin directly\n
\t\t * tinymce.activeEditor.plugins.someplugin.someMethod();\n
\t\t */\n
\t\tself.plugins = {};\n
\n
\t\t/**\n
\t\t * URI object to document configured for the TinyMCE instance.\n
\t\t *\n
\t\t * @property documentBaseURI\n
\t\t * @type tinymce.util.URI\n
\t\t * @example\n
\t\t * // Get relative URL from the location of document_base_url\n
\t\t * tinymce.activeEditor.documentBaseURI.toRelative(\'/somedir/somefile.htm\');\n
\t\t *\n
\t\t * // Get absolute URL from the location of document_base_url\n
\t\t * tinymce.activeEditor.documentBaseURI.toAbsolute(\'somefile.htm\');\n
\t\t */\n
\t\tself.documentBaseURI = new URI(settings.document_base_url || documentBaseUrl, {\n
\t\t\tbase_uri: baseUri\n
\t\t});\n
\n
\t\t/**\n
\t\t * URI object to current document that holds the TinyMCE editor instance.\n
\t\t *\n
\t\t * @property baseURI\n
\t\t * @type tinymce.util.URI\n
\t\t * @example\n
\t\t * // Get relative URL from the location of the API\n
\t\t * tinymce.activeEditor.baseURI.toRelative(\'/somedir/somefile.htm\');\n
\t\t *\n
\t\t * // Get absolute URL from the location of the API\n
\t\t * tinymce.activeEditor.baseURI.toAbsolute(\'somefile.htm\');\n
\t\t */\n
\t\tself.baseURI = baseUri;\n
\n
\t\t/**\n
\t\t * Array with CSS files to load into the iframe.\n
\t\t *\n
\t\t * @property contentCSS\n
\t\t * @type Array\n
\t\t */\n
\t\tself.contentCSS = [];\n
\n
\t\t/**\n
\t\t * Array of CSS styles to add to head of document when the editor loads.\n
\t\t *\n
\t\t * @property contentStyles\n
\t\t * @type Array\n
\t\t */\n
\t\tself.contentStyles = [];\n
\n
\t\t// Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic\n
\t\tself.shortcuts = new Shortcuts(self);\n
\t\tself.loadedCSS = {};\n
\t\tself.editorCommands = new EditorCommands(self);\n
\n
\t\tif (settings.target) {\n
\t\t\tself.targetElm = settings.target;\n
\t\t}\n
\n
\t\tself.suffix = editorManager.suffix;\n
\t\tself.editorManager = editorManager;\n
\t\tself.inline = settings.inline;\n
\n
\t\tif (settings.cache_suffix) {\n
\t\t\tEnv.cacheSuffix = settings.cache_suffix.replace(/^[\\?\\&]+/, \'\');\n
\t\t}\n
\n
\t\tif (settings.override_viewport === false) {\n
\t\t\tEnv.overrideViewPort = false;\n
\t\t}\n
\n
\t\t// Call setup\n
\t\teditorManager.fire(\'SetupEditor\', self);\n
\t\tself.execCallback(\'setup\', self);\n
\n
\t\t/**\n
\t\t * Dom query instance with default scope to the editor document and default element is the body of the editor.\n
\t\t *\n
\t\t * @property $\n
\t\t * @type tinymce.dom.DomQuery\n
\t\t * @example\n
\t\t * tinymce.activeEditor.$(\'p\').css(\'color\', \'red\');\n
\t\t * tinymce.activeEditor.$().append(\'<p>new</p>\');\n
\t\t */\n
\t\tself.$ = DomQuery.overrideDefaults(function() {\n
\t\t\treturn {\n
\t\t\t\tcontext: self.inline ? self.getBody() : self.getDoc(),\n
\t\t\t\telement: self.getBody()\n
\t\t\t};\n
\t\t});\n
\t}\n
\n
\tEditor.prototype = {\n
\t\t/**\n
\t\t * Renderes the editor/adds it to the page.\n
\t\t *\n
\t\t * @method render\n
\t\t */\n
\t\trender: function() {\n
\t\t\tvar self = this, settings = self.settings, id = self.id, suffix = self.suffix;\n
\n
\t\t\tfunction readyHandler() {\n
\t\t\t\tDOM.unbind(window, \'ready\', readyHandler);\n
\t\t\t\tself.render();\n
\t\t\t}\n
\n
\t\t\t// Page is not loaded yet, wait for it\n
\t\t\tif (!Event.domLoaded) {\n
\t\t\t\tDOM.bind(window, \'ready\', readyHandler);\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Element not found, then skip initialization\n
\t\t\tif (!self.getElement()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// No editable support old iOS versions etc\n
\t\t\tif (!Env.contentEditable) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Hide target element early to prevent content flashing\n
\t\t\tif (!settings.inline) {\n
\t\t\t\tself.orgVisibility = self.getElement().style.visibility;\n
\t\t\t\tself.getElement().style.visibility = \'hidden\';\n
\t\t\t} else {\n
\t\t\t\tself.inline = true;\n
\t\t\t}\n
\n
\t\t\tvar form = self.getElement().form || DOM.getParent(id, \'form\');\n
\t\t\tif (form) {\n
\t\t\t\tself.formElement = form;\n
\n
\t\t\t\t// Add hidden input for non input elements inside form elements\n
\t\t\t\tif (settings.hidden_input && !/TEXTAREA|INPUT/i.test(self.getElement().nodeName)) {\n
\t\t\t\t\tDOM.insertAfter(DOM.create(\'input\', {type: \'hidden\', name: id}), id);\n
\t\t\t\t\tself.hasHiddenInput = true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Pass submit/reset from form to editor instance\n
\t\t\t\tself.formEventDelegate = function(e) {\n
\t\t\t\t\tself.fire(e.type, e);\n
\t\t\t\t};\n
\n
\t\t\t\tDOM.bind(form, \'submit reset\', self.formEventDelegate);\n
\n
\t\t\t\t// Reset contents in editor when the form is reset\n
\t\t\t\tself.on(\'reset\', function() {\n
\t\t\t\t\tself.setContent(self.startContent, {format: \'raw\'});\n
\t\t\t\t});\n
\n
\t\t\t\t// Check page uses id="submit" or name="submit" for it\'s submit button\n
\t\t\t\tif (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n
\t\t\t\t\tform._mceOldSubmit = form.submit;\n
\t\t\t\t\tform.submit = function() {\n
\t\t\t\t\t\tself.editorManager.triggerSave();\n
\t\t\t\t\t\tself.isNotDirty = true;\n
\n
\t\t\t\t\t\treturn form._mceOldSubmit(form);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Window manager reference, use this to open new windows and dialogs.\n
\t\t\t *\n
\t\t\t * @property windowManager\n
\t\t\t * @type tinymce.WindowManager\n
\t\t\t * @example\n
\t\t\t * // Shows an alert message\n
\t\t\t * tinymce.activeEditor.windowManager.alert(\'Hello world!\');\n
\t\t\t *\n
\t\t\t * // Opens a new dialog with the file.htm file and the size 320x240\n
\t\t\t * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.\n
\t\t\t * tinymce.activeEditor.windowManager.open({\n
\t\t\t *    url: \'file.htm\',\n
\t\t\t *    width: 320,\n
\t\t\t *    height: 240\n
\t\t\t * }, {\n
\t\t\t *    custom_param: 1\n
\t\t\t * });\n
\t\t\t */\n
\t\t\tself.windowManager = new WindowManager(self);\n
\n
\t\t\tif (settings.encoding == \'xml\') {\n
\t\t\t\tself.on(\'GetContent\', function(e) {\n
\t\t\t\t\tif (e.save) {\n
\t\t\t\t\t\te.content = DOM.encode(e.content);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (settings.add_form_submit_trigger) {\n
\t\t\t\tself.on(\'submit\', function() {\n
\t\t\t\t\tif (self.initialized) {\n
\t\t\t\t\t\tself.save();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (settings.add_unload_trigger) {\n
\t\t\t\tself._beforeUnload = function() {\n
\t\t\t\t\tif (self.initialized && !self.destroyed && !self.isHidden()) {\n
\t\t\t\t\t\tself.save({format: \'raw\', no_events: true, set_dirty: false});\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\tself.editorManager.on(\'BeforeUnload\', self._beforeUnload);\n
\t\t\t}\n
\n
\t\t\t// Load scripts\n
\t\t\tfunction loadScripts() {\n
\t\t\t\tvar scriptLoader = ScriptLoader.ScriptLoader;\n
\n
\t\t\t\tif (settings.language && settings.language != \'en\' && !settings.language_url) {\n
\t\t\t\t\tsettings.language_url = self.editorManager.baseURL + \'/langs/\' + settings.language + \'.js\';\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.language_url) {\n
\t\t\t\t\tscriptLoader.add(settings.language_url);\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.theme && typeof settings.theme != "function" &&\n
\t\t\t\t\tsettings.theme.charAt(0) != \'-\' && !ThemeManager.urls[settings.theme]) {\n
\t\t\t\t\tvar themeUrl = settings.theme_url;\n
\n
\t\t\t\t\tif (themeUrl) {\n
\t\t\t\t\t\tthemeUrl = self.documentBaseURI.toAbsolute(themeUrl);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tthemeUrl = \'themes/\' + settings.theme + \'/theme\' + suffix + \'.js\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tThemeManager.load(settings.theme, themeUrl);\n
\t\t\t\t}\n
\n
\t\t\t\tif (Tools.isArray(settings.plugins)) {\n
\t\t\t\t\tsettings.plugins = settings.plugins.join(\' \');\n
\t\t\t\t}\n
\n
\t\t\t\teach(settings.external_plugins, function(url, name) {\n
\t\t\t\t\tPluginManager.load(name, url);\n
\t\t\t\t\tsettings.plugins += \' \' + name;\n
\t\t\t\t});\n
\n
\t\t\t\teach(settings.plugins.split(/[ ,]/), function(plugin) {\n
\t\t\t\t\tplugin = trim(plugin);\n
\n
\t\t\t\t\tif (plugin && !PluginManager.urls[plugin]) {\n
\t\t\t\t\t\tif (plugin.charAt(0) == \'-\') {\n
\t\t\t\t\t\t\tplugin = plugin.substr(1, plugin.length);\n
\n
\t\t\t\t\t\t\tvar dependencies = PluginManager.dependencies(plugin);\n
\n
\t\t\t\t\t\t\teach(dependencies, function(dep) {\n
\t\t\t\t\t\t\t\tvar defaultSettings = {\n
\t\t\t\t\t\t\t\t\tprefix: \'plugins/\',\n
\t\t\t\t\t\t\t\t\tresource: dep,\n
\t\t\t\t\t\t\t\t\tsuffix: \'/plugin\' + suffix + \'.js\'\n
\t\t\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\t\t\tdep = PluginManager.createUrl(defaultSettings, dep);\n
\t\t\t\t\t\t\t\tPluginManager.load(dep.resource, dep);\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tPluginManager.load(plugin, {\n
\t\t\t\t\t\t\t\tprefix: \'plugins/\',\n
\t\t\t\t\t\t\t\tresource: plugin,\n
\t\t\t\t\t\t\t\tsuffix: \'/plugin\' + suffix + \'.js\'\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tscriptLoader.loadQueue(function() {\n
\t\t\t\t\tif (!self.removed) {\n
\t\t\t\t\t\tself.init();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tloadScripts();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the editor this will be called automatically when\n
\t\t * all plugins/themes and language packs are loaded by the rendered method.\n
\t\t * This method will setup the iframe and create the theme and plugin instances.\n
\t\t *\n
\t\t * @method init\n
\t\t */\n
\t\tinit: function() {\n
\t\t\tvar self = this, settings = self.settings, elm = self.getElement();\n
\t\t\tvar w, h, minHeight, n, o, Theme, url, bodyId, bodyClass, re, i, initializedPlugins = [];\n
\n
\t\t\tthis.editorManager.i18n.setCode(settings.language);\n
\t\t\tself.rtl = settings.rtl_ui || this.editorManager.i18n.rtl;\n
\t\t\tself.editorManager.add(self);\n
\n
\t\t\tsettings.aria_label = settings.aria_label || DOM.getAttrib(elm, \'aria-label\', self.getLang(\'aria.rich_text_area\'));\n
\n
\t\t\t/**\n
\t\t\t * Reference to the theme instance that was used to generate the UI.\n
\t\t\t *\n
\t\t\t * @property theme\n
\t\t\t * @type tinymce.Theme\n
\t\t\t * @example\n
\t\t\t * // Executes a method on the theme directly\n
\t\t\t * tinymce.activeEditor.theme.someMethod();\n
\t\t\t */\n
\t\t\tif (settings.theme) {\n
\t\t\t\tif (typeof settings.theme != "function") {\n
\t\t\t\t\tsettings.theme = settings.theme.replace(/-/, \'\');\n
\t\t\t\t\tTheme = ThemeManager.get(settings.theme);\n
\t\t\t\t\tself.theme = new Theme(self, ThemeManager.urls[settings.theme]);\n
\n
\t\t\t\t\tif (self.theme.init) {\n
\t\t\t\t\t\tself.theme.init(self, ThemeManager.urls[settings.theme] || self.documentBaseUrl.replace(/\\/$/, \'\'), self.$);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tself.theme = settings.theme;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction initPlugin(plugin) {\n
\t\t\t\tvar Plugin = PluginManager.get(plugin), pluginUrl, pluginInstance;\n
\n
\t\t\t\tpluginUrl = PluginManager.urls[plugin] || self.documentBaseUrl.replace(/\\/$/, \'\');\n
\t\t\t\tplugin = trim(plugin);\n
\t\t\t\tif (Plugin && inArray(initializedPlugins, plugin) === -1) {\n
\t\t\t\t\teach(PluginManager.dependencies(plugin), function(dep) {\n
\t\t\t\t\t\tinitPlugin(dep);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tpluginInstance = new Plugin(self, pluginUrl, self.$);\n
\n
\t\t\t\t\tself.plugins[plugin] = pluginInstance;\n
\n
\t\t\t\t\tif (pluginInstance.init) {\n
\t\t\t\t\t\tpluginInstance.init(self, pluginUrl);\n
\t\t\t\t\t\tinitializedPlugins.push(plugin);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Create all plugins\n
\t\t\teach(settings.plugins.replace(/\\-/g, \'\').split(/[ ,]/), initPlugin);\n
\n
\t\t\t// Measure box\n
\t\t\tif (settings.render_ui && self.theme) {\n
\t\t\t\tself.orgDisplay = elm.style.display;\n
\n
\t\t\t\tif (typeof settings.theme != "function") {\n
\t\t\t\t\tw = settings.width || elm.style.width || elm.offsetWidth;\n
\t\t\t\t\th = settings.height || elm.style.height || elm.offsetHeight;\n
\t\t\t\t\tminHeight = settings.min_height || 100;\n
\t\t\t\t\tre = /^[0-9\\.]+(|px)$/i;\n
\n
\t\t\t\t\tif (re.test(\'\' + w)) {\n
\t\t\t\t\t\tw = Math.max(parseInt(w, 10), 100);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (re.test(\'\' + h)) {\n
\t\t\t\t\t\th = Math.max(parseInt(h, 10), minHeight);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Render UI\n
\t\t\t\t\to = self.theme.renderUI({\n
\t\t\t\t\t\ttargetNode: elm,\n
\t\t\t\t\t\twidth: w,\n
\t\t\t\t\t\theight: h,\n
\t\t\t\t\t\tdeltaWidth: settings.delta_width,\n
\t\t\t\t\t\tdeltaHeight: settings.delta_height\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Resize editor\n
\t\t\t\t\tif (!settings.content_editable) {\n
\t\t\t\t\t\th = (o.iframeHeight || h) + (typeof h == \'number\' ? (o.deltaHeight || 0) : \'\');\n
\t\t\t\t\t\tif (h < minHeight) {\n
\t\t\t\t\t\t\th = minHeight;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\to = settings.theme(self, elm);\n
\n
\t\t\t\t\t// Convert element type to id:s\n
\t\t\t\t\tif (o.editorContainer.nodeType) {\n
\t\t\t\t\t\to.editorContainer = o.editorContainer.id = o.editorContainer.id || self.id + "_parent";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Convert element type to id:s\n
\t\t\t\t\tif (o.iframeContainer.nodeType) {\n
\t\t\t\t\t\to.iframeContainer = o.iframeContainer.id = o.iframeContainer.id || self.id + "_iframecontainer";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Use specified iframe height or the targets offsetHeight\n
\t\t\t\t\th = o.iframeHeight || elm.offsetHeight;\n
\t\t\t\t}\n
\n
\t\t\t\tself.editorContainer = o.editorContainer;\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\tif (settings.content_css) {\n
\t\t\t\teach(explode(settings.content_css), function(u) {\n
\t\t\t\t\tself.contentCSS.push(self.documentBaseURI.toAbsolute(u));\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\tif (settings.content_style) {\n
\t\t\t\tself.contentStyles.push(settings.content_style);\n
\t\t\t}\n
\n
\t\t\t// Content editable mode ends here\n
\t\t\tif (settings.content_editable) {\n
\t\t\t\telm = n = o = null; // Fix IE leak\n
\t\t\t\treturn self.initContentBody();\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML = settings.doctype + \'<html><head>\';\n
\n
\t\t\t// We only need to override paths if we have to\n
\t\t\t// IE has a bug where it remove site absolute urls to relative ones if this is specified\n
\t\t\tif (settings.document_base_url != self.documentBaseUrl) {\n
\t\t\t\tself.iframeHTML += \'<base href="\' + self.documentBaseURI.getURI() + \'" />\';\n
\t\t\t}\n
\n
\t\t\t// IE8 doesn\'t support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.\n
\t\t\tif (!Env.caretAfter && settings.ie7_compat) {\n
\t\t\t\tself.iframeHTML += \'<meta http-equiv="X-UA-Compatible" content="IE=7" />\';\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML += \'<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\';\n
\n
\t\t\t// Load the CSS by injecting them into the HTML this will reduce "flicker"\n
\t\t\tfor (i = 0; i < self.contentCSS.length; i++) {\n
\t\t\t\tvar cssUrl = self.contentCSS[i];\n
\t\t\t\tself.iframeHTML += (\n
\t\t\t\t\t\'<link type="text/css" \' +\n
\t\t\t\t\t\t\'rel="stylesheet" \' +\n
\t\t\t\t\t\t\'href="\' + Tools._addCacheSuffix(cssUrl) + \'" />\'\n
\t\t\t\t);\n
\t\t\t\tself.loadedCSS[cssUrl] = true;\n
\t\t\t}\n
\n
\t\t\tbodyId = settings.body_id || \'tinymce\';\n
\t\t\tif (bodyId.indexOf(\'=\') != -1) {\n
\t\t\t\tbodyId = self.getParam(\'body_id\', \'\', \'hash\');\n
\t\t\t\tbodyId = bodyId[self.id] || bodyId;\n
\t\t\t}\n
\n
\t\t\tbodyClass = settings.body_class || \'\';\n
\t\t\tif (bodyClass.indexOf(\'=\') != -1) {\n
\t\t\t\tbodyClass = self.getParam(\'body_class\', \'\', \'hash\');\n
\t\t\t\tbodyClass = bodyClass[self.id] || \'\';\n
\t\t\t}\n
\n
\t\t\tif (settings.content_security_policy) {\n
\t\t\t\tself.iframeHTML += \'<meta http-equiv="Content-Security-Policy" content="\' + settings.content_security_policy + \'" />\';\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML += \'</head><body id="\' + bodyId +\n
\t\t\t\t\'" class="mce-content-body \' + bodyClass +\n
\t\t\t\t\'" data-id="\' + self.id + \'"><br></body></html>\';\n
\n
\t\t\t/*eslint no-script-url:0 */\n
\t\t\tvar domainRelaxUrl = \'javascript:(function(){\' +\n
\t\t\t\t\'document.open();document.domain="\' + document.domain + \'";\' +\n
\t\t\t\t\'var ed = window.parent.tinymce.get("\' + self.id + \'");document.write(ed.iframeHTML);\' +\n
\t\t\t\t\'document.close();ed.initContentBody(true);})()\';\n
\n
\t\t\t// Domain relaxing is required since the user has messed around with document.domain\n
\t\t\tif (document.domain != location.hostname) {\n
\t\t\t\turl = domainRelaxUrl;\n
\t\t\t}\n
\n
\t\t\t// Create iframe\n
\t\t\t// TODO: ACC add the appropriate description on this.\n
\t\t\tvar ifr = DOM.create(\'iframe\', {\n
\t\t\t\tid: self.id + "_ifr",\n
\t\t\t\t//src: url || \'javascript:""\', // Workaround for HTTPS warning in IE6/7\n
\t\t\t\tframeBorder: \'0\',\n
\t\t\t\tallowTransparency: "true",\n
\t\t\t\ttitle: self.editorManager.translate(\n
\t\t\t\t\t\t"Rich Text Area. Press ALT-F9 for menu. " +\n
\t\t\t\t\t\t"Press ALT-F10 for toolbar. Press ALT-0 for help"\n
\t\t\t\t),\n
\t\t\t\tstyle: {\n
\t\t\t\t\twidth: \'100%\',\n
\t\t\t\t\theight: h,\n
\t\t\t\t\tdisplay: \'block\' // Important for Gecko to render the iframe correctly\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tifr.onload = function() {\n
\t\t\t\tifr.onload = null;\n
\t\t\t\tself.fire("load");\n
\t\t\t};\n
\n
\t\t\tDOM.setAttrib(ifr, "src", url || \'javascript:""\');\n
\n
\t\t\tself.contentAreaContainer = o.iframeContainer;\n
\t\t\tself.iframeElement = ifr;\n
\n
\t\t\tn = DOM.add(o.iframeContainer, ifr);\n
\n
\t\t\t// Try accessing the document this will fail on IE when document.domain is set to the same as location.hostname\n
\t\t\t// Then we have to force domain relaxing using the domainRelaxUrl approach very ugly!!\n
\t\t\tif (ie) {\n
\t\t\t\ttry {\n
\t\t\t\t\tself.getDoc();\n
\t\t\t\t} catch (e) {\n
\t\t\t\t\tn.src = url = domainRelaxUrl;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (o.editorContainer) {\n
\t\t\t\tDOM.get(o.editorContainer).style.display = self.orgDisplay;\n
\t\t\t\tself.hidden = DOM.isHidden(o.editorContainer);\n
\t\t\t}\n
\n
\t\t\tself.getElement().style.display = \'none\';\n
\t\t\tDOM.setAttrib(self.id, \'aria-hidden\', true);\n
\n
\t\t\tif (!url) {\n
\t\t\t\tself.initContentBody();\n
\t\t\t}\n
\n
\t\t\telm = n = o = null; // Cleanup\n
\t\t},\n
\n
\t\t/**\n
\t\t * This method get called by the init method ones the iframe is loaded.\n
\t\t * It will fill the iframe with contents, setups DOM and selection objects for the iframe.\n
\t\t *\n
\t\t * @method initContentBody\n
\t\t * @private\n
\t\t */\n
\t\tinitContentBody: function(skipWrite) {\n
\t\t\tvar self = this, settings = self.settings, targetElm = self.getElement(), doc = self.getDoc(), body, contentCssText;\n
\n
\t\t\t// Restore visibility on target element\n
\t\t\tif (!settings.inline) {\n
\t\t\t\tself.getElement().style.visibility = self.orgVisibility;\n
\t\t\t}\n
\n
\t\t\t// Setup iframe body\n
\t\t\tif (!skipWrite && !settings.content_editable) {\n
\t\t\t\tdoc.open();\n
\t\t\t\tdoc.write(self.iframeHTML);\n
\t\t\t\tdoc.close();\n
\t\t\t}\n
\n
\t\t\tif (settings.content_editable) {\n
\t\t\t\tself.on(\'remove\', function() {\n
\t\t\t\t\tvar bodyEl = this.getBody();\n
\n
\t\t\t\t\tDOM.removeClass(bodyEl, \'mce-content-body\');\n
\t\t\t\t\tDOM.removeClass(bodyEl, \'mce-edit-focus\');\n
\t\t\t\t\tDOM.setAttrib(bodyEl, \'contentEditable\', null);\n
\t\t\t\t});\n
\n
\t\t\t\tDOM.addClass(targetElm, \'mce-content-body\');\n
\t\t\t\tself.contentDocument = doc = settings.content_document || document;\n
\t\t\t\tself.contentWindow = settings.content_window || window;\n
\t\t\t\tself.bodyElement = targetElm;\n
\n
\t\t\t\t// Prevent leak in IE\n
\t\t\t\tsettings.content_document = settings.content_window = null;\n
\n
\t\t\t\t// TODO: Fix this\n
\t\t\t\tsettings.root_name = targetElm.nodeName.toLowerCase();\n
\t\t\t}\n
\n
\t\t\t// It will not steal focus while setting contentEditable\n
\t\t\tbody = self.getBody();\n
\t\t\tbody.disabled = true;\n
\n
\t\t\tif (!settings.readonly) {\n
\t\t\t\tif (self.inline && DOM.getStyle(body, \'position\', true) == \'static\') {\n
\t\t\t\t\tbody.style.position = \'relative\';\n
\t\t\t\t}\n
\n
\t\t\t\tbody.contentEditable = self.getParam(\'content_editable_state\', true);\n
\t\t\t}\n
\n
\t\t\tbody.disabled = false;\n
\n
\t\t\tself.editorUpload = new EditorUpload(self);\n
\n
\t\t\t/**\n
\t\t\t * Schema instance, enables you to validate elements and it\'s children.\n
\t\t\t *\n
\t\t\t * @property schema\n
\t\t\t * @type tinymce.html.Schema\n
\t\t\t */\n
\t\t\tself.schema = new Schema(settings);\n
\n
\t\t\t/**\n
\t\t\t * DOM instance for the editor.\n
\t\t\t *\n
\t\t\t * @property dom\n
\t\t\t * @type tinymce.dom.DOMUtils\n
\t\t\t * @example\n
\t\t\t * // Adds a class to all paragraphs within the editor\n
\t\t\t * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'someclass\');\n
\t\t\t */\n
\t\t\tself.dom = new DOMUtils(doc, {\n
\t\t\t\tkeep_values: true,\n
\t\t\t\turl_converter: self.convertURL,\n
\t\t\t\turl_converter_scope: self,\n
\t\t\t\thex_colors: settings.force_hex_style_colors,\n
\t\t\t\tclass_filter: settings.class_filter,\n
\t\t\t\tupdate_styles: true,\n
\t\t\t\troot_element: self.inline ? self.getBody() : null,\n
\t\t\t\tcollect: settings.content_editable,\n
\t\t\t\tschema: self.schema,\n
\t\t\t\tonSetAttrib: function(e) {\n
\t\t\t\t\tself.fire(\'SetAttrib\', e);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t/**\n
\t\t\t * HTML parser will be used when contents is inserted into the editor.\n
\t\t\t *\n
\t\t\t * @property parser\n
\t\t\t * @type tinymce.html.DomParser\n
\t\t\t */\n
\t\t\tself.parser = new DomParser(settings, self.schema);\n
\n
\t\t\t// Convert src and href into data-mce-src, data-mce-href and data-mce-style\n
\t\t\tself.parser.addAttributeFilter(\'src,href,style,tabindex\', function(nodes, name) {\n
\t\t\t\tvar i = nodes.length, node, dom = self.dom, value, internalName;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tvalue = node.attr(name);\n
\t\t\t\t\tinternalName = \'data-mce-\' + name;\n
\n
\t\t\t\t\t// Add internal attribute if we need to we don\'t on a refresh of the document\n
\t\t\t\t\tif (!node.attributes.map[internalName]) {\n
\t\t\t\t\t\t// Don\'t duplicate these since they won\'t get modified by any browser\n
\t\t\t\t\t\tif (value.indexOf(\'data:\') === 0 || value.indexOf(\'blob:\') === 0) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (name === "style") {\n
\t\t\t\t\t\t\tvalue = dom.serializeStyle(dom.parseStyle(value), node.name);\n
\n
\t\t\t\t\t\t\tif (!value.length) {\n
\t\t\t\t\t\t\t\tvalue = null;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tnode.attr(internalName, value);\n
\t\t\t\t\t\t\tnode.attr(name, value);\n
\t\t\t\t\t\t} else if (name === "tabindex") {\n
\t\t\t\t\t\t\tnode.attr(internalName, value);\n
\t\t\t\t\t\t\tnode.attr(name, null);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode.attr(internalName, self.convertURL(value, name, node.name));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Keep scripts from executing\n
\t\t\tself.parser.addNodeFilter(\'script\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tnode.attr(\'type\', \'mce-\' + (node.attr(\'type\') || \'no/type\'));\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.parser.addNodeFilter(\'#cdata\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tnode.type = 8;\n
\t\t\t\t\tnode.name = \'#comment\';\n
\t\t\t\t\tnode.value = \'[CDATA[\' + node.value + \']]\';\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.parser.addNodeFilter(\'p,h1,h2,h3,h4,h5,h6,div\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node, nonEmptyElements = self.schema.getNonEmptyElements();\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\t\tif (node.isEmpty(nonEmptyElements)) {\n
\t\t\t\t\t\tnode.append(new Node(\'br\', 1)).shortEnded = true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t/**\n
\t\t\t * DOM serializer for the editor. Will be used when contents is extracted from the editor.\n
\t\t\t *\n
\t\t\t * @property serializer\n
\t\t\t * @type tinymce.dom.Serializer\n
\t\t\t * @example\n
\t\t\t * // Serializes the first paragraph in the editor into a string\n
\t\t\t * tinymce.activeEditor.serializer.serialize(tinymce.activeEditor.dom.select(\'p\')[0]);\n
\t\t\t */\n
\t\t\tself.serializer = new DomSerializer(settings, self);\n
\n
\t\t\t/**\n
\t\t\t * Selection instance for the editor.\n
\t\t\t *\n
\t\t\t * @property selection\n
\t\t\t * @type tinymce.dom.Selection\n
\t\t\t * @example\n
\t\t\t * // Sets some contents to the current selection in the editor\n
\t\t\t * tinymce.activeEditor.selection.setContent(\'Some contents\');\n
\t\t\t *\n
\t\t\t * // Gets the current selection\n
\t\t\t * alert(tinymce.activeEditor.selection.getContent());\n
\t\t\t *\n
\t\t\t * // Selects the first paragraph found\n
\t\t\t * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select(\'p\')[0]);\n
\t\t\t */\n
\t\t\tself.selection = new Selection(self.dom, self.getWin(), self.serializer, self);\n
\n
\t\t\t/**\n
\t\t\t * Formatter instance.\n
\t\t\t *\n
\t\t\t * @property formatter\n
\t\t\t * @type tinymce.Formatter\n
\t\t\t */\n
\t\t\tself.formatter = new Formatter(self);\n
\n
\t\t\t/**\n
\t\t\t * Undo manager instance, responsible for handling undo levels.\n
\t\t\t *\n
\t\t\t * @property undoManager\n
\t\t\t * @type tinymce.UndoManager\n
\t\t\t * @example\n
\t\t\t * // Undoes the last modification to the editor\n
\t\t\t * tinymce.activeEditor.undoManager.undo();\n
\t\t\t */\n
\t\t\tself.undoManager = new UndoManager(self);\n
\n
\t\t\tself.forceBlocks = new ForceBlocks(self);\n
\t\t\tself.enterKey = new EnterKey(self);\n
\t\t\tself._nodeChangeDispatcher = new NodeChange(self);\n
\n
\t\t\tself.fire(\'PreInit\');\n
\n
\t\t\tif (!settings.browser_spellcheck && !settings.gecko_spellcheck) {\n
\t\t\t\tdoc.body.spellcheck = false; // Gecko\n
\t\t\t\tDOM.setAttrib(body, "spellcheck", "false");\n
\t\t\t}\n
\n
\t\t\tself.fire(\'PostRender\');\n
\n
\t\t\tself.quirks = new Quirks(self);\n
\n
\t\t\tif (settings.directionality) {\n
\t\t\t\tbody.dir = settings.directionality;\n
\t\t\t}\n
\n
\t\t\tif (settings.nowrap) {\n
\t\t\t\tbody.style.whiteSpace = "nowrap";\n
\t\t\t}\n
\n
\t\t\tif (settings.protect) {\n
\t\t\t\tself.on(\'BeforeSetContent\', function(e) {\n
\t\t\t\t\teach(settings.protect, function(pattern) {\n
\t\t\t\t\t\te.content = e.content.replace(pattern, function(str) {\n
\t\t\t\t\t\t\treturn \'<!--mce:protected \' + escape(str) + \'-->\';\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.on(\'SetContent\', function() {\n
\t\t\t\tself.addVisual(self.getBody());\n
\t\t\t});\n
\n
\t\t\t// Remove empty contents\n
\t\t\tif (settings.padd_empty_editor) {\n
\t\t\t\tself.on(\'PostProcess\', function(e) {\n
\t\t\t\t\te.content = e.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\\s|\\u00a0|)<\\/p>[\\r\\n]*|<br \\/>[\\r\\n]*)$/, \'\');\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.load({initial: true, format: \'html\'});\n
\t\t\tself.startContent = self.getContent({format: \'raw\'});\n
\n
\t\t\t/**\n
\t\t\t * Is set to true after the editor instance has been initialized\n
\t\t\t *\n
\t\t\t * @property initialized\n
\t\t\t * @type Boolean\n
\t\t\t * @example\n
\t\t\t * function isEditorInitialized(editor) {\n
\t\t\t *     return editor && editor.initialized;\n
\t\t\t * }\n
\t\t\t */\n
\t\t\tself.initialized = true;\n
\t\t\tself.bindPendingEventDelegates();\n
\n
\t\t\tself.fire(\'init\');\n
\t\t\tself.focus(true);\n
\t\t\tself.nodeChanged({initial: true});\n
\t\t\tself.execCallback(\'init_instance_callback\', self);\n
\n
\t\t\t// Add editor specific CSS styles\n
\t\t\tif (self.contentStyles.length > 0) {\n
\t\t\t\tcontentCssText = \'\';\n
\n
\t\t\t\teach(self.contentStyles, function(style) {\n
\t\t\t\t\tcontentCssText += style + "\\r\\n";\n
\t\t\t\t});\n
\n
\t\t\t\tself.dom.addStyle(contentCssText);\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\teach(self.contentCSS, function(cssUrl) {\n
\t\t\t\tif (!self.loadedCSS[cssUrl]) {\n
\t\t\t\t\tself.dom.loadCSS(cssUrl);\n
\t\t\t\t\tself.loadedCSS[cssUrl] = true;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Handle auto focus\n
\t\t\tif (settings.auto_focus) {\n
\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\tvar editor;\n
\n
\t\t\t\t\tif (settings.auto_focus === true) {\n
\t\t\t\t\t\teditor = self;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor = self.editorManager.get(settings.auto_focus);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!editor.destroyed) {\n
\t\t\t\t\t\teditor.focus();\n
\t\t\t\t\t}\n
\t\t\t\t}, 100);\n
\t\t\t}\n
\n
\t\t\t// Clean up references for IE\n
\t\t\ttargetElm = doc = body = null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection\n
\t\t * it will also place DOM focus inside the editor.\n
\t\t *\n
\t\t * @method focus\n
\t\t * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.\n
\t\t */\n
\t\tfocus: function(skipFocus) {\n
\t\t\tvar self = this, selection = self.selection, contentEditable = self.settings.content_editable, rng;\n
\t\t\tvar controlElm, doc = self.getDoc(), body;\n
\n
\t\t\tif (!skipFocus) {\n
\t\t\t\t// Get selected control element\n
\t\t\t\trng = selection.getRng();\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\tcontrolElm = rng.item(0);\n
\t\t\t\t}\n
\n
\t\t\t\tself._refreshContentEditable();\n
\n
\t\t\t\t// Focus the window iframe\n
\t\t\t\tif (!contentEditable) {\n
\t\t\t\t\t// WebKit needs this call to fire focusin event properly see #5948\n
\t\t\t\t\t// But Opera pre Blink engine will produce an empty selection so skip Opera\n
\t\t\t\t\tif (!Env.opera) {\n
\t\t\t\t\t\tself.getBody().focus();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.getWin().focus();\n
\t\t\t\t}\n
\n
\t\t\t\t// Focus the body as well since it\'s contentEditable\n
\t\t\t\tif (isGecko || contentEditable) {\n
\t\t\t\t\tbody = self.getBody();\n
\n
\t\t\t\t\t// Check for setActive since it doesn\'t scroll to the element\n
\t\t\t\t\tif (body.setActive) {\n
\t\t\t\t\t\t// IE 11 sometimes throws "Invalid function" then fallback to focus\n
\t\t\t\t\t\ttry {\n
\t\t\t\t\t\t\tbody.setActive();\n
\t\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t\tbody.focus();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tbody.focus();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (contentEditable) {\n
\t\t\t\t\t\tselection.normalize();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Restore selected control element\n
\t\t\t\t// This is needed when for example an image is selected within a\n
\t\t\t\t// layer a call to focus will then remove the control selection\n
\t\t\t\tif (controlElm && controlElm.ownerDocument == doc) {\n
\t\t\t\t\trng = doc.body.createControlRange();\n
\t\t\t\t\trng.addElement(controlElm);\n
\t\t\t\t\trng.select();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.editorManager.setActive(self);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes a legacy callback. This method is useful to call old 2.x option callbacks.\n
\t\t * There new event model is a better way to add callback so this method might be removed in the future.\n
\t\t *\n
\t\t * @method execCallback\n
\t\t * @param {String} name Name of the callback to execute.\n
\t\t * @return {Object} Return value passed from callback function.\n
\t\t */\n
\t\texecCallback: function(name) {\n
\t\t\tvar self = this, callback = self.settings[name], scope;\n
\n
\t\t\tif (!callback) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Look through lookup\n
\t\t\tif (self.callbackLookup && (scope = self.callbackLookup[name])) {\n
\t\t\t\tcallback = scope.func;\n
\t\t\t\tscope = scope.scope;\n
\t\t\t}\n
\n
\t\t\tif (typeof callback === \'string\') {\n
\t\t\t\tscope = callback.replace(/\\.\\w+$/, \'\');\n
\t\t\t\tscope = scope ? resolve(scope) : 0;\n
\t\t\t\tcallback = resolve(callback);\n
\t\t\t\tself.callbackLookup = self.callbackLookup || {};\n
\t\t\t\tself.callbackLookup[name] = {func: callback, scope: scope};\n
\t\t\t}\n
\n
\t\t\treturn callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Translates the specified string by replacing variables with language pack items it will also check if there is\n
\t\t * a key mathcin the input.\n
\t\t *\n
\t\t * @method translate\n
\t\t * @param {String} text String to translate by the language pack data.\n
\t\t * @return {String} Translated string.\n
\t\t */\n
\t\ttranslate: function(text) {\n
\t\t\tvar lang = this.settings.language || \'en\', i18n = this.editorManager.i18n;\n
\n
\t\t\tif (!text) {\n
\t\t\t\treturn \'\';\n
\t\t\t}\n
\n
\t\t\treturn i18n.data[lang + \'.\' + text] || text.replace(/\\{\\#([^\\}]+)\\}/g, function(a, b) {\n
\t\t\t\treturn i18n.data[lang + \'.\' + b] || \'{#\' + b + \'}\';\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a language pack item by name/key.\n
\t\t *\n
\t\t * @method getLang\n
\t\t * @param {String} name Name/key to get from the language pack.\n
\t\t * @param {String} defaultVal Optional default value to retrive.\n
\t\t */\n
\t\tgetLang: function(name, defaultVal) {\n
\t\t\treturn (\n
\t\t\t\tthis.editorManager.i18n.data[(this.settings.language || \'en\') + \'.\' + name] ||\n
\t\t\t\t(defaultVal !== undefined ? defaultVal : \'{#\' + name + \'}\')\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a configuration parameter by name.\n
\t\t *\n
\t\t * @method getParam\n
\t\t * @param {String} name Configruation parameter to retrive.\n
\t\t * @param {String} defaultVal Optional default value to return.\n
\t\t * @param {String} type Optional type parameter.\n
\t\t * @return {String} Configuration parameter value or default value.\n
\t\t * @example\n
\t\t * // Returns a specific config value from the currently active editor\n
\t\t * var someval = tinymce.activeEditor.getParam(\'myvalue\');\n
\t\t *\n
\t\t * // Returns a specific config value from a specific editor instance by id\n
\t\t * var someval2 = tinymce.get(\'my_editor\').getParam(\'myvalue\');\n
\t\t */\n
\t\tgetParam: function(name, defaultVal, type) {\n
\t\t\tvar value = name in this.settings ? this.settings[name] : defaultVal, output;\n
\n
\t\t\tif (type === \'hash\') {\n
\t\t\t\toutput = {};\n
\n
\t\t\t\tif (typeof value === \'string\') {\n
\t\t\t\t\teach(value.indexOf(\'=\') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(\',\'), function(value) {\n
\t\t\t\t\t\tvalue = value.split(\'=\');\n
\n
\t\t\t\t\t\tif (value.length > 1) {\n
\t\t\t\t\t\t\toutput[trim(value[0])] = trim(value[1]);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\toutput[trim(value[0])] = trim(value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\toutput = value;\n
\t\t\t\t}\n
\n
\t\t\t\treturn output;\n
\t\t\t}\n
\n
\t\t\treturn value;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Distpaches out a onNodeChange event to all observers. This method should be called when you\n
\t\t * need to update the UI states or element path etc.\n
\t\t *\n
\t\t * @method nodeChanged\n
\t\t * @param {Object} args Optional args to pass to NodeChange event handlers.\n
\t\t */\n
\t\tnodeChanged: function(args) {\n
\t\t\tthis._nodeChangeDispatcher.nodeChanged(args);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a button that later gets created by the theme in the editors toolbars.\n
\t\t *\n
\t\t * @method addButton\n
\t\t * @param {String} name Button name to add.\n
\t\t * @param {Object} settings Settings object with title, cmd etc.\n
\t\t * @example\n
\t\t * // Adds a custom button to the editor that inserts contents when clicked\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    toolbar: \'example\'\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       ed.addButton(\'example\', {\n
\t\t *          title: \'My title\',\n
\t\t *          image: \'../js/tinymce/plugins/example/img/example.gif\',\n
\t\t *          onclick: function() {\n
\t\t *             ed.insertContent(\'Hello world!!\');\n
\t\t *          }\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddButton: function(name, settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (settings.cmd) {\n
\t\t\t\tsettings.onclick = function() {\n
\t\t\t\t\tself.execCommand(settings.cmd);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tif (!settings.text && !settings.icon) {\n
\t\t\t\tsettings.icon = name;\n
\t\t\t}\n
\n
\t\t\tself.buttons = self.buttons || {};\n
\t\t\tsettings.tooltip = settings.tooltip || settings.title;\n
\t\t\tself.buttons[name] = settings;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a menu item to be used in the menus of the theme. There might be multiple instances\n
\t\t * of this menu item for example it might be used in the main menus of the theme but also in\n
\t\t * the context menu so make sure that it\'s self contained and supports multiple instances.\n
\t\t *\n
\t\t * @method addMenuItem\n
\t\t * @param {String} name Menu item name to add.\n
\t\t * @param {Object} settings Settings object with title, cmd etc.\n
\t\t * @example\n
\t\t * // Adds a custom menu item to the editor that inserts contents when clicked\n
\t\t * // The context option allows you to add the menu item to an existing default menu\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       ed.addMenuItem(\'example\', {\n
\t\t *          text: \'My menu item\',\n
\t\t *          context: \'tools\',\n
\t\t *          onclick: function() {\n
\t\t *             ed.insertContent(\'Hello world!!\');\n
\t\t *          }\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddMenuItem: function(name, settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (settings.cmd) {\n
\t\t\t\tsettings.onclick = function() {\n
\t\t\t\t\tself.execCommand(settings.cmd);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tself.menuItems = self.menuItems || {};\n
\t\t\tself.menuItems[name] = settings;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a contextual toolbar to be rendered when the selector matches.\n
\t\t *\n
\t\t * @method addContextToolbar\n
\t\t * @param {function/string} predicate Predicate that needs to return true if provided strings get converted into CSS predicates.\n
\t\t * @param {String/Array} items String or array with items to add to the context toolbar.\n
\t\t */\n
\t\taddContextToolbar: function(predicate, items) {\n
\t\t\tvar self = this, selector;\n
\n
\t\t\tself.contextToolbars = self.contextToolbars || [];\n
\n
\t\t\t// Convert selector to predicate\n
\t\t\tif (typeof predicate == "string") {\n
\t\t\t\tselector = predicate;\n
\t\t\t\tpredicate = function(elm) {\n
\t\t\t\t\treturn self.dom.is(elm, selector);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tself.contextToolbars.push({\n
\t\t\t\tpredicate: predicate,\n
\t\t\t\titems: items\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with execCommand.\n
\t\t *\n
\t\t * @method addCommand\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addCommandCallback} callback Function to execute when the command occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t * @example\n
\t\t * // Adds a custom command that later can be executed using execCommand\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       // Register example command\n
\t\t *       ed.addCommand(\'mycommand\', function(ui, v) {\n
\t\t *          ed.windowManager.alert(\'Hello world!! Selection: \' + ed.selection.getContent({format: \'text\'}));\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddCommand: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a command is executed.\n
\t\t\t *\n
\t\t\t * @callback addCommandCallback\n
\t\t\t * @param {Boolean} ui Display UI state true/false.\n
\t\t\t * @param {Object} value Optional value for command.\n
\t\t\t * @return {Boolean} True/false state if the command was handled or not.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addCommand(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom query state command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with queryCommandState function.\n
\t\t *\n
\t\t * @method addQueryStateHandler\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrival occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t */\n
\t\taddQueryStateHandler: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a queryCommandState is executed.\n
\t\t\t *\n
\t\t\t * @callback addQueryStateHandlerCallback\n
\t\t\t * @return {Boolean} True/false state if the command is enabled or not like is it bold.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addQueryStateHandler(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom query value command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with queryCommandValue function.\n
\t\t *\n
\t\t * @method addQueryValueHandler\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrival occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t */\n
\t\taddQueryValueHandler: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a queryCommandValue is executed.\n
\t\t\t *\n
\t\t\t * @callback addQueryValueHandlerCallback\n
\t\t\t * @return {Object} Value of the command or undefined.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addQueryValueHandler(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a keyboard shortcut for some command or function.\n
\t\t *\n
\t\t * @method addShortcut\n
\t\t * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.\n
\t\t * @param {String} desc Text description for the command.\n
\t\t * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.\n
\t\t * @param {Object} sc Optional scope to execute the function in.\n
\t\t * @return {Boolean} true/false state if the shortcut was added or not.\n
\t\t */\n
\t\taddShortcut: function(pattern, desc, cmdFunc, scope) {\n
\t\t\tthis.shortcuts.add(pattern, desc, cmdFunc, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or\n
\t\t * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.\n
\t\t * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these\n
\t\t * return true it will handle the command as a internal browser command.\n
\t\t *\n
\t\t * @method execCommand\n
\t\t * @param {String} cmd Command name to execute, for example mceLink or Bold.\n
\t\t * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.\n
\t\t * @param {mixed} value Optional command value, this can be anything.\n
\t\t * @param {Object} args Optional arguments object.\n
\t\t */\n
\t\texecCommand: function(cmd, ui, value, args) {\n
\t\t\treturn this.editorCommands.execCommand(cmd, ui, value, args);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a command specific state, for example if bold is enabled or not.\n
\t\t *\n
\t\t * @method queryCommandState\n
\t\t * @param {string} cmd Command to query state from.\n
\t\t * @return {Boolean} Command specific state, for example if bold is enabled or not.\n
\t\t */\n
\t\tqueryCommandState: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandState(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a command specific value, for example the current font size.\n
\t\t *\n
\t\t * @method queryCommandValue\n
\t\t * @param {string} cmd Command to query value from.\n
\t\t * @return {Object} Command specific value, for example the current font size.\n
\t\t */\n
\t\tqueryCommandValue: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandValue(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the command is supported or not.\n
\t\t *\n
\t\t * @method queryCommandSupported\n
\t\t * @param {String} cmd Command that we check support for.\n
\t\t * @return {Boolean} true/false if the command is supported or not.\n
\t\t */\n
\t\tqueryCommandSupported: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandSupported(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the editor and hides any textarea/div that the editor is supposed to replace.\n
\t\t *\n
\t\t * @method show\n
\t\t */\n
\t\tshow: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.hidden) {\n
\t\t\t\tself.hidden = false;\n
\n
\t\t\t\tif (self.inline) {\n
\t\t\t\t\tself.getBody().contentEditable = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tDOM.show(self.getContainer());\n
\t\t\t\t\tDOM.hide(self.id);\n
\t\t\t\t}\n
\n
\t\t\t\tself.load();\n
\t\t\t\tself.fire(\'show\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the editor and shows any textarea/div that the editor is supposed to replace.\n
\t\t *\n
\t\t * @method hide\n
\t\t */\n
\t\thide: function() {\n
\t\t\tvar self = this, doc = self.getDoc();\n
\n
\t\t\tif (!self.hidden) {\n
\t\t\t\t// Fixed bug where IE has a blinking cursor left from the editor\n
\t\t\t\tif (ie && doc && !self.inline) {\n
\t\t\t\t\tdoc.execCommand(\'SelectAll\');\n
\t\t\t\t}\n
\n
\t\t\t\t// We must save before we hide so Safari doesn\'t crash\n
\t\t\t\tself.save();\n
\n
\t\t\t\tif (self.inline) {\n
\t\t\t\t\tself.getBody().contentEditable = false;\n
\n
\t\t\t\t\t// Make sure the editor gets blurred\n
\t\t\t\t\tif (self == self.editorManager.focusedEditor) {\n
\t\t\t\t\t\tself.editorManager.focusedEditor = null;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tDOM.hide(self.getContainer());\n
\t\t\t\t\tDOM.setStyle(self.id, \'display\', self.orgDisplay);\n
\t\t\t\t}\n
\n
\t\t\t\tself.hidden = true;\n
\t\t\t\tself.fire(\'hide\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the editor is hidden or not.\n
\t\t *\n
\t\t * @method isHidden\n
\t\t * @return {Boolean} True/false if the editor is hidden or not.\n
\t\t */\n
\t\tisHidden: function() {\n
\t\t\treturn !!this.hidden;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the progress state, this will display a throbber/progess for the editor.\n
\t\t * This is ideal for asycronous operations like an AJAX save call.\n
\t\t *\n
\t\t * @method setProgressState\n
\t\t * @param {Boolean} state Boolean state if the progress should be shown or hidden.\n
\t\t * @param {Number} time Optional time to wait before the progress gets shown.\n
\t\t * @return {Boolean} Same as the input state.\n
\t\t * @example\n
\t\t * // Show progress for the active editor\n
\t\t * tinymce.activeEditor.setProgressState(true);\n
\t\t *\n
\t\t * // Hide progress for the active editor\n
\t\t * tinymce.activeEditor.setProgressState(false);\n
\t\t *\n
\t\t * // Show progress after 3 seconds\n
\t\t * tinymce.activeEditor.setProgressState(true, 3000);\n
\t\t */\n
\t\tsetProgressState: function(state, time) {\n
\t\t\tthis.fire(\'ProgressState\', {state: state, time: time});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Loads contents from the textarea or div element that got converted into an editor instance.\n
\t\t * This method will move the contents from that textarea or div into the editor by using setContent\n
\t\t * so all events etc that method has will get dispatched as well.\n
\t\t *\n
\t\t * @method load\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole load process.\n
\t\t * @return {String} HTML string that got set into the editor.\n
\t\t */\n
\t\tload: function(args) {\n
\t\t\tvar self = this, elm = self.getElement(), html;\n
\n
\t\t\tif (elm) {\n
\t\t\t\targs = args || {};\n
\t\t\t\targs.load = true;\n
\n
\t\t\t\thtml = self.setContent(elm.value !== undefined ? elm.value : elm.innerHTML, args);\n
\t\t\t\targs.element = elm;\n
\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\tself.fire(\'LoadContent\', args);\n
\t\t\t\t}\n
\n
\t\t\t\targs.element = elm = null;\n
\n
\t\t\t\treturn html;\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.\n
\t\t * This method will move the HTML contents from the editor into that textarea or div by getContent\n
\t\t * so all events etc that method has will get dispatched as well.\n
\t\t *\n
\t\t * @method save\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole save process.\n
\t\t * @return {String} HTML string that got set into the textarea/div.\n
\t\t */\n
\t\tsave: function(args) {\n
\t\t\tvar self = this, elm = self.getElement(), html, form;\n
\n
\t\t\tif (!elm || !self.initialized) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\targs = args || {};\n
\t\t\targs.save = true;\n
\n
\t\t\targs.element = elm;\n
\t\t\thtml = args.content = self.getContent(args);\n
\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'SaveContent\', args);\n
\t\t\t}\n
\n
\t\t\t// Always run this internal event\n
\t\t\tif (args.format == \'raw\') {\n
\t\t\t\tself.fire(\'RawSaveContent\', args);\n
\t\t\t}\n
\n
\t\t\thtml = args.content;\n
\n
\t\t\tif (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {\n
\t\t\t\t// Update DIV element when not in inline mode\n
\t\t\t\tif (!self.inline) {\n
\t\t\t\t\telm.innerHTML = html;\n
\t\t\t\t}\n
\n
\t\t\t\t// Update hidden form element\n
\t\t\t\tif ((form = DOM.getParent(self.id, \'form\'))) {\n
\t\t\t\t\teach(form.elements, function(elm) {\n
\t\t\t\t\t\tif (elm.name == self.id) {\n
\t\t\t\t\t\t\telm.value = html;\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\telm.value = html;\n
\t\t\t}\n
\n
\t\t\targs.element = elm = null;\n
\n
\t\t\tif (args.set_dirty !== false) {\n
\t\t\t\tself.isNotDirty = true;\n
\t\t\t}\n
\n
\t\t\treturn html;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified content to the editor instance, this will cleanup the content before it gets set using\n
\t\t * the different cleanup rules options.\n
\t\t *\n
\t\t * @method setContent\n
\t\t * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole set process.\n
\t\t * @return {String} HTML string that got set into the editor.\n
\t\t * @example\n
\t\t * // Sets the HTML contents of the activeEditor editor\n
\t\t * tinymce.activeEditor.setContent(\'<span>some</span> html\');\n
\t\t *\n
\t\t * // Sets the raw contents of the activeEditor editor\n
\t\t * tinymce.activeEditor.setContent(\'<span>some</span> html\', {format: \'raw\'});\n
\t\t *\n
\t\t * // Sets the content of a specific editor (my_editor in this example)\n
\t\t * tinymce.get(\'my_editor\').setContent(data);\n
\t\t *\n
\t\t * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added\n
\t\t * tinymce.activeEditor.setContent(\'[b]some[/b] html\', {format: \'bbcode\'});\n
\t\t */\n
\t\tsetContent: function(content, args) {\n
\t\t\tvar self = this, body = self.getBody(), forcedRootBlockName;\n
\n
\t\t\t// Setup args object\n
\t\t\targs = args || {};\n
\t\t\targs.format = args.format || \'html\';\n
\t\t\targs.set = true;\n
\t\t\targs.content = content;\n
\n
\t\t\t// Do preprocessing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'BeforeSetContent\', args);\n
\t\t\t}\n
\n
\t\t\tcontent = args.content;\n
\n
\t\t\t// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content\n
\t\t\t// It will also be impossible to place the caret in the editor unless there is a BR element present\n
\t\t\tif (content.length === 0 || /^\\s+$/.test(content)) {\n
\t\t\t\tforcedRootBlockName = self.settings.forced_root_block;\n
\n
\t\t\t\t// Check if forcedRootBlock is configured and that the block is a valid child of the body\n
\t\t\t\tif (forcedRootBlockName && self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n
\t\t\t\t\t// Padd with bogus BR elements on modern browsers and IE 7 and 8 since they don\'t render empty P tags properly\n
\t\t\t\t\tcontent = ie && ie < 11 ? \'\' : \'<br data-mce-bogus="1">\';\n
\t\t\t\t\tcontent = self.dom.createHTML(forcedRootBlockName, self.settings.forced_root_block_attrs, content);\n
\t\t\t\t} else if (!ie) {\n
\t\t\t\t\t// We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret\n
\t\t\t\t\tcontent = \'<br data-mce-bogus="1">\';\n
\t\t\t\t}\n
\n
\t\t\t\tself.dom.setHTML(body, content);\n
\n
\t\t\t\tself.fire(\'SetContent\', args);\n
\t\t\t} else {\n
\t\t\t\t// Parse and serialize the html\n
\t\t\t\tif (args.format !== \'raw\') {\n
\t\t\t\t\tcontent = new Serializer({}, self.schema).serialize(\n
\t\t\t\t\t\tself.parser.parse(content, {isRootContent: true})\n
\t\t\t\t\t);\n
\t\t\t\t}\n
\n
\t\t\t\t// Set the new cleaned contents to the editor\n
\t\t\t\targs.content = trim(content);\n
\t\t\t\tself.dom.setHTML(body, args.content);\n
\n
\t\t\t\t// Do post processing\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\tself.fire(\'SetContent\', args);\n
\t\t\t\t}\n
\n
\t\t\t\t// Don\'t normalize selection if the focused element isn\'t the body in\n
\t\t\t\t// content editable mode since it will steal focus otherwise\n
\t\t\t\t/*if (!self.settings.content_editable || document.activeElement === self.getBody()) {\n
\t\t\t\t\tself.selection.normalize();\n
\t\t\t\t}*/\n
\t\t\t}\n
\n
\t\t\treturn args.content;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets the content from the editor instance, this will cleanup the content before it gets returned using\n
\t\t * the different cleanup rules options.\n
\t\t *\n
\t\t * @method getContent\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole get process.\n
\t\t * @return {String} Cleaned content string, normally HTML contents.\n
\t\t * @example\n
\t\t * // Get the HTML contents of the currently active editor\n
\t\t * console.debug(tinymce.activeEditor.getContent());\n
\t\t *\n
\t\t * // Get the raw contents of the currently active editor\n
\t\t * tinymce.activeEditor.getContent({format: \'raw\'});\n
\t\t *\n
\t\t * // Get content of a specific editor:\n
\t\t * tinymce.get(\'content id\').getContent()\n
\t\t */\n
\t\tgetContent: function(args) {\n
\t\t\tvar self = this, content, body = self.getBody();\n
\n
\t\t\t// Setup args object\n
\t\t\targs = args || {};\n
\t\t\targs.format = args.format || \'html\';\n
\t\t\targs.get = true;\n
\t\t\targs.getInner = true;\n
\n
\t\t\t// Do preprocessing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'BeforeGetContent\', args);\n
\t\t\t}\n
\n
\t\t\t// Get raw contents or by default the cleaned contents\n
\t\t\tif (args.format == \'raw\') {\n
\t\t\t\tcontent = body.innerHTML;\n
\t\t\t} else if (args.format == \'text\') {\n
\t\t\t\tcontent = body.innerText || body.textContent;\n
\t\t\t} else {\n
\t\t\t\tcontent = self.serializer.serialize(body, args);\n
\t\t\t}\n
\n
\t\t\t// Trim whitespace in beginning/end of HTML\n
\t\t\tif (args.format != \'text\') {\n
\t\t\t\ta

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAA4=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="14" aka="AAAAAAAAAA4=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

rgs.content = trim(content);\n
\t\t\t} else {\n
\t\t\t\targs.content = content;\n
\t\t\t}\n
\n
\t\t\t// Do post processing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'GetContent\', args);\n
\t\t\t}\n
\n
\t\t\treturn args.content;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Inserts content at caret position.\n
\t\t *\n
\t\t * @method insertContent\n
\t\t * @param {String} content Content to insert.\n
\t\t * @param {Object} args Optional args to pass to insert call.\n
\t\t */\n
\t\tinsertContent: function(content, args) {\n
\t\t\tif (args) {\n
\t\t\t\tcontent = extend({content: content}, args);\n
\t\t\t}\n
\n
\t\t\tthis.execCommand(\'mceInsertContent\', false, content);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\n
\t\t *\n
\t\t * @method isDirty\n
\t\t * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\n
\t\t * @example\n
\t\t * if (tinymce.activeEditor.isDirty())\n
\t\t *     alert("You must save your contents.");\n
\t\t */\n
\t\tisDirty: function() {\n
\t\t\treturn !this.isNotDirty;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the editors container element. The container element wrappes in\n
\t\t * all the elements added to the page for the editor. Such as UI, iframe etc.\n
\t\t *\n
\t\t * @method getContainer\n
\t\t * @return {Element} HTML DOM element for the editor container.\n
\t\t */\n
\t\tgetContainer: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.container) {\n
\t\t\t\tself.container = DOM.get(self.editorContainer || self.id + \'_parent\');\n
\t\t\t}\n
\n
\t\t\treturn self.container;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the editors content area container element. The this element is the one who\n
\t\t * holds the iframe or the editable element.\n
\t\t *\n
\t\t * @method getContentAreaContainer\n
\t\t * @return {Element} HTML DOM element for the editor area container.\n
\t\t */\n
\t\tgetContentAreaContainer: function() {\n
\t\t\treturn this.contentAreaContainer;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the target element/textarea that got replaced with a TinyMCE editor instance.\n
\t\t *\n
\t\t * @method getElement\n
\t\t * @return {Element} HTML DOM element for the replaced element.\n
\t\t */\n
\t\tgetElement: function() {\n
\t\t\tif (!this.targetElm) {\n
\t\t\t\tthis.targetElm = DOM.get(this.id);\n
\t\t\t}\n
\n
\t\t\treturn this.targetElm;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the iframes window object.\n
\t\t *\n
\t\t * @method getWin\n
\t\t * @return {Window} Iframe DOM window object.\n
\t\t */\n
\t\tgetWin: function() {\n
\t\t\tvar self = this, elm;\n
\n
\t\t\tif (!self.contentWindow) {\n
\t\t\t\telm = self.iframeElement;\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\tself.contentWindow = elm.contentWindow;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self.contentWindow;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the iframes document object.\n
\t\t *\n
\t\t * @method getDoc\n
\t\t * @return {Document} Iframe DOM document object.\n
\t\t */\n
\t\tgetDoc: function() {\n
\t\t\tvar self = this, win;\n
\n
\t\t\tif (!self.contentDocument) {\n
\t\t\t\twin = self.getWin();\n
\n
\t\t\t\tif (win) {\n
\t\t\t\t\tself.contentDocument = win.document;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self.contentDocument;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the root element of the editable area.\n
\t\t * For a non-inline iframe-based editor, returns the iframe\'s body element.\n
\t\t *\n
\t\t * @method getBody\n
\t\t * @return {Element} The root element of the editable area.\n
\t\t */\n
\t\tgetBody: function() {\n
\t\t\treturn this.bodyElement || this.getDoc().body;\n
\t\t},\n
\n
\t\t/**\n
\t\t * URL converter function this gets executed each time a user adds an img, a or\n
\t\t * any other element that has a URL in it. This will be called both by the DOM and HTML\n
\t\t * manipulation functions.\n
\t\t *\n
\t\t * @method convertURL\n
\t\t * @param {string} url URL to convert.\n
\t\t * @param {string} name Attribute name src, href etc.\n
\t\t * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.\n
\t\t * @return {string} Converted URL string.\n
\t\t */\n
\t\tconvertURL: function(url, name, elm) {\n
\t\t\tvar self = this, settings = self.settings;\n
\n
\t\t\t// Use callback instead\n
\t\t\tif (settings.urlconverter_callback) {\n
\t\t\t\treturn self.execCallback(\'urlconverter_callback\', url, elm, true, name);\n
\t\t\t}\n
\n
\t\t\t// Don\'t convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs\n
\t\t\tif (!settings.convert_urls || (elm && elm.nodeName == \'LINK\') || url.indexOf(\'file:\') === 0 || url.length === 0) {\n
\t\t\t\treturn url;\n
\t\t\t}\n
\n
\t\t\t// Convert to relative\n
\t\t\tif (settings.relative_urls) {\n
\t\t\t\treturn self.documentBaseURI.toRelative(url);\n
\t\t\t}\n
\n
\t\t\t// Convert to absolute\n
\t\t\turl = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);\n
\n
\t\t\treturn url;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.\n
\t\t *\n
\t\t * @method addVisual\n
\t\t * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.\n
\t\t */\n
\t\taddVisual: function(elm) {\n
\t\t\tvar self = this, settings = self.settings, dom = self.dom, cls;\n
\n
\t\t\telm = elm || self.getBody();\n
\n
\t\t\tif (self.hasVisual === undefined) {\n
\t\t\t\tself.hasVisual = settings.visual;\n
\t\t\t}\n
\n
\t\t\teach(dom.select(\'table,a\', elm), function(elm) {\n
\t\t\t\tvar value;\n
\n
\t\t\t\tswitch (elm.nodeName) {\n
\t\t\t\t\tcase \'TABLE\':\n
\t\t\t\t\t\tcls = settings.visual_table_class || \'mce-item-table\';\n
\t\t\t\t\t\tvalue = dom.getAttrib(elm, \'border\');\n
\n
\t\t\t\t\t\tif ((!value || value == \'0\') && self.hasVisual) {\n
\t\t\t\t\t\t\tdom.addClass(elm, cls);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tdom.removeClass(elm, cls);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\tcase \'A\':\n
\t\t\t\t\t\tif (!dom.getAttrib(elm, \'href\', false)) {\n
\t\t\t\t\t\t\tvalue = dom.getAttrib(elm, \'name\') || elm.id;\n
\t\t\t\t\t\t\tcls = settings.visual_anchor_class || \'mce-item-anchor\';\n
\n
\t\t\t\t\t\t\tif (value && self.hasVisual) {\n
\t\t\t\t\t\t\t\tdom.addClass(elm, cls);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tdom.removeClass(elm, cls);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.fire(\'VisualAid\', {element: elm, hasVisual: self.hasVisual});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the editor from the dom and tinymce collection.\n
\t\t *\n
\t\t * @method remove\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.removed) {\n
\t\t\t\tself.save();\n
\t\t\t\tself.removed = 1;\n
\t\t\t\tself.unbindAllNativeEvents();\n
\n
\t\t\t\t// Remove any hidden input\n
\t\t\t\tif (self.hasHiddenInput) {\n
\t\t\t\t\tDOM.remove(self.getElement().nextSibling);\n
\t\t\t\t}\n
\n
\t\t\t\tif (!self.inline) {\n
\t\t\t\t\t// IE 9 has a bug where the selection stops working if you place the\n
\t\t\t\t\t// caret inside the editor then remove the iframe\n
\t\t\t\t\tif (ie && ie < 10) {\n
\t\t\t\t\t\tself.getDoc().execCommand(\'SelectAll\', false, null);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tDOM.setStyle(self.id, \'display\', self.orgDisplay);\n
\t\t\t\t\tself.getBody().onload = null; // Prevent #6816\n
\t\t\t\t}\n
\n
\t\t\t\tself.fire(\'remove\');\n
\n
\t\t\t\tself.editorManager.remove(self);\n
\t\t\t\tDOM.remove(self.getContainer());\n
\t\t\t\tself.editorUpload.destroy();\n
\t\t\t\tself.destroy();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Destroys the editor instance by removing all events, element references or other resources\n
\t\t * that could leak memory. This method will be called automatically when the page is unloaded\n
\t\t * but you can also call it directly if you know what you are doing.\n
\t\t *\n
\t\t * @method destroy\n
\t\t * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.\n
\t\t */\n
\t\tdestroy: function(automatic) {\n
\t\t\tvar self = this, form;\n
\n
\t\t\t// One time is enough\n
\t\t\tif (self.destroyed) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// If user manually calls destroy and not remove\n
\t\t\t// Users seems to have logic that calls destroy instead of remove\n
\t\t\tif (!automatic && !self.removed) {\n
\t\t\t\tself.remove();\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!automatic) {\n
\t\t\t\tself.editorManager.off(\'beforeunload\', self._beforeUnload);\n
\n
\t\t\t\t// Manual destroy\n
\t\t\t\tif (self.theme && self.theme.destroy) {\n
\t\t\t\t\tself.theme.destroy();\n
\t\t\t\t}\n
\n
\t\t\t\t// Destroy controls, selection and dom\n
\t\t\t\tself.selection.destroy();\n
\t\t\t\tself.dom.destroy();\n
\t\t\t}\n
\n
\t\t\tform = self.formElement;\n
\t\t\tif (form) {\n
\t\t\t\tif (form._mceOldSubmit) {\n
\t\t\t\t\tform.submit = form._mceOldSubmit;\n
\t\t\t\t\tform._mceOldSubmit = null;\n
\t\t\t\t}\n
\n
\t\t\t\tDOM.unbind(form, \'submit reset\', self.formEventDelegate);\n
\t\t\t}\n
\n
\t\t\tself.contentAreaContainer = self.formElement = self.container = self.editorContainer = null;\n
\t\t\tself.bodyElement = self.contentDocument = self.contentWindow = null;\n
\t\t\tself.iframeElement = self.targetElm = null;\n
\n
\t\t\tif (self.selection) {\n
\t\t\t\tself.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = null;\n
\t\t\t}\n
\n
\t\t\tself.destroyed = 1;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Uploads all data uri/blob uri images in the editor contents to server.\n
\t\t *\n
\t\t * @method uploadImages\n
\t\t * @param {function} callback Optional callback with images and status for each image.\n
\t\t * @return {tinymce.util.Promise} Promise instance.\n
\t\t */\n
\t\tuploadImages: function(callback) {\n
\t\t\treturn this.editorUpload.uploadImages(callback);\n
\t\t},\n
\n
\t\t// Internal functions\n
\n
\t\t_scanForImages: function() {\n
\t\t\treturn this.editorUpload.scanForImages();\n
\t\t},\n
\n
\t\t_refreshContentEditable: function() {\n
\t\t\tvar self = this, body, parent;\n
\n
\t\t\t// Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again\n
\t\t\tif (self._isHidden()) {\n
\t\t\t\tbody = self.getBody();\n
\t\t\t\tparent = body.parentNode;\n
\n
\t\t\t\tparent.removeChild(body);\n
\t\t\t\tparent.appendChild(body);\n
\n
\t\t\t\tbody.focus();\n
\t\t\t}\n
\t\t},\n
\n
\t\t_isHidden: function() {\n
\t\t\tvar sel;\n
\n
\t\t\tif (!isGecko) {\n
\t\t\t\treturn 0;\n
\t\t\t}\n
\n
\t\t\t// Weird, wheres that cursor selection?\n
\t\t\tsel = this.selection.getSel();\n
\t\t\treturn (!sel || !sel.rangeCount || sel.rangeCount === 0);\n
\t\t}\n
\t};\n
\n
\textend(Editor.prototype, EditorObservable);\n
\n
\treturn Editor;\n
});\n
\n
// Included from: js/tinymce/classes/util/I18n.js\n
\n
/**\n
 * I18n.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * I18n class that handles translation of TinyMCE UI.\n
 * Uses po style with csharp style parameters.\n
 *\n
 * @class tinymce.util.I18n\n
 */\n
define("tinymce/util/I18n", [], function() {\n
\t"use strict";\n
\n
\tvar data = {}, code = "en";\n
\n
\treturn {\n
\t\t/**\n
\t\t * Sets the current language code.\n
\t\t *\n
\t\t * @method setCode\n
\t\t * @param {String} newCode Current language code.\n
\t\t */\n
\t\tsetCode: function(newCode) {\n
\t\t\tif (newCode) {\n
\t\t\t\tcode = newCode;\n
\t\t\t\tthis.rtl = this.data[newCode] ? this.data[newCode]._dir === \'rtl\' : false;\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the current language code.\n
\t\t *\n
\t\t * @method getCode\n
\t\t * @return {String} Current language code.\n
\t\t */\n
\t\tgetCode: function() {\n
\t\t\treturn code;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Property gets set to true if a RTL language pack was loaded.\n
\t\t *\n
\t\t * @property rtl\n
\t\t * @type Boolean\n
\t\t */\n
\t\trtl: false,\n
\n
\t\t/**\n
\t\t * Adds translations for a specific language code.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {String} code Language code like sv_SE.\n
\t\t * @param {Array} items Name/value array with English en_US to sv_SE.\n
\t\t */\n
\t\tadd: function(code, items) {\n
\t\t\tvar langData = data[code];\n
\n
\t\t\tif (!langData) {\n
\t\t\t\tdata[code] = langData = {};\n
\t\t\t}\n
\n
\t\t\tfor (var name in items) {\n
\t\t\t\tlangData[name] = items[name];\n
\t\t\t}\n
\n
\t\t\tthis.setCode(code);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Translates the specified text.\n
\t\t *\n
\t\t * It has a few formats:\n
\t\t * I18n.translate("Text");\n
\t\t * I18n.translate(["Text {0}/{1}", 0, 1]);\n
\t\t * I18n.translate({raw: "Raw string"});\n
\t\t *\n
\t\t * @method translate\n
\t\t * @param {String/Object/Array} text Text to translate.\n
\t\t * @return {String} String that got translated.\n
\t\t */\n
\t\ttranslate: function(text) {\n
\t\t\tvar langData;\n
\n
\t\t\tlangData = data[code];\n
\t\t\tif (!langData) {\n
\t\t\t\tlangData = {};\n
\t\t\t}\n
\n
\t\t\tif (typeof text == "undefined") {\n
\t\t\t\treturn text;\n
\t\t\t}\n
\n
\t\t\tif (typeof text != "string" && text.raw) {\n
\t\t\t\treturn text.raw;\n
\t\t\t}\n
\n
\t\t\tif (text.push) {\n
\t\t\t\tvar values = text.slice(1);\n
\n
\t\t\t\ttext = (langData[text[0]] || text[0]).replace(/\\{([0-9]+)\\}/g, function(match1, match2) {\n
\t\t\t\t\treturn values[match2];\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn (langData[text] || text).replace(/{context:\\w+}$/, \'\');\n
\t\t},\n
\n
\t\tdata: data\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/FocusManager.js\n
\n
/**\n
 * FocusManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class manages the focus/blur state of the editor. This class is needed since some\n
 * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.\n
 *\n
 * This class will fire two events focus and blur on the editor instances that got affected.\n
 * It will also handle the restore of selection when the focus is lost and returned.\n
 *\n
 * @class tinymce.FocusManager\n
 */\n
define("tinymce/FocusManager", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/Env"\n
], function(DOMUtils, Env) {\n
\tvar selectionChangeHandler, documentFocusInHandler, documentMouseUpHandler, DOM = DOMUtils.DOM;\n
\n
\t/**\n
\t * Constructs a new focus manager instance.\n
\t *\n
\t * @constructor FocusManager\n
\t * @param {tinymce.EditorManager} editorManager Editor manager instance to handle focus for.\n
\t */\n
\tfunction FocusManager(editorManager) {\n
\t\tfunction getActiveElement() {\n
\t\t\ttry {\n
\t\t\t\treturn document.activeElement;\n
\t\t\t} catch (ex) {\n
\t\t\t\t// IE sometimes fails to get the activeElement when resizing table\n
\t\t\t\t// TODO: Investigate this\n
\t\t\t\treturn document.body;\n
\t\t\t}\n
\t\t}\n
\n
\t\t// We can\'t store a real range on IE 11 since it gets mutated so we need to use a bookmark object\n
\t\t// TODO: Move this to a separate range utils class since it\'s it\'s logic is present in Selection as well.\n
\t\tfunction createBookmark(dom, rng) {\n
\t\t\tif (rng && rng.startContainer) {\n
\t\t\t\t// Verify that the range is within the root of the editor\n
\t\t\t\tif (!dom.isChildOf(rng.startContainer, dom.getRoot()) || !dom.isChildOf(rng.endContainer, dom.getRoot())) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\treturn {\n
\t\t\t\t\tstartContainer: rng.startContainer,\n
\t\t\t\t\tstartOffset: rng.startOffset,\n
\t\t\t\t\tendContainer: rng.endContainer,\n
\t\t\t\t\tendOffset: rng.endOffset\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\treturn rng;\n
\t\t}\n
\n
\t\tfunction bookmarkToRng(editor, bookmark) {\n
\t\t\tvar rng;\n
\n
\t\t\tif (bookmark.startContainer) {\n
\t\t\t\trng = editor.getDoc().createRange();\n
\t\t\t\trng.setStart(bookmark.startContainer, bookmark.startOffset);\n
\t\t\t\trng.setEnd(bookmark.endContainer, bookmark.endOffset);\n
\t\t\t} else {\n
\t\t\t\trng = bookmark;\n
\t\t\t}\n
\n
\t\t\treturn rng;\n
\t\t}\n
\n
\t\tfunction isUIElement(elm) {\n
\t\t\treturn !!DOM.getParent(elm, FocusManager.isEditorUIElement);\n
\t\t}\n
\n
\t\tfunction registerEvents(e) {\n
\t\t\tvar editor = e.editor;\n
\n
\t\t\teditor.on(\'init\', function() {\n
\t\t\t\t// Gecko/WebKit has ghost selections in iframes and IE only has one selection per browser tab\n
\t\t\t\tif (editor.inline || Env.ie) {\n
\t\t\t\t\t// Use the onbeforedeactivate event when available since it works better see #7023\n
\t\t\t\t\tif ("onbeforedeactivate" in document && Env.ie < 9) {\n
\t\t\t\t\t\teditor.dom.bind(editor.getBody(), \'beforedeactivate\', function(e) {\n
\t\t\t\t\t\t\tif (e.target != editor.getBody()) {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\ttry {\n
\t\t\t\t\t\t\t\teditor.lastRng = editor.selection.getRng();\n
\t\t\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t\t\t// IE throws "Unexcpected call to method or property access" some times so lets ignore it\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// On other browsers take snapshot on nodechange in inline mode since they have Ghost selections for iframes\n
\t\t\t\t\t\teditor.on(\'nodechange mouseup keyup\', function(e) {\n
\t\t\t\t\t\t\tvar node = getActiveElement();\n
\n
\t\t\t\t\t\t\t// Only act on manual nodechanges\n
\t\t\t\t\t\t\tif (e.type == \'nodechange\' && e.selectionChange) {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// IE 11 reports active element as iframe not body of iframe\n
\t\t\t\t\t\t\tif (node && node.id == editor.id + \'_ifr\') {\n
\t\t\t\t\t\t\t\tnode = editor.getBody();\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (editor.dom.isChildOf(node, editor.getBody())) {\n
\t\t\t\t\t\t\t\teditor.lastRng = editor.selection.getRng();\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Handles the issue with WebKit not retaining selection within inline document\n
\t\t\t\t\t// If the user releases the mouse out side the body since a mouse up event wont occur on the body\n
\t\t\t\t\tif (Env.webkit && !selectionChangeHandler) {\n
\t\t\t\t\t\tselectionChangeHandler = function() {\n
\t\t\t\t\t\t\tvar activeEditor = editorManager.activeEditor;\n
\n
\t\t\t\t\t\t\tif (activeEditor && activeEditor.selection) {\n
\t\t\t\t\t\t\t\tvar rng = activeEditor.selection.getRng();\n
\n
\t\t\t\t\t\t\t\t// Store when it\'s non collapsed\n
\t\t\t\t\t\t\t\tif (rng && !rng.collapsed) {\n
\t\t\t\t\t\t\t\t\teditor.lastRng = rng;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\tDOM.bind(document, \'selectionchange\', selectionChangeHandler);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.on(\'setcontent\', function() {\n
\t\t\t\teditor.lastRng = null;\n
\t\t\t});\n
\n
\t\t\t// Remove last selection bookmark on mousedown see #6305\n
\t\t\teditor.on(\'mousedown\', function() {\n
\t\t\t\teditor.selection.lastFocusBookmark = null;\n
\t\t\t});\n
\n
\t\t\teditor.on(\'focusin\', function() {\n
\t\t\t\tvar focusedEditor = editorManager.focusedEditor;\n
\n
\t\t\t\tif (editor.selection.lastFocusBookmark) {\n
\t\t\t\t\teditor.selection.setRng(bookmarkToRng(editor, editor.selection.lastFocusBookmark));\n
\t\t\t\t\teditor.selection.lastFocusBookmark = null;\n
\t\t\t\t}\n
\n
\t\t\t\tif (focusedEditor != editor) {\n
\t\t\t\t\tif (focusedEditor) {\n
\t\t\t\t\t\tfocusedEditor.fire(\'blur\', {focusedEditor: editor});\n
\t\t\t\t\t}\n
\n
\t\t\t\t\teditorManager.setActive(editor);\n
\t\t\t\t\teditorManager.focusedEditor = editor;\n
\t\t\t\t\teditor.fire(\'focus\', {blurredEditor: focusedEditor});\n
\t\t\t\t\teditor.focus(true);\n
\t\t\t\t}\n
\n
\t\t\t\teditor.lastRng = null;\n
\t\t\t});\n
\n
\t\t\teditor.on(\'focusout\', function() {\n
\t\t\t\twindow.setTimeout(function() {\n
\t\t\t\t\tvar focusedEditor = editorManager.focusedEditor;\n
\n
\t\t\t\t\t// Still the same editor the the blur was outside any editor UI\n
\t\t\t\t\tif (!isUIElement(getActiveElement()) && focusedEditor == editor) {\n
\t\t\t\t\t\teditor.fire(\'blur\', {focusedEditor: null});\n
\t\t\t\t\t\teditorManager.focusedEditor = null;\n
\n
\t\t\t\t\t\t// Make sure selection is valid could be invalid if the editor is blured and removed before the timeout occurs\n
\t\t\t\t\t\tif (editor.selection) {\n
\t\t\t\t\t\t\teditor.selection.lastFocusBookmark = null;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}, 0);\n
\t\t\t});\n
\n
\t\t\t// Check if focus is moved to an element outside the active editor by checking if the target node\n
\t\t\t// isn\'t within the body of the activeEditor nor a UI element such as a dialog child control\n
\t\t\tif (!documentFocusInHandler) {\n
\t\t\t\tdocumentFocusInHandler = function(e) {\n
\t\t\t\t\tvar activeEditor = editorManager.activeEditor;\n
\n
\t\t\t\t\tif (activeEditor && e.target.ownerDocument == document) {\n
\t\t\t\t\t\t// Check to make sure we have a valid selection don\'t update the bookmark if it\'s\n
\t\t\t\t\t\t// a focusin to the body of the editor see #7025\n
\t\t\t\t\t\tif (activeEditor.selection && e.target != activeEditor.getBody()) {\n
\t\t\t\t\t\t\tactiveEditor.selection.lastFocusBookmark = createBookmark(activeEditor.dom, activeEditor.lastRng);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Fire a blur event if the element isn\'t a UI element\n
\t\t\t\t\t\tif (e.target != document.body && !isUIElement(e.target) && editorManager.focusedEditor == activeEditor) {\n
\t\t\t\t\t\t\tactiveEditor.fire(\'blur\', {focusedEditor: null});\n
\t\t\t\t\t\t\teditorManager.focusedEditor = null;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\tDOM.bind(document, \'focusin\', documentFocusInHandler);\n
\t\t\t}\n
\n
\t\t\t// Handle edge case when user starts the selection inside the editor and releases\n
\t\t\t// the mouse outside the editor producing a new selection. This weird workaround is needed since\n
\t\t\t// Gecko doesn\'t have the "selectionchange" event we need to do this. Fixes: #6843\n
\t\t\tif (editor.inline && !documentMouseUpHandler) {\n
\t\t\t\tdocumentMouseUpHandler = function(e) {\n
\t\t\t\t\tvar activeEditor = editorManager.activeEditor;\n
\n
\t\t\t\t\tif (activeEditor.inline && !activeEditor.dom.isChildOf(e.target, activeEditor.getBody())) {\n
\t\t\t\t\t\tvar rng = activeEditor.selection.getRng();\n
\n
\t\t\t\t\t\tif (!rng.collapsed) {\n
\t\t\t\t\t\t\tactiveEditor.lastRng = rng;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\tDOM.bind(document, \'mouseup\', documentMouseUpHandler);\n
\t\t\t}\n
\t\t}\n
\n
\t\tfunction unregisterDocumentEvents(e) {\n
\t\t\tif (editorManager.focusedEditor == e.editor) {\n
\t\t\t\teditorManager.focusedEditor = null;\n
\t\t\t}\n
\n
\t\t\tif (!editorManager.activeEditor) {\n
\t\t\t\tDOM.unbind(document, \'selectionchange\', selectionChangeHandler);\n
\t\t\t\tDOM.unbind(document, \'focusin\', documentFocusInHandler);\n
\t\t\t\tDOM.unbind(document, \'mouseup\', documentMouseUpHandler);\n
\t\t\t\tselectionChangeHandler = documentFocusInHandler = documentMouseUpHandler = null;\n
\t\t\t}\n
\t\t}\n
\n
\t\teditorManager.on(\'AddEditor\', registerEvents);\n
\t\teditorManager.on(\'RemoveEditor\', unregisterDocumentEvents);\n
\t}\n
\n
\t/**\n
\t * Returns true if the specified element is part of the UI for example an button or text input.\n
\t *\n
\t * @method isEditorUIElement\n
\t * @param  {Element} elm Element to check if it\'s part of the UI or not.\n
\t * @return {Boolean} True/false state if the element is part of the UI or not.\n
\t */\n
\tFocusManager.isEditorUIElement = function(elm) {\n
\t\t// Needs to be converted to string since svg can have focus: #6776\n
\t\treturn elm.className.toString().indexOf(\'mce-\') !== -1;\n
\t};\n
\n
\treturn FocusManager;\n
});\n
\n
// Included from: js/tinymce/classes/EditorManager.js\n
\n
/**\n
 * EditorManager.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class used as a factory for manager for tinymce.Editor instances.\n
 *\n
 * @example\n
 * tinymce.EditorManager.init({});\n
 *\n
 * @class tinymce.EditorManager\n
 * @mixes tinymce.util.Observable\n
 * @static\n
 */\n
define("tinymce/EditorManager", [\n
\t"tinymce/Editor",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/util/URI",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/util/Observable",\n
\t"tinymce/util/I18n",\n
\t"tinymce/FocusManager"\n
], function(Editor, $, DOMUtils, URI, Env, Tools, Observable, I18n, FocusManager) {\n
\tvar DOM = DOMUtils.DOM;\n
\tvar explode = Tools.explode, each = Tools.each, extend = Tools.extend;\n
\tvar instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;\n
\n
\tfunction globalEventDelegate(e) {\n
\t\teach(EditorManager.editors, function(editor) {\n
\t\t\teditor.fire(\'ResizeWindow\', e);\n
\t\t});\n
\t}\n
\n
\tfunction toggleGlobalEvents(editors, state) {\n
\t\tif (state !== boundGlobalEvents) {\n
\t\t\tif (state) {\n
\t\t\t\t$(window).on(\'resize\', globalEventDelegate);\n
\t\t\t} else {\n
\t\t\t\t$(window).off(\'resize\', globalEventDelegate);\n
\t\t\t}\n
\n
\t\t\tboundGlobalEvents = state;\n
\t\t}\n
\t}\n
\n
\tfunction removeEditorFromList(editor) {\n
\t\tvar editors = EditorManager.editors, removedFromList;\n
\n
\t\tdelete editors[editor.id];\n
\n
\t\tfor (var i = 0; i < editors.length; i++) {\n
\t\t\tif (editors[i] == editor) {\n
\t\t\t\teditors.splice(i, 1);\n
\t\t\t\tremovedFromList = true;\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\n
\t\t// Select another editor since the active one was removed\n
\t\tif (EditorManager.activeEditor == editor) {\n
\t\t\tEditorManager.activeEditor = editors[0];\n
\t\t}\n
\n
\t\t// Clear focusedEditor if necessary, so that we don\'t try to blur the destroyed editor\n
\t\tif (EditorManager.focusedEditor == editor) {\n
\t\t\tEditorManager.focusedEditor = null;\n
\t\t}\n
\n
\t\treturn removedFromList;\n
\t}\n
\n
\tfunction purgeDestroyedEditor(editor) {\n
\t\t// User has manually destroyed the editor lets clean up the mess\n
\t\tif (editor && !(editor.getContainer() || editor.getBody()).parentNode) {\n
\t\t\tremoveEditorFromList(editor);\n
\t\t\teditor.unbindAllNativeEvents();\n
\t\t\teditor.destroy(true);\n
\t\t\teditor = null;\n
\t\t}\n
\n
\t\treturn editor;\n
\t}\n
\n
\tEditorManager = {\n
\t\t/**\n
\t\t * Dom query instance.\n
\t\t *\n
\t\t * @property $\n
\t\t * @type tinymce.dom.DomQuery\n
\t\t */\n
\t\t$: $,\n
\n
\t\t/**\n
\t\t * Major version of TinyMCE build.\n
\t\t *\n
\t\t * @property majorVersion\n
\t\t * @type String\n
\t\t */\n
\t\tmajorVersion: \'4\',\n
\n
\t\t/**\n
\t\t * Minor version of TinyMCE build.\n
\t\t *\n
\t\t * @property minorVersion\n
\t\t * @type String\n
\t\t */\n
\t\tminorVersion: \'2.4\',\n
\n
\t\t/**\n
\t\t * Release date of TinyMCE build.\n
\t\t *\n
\t\t * @property releaseDate\n
\t\t * @type String\n
\t\t */\n
\t\treleaseDate: \'2015-08-17\',\n
\n
\t\t/**\n
\t\t * Collection of editor instances.\n
\t\t *\n
\t\t * @property editors\n
\t\t * @type Object\n
\t\t * @example\n
\t\t * for (edId in tinymce.editors)\n
\t\t *     tinymce.editors[edId].save();\n
\t\t */\n
\t\teditors: [],\n
\n
\t\t/**\n
\t\t * Collection of language pack data.\n
\t\t *\n
\t\t * @property i18n\n
\t\t * @type Object\n
\t\t */\n
\t\ti18n: I18n,\n
\n
\t\t/**\n
\t\t * Currently active editor instance.\n
\t\t *\n
\t\t * @property activeEditor\n
\t\t * @type tinymce.Editor\n
\t\t * @example\n
\t\t * tinyMCE.activeEditor.selection.getContent();\n
\t\t * tinymce.EditorManager.activeEditor.selection.getContent();\n
\t\t */\n
\t\tactiveEditor: null,\n
\n
\t\tsetup: function() {\n
\t\t\tvar self = this, baseURL, documentBaseURL, suffix = "", preInit, src;\n
\n
\t\t\t// Get base URL for the current document\n
\t\t\tdocumentBaseURL = document.location.href;\n
\n
\t\t\t// Check if the URL is a document based format like: http://site/dir/file and file:///\n
\t\t\t// leave other formats like applewebdata://... intact\n
\t\t\tif (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n
\t\t\t\tdocumentBaseURL = documentBaseURL.replace(/[\\?#].*$/, \'\').replace(/[\\/\\\\][^\\/]+$/, \'\');\n
\n
\t\t\t\tif (!/[\\/\\\\]$/.test(documentBaseURL)) {\n
\t\t\t\t\tdocumentBaseURL += \'/\';\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// If tinymce is defined and has a base use that or use the old tinyMCEPreInit\n
\t\t\tpreInit = window.tinymce || window.tinyMCEPreInit;\n
\t\t\tif (preInit) {\n
\t\t\t\tbaseURL = preInit.base || preInit.baseURL;\n
\t\t\t\tsuffix = preInit.suffix;\n
\t\t\t} else {\n
\t\t\t\t// Get base where the tinymce script is located\n
\t\t\t\tvar scripts = document.getElementsByTagName(\'script\');\n
\t\t\t\tfor (var i = 0; i < scripts.length; i++) {\n
\t\t\t\t\tsrc = scripts[i].src;\n
\n
\t\t\t\t\t// Script types supported:\n
\t\t\t\t\t// tinymce.js tinymce.min.js tinymce.dev.js\n
\t\t\t\t\t// tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js\n
\t\t\t\t\t// tinymce.full.js tinymce.full.min.js tinymce.full.dev.js\n
\t\t\t\t\tif (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n
\t\t\t\t\t\tif (src.indexOf(\'.min\') != -1) {\n
\t\t\t\t\t\t\tsuffix = \'.min\';\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tbaseURL = src.substring(0, src.lastIndexOf(\'/\'));\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// We didn\'t find any baseURL by looking at the script elements\n
\t\t\t\t// Try to use the document.currentScript as a fallback\n
\t\t\t\tif (!baseURL && document.currentScript) {\n
\t\t\t\t\tsrc = document.currentScript.src;\n
\n
\t\t\t\t\tif (src.indexOf(\'.min\') != -1) {\n
\t\t\t\t\t\tsuffix = \'.min\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tbaseURL = src.substring(0, src.lastIndexOf(\'/\'));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Base URL where the root directory if TinyMCE is located.\n
\t\t\t *\n
\t\t\t * @property baseURL\n
\t\t\t * @type String\n
\t\t\t */\n
\t\t\tself.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n
\n
\t\t\t/**\n
\t\t\t * Document base URL where the current document is located.\n
\t\t\t *\n
\t\t\t * @property documentBaseURL\n
\t\t\t * @type String\n
\t\t\t */\n
\t\t\tself.documentBaseURL = documentBaseURL;\n
\n
\t\t\t/**\n
\t\t\t * Absolute baseURI for the installation path of TinyMCE.\n
\t\t\t *\n
\t\t\t * @property baseURI\n
\t\t\t * @type tinymce.util.URI\n
\t\t\t */\n
\t\t\tself.baseURI = new URI(self.baseURL);\n
\n
\t\t\t/**\n
\t\t\t * Current suffix to add to each plugin/theme that gets loaded for example ".min".\n
\t\t\t *\n
\t\t\t * @property suffix\n
\t\t\t * @type String\n
\t\t\t */\n
\t\t\tself.suffix = suffix;\n
\n
\t\t\tself.focusManager = new FocusManager(self);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes a set of editors. This method will create editors based on various settings.\n
\t\t *\n
\t\t * @method init\n
\t\t * @param {Object} settings Settings object to be passed to each editor instance.\n
\t\t * @example\n
\t\t * // Initializes a editor using the longer method\n
\t\t * tinymce.EditorManager.init({\n
\t\t *    some_settings : \'some value\'\n
\t\t * });\n
\t\t *\n
\t\t * // Initializes a editor instance using the shorter version\n
\t\t * tinyMCE.init({\n
\t\t *    some_settings : \'some value\'\n
\t\t * });\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, editors = [];\n
\n
\t\t\tfunction createId(elm) {\n
\t\t\t\tvar id = elm.id;\n
\n
\t\t\t\t// Use element id, or unique name or generate a unique id\n
\t\t\t\tif (!id) {\n
\t\t\t\t\tid = elm.name;\n
\n
\t\t\t\t\tif (id && !DOM.get(id)) {\n
\t\t\t\t\t\tid = elm.name;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// Generate unique name\n
\t\t\t\t\t\tid = DOM.uniqueId();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\telm.setAttribute(\'id\', id);\n
\t\t\t\t}\n
\n
\t\t\t\treturn id;\n
\t\t\t}\n
\n
\t\t\tfunction createEditor(id, settings, targetElm) {\n
\t\t\t\tif (!purgeDestroyedEditor(self.get(id))) {\n
\t\t\t\t\tvar editor = new Editor(id, settings, self);\n
\n
\t\t\t\t\teditor.targetElm = editor.targetElm || targetElm;\n
\t\t\t\t\teditors.push(editor);\n
\t\t\t\t\teditor.render();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction execCallback(name) {\n
\t\t\t\tvar callback = settings[name];\n
\n
\t\t\t\tif (!callback) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\treturn callback.apply(self, Array.prototype.slice.call(arguments, 2));\n
\t\t\t}\n
\n
\t\t\tfunction hasClass(elm, className) {\n
\t\t\t\treturn className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);\n
\t\t\t}\n
\n
\t\t\tfunction readyHandler() {\n
\t\t\t\tvar l, co;\n
\n
\t\t\t\tDOM.unbind(window, \'ready\', readyHandler);\n
\n
\t\t\t\texecCallback(\'onpageload\');\n
\n
\t\t\t\tif (settings.types) {\n
\t\t\t\t\t// Process type specific selector\n
\t\t\t\t\teach(settings.types, function(type) {\n
\t\t\t\t\t\teach(DOM.select(type.selector), function(elm) {\n
\t\t\t\t\t\t\tcreateEditor(createId(elm), extend({}, settings, type), elm);\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t} else if (settings.selector) {\n
\t\t\t\t\t// Process global selector\n
\t\t\t\t\teach(DOM.select(settings.selector), function(elm) {\n
\t\t\t\t\t\tcreateEditor(createId(elm), settings, elm);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\treturn;\n
\t\t\t\t} else if (settings.target) {\n
\t\t\t\t\tcreateEditor(createId(settings.target), settings);\n
\t\t\t\t}\n
\n
\t\t\t\t// Fallback to old setting\n
\t\t\t\tswitch (settings.mode) {\n
\t\t\t\t\tcase "exact":\n
\t\t\t\t\t\tl = settings.elements || \'\';\n
\n
\t\t\t\t\t\tif (l.length > 0) {\n
\t\t\t\t\t\t\teach(explode(l), function(id) {\n
\t\t\t\t\t\t\t\tvar elm;\n
\n
\t\t\t\t\t\t\t\tif ((elm = DOM.get(id))) {\n
\t\t\t\t\t\t\t\t\tcreateEditor(id, settings, elm);\n
\t\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\t\teach(document.forms, function(f) {\n
\t\t\t\t\t\t\t\t\t\teach(f.elements, function(e) {\n
\t\t\t\t\t\t\t\t\t\t\tif (e.name === id) {\n
\t\t\t\t\t\t\t\t\t\t\t\tid = \'mce_editor_\' + instanceCounter++;\n
\t\t\t\t\t\t\t\t\t\t\t\tDOM.setAttrib(e, \'id\', id);\n
\t\t\t\t\t\t\t\t\t\t\t\tcreateEditor(id, settings, e);\n
\t\t\t\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\tcase "textareas":\n
\t\t\t\t\tcase "specific_textareas":\n
\t\t\t\t\t\teach(DOM.select(\'textarea\'), function(elm) {\n
\t\t\t\t\t\t\tif (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {\n
\t\t\t\t\t\t\t\tcreateEditor(createId(elm), settings, elm);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\t// Call onInit when all editors are initialized\n
\t\t\t\tif (settings.oninit) {\n
\t\t\t\t\tl = co = 0;\n
\n
\t\t\t\t\teach(editors, function(ed) {\n
\t\t\t\t\t\tco++;\n
\n
\t\t\t\t\t\tif (!ed.initialized) {\n
\t\t\t\t\t\t\t// Wait for it\n
\t\t\t\t\t\t\ted.on(\'init\', function() {\n
\t\t\t\t\t\t\t\tl++;\n
\n
\t\t\t\t\t\t\t\t// All done\n
\t\t\t\t\t\t\t\tif (l == co) {\n
\t\t\t\t\t\t\t\t\texecCallback(\'oninit\');\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tl++;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// All done\n
\t\t\t\t\t\tif (l == co) {\n
\t\t\t\t\t\t\texecCallback(\'oninit\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.settings = settings;\n
\n
\t\t\tDOM.bind(window, \'ready\', readyHandler);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a editor instance by id.\n
\t\t *\n
\t\t * @method get\n
\t\t * @param {String/Number} id Editor instance id or index to return.\n
\t\t * @return {tinymce.Editor} Editor instance to return.\n
\t\t * @example\n
\t\t * // Adds an onclick event to an editor by id (shorter version)\n
\t\t * tinymce.get(\'mytextbox\').on(\'click\', function(e) {\n
\t\t *    ed.windowManager.alert(\'Hello world!\');\n
\t\t * });\n
\t\t *\n
\t\t * // Adds an onclick event to an editor by id (longer version)\n
\t\t * tinymce.EditorManager.get(\'mytextbox\').on(\'click\', function(e) {\n
\t\t *    ed.windowManager.alert(\'Hello world!\');\n
\t\t * });\n
\t\t */\n
\t\tget: function(id) {\n
\t\t\tif (!arguments.length) {\n
\t\t\t\treturn this.editors;\n
\t\t\t}\n
\n
\t\t\treturn id in this.editors ? this.editors[id] : null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds an editor instance to the editor collection. This will also set it as the active editor.\n
\t\t *\n
\t\t * @method add\n
\t\t * @param {tinymce.Editor} editor Editor instance to add to the collection.\n
\t\t * @return {tinymce.Editor} The same instance that got passed in.\n
\t\t */\n
\t\tadd: function(editor) {\n
\t\t\tvar self = this, editors = self.editors;\n
\n
\t\t\t// Add named and index editor instance\n
\t\t\teditors[editor.id] = editor;\n
\t\t\teditors.push(editor);\n
\n
\t\t\ttoggleGlobalEvents(editors, true);\n
\n
\t\t\t// Doesn\'t call setActive method since we don\'t want\n
\t\t\t// to fire a bunch of activate/deactivate calls while initializing\n
\t\t\tself.activeEditor = editor;\n
\n
\t\t\t/**\n
\t\t\t * Fires when an editor is added to the EditorManager collection.\n
\t\t\t *\n
\t\t\t * @event AddEditor\n
\t\t\t * @param {Object} e Event arguments.\n
\t\t\t */\n
\t\t\tself.fire(\'AddEditor\', {editor: editor});\n
\n
\t\t\tif (!beforeUnloadDelegate) {\n
\t\t\t\tbeforeUnloadDelegate = function() {\n
\t\t\t\t\tself.fire(\'BeforeUnload\');\n
\t\t\t\t};\n
\n
\t\t\t\tDOM.bind(window, \'beforeunload\', beforeUnloadDelegate);\n
\t\t\t}\n
\n
\t\t\treturn editor;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Creates an editor instance and adds it to the EditorManager collection.\n
\t\t *\n
\t\t * @method createEditor\n
\t\t * @param {String} id Instance id to use for editor.\n
\t\t * @param {Object} settings Editor instance settings.\n
\t\t * @return {tinymce.Editor} Editor instance that got created.\n
\t\t */\n
\t\tcreateEditor: function(id, settings) {\n
\t\t\treturn this.add(new Editor(id, settings, this));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes a editor or editors form page.\n
\t\t *\n
\t\t * @example\n
\t\t * // Remove all editors bound to divs\n
\t\t * tinymce.remove(\'div\');\n
\t\t *\n
\t\t * // Remove all editors bound to textareas\n
\t\t * tinymce.remove(\'textarea\');\n
\t\t *\n
\t\t * // Remove all editors\n
\t\t * tinymce.remove();\n
\t\t *\n
\t\t * // Remove specific instance by id\n
\t\t * tinymce.remove(\'#id\');\n
\t\t *\n
\t\t * @method remove\n
\t\t * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.\n
\t\t * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.\n
\t\t */\n
\t\tremove: function(selector) {\n
\t\t\tvar self = this, i, editors = self.editors, editor;\n
\n
\t\t\t// Remove all editors\n
\t\t\tif (!selector) {\n
\t\t\t\tfor (i = editors.length - 1; i >= 0; i--) {\n
\t\t\t\t\tself.remove(editors[i]);\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Remove editors by selector\n
\t\t\tif (typeof selector == "string") {\n
\t\t\t\tselector = selector.selector || selector;\n
\n
\t\t\t\teach(DOM.select(selector), function(elm) {\n
\t\t\t\t\teditor = editors[elm.id];\n
\n
\t\t\t\t\tif (editor) {\n
\t\t\t\t\t\tself.remove(editor);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Remove specific editor\n
\t\t\teditor = selector;\n
\n
\t\t\t// Not in the collection\n
\t\t\tif (!editors[editor.id]) {\n
\t\t\t\treturn null;\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Fires when an editor is removed from EditorManager collection.\n
\t\t\t *\n
\t\t\t * @event RemoveEditor\n
\t\t\t * @param {Object} e Event arguments.\n
\t\t\t */\n
\t\t\tif (removeEditorFromList(editor)) {\n
\t\t\t\tself.fire(\'RemoveEditor\', {editor: editor});\n
\t\t\t}\n
\n
\t\t\tif (!editors.length) {\n
\t\t\t\tDOM.unbind(window, \'beforeunload\', beforeUnloadDelegate);\n
\t\t\t}\n
\n
\t\t\teditor.remove();\n
\n
\t\t\ttoggleGlobalEvents(editors, editors.length > 0);\n
\n
\t\t\treturn editor;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes a specific command on the currently active editor.\n
\t\t *\n
\t\t * @method execCommand\n
\t\t * @param {String} c Command to perform for example Bold.\n
\t\t * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.\n
\t\t * @param {String} v Optional value parameter like for example an URL to a link.\n
\t\t * @return {Boolean} true/false if the command was executed or not.\n
\t\t */\n
\t\texecCommand: function(cmd, ui, value) {\n
\t\t\tvar self = this, editor = self.get(value);\n
\n
\t\t\t// Manager commands\n
\t\t\tswitch (cmd) {\n
\t\t\t\tcase "mceAddEditor":\n
\t\t\t\t\tif (!self.get(value)) {\n
\t\t\t\t\t\tnew Editor(value, self.settings, self).render();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn true;\n
\n
\t\t\t\tcase "mceRemoveEditor":\n
\t\t\t\t\tif (editor) {\n
\t\t\t\t\t\teditor.remove();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn true;\n
\n
\t\t\t\tcase \'mceToggleEditor\':\n
\t\t\t\t\tif (!editor) {\n
\t\t\t\t\t\tself.execCommand(\'mceAddEditor\', 0, value);\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (editor.isHidden()) {\n
\t\t\t\t\t\teditor.show();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.hide();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\t// Run command on active editor\n
\t\t\tif (self.activeEditor) {\n
\t\t\t\treturn self.activeEditor.execCommand(cmd, ui, value);\n
\t\t\t}\n
\n
\t\t\treturn false;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.\n
\t\t *\n
\t\t * @method triggerSave\n
\t\t * @example\n
\t\t * // Saves all contents\n
\t\t * tinyMCE.triggerSave();\n
\t\t */\n
\t\ttriggerSave: function() {\n
\t\t\teach(this.editors, function(editor) {\n
\t\t\t\teditor.save();\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a language pack, this gets called by the loaded language files like en.js.\n
\t\t *\n
\t\t * @method addI18n\n
\t\t * @param {String} code Optional language code.\n
\t\t * @param {Object} items Name/value object with translations.\n
\t\t */\n
\t\taddI18n: function(code, items) {\n
\t\t\tI18n.add(code, items);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Translates the specified string using the language pack items.\n
\t\t *\n
\t\t * @method translate\n
\t\t * @param {String/Array/Object} text String to translate\n
\t\t * @return {String} Translated string.\n
\t\t */\n
\t\ttranslate: function(text) {\n
\t\t\treturn I18n.translate(text);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the active editor instance and fires the deactivate/activate events.\n
\t\t *\n
\t\t * @method setActive\n
\t\t * @param {tinymce.Editor} editor Editor instance to set as the active instance.\n
\t\t */\n
\t\tsetActive: function(editor) {\n
\t\t\tvar activeEditor = this.activeEditor;\n
\n
\t\t\tif (this.activeEditor != editor) {\n
\t\t\t\tif (activeEditor) {\n
\t\t\t\t\tactiveEditor.fire(\'deactivate\', {relatedTarget: editor});\n
\t\t\t\t}\n
\n
\t\t\t\teditor.fire(\'activate\', {relatedTarget: activeEditor});\n
\t\t\t}\n
\n
\t\t\tthis.activeEditor = editor;\n
\t\t}\n
\t};\n
\n
\textend(EditorManager, Observable);\n
\n
\tEditorManager.setup();\n
\n
\t// Export EditorManager as tinymce/tinymce in global namespace\n
\twindow.tinymce = window.tinyMCE = EditorManager;\n
\n
\treturn EditorManager;\n
});\n
\n
// Included from: js/tinymce/classes/LegacyInput.js\n
\n
/**\n
 * LegacyInput.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
define("tinymce/LegacyInput", [\n
\t"tinymce/EditorManager",\n
\t"tinymce/util/Tools"\n
], function(EditorManager, Tools) {\n
\tvar each = Tools.each, explode = Tools.explode;\n
\n
\tEditorManager.on(\'AddEditor\', function(e) {\n
\t\tvar editor = e.editor;\n
\n
\t\teditor.on(\'preInit\', function() {\n
\t\t\tvar filters, fontSizes, dom, settings = editor.settings;\n
\n
\t\t\tfunction replaceWithSpan(node, styles) {\n
\t\t\t\teach(styles, function(value, name) {\n
\t\t\t\t\tif (value) {\n
\t\t\t\t\t\tdom.setStyle(node, name, value);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tdom.rename(node, \'span\');\n
\t\t\t}\n
\n
\t\t\tfunction convert(e) {\n
\t\t\t\tdom = editor.dom;\n
\n
\t\t\t\tif (settings.convert_fonts_to_spans) {\n
\t\t\t\t\teach(dom.select(\'font,u,strike\', e.node), function(node) {\n
\t\t\t\t\t\tfilters[node.nodeName.toLowerCase()](dom, node);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (settings.inline_styles) {\n
\t\t\t\tfontSizes = explode(settings.font_size_legacy_values);\n
\n
\t\t\t\tfilters = {\n
\t\t\t\t\tfont: function(dom, node) {\n
\t\t\t\t\t\treplaceWithSpan(node, {\n
\t\t\t\t\t\t\tbackgroundColor: node.style.backgroundColor,\n
\t\t\t\t\t\t\tcolor: node.color,\n
\t\t\t\t\t\t\tfontFamily: node.face,\n
\t\t\t\t\t\t\tfontSize: fontSizes[parseInt(node.size, 10) - 1]\n
\t\t\t\t\t\t});\n
\t\t\t\t\t},\n
\n
\t\t\t\t\tu: function(dom, node) {\n
\t\t\t\t\t\t// HTML5 allows U element\n
\t\t\t\t\t\tif (editor.settings.schema === "html4") {\n
\t\t\t\t\t\t\treplaceWithSpan(node, {\n
\t\t\t\t\t\t\t\ttextDecoration: \'underline\'\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t},\n
\n
\t\t\t\t\tstrike: function(dom, node) {\n
\t\t\t\t\t\treplaceWithSpan(node, {\n
\t\t\t\t\t\t\ttextDecoration: \'line-through\'\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\teditor.on(\'PreProcess SetContent\', convert);\n
\t\t\t}\n
\t\t});\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/util/XHR.js\n
\n
/**\n
 * XHR.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class enables you to send XMLHTTPRequests cross browser.\n
 * @class tinymce.util.XHR\n
 * @mixes tinymce.util.Observable\n
 * @static\n
 * @example\n
 * // Sends a low level Ajax request\n
 * tinymce.util.XHR.send({\n
 *    url: \'someurl\',\n
 *    success: function(text) {\n
 *       console.debug(text);\n
 *    }\n
 * });\n
 *\n
 * // Add custom header to XHR request\n
 * tinymce.util.XHR.on(\'beforeSend\', function(e) {\n
 *     e.xhr.setRequestHeader(\'X-Requested-With\', \'Something\');\n
 * });\n
 */\n
define("tinymce/util/XHR", [\n
\t"tinymce/util/Observable",\n
\t"tinymce/util/Tools"\n
], function(Observable, Tools) {\n
\tvar XHR = {\n
\t\t/**\n
\t\t * Sends a XMLHTTPRequest.\n
\t\t * Consult the Wiki for details on what settings this method takes.\n
\t\t *\n
\t\t * @method send\n
\t\t * @param {Object} settings Object will target URL, callbacks and other info needed to make the request.\n
\t\t */\n
\t\tsend: function(settings) {\n
\t\t\tvar xhr, count = 0;\n
\n
\t\t\tfunction ready() {\n
\t\t\t\tif (!settings.async || xhr.readyState == 4 || count++ > 10000) {\n
\t\t\t\t\tif (settings.success && count < 10000 && xhr.status == 200) {\n
\t\t\t\t\t\tsettings.success.call(settings.success_scope, \'\' + xhr.responseText, xhr, settings);\n
\t\t\t\t\t} else if (settings.error) {\n
\t\t\t\t\t\tsettings.error.call(settings.error_scope, count > 10000 ? \'TIMED_OUT\' : \'GENERAL\', xhr, settings);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\txhr = null;\n
\t\t\t\t} else {\n
\t\t\t\t\tsetTimeout(ready, 10);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Default settings\n
\t\t\tsettings.scope = settings.scope || this;\n
\t\t\tsettings.success_scope = settings.success_scope || settings.scope;\n
\t\t\tsettings.error_scope = settings.error_scope || settings.scope;\n
\t\t\tsettings.async = settings.async === false ? false : true;\n
\t\t\tsettings.data = settings.data || \'\';\n
\n
\t\t\txhr = new XMLHttpRequest();\n
\n
\t\t\tif (xhr) {\n
\t\t\t\tif (xhr.overrideMimeType) {\n
\t\t\t\t\txhr.overrideMimeType(settings.content_type);\n
\t\t\t\t}\n
\n
\t\t\t\txhr.open(settings.type || (settings.data ? \'POST\' : \'GET\'), settings.url, settings.async);\n
\n
\t\t\t\tif (settings.crossDomain) {\n
\t\t\t\t\txhr.withCredentials = true;\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.content_type) {\n
\t\t\t\t\txhr.setRequestHeader(\'Content-Type\', settings.content_type);\n
\t\t\t\t}\n
\n
\t\t\t\txhr.setRequestHeader(\'X-Requested-With\', \'XMLHttpRequest\');\n
\n
\t\t\t\txhr = XHR.fire(\'beforeSend\', {xhr: xhr, settings: settings}).xhr;\n
\t\t\t\txhr.send(settings.data);\n
\n
\t\t\t\t// Syncronous request\n
\t\t\t\tif (!settings.async) {\n
\t\t\t\t\treturn ready();\n
\t\t\t\t}\n
\n
\t\t\t\t// Wait for response, onReadyStateChange can not be used since it leaks memory in IE\n
\t\t\t\tsetTimeout(ready, 10);\n
\t\t\t}\n
\t\t}\n
\t};\n
\n
\tTools.extend(XHR, Observable);\n
\n
\treturn XHR;\n
});\n
\n
// Included from: js/tinymce/classes/util/JSON.js\n
\n
/**\n
 * JSON.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * JSON parser and serializer class.\n
 *\n
 * @class tinymce.util.JSON\n
 * @static\n
 * @example\n
 * // JSON parse a string into an object\n
 * var obj = tinymce.util.JSON.parse(somestring);\n
 *\n
 * // JSON serialize a object into an string\n
 * var str = tinymce.util.JSON.serialize(obj);\n
 */\n
define("tinymce/util/JSON", [], function() {\n
\tfunction serialize(o, quote) {\n
\t\tvar i, v, t, name;\n
\n
\t\tquote = quote || \'"\';\n
\n
\t\tif (o === null) {\n
\t\t\treturn \'null\';\n
\t\t}\n
\n
\t\tt = typeof o;\n
\n
\t\tif (t == \'string\') {\n
\t\t\tv = \'\\bb\\tt\\nn\\ff\\rr\\""\\\'\\\'\\\\\\\\\';\n
\n
\t\t\treturn quote + o.replace(/([\\u0080-\\uFFFF\\x00-\\x1f\\"\\\'\\\\])/g, function(a, b) {\n
\t\t\t\t// Make sure single quotes never get encoded inside double quotes for JSON compatibility\n
\t\t\t\tif (quote === \'"\' && a === "\'") {\n
\t\t\t\t\treturn a;\n
\t\t\t\t}\n
\n
\t\t\t\ti = v.indexOf(b);\n
\n
\t\t\t\tif (i + 1) {\n
\t\t\t\t\treturn \'\\\\\' + v.charAt(i + 1);\n
\t\t\t\t}\n
\n
\t\t\t\ta = b.charCodeAt().toString(16);\n
\n
\t\t\t\treturn \'\\\\u\' + \'0000\'.substring(a.length) + a;\n
\t\t\t}) + quote;\n
\t\t}\n
\n
\t\tif (t == \'object\') {\n
\t\t\tif (o.hasOwnProperty && Object.prototype.toString.call(o) === \'[object Array]\') {\n
\t\t\t\tfor (i = 0, v = \'[\'; i < o.length; i++) {\n
\t\t\t\t\tv += (i > 0 ? \',\' : \'\') + serialize(o[i], quote);\n
\t\t\t\t}\n
\n
\t\t\t\treturn v + \']\';\n
\t\t\t}\n
\n
\t\t\tv = \'{\';\n
\n
\t\t\tfor (name in o) {\n
\t\t\t\tif (o.hasOwnProperty(name)) {\n
\t\t\t\t\tv += typeof o[name] != \'function\' ? (v.length > 1 ? \',\' + quote : quote) + name +\n
\t\t\t\t\t\tquote + \':\' + serialize(o[name], quote) : \'\';\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn v + \'}\';\n
\t\t}\n
\n
\t\treturn \'\' + o;\n
\t}\n
\n
\treturn {\n
\t\t/**\n
\t\t * Serializes the specified object as a JSON string.\n
\t\t *\n
\t\t * @method serialize\n
\t\t * @param {Object} obj Object to serialize as a JSON string.\n
\t\t * @param {String} quote Optional quote string defaults to ".\n
\t\t * @return {string} JSON string serialized from input.\n
\t\t */\n
\t\tserialize: serialize,\n
\n
\t\t/**\n
\t\t * Unserializes/parses the specified JSON string into a object.\n
\t\t *\n
\t\t * @method parse\n
\t\t * @param {string} s JSON String to parse into a JavaScript object.\n
\t\t * @return {Object} Object from input JSON string or undefined if it failed.\n
\t\t */\n
\t\tparse: function(text) {\n
\t\t\ttry {\n
\t\t\t\t// Trick uglify JS\n
\t\t\t\treturn window[String.fromCharCode(101) + \'val\'](\'(\' + text + \')\');\n
\t\t\t} catch (ex) {\n
\t\t\t\t// Ignore\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**#@-*/\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/JSONRequest.js\n
\n
/**\n
 * JSONRequest.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class enables you to use JSON-RPC to call backend methods.\n
 *\n
 * @class tinymce.util.JSONRequest\n
 * @example\n
 * var json = new tinymce.util.JSONRequest({\n
 *     url: \'somebackend.php\'\n
 * });\n
 *\n
 * // Send RPC call 1\n
 * json.send({\n
 *     method: \'someMethod1\',\n
 *     params: [\'a\', \'b\'],\n
 *     success: function(result) {\n
 *         console.dir(result);\n
 *     }\n
 * });\n
 *\n
 * // Send RPC call 2\n
 * json.send({\n
 *     method: \'someMethod2\',\n
 *     params: [\'a\', \'b\'],\n
 *     success: function(result) {\n
 *         console.dir(result);\n
 *     }\n
 * });\n
 */\n
define("tinymce/util/JSONRequest", [\n
\t"tinymce/util/JSON",\n
\t"tinymce/util/XHR",\n
\t"tinymce/util/Tools"\n
], function(JSON, XHR, Tools) {\n
\tvar extend = Tools.extend;\n
\n
\tfunction JSONRequest(settings) {\n
\t\tthis.settings = extend({}, settings);\n
\t\tthis.count = 0;\n
\t}\n
\n
\t/**\n
\t * Simple helper function to send a JSON-RPC request without the need to initialize an object.\n
\t * Consult the Wiki API documentation for more details on what you can pass to this function.\n
\t *\n
\t * @method sendRPC\n
\t * @static\n
\t * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.\n
\t */\n
\tJSONRequest.sendRPC = function(o) {\n
\t\treturn new JSONRequest().send(o);\n
\t};\n
\n
\tJSONRequest.prototype = {\n
\t\t/**\n
\t\t * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.\n
\t\t *\n
\t\t * @method send\n
\t\t * @param {Object} args Call object where there are three field id, method and params this object should also contain callbacks etc.\n
\t\t */\n
\t\tsend: function(args) {\n
\t\t\tvar ecb = args.error, scb = args.success;\n
\n
\t\t\targs = extend(this.settings, args);\n
\n
\t\t\targs.success = function(c, x) {\n
\t\t\t\tc = JSON.parse(c);\n
\n
\t\t\t\tif (typeof c == \'undefined\') {\n
\t\t\t\t\tc = {\n
\t\t\t\t\t\terror: \'JSON Parse error.\'\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\tif (c.error) {\n
\t\t\t\t\tecb.call(args.error_scope || args.scope, c.error, x);\n
\t\t\t\t} else {\n
\t\t\t\t\tscb.call(args.success_scope || args.scope, c.result);\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\targs.error = function(ty, x) {\n
\t\t\t\tif (ecb) {\n
\t\t\t\t\tecb.call(args.error_scope || args.scope, ty, x);\n
\t\t\t\t}\n
\t\t\t};\n
\n
\t\t\targs.data = JSON.serialize({\n
\t\t\t\tid: args.id || \'c\' + (this.count++),\n
\t\t\t\tmethod: args.method,\n
\t\t\t\tparams: args.params\n
\t\t\t});\n
\n
\t\t\t// JSON content type for Ruby on rails. Bug: #1883287\n
\t\t\targs.content_type = \'application/json\';\n
\n
\t\t\tXHR.send(args);\n
\t\t}\n
\t};\n
\n
\treturn JSONRequest;\n
});\n
\n
// Included from: js/tinymce/classes/util/JSONP.js\n
\n
/**\n
 * JSONP.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
define("tinymce/util/JSONP", [\n
\t"tinymce/dom/DOMUtils"\n
], function(DOMUtils) {\n
\treturn {\n
\t\tcallbacks: {},\n
\t\tcount: 0,\n
\n
\t\tsend: function(settings) {\n
\t\t\tvar self = this, dom = DOMUtils.DOM, count = settings.count !== undefined ? settings.count : self.count;\n
\t\t\tvar id = \'tinymce_jsonp_\' + count;\n
\n
\t\t\tself.callbacks[count] = function(json) {\n
\t\t\t\tdom.remove(id);\n
\t\t\t\tdelete self.callbacks[count];\n
\n
\t\t\t\tsettings.callback(json);\n
\t\t\t};\n
\n
\t\t\tdom.add(dom.doc.body, \'script\', {\n
\t\t\t\tid: id,\n
\t\t\t\tsrc: settings.url,\n
\t\t\t\ttype: \'text/javascript\'\n
\t\t\t});\n
\n
\t\t\tself.count++;\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/util/LocalStorage.js\n
\n
/**\n
 * LocalStorage.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class will simulate LocalStorage on IE 7 and return the native version on modern browsers.\n
 * Storage is done using userData on IE 7 and a special serialization format. The format is designed\n
 * to be as small as possible by making sure that the keys and values doesn\'t need to be encoded. This\n
 * makes it possible to store for example HTML data.\n
 *\n
 * Storage format for userData:\n
 * <base 32 key length>,<key string>,<base 32 value length>,<value>,...\n
 *\n
 * For example this data key1=value1,key2=value2 would be:\n
 * 4,key1,6,value1,4,key2,6,value2\n
 *\n
 * @class tinymce.util.LocalStorage\n
 * @static\n
 * @version 4.0\n
 * @example\n
 * tinymce.util.LocalStorage.setItem(\'key\', \'value\');\n
 * var value = tinymce.util.LocalStorage.getItem(\'key\');\n
 */\n
define("tinymce/util/LocalStorage", [], function() {\n
\tvar LocalStorage, storageElm, items, keys, userDataKey, hasOldIEDataSupport;\n
\n
\t// Check for native support\n
\ttry {\n
\t\tif (window.localStorage) {\n
\t\t\treturn localStorage;\n
\t\t}\n
\t} catch (ex) {\n
\t\t// Ignore\n
\t}\n
\n
\tuserDataKey = "tinymce";\n
\tstorageElm = document.documentElement;\n
\thasOldIEDataSupport = !!storageElm.addBehavior;\n
\n
\tif (hasOldIEDataSupport) {\n
\t\tstorageElm.addBehavior(\'#default#userData\');\n
\t}\n
\n
\t/**\n
\t * Gets the keys names and updates LocalStorage.length property. Since IE7 doesn\'t have any getters/setters.\n
\t */\n
\tfunction updateKeys() {\n
\t\tkeys = [];\n
\n
\t\tfor (var key in items) {\n
\t\t\tkeys.push(key);\n
\t\t}\n
\n
\t\tLocalStorage.length = keys.length;\n
\t}\n
\n
\t/**\n
\t * Loads the userData string and parses it into the items structure.\n
\t */\n
\tfunction load() {\n
\t\tvar key, data, value, pos = 0;\n
\n
\t\titems = {};\n
\n
\t\t// localStorage can be disabled on WebKit/Gecko so make a dummy storage\n
\t\tif (!hasOldIEDataSupport) {\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tfunction next(end) {\n
\t\t\tvar value, nextPos;\n
\n
\t\t\tnextPos = end !== undefined ? pos + end : data.indexOf(\',\', pos);\n
\t\t\tif (nextPos === -1 || nextPos > data.length) {\n
\t\t\t\treturn null;\n
\t\t\t}\n
\n
\t\t\tvalue = data.substring(pos, nextPos);\n
\t\t\tpos = nextPos + 1;\n
\n
\t\t\treturn value;\n
\t\t}\n
\n
\t\tstorageElm.load(userDataKey);\n
\t\tdata = storageElm.getAttribute(userDataKey) || \'\';\n
\n
\t\tdo {\n
\t\t\tvar offset = next();\n
\t\t\tif (offset === null) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\n
\t\t\tkey = next(parseInt(offset, 32) || 0);\n
\t\t\tif (key !== null) {\n
\t\t\t\toffset = next();\n
\t\t\t\tif (offset === null) {\n
\t\t\t\t\tbreak;\n
\t\t\t\t}\n
\n
\t\t\t\tvalue = next(parseInt(offset, 32) || 0);\n
\n
\t\t\t\tif (key) {\n
\t\t\t\t\titems[key] = value;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t} while (key !== null);\n
\n
\t\tupdateKeys();\n
\t}\n
\n
\t/**\n
\t * Saves the items structure into a the userData format.\n
\t */\n
\tfunction save() {\n
\t\tvar value, data = \'\';\n
\n
\t\t// localStorage can be disabled on WebKit/Gecko so make a dummy storage\n
\t\tif (!hasOldIEDataSupport) {\n
\t\t\treturn;\n
\t\t}\n
\n
\t\tfor (var key in items) {\n
\t\t\tvalue = items[key];\n
\t\t\tdata += (data ? \',\' : \'\') + key.length.toString(32) + \',\' + key + \',\' + value.length.toString(32) + \',\' + value;\n
\t\t}\n
\n
\t\tstorageElm.setAttribute(userDataKey, data);\n
\n
\t\ttry {\n
\t\t\tstorageElm.save(userDataKey);\n
\t\t} catch (ex) {\n
\t\t\t// Ignore disk full\n
\t\t}\n
\n
\t\tupdateKeys();\n
\t}\n
\n
\tLocalStorage = {\n
\t\t/**\n
\t\t * Length of the number of items in storage.\n
\t\t *\n
\t\t * @property length\n
\t\t * @type Number\n
\t\t * @return {Number} Number of items in storage.\n
\t\t */\n
\t\t//length:0,\n
\n
\t\t/**\n
\t\t * Returns the key name by index.\n
\t\t *\n
\t\t * @method key\n
\t\t * @param {Number} index Index of key to return.\n
\t\t * @return {String} Key value or null if it wasn\'t found.\n
\t\t */\n
\t\tkey: function(index) {\n
\t\t\treturn keys[index];\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the value if the specified key or null if it wasn\'t found.\n
\t\t *\n
\t\t * @method getItem\n
\t\t * @param {String} key Key of item to retrive.\n
\t\t * @return {String} Value of the specified item or null if it wasn\'t found.\n
\t\t */\n
\t\tgetItem: function(key) {\n
\t\t\treturn key in items ? items[key] : null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the value of the specified item by it\'s key.\n
\t\t *\n
\t\t * @method setItem\n
\t\t * @param {String} key Key of the item to set.\n
\t\t * @param {String} value Value of the item to set.\n
\t\t */\n
\t\tsetItem: function(key, value) {\n
\t\t\titems[key] = "" + value;\n
\t\t\tsave();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the specified item by key.\n
\t\t *\n
\t\t * @method removeItem\n
\t\t * @param {String} key Key of item to remove.\n
\t\t */\n
\t\tremoveItem: function(key) {\n
\t\t\tdelete items[key];\n
\t\t\tsave();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes all items.\n
\t\t *\n
\t\t * @method clear\n
\t\t */\n
\t\tclear: function() {\n
\t\t\titems = {};\n
\t\t\tsave();\n
\t\t}\n
\t};\n
\n
\tload();\n
\n
\treturn LocalStorage;\n
});\n
\n
// Included from: js/tinymce/classes/Compat.js\n
\n
/**\n
 * Compat.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * TinyMCE core class.\n
 *\n
 * @static\n
 * @class tinymce\n
 * @borrow-members tinymce.EditorManager\n
 * @borrow-members tinymce.util.Tools\n
 */\n
define("tinymce/Compat", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/dom/EventUtils",\n
\t"tinymce/dom/ScriptLoader",\n
\t"tinymce/AddOnManager",\n
\t"tinymce/util/Tools",\n
\t"tinymce/Env"\n
], function(DOMUtils, EventUtils, ScriptLoader, AddOnManager, Tools, Env) {\n
\tvar tinymce = window.tinymce;\n
\n
\t/**\n
\t * @property {tinymce.dom.DOMUtils} DOM Global DOM instance.\n
\t * @property {tinymce.dom.ScriptLoader} ScriptLoader Global ScriptLoader instance.\n
\t * @property {tinymce.AddOnManager} PluginManager Global PluginManager instance.\n
\t * @property {tinymce.AddOnManager} ThemeManager Global ThemeManager instance.\n
\t */\n
\ttinymce.DOM = DOMUtils.DOM;\n
\ttinymce.ScriptLoader = ScriptLoader.ScriptLoader;\n
\ttinymce.PluginManager = AddOnManager.PluginManager;\n
\ttinymce.ThemeManager = AddOnManager.ThemeManager;\n
\n
\ttinymce.dom = tinymce.dom || {};\n
\ttinymce.dom.Event = EventUtils.Event;\n
\n
\tTools.each(Tools, function(func, key) {\n
\t\ttinymce[key] = func;\n
\t});\n
\n
\tTools.each(\'isOpera isWebKit isIE isGecko isMac\'.split(\' \'), function(name) {\n
\t\ttinymce[name] = Env[name.substr(2).toLowerCase()];\n
\t});\n
\n
\treturn {};\n
});\n
\n
// Describe the different namespaces\n
\n
/**\n
 * Root level namespace this contains classes directly releated to the TinyMCE editor.\n
 *\n
 * @namespace tinymce\n
 */\n
\n
/**\n
 * Contains classes for handling the browsers DOM.\n
 *\n
 * @namespace tinymce.dom\n
 */\n
\n
/**\n
 * Contains html parser and serializer logic.\n
 *\n
 * @namespace tinymce.html\n
 */\n
\n
/**\n
 * Contains the different UI types such as buttons, listboxes etc.\n
 *\n
 * @namespace tinymce.ui\n
 */\n
\n
/**\n
 * Contains various utility classes such as json parser, cookies etc.\n
 *\n
 * @namespace tinymce.util\n
 */\n
\n
// Included from: js/tinymce/classes/ui/Layout.js\n
\n
/**\n
 * Layout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Base layout manager class.\n
 *\n
 * @class tinymce.ui.Layout\n
 */\n
define("tinymce/ui/Layout", [\n
\t"tinymce/util/Class",\n
\t"tinymce/util/Tools"\n
], function(Class, Tools) {\n
\t"use strict";\n
\n
\treturn Class.extend({\n
\t\tDefaults: {\n
\t\t\tfirstControlClass: \'first\',\n
\t\t\tlastControlClass: \'last\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a layout instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tthis.settings = Tools.extend({}, this.Defaults, settings);\n
\t\t},\n
\n
\t\t/**\n
\t\t * This method gets invoked before the layout renders the controls.\n
\t\t *\n
\t\t * @method preRender\n
\t\t * @param {tinymce.ui.Container} container Container instance to preRender.\n
\t\t */\n
\t\tpreRender: function(container) {\n
\t\t\tcontainer.bodyClasses.add(this.settings.containerClass);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Applies layout classes to the container.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tapplyClasses: function(items) {\n
\t\t\tvar self = this, settings = self.settings, firstClass, lastClass, firstItem, lastItem;\n
\n
\t\t\tfirstClass = settings.firstControlClass;\n
\t\t\tlastClass = settings.lastControlClass;\n
\n
\t\t\titems.each(function(item) {\n
\t\t\t\titem.classes.remove(firstClass).remove(lastClass).add(settings.controlClass);\n
\n
\t\t\t\tif (item.visible()) {\n
\t\t\t\t\tif (!firstItem) {\n
\t\t\t\t\t\tfirstItem = item;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tlastItem = item;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (firstItem) {\n
\t\t\t\tfirstItem.classes.add(firstClass);\n
\t\t\t}\n
\n
\t\t\tif (lastItem) {\n
\t\t\t\tlastItem.classes.add(lastClass);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the specified container and any layout specific HTML.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @param {tinymce.ui.Container} container Container to render HTML for.\n
\t\t */\n
\t\trenderHtml: function(container) {\n
\t\t\tvar self = this, html = \'\';\n
\n
\t\t\tself.applyClasses(container.items());\n
\n
\t\t\tcontainer.items().each(function(item) {\n
\t\t\t\thtml += item.renderHtml();\n
\t\t\t});\n
\n
\t\t\treturn html;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function() {\n
\t\t},\n
\n
\t\t/**\n
\t\t * This method gets invoked after the layout renders the controls.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @param {tinymce.ui.Container} container Container instance to postRender.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t},\n
\n
\t\tisNative: function() {\n
\t\t\treturn false;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/AbsoluteLayout.js\n
\n
/**\n
 * AbsoluteLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * LayoutManager for absolute positioning. This layout manager is more of\n
 * a base class for other layouts but can be created and used directly.\n
 *\n
 * @-x-less AbsoluteLayout.less\n
 * @class tinymce.ui.AbsoluteLayout\n
 * @extends tinymce.ui.Layout\n
 */\n
define("tinymce/ui/AbsoluteLayout", [\n
\t"tinymce/ui/Layout"\n
], function(Layout) {\n
\t"use strict";\n
\n
\treturn Layout.extend({\n
\t\tDefaults: {\n
\t\t\tcontainerClass: \'abs-layout\',\n
\t\t\tcontrolClass: \'abs-layout-item\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\tcontainer.items().filter(\':visible\').each(function(ctrl) {\n
\t\t\t\tvar settings = ctrl.settings;\n
\n
\t\t\t\tctrl.layoutRect({\n
\t\t\t\t\tx: settings.x,\n
\t\t\t\t\ty: settings.y,\n
\t\t\t\t\tw: settings.w,\n
\t\t\t\t\th: settings.h\n
\t\t\t\t});\n
\n
\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\tctrl.recalc();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the specified container and any layout specific HTML.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @param {tinymce.ui.Container} container Container to render HTML for.\n
\t\t */\n
\t\trenderHtml: function(container) {\n
\t\t\treturn \'<div id="\' + container._id + \'-absend" class="\' + container.classPrefix + \'abs-end"></div>\' + this._super(container);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Tooltip.js\n
\n
/**\n
 * Tooltip.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a tooltip instance.\n
 *\n
 * @-x-less ToolTip.less\n
 * @class tinymce.ui.ToolTip\n
 * @extends tinymce.ui.Control\n
 * @mixes tinymce.ui.Movable\n
 */\n
define("tinymce/ui/Tooltip", [\n
\t"tinymce/ui/Control",\n
\t"tinymce/ui/Movable"\n
], function(Control, Movable) {\n
\treturn Control.extend({\n
\t\tMixins: [Movable],\n
\n
\t\tDefaults: {\n
\t\t\tclasses: \'widget tooltip tooltip-n\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, prefix = self.classPrefix;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'" role="presentation">\' +\n
\t\t\t\t\t\'<div class="\' + prefix + \'tooltip-arrow"></div>\' +\n
\t\t\t\t\t\'<div class="\' + prefix + \'tooltip-inner">\' + self.encode(self.state.get(\'text\')) + \'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:text\', function(e) {\n
\t\t\t\tself.getEl().lastChild.innerHTML = self.encode(e.value);\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this, style, rect;\n
\n
\t\t\tstyle = self.getEl().style;\n
\t\t\trect = self._layoutRect;\n
\n
\t\t\tstyle.left = rect.x + \'px\';\n
\t\t\tstyle.top = rect.y + \'px\';\n
\t\t\tstyle.zIndex = 0xFFFF + 0xFFFF;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Widget.js\n
\n
/**\n
 * Widget.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Widget base class a widget is a control that has a tooltip and some basic states.\n
 *\n
 * @class tinymce.ui.Widget\n
 * @extends tinymce.ui.Control\n
 */\n
define("tinymce/ui/Widget", [\n
\t"tinymce/ui/Control",\n
\t"tinymce/ui/Tooltip"\n
], function(Control, Tooltip) {\n
\t"use strict";\n
\n
\tvar tooltip;\n
\n
\tvar Widget = Control.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} tooltip Tooltip text to display when hovering.\n
\t\t * @setting {Boolean} autofocus True if the control should be focused when rendered.\n
\t\t * @setting {String} text Text to display inside widget.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\t\t\tself.canFocus = true;\n
\n
\t\t\tif (settings.tooltip && Widget.tooltips !== false) {\n
\t\t\t\tself.on(\'mouseenter\', function(e) {\n
\t\t\t\t\tvar tooltip = self.tooltip().moveTo(-0xFFFF);\n
\n
\t\t\t\t\tif (e.control == self) {\n
\t\t\t\t\t\tvar rel = tooltip.text(settings.tooltip).show().testMoveRel(self.getEl(), [\'bc-tc\', \'bc-tl\', \'bc-tr\']);\n
\n
\t\t\t\t\t\ttooltip.classes.toggle(\'tooltip-n\', rel == \'bc-tc\');\n
\t\t\t\t\t\ttooltip.classes.toggle(\'tooltip-nw\', rel == \'bc-tl\');\n
\t\t\t\t\t\ttooltip.classes.toggle(\'tooltip-ne\', rel == \'bc-tr\');\n
\n
\t\t\t\t\t\ttooltip.moveRel(self.getEl(), rel);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\ttooltip.hide();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.on(\'mouseleave mousedown click\', function() {\n
\t\t\t\t\tself.tooltip().hide();\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.aria(\'label\', settings.ariaLabel || settings.tooltip);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the current tooltip instance.\n
\t\t *\n
\t\t * @method tooltip\n
\t\t * @return {tinymce.ui.Tooltip} Tooltip instance.\n
\t\t */\n
\t\ttooltip: function() {\n
\t\t\tif (!tooltip) {\n
\t\t\t\ttooltip = new Tooltip({type: \'tooltip\'});\n
\t\t\t\ttooltip.renderTo();\n
\t\t\t}\n
\n
\t\t\treturn tooltip;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, settings = self.settings;\n
\n
\t\t\tself._super();\n
\n
\t\t\tif (!self.parent() && (settings.width || settings.height)) {\n
\t\t\t\tself.initLayoutRect();\n
\t\t\t\tself.repaint();\n
\t\t\t}\n
\n
\t\t\tif (settings.autofocus) {\n
\t\t\t\tself.focus();\n
\t\t\t}\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tfunction disable(state) {\n
\t\t\t\tself.aria(\'disabled\', state);\n
\t\t\t\tself.classes.toggle(\'disabled\', state);\n
\t\t\t}\n
\n
\t\t\tfunction active(state) {\n
\t\t\t\tself.aria(\'pressed\', state);\n
\t\t\t\tself.classes.toggle(\'active\', state);\n
\t\t\t}\n
\n
\t\t\tself.state.on(\'change:disabled\', function(e) {\n
\t\t\t\tdisable(e.value);\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:active\', function(e) {\n
\t\t\t\tactive(e.value);\n
\t\t\t});\n
\n
\t\t\tif (self.state.get(\'disabled\')) {\n
\t\t\t\tdisable(true);\n
\t\t\t}\n
\n
\t\t\tif (self.state.get(\'active\')) {\n
\t\t\t\tactive(true);\n
\t\t\t}\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the current control from DOM and from UI collections.\n
\t\t *\n
\t\t * @method remove\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tthis._super();\n
\n
\t\t\tif (tooltip) {\n
\t\t\t\ttooltip.remove();\n
\t\t\t\ttooltip = null;\n
\t\t\t}\n
\t\t}\n
\t});\n
\n
\treturn Widget;\n
});\n
\n
// Included from: js/tinymce/classes/ui/Button.js\n
\n
/**\n
 * Button.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is used to create buttons. You can create them directly or through the Factory.\n
 *\n
 * @example\n
 * // Create and render a button to the body element\n
 * tinymce.ui.Factory.create({\n
 *     type: \'button\',\n
 *     text: \'My button\'\n
 * }).renderTo(document.body);\n
 *\n
 * @-x-less Button.less\n
 * @class tinymce.ui.Button\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Button", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\tDefaults: {\n
\t\t\tclasses: "widget btn",\n
\t\t\trole: "button"\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a new button instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} size Size of the button small|medium|large.\n
\t\t * @setting {String} image Image to use for icon.\n
\t\t * @setting {String} icon Icon to use for button.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, size;\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tsize = self.settings.size;\n
\n
\t\t\tself.on(\'click mousedown\', function(e) {\n
\t\t\t\te.preventDefault();\n
\t\t\t});\n
\n
\t\t\tself.on(\'touchstart\', function(e) {\n
\t\t\t\tself.fire(\'click\', e);\n
\t\t\t\te.preventDefault();\n
\t\t\t});\n
\n
\t\t\tif (settings.subtype) {\n
\t\t\t\tself.classes.add(settings.subtype);\n
\t\t\t}\n
\n
\t\t\tif (size) {\n
\t\t\t\tself.classes.add(\'btn-\' + size);\n
\t\t\t}\n
\n
\t\t\tif (settings.icon) {\n
\t\t\t\tself.icon(settings.icon);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets the current button icon.\n
\t\t *\n
\t\t * @method icon\n
\t\t * @param {String} [icon] New icon identifier.\n
\t\t * @return {String|tinymce.ui.MenuButton} Current icon or current MenuButton instance.\n
\t\t */\n
\t\ticon: function(icon) {\n
\t\t\tif (!arguments.length) {\n
\t\t\t\treturn this.state.get(\'icon\');\n
\t\t\t}\n
\n
\t\t\tthis.state.set(\'icon\', icon);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the button for example after it\'s been resizes by a layout engine.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar btnStyle = this.getEl().firstChild.style;\n
\n
\t\t\tbtnStyle.width = btnStyle.height = "100%";\n
\n
\t\t\tthis._sup

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAA8=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="15" aka="AAAAAAAAAA8=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

er();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix;\n
\t\t\tvar icon = self.state.get(\'icon\'), image, text = self.state.get(\'text\');\n
\n
\t\t\timage = self.settings.image;\n
\t\t\tif (image) {\n
\t\t\t\ticon = \'none\';\n
\n
\t\t\t\t// Support for [high dpi, low dpi] image sources\n
\t\t\t\tif (typeof image != "string") {\n
\t\t\t\t\timage = window.getSelection ? image[0] : image[1];\n
\t\t\t\t}\n
\n
\t\t\t\timage = \' style="background-image: url(\\\'\' + image + \'\\\')"\';\n
\t\t\t} else {\n
\t\t\t\timage = \'\';\n
\t\t\t}\n
\n
\t\t\tif (text) {\n
\t\t\t\tself.classes.add(\'btn-has-text\');\n
\t\t\t}\n
\n
\t\t\ticon = self.settings.icon ? prefix + \'ico \' + prefix + \'i-\' + icon : \'\';\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" tabindex="-1" aria-labelledby="\' + id + \'">\' +\n
\t\t\t\t\t\'<button role="presentation" type="button" tabindex="-1">\' +\n
\t\t\t\t\t\t(icon ? \'<i class="\' + icon + \'"\' + image + \'></i>\' : \'\') +\n
\t\t\t\t\t\t(text ? self.encode(text) : \'\') +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tfunction setButtonText(text) {\n
\t\t\t\tvar node = self.getEl().firstChild.firstChild;\n
\n
\t\t\t\tfor (; node; node = node.nextSibling) {\n
\t\t\t\t\tif (node.nodeType == 3) {\n
\t\t\t\t\t\tnode.data = self.translate(text);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tself.classes.toggle(\'btn-has-text\', !!text);\n
\t\t\t}\n
\n
\t\t\tself.state.on(\'change:text\', function(e) {\n
\t\t\t\tsetButtonText(e.value);\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:icon\', function(e) {\n
\t\t\t\tvar icon = e.value, prefix = self.classPrefix;\n
\n
\t\t\t\tself.settings.icon = icon;\n
\t\t\t\ticon = icon ? prefix + \'ico \' + prefix + \'i-\' + self.settings.icon : \'\';\n
\n
\t\t\t\tvar btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName(\'i\')[0];\n
\n
\t\t\t\tif (icon) {\n
\t\t\t\t\tif (!iconElm || iconElm != btnElm.firstChild) {\n
\t\t\t\t\t\ticonElm = document.createElement(\'i\');\n
\t\t\t\t\t\tbtnElm.insertBefore(iconElm, btnElm.firstChild);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\ticonElm.className = icon;\n
\t\t\t\t} else if (iconElm) {\n
\t\t\t\t\tbtnElm.removeChild(iconElm);\n
\t\t\t\t}\n
\n
\t\t\t\tsetButtonText(self.state.get(\'text\'));\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/ButtonGroup.js\n
\n
/**\n
 * ButtonGroup.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This control enables you to put multiple buttons into a group. This is\n
 * useful when you want to combine similar toolbar buttons into a group.\n
 *\n
 * @example\n
 * // Create and render a buttongroup with two buttons to the body element\n
 * tinymce.ui.Factory.create({\n
 *     type: \'buttongroup\',\n
 *     items: [\n
 *         {text: \'Button A\'},\n
 *         {text: \'Button B\'}\n
 *     ]\n
 * }).renderTo(document.body);\n
 *\n
 * @-x-less ButtonGroup.less\n
 * @class tinymce.ui.ButtonGroup\n
 * @extends tinymce.ui.Container\n
 */\n
define("tinymce/ui/ButtonGroup", [\n
\t"tinymce/ui/Container"\n
], function(Container) {\n
\t"use strict";\n
\n
\treturn Container.extend({\n
\t\tDefaults: {\n
\t\t\tdefaultType: \'button\',\n
\t\t\trole: \'group\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout;\n
\n
\t\t\tself.classes.add(\'btn-group\');\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body">\' +\n
\t\t\t\t\t\t(self.settings.html || \'\') + layout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Checkbox.js\n
\n
/**\n
 * Checkbox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This control creates a custom checkbox.\n
 *\n
 * @example\n
 * // Create and render a checkbox to the body element\n
 * tinymce.ui.Factory.create({\n
 *     type: \'checkbox\',\n
 *     checked: true,\n
 *     text: \'My checkbox\'\n
 * }).renderTo(document.body);\n
 *\n
 * @-x-less Checkbox.less\n
 * @class tinymce.ui.Checkbox\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Checkbox", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\tDefaults: {\n
\t\t\tclasses: "checkbox",\n
\t\t\trole: "checkbox",\n
\t\t\tchecked: false\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a new Checkbox instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Boolean} checked True if the checkbox should be checked by default.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\n
\t\t\tself.on(\'click mousedown\', function(e) {\n
\t\t\t\te.preventDefault();\n
\t\t\t});\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\te.preventDefault();\n
\n
\t\t\t\tif (!self.disabled()) {\n
\t\t\t\t\tself.checked(!self.checked());\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.checked(self.settings.checked);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Getter/setter function for the checked state.\n
\t\t *\n
\t\t * @method checked\n
\t\t * @param {Boolean} [state] State to be set.\n
\t\t * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it\'s a set operation.\n
\t\t */\n
\t\tchecked: function(state) {\n
\t\t\tif (!arguments.length) {\n
\t\t\t\treturn this.state.get(\'checked\');\n
\t\t\t}\n
\n
\t\t\tthis.state.set(\'checked\', state);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Getter/setter function for the value state.\n
\t\t *\n
\t\t * @method value\n
\t\t * @param {Boolean} [state] State to be set.\n
\t\t * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it\'s a set operation.\n
\t\t */\n
\t\tvalue: function(state) {\n
\t\t\tif (!arguments.length) {\n
\t\t\t\treturn this.checked();\n
\t\t\t}\n
\n
\t\t\treturn this.checked(state);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" unselectable="on" aria-labelledby="\' + id + \'-al" tabindex="-1">\' +\n
\t\t\t\t\t\'<i class="\' + prefix + \'ico \' + prefix + \'i-checkbox"></i>\' +\n
\t\t\t\t\t\'<span id="\' + id + \'-al" class="\' + prefix + \'label">\' + self.encode(self.state.get(\'text\')) + \'</span>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tfunction checked(state) {\n
\t\t\t\tself.classes.toggle("checked", state);\n
\t\t\t\tself.aria(\'checked\', state);\n
\t\t\t}\n
\n
\t\t\tself.state.on(\'change:text\', function(e) {\n
\t\t\t\tself.getEl(\'al\').firstChild.data = self.translate(e.value);\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:checked change:value\', function(e) {\n
\t\t\t\tself.fire(\'change\');\n
\t\t\t\tchecked(e.value);\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:icon\', function(e) {\n
\t\t\t\tvar icon = e.value, prefix = self.classPrefix;\n
\n
\t\t\t\tif (typeof icon == \'undefined\') {\n
\t\t\t\t\treturn self.settings.icon;\n
\t\t\t\t}\n
\n
\t\t\t\tself.settings.icon = icon;\n
\t\t\t\ticon = icon ? prefix + \'ico \' + prefix + \'i-\' + self.settings.icon : \'\';\n
\n
\t\t\t\tvar btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName(\'i\')[0];\n
\n
\t\t\t\tif (icon) {\n
\t\t\t\t\tif (!iconElm || iconElm != btnElm.firstChild) {\n
\t\t\t\t\t\ticonElm = document.createElement(\'i\');\n
\t\t\t\t\t\tbtnElm.insertBefore(iconElm, btnElm.firstChild);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\ticonElm.className = icon;\n
\t\t\t\t} else if (iconElm) {\n
\t\t\t\t\tbtnElm.removeChild(iconElm);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (self.state.get(\'checked\')) {\n
\t\t\t\tchecked(true);\n
\t\t\t}\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/ComboBox.js\n
\n
/**\n
 * ComboBox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates a combobox control. Select box that you select a value from or\n
 * type a value into.\n
 *\n
 * @-x-less ComboBox.less\n
 * @class tinymce.ui.ComboBox\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/ComboBox", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/Factory",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/dom/DomQuery"\n
], function(Widget, Factory, DomUtils, $) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} placeholder Placeholder text to display.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tself.classes.add(\'combobox\');\n
\t\t\tself.subinput = true;\n
\t\t\tself.ariaTarget = \'inp\'; // TODO: Figure out a better way\n
\n
\t\t\tsettings.menu = settings.menu || settings.values;\n
\n
\t\t\tif (settings.menu) {\n
\t\t\t\tsettings.icon = \'caret\';\n
\t\t\t}\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tvar elm = e.target, root = self.getEl();\n
\n
\t\t\t\tif (!$.contains(root, elm) && elm != root) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\twhile (elm && elm != root) {\n
\t\t\t\t\tif (elm.id && elm.id.indexOf(\'-open\') != -1) {\n
\t\t\t\t\t\tself.fire(\'action\');\n
\n
\t\t\t\t\t\tif (settings.menu) {\n
\t\t\t\t\t\t\tself.showMenu();\n
\n
\t\t\t\t\t\t\tif (e.aria) {\n
\t\t\t\t\t\t\t\tself.menu.items()[0].focus();\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\telm = elm.parentNode;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// TODO: Rework this\n
\t\t\tself.on(\'keydown\', function(e) {\n
\t\t\t\tif (e.target.nodeName == "INPUT" && e.keyCode == 13) {\n
\t\t\t\t\tself.parents().reverse().each(function(ctrl) {\n
\t\t\t\t\t\tvar stateValue = self.state.get(\'value\'), inputValue = self.getEl(\'inp\').value;\n
\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\tself.state.set(\'value\', inputValue);\n
\n
\t\t\t\t\t\tif (stateValue != inputValue) {\n
\t\t\t\t\t\t\tself.fire(\'change\');\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (ctrl.hasEventListeners(\'submit\') && ctrl.toJSON) {\n
\t\t\t\t\t\t\tctrl.fire(\'submit\', {data: ctrl.toJSON()});\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'keyup\', function(e) {\n
\t\t\t\tif (e.target.nodeName == "INPUT") {\n
\t\t\t\t\tself.state.set(\'value\', e.target.value);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\tshowMenu: function() {\n
\t\t\tvar self = this, settings = self.settings, menu;\n
\n
\t\t\tif (!self.menu) {\n
\t\t\t\tmenu = settings.menu || [];\n
\n
\t\t\t\t// Is menu array then auto constuct menu control\n
\t\t\t\tif (menu.length) {\n
\t\t\t\t\tmenu = {\n
\t\t\t\t\t\ttype: \'menu\',\n
\t\t\t\t\t\titems: menu\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\tmenu.type = menu.type || \'menu\';\n
\t\t\t\t}\n
\n
\t\t\t\tself.menu = Factory.create(menu).parent(self).renderTo(self.getContainerElm());\n
\t\t\t\tself.fire(\'createmenu\');\n
\t\t\t\tself.menu.reflow();\n
\t\t\t\tself.menu.on(\'cancel\', function(e) {\n
\t\t\t\t\tif (e.control === self.menu) {\n
\t\t\t\t\t\tself.focus();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.menu.on(\'show hide\', function(e) {\n
\t\t\t\t\te.control.items().each(function(ctrl) {\n
\t\t\t\t\t\tctrl.active(ctrl.value() == self.value());\n
\t\t\t\t\t});\n
\t\t\t\t}).fire(\'show\');\n
\n
\t\t\t\tself.menu.on(\'select\', function(e) {\n
\t\t\t\t\tself.value(e.control.value());\n
\t\t\t\t});\n
\n
\t\t\t\tself.on(\'focusin\', function(e) {\n
\t\t\t\t\tif (e.target.tagName.toUpperCase() == \'INPUT\') {\n
\t\t\t\t\t\tself.menu.hide();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.aria(\'expanded\', true);\n
\t\t\t}\n
\n
\t\t\tself.menu.show();\n
\t\t\tself.menu.layoutRect({w: self.layoutRect().w});\n
\t\t\tself.menu.moveRel(self.getEl(), self.isRtl() ? [\'br-tr\', \'tr-br\'] : [\'bl-tl\', \'tl-bl\']);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses the input area of the control.\n
\t\t *\n
\t\t * @method focus\n
\t\t */\n
\t\tfocus: function() {\n
\t\t\tthis.getEl(\'inp\').focus();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this, elm = self.getEl(), openElm = self.getEl(\'open\'), rect = self.layoutRect();\n
\t\t\tvar width, lineHeight;\n
\n
\t\t\tif (openElm) {\n
\t\t\t\twidth = rect.w - DomUtils.getSize(openElm).width - 10;\n
\t\t\t} else {\n
\t\t\t\twidth = rect.w - 10;\n
\t\t\t}\n
\n
\t\t\t// Detect old IE 7+8 add lineHeight to align caret vertically in the middle\n
\t\t\tvar doc = document;\n
\t\t\tif (doc.all && (!doc.documentMode || doc.documentMode <= 8)) {\n
\t\t\t\tlineHeight = (self.layoutRect().h - 2) + \'px\';\n
\t\t\t}\n
\n
\t\t\t$(elm.firstChild).css({\n
\t\t\t\twidth: width,\n
\t\t\t\tlineHeight: lineHeight\n
\t\t\t});\n
\n
\t\t\tself._super();\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Post render method. Called after the control has been rendered to the target.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @return {tinymce.ui.ComboBox} Current combobox instance.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\t$(this.getEl(\'inp\')).on(\'change\', function(e) {\n
\t\t\t\tself.state.set(\'value\', e.target.value);\n
\t\t\t\tself.fire(\'change\', e);\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, settings = self.settings, prefix = self.classPrefix;\n
\t\t\tvar value = self.state.get(\'value\') || \'\';\n
\t\t\tvar icon, text, openBtnHtml = \'\', extraAttrs = \'\';\n
\n
\t\t\tif ("spellcheck" in settings) {\n
\t\t\t\textraAttrs += \' spellcheck="\' + settings.spellcheck + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.maxLength) {\n
\t\t\t\textraAttrs += \' maxlength="\' + settings.maxLength + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.size) {\n
\t\t\t\textraAttrs += \' size="\' + settings.size + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.subtype) {\n
\t\t\t\textraAttrs += \' type="\' + settings.subtype + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (self.disabled()) {\n
\t\t\t\textraAttrs += \' disabled="disabled"\';\n
\t\t\t}\n
\n
\t\t\ticon = settings.icon;\n
\t\t\tif (icon && icon != \'caret\') {\n
\t\t\t\ticon = prefix + \'ico \' + prefix + \'i-\' + settings.icon;\n
\t\t\t}\n
\n
\t\t\ttext = self.state.get(\'text\');\n
\n
\t\t\tif (icon || text) {\n
\t\t\t\topenBtnHtml = (\n
\t\t\t\t\t\'<div id="\' + id + \'-open" class="\' + prefix + \'btn \' + prefix + \'open" tabIndex="-1" role="button">\' +\n
\t\t\t\t\t\t\'<button id="\' + id + \'-action" type="button" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t\t\t(icon != \'caret\' ? \'<i class="\' + icon + \'"></i>\' : \'<i class="\' + prefix + \'caret"></i>\') +\n
\t\t\t\t\t\t\t(text ? (icon ? \' \' : \'\') + text : \'\') +\n
\t\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\t\'</div>\'\n
\t\t\t\t);\n
\n
\t\t\t\tself.classes.add(\'has-open\');\n
\t\t\t}\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\t\'<input id="\' + id + \'-inp" class="\' + prefix + \'textbox" value="\' +\n
\t\t\t\t\tself.encode(value, false) + \'" hidefocus="1"\' + extraAttrs + \' placeholder="\' +\n
\t\t\t\t\tself.encode(settings.placeholder) + \'" />\' +\n
\t\t\t\t\topenBtnHtml +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tvalue: function(value) {\n
\t\t\tif (arguments.length) {\n
\t\t\t\tthis.state.set(\'value\', value);\n
\t\t\t\treturn this;\n
\t\t\t}\n
\n
\t\t\t// Make sure the real state is in sync\n
\t\t\tif (this.state.get(\'rendered\')) {\n
\t\t\t\tthis.state.set(\'value\', this.getEl(\'inp\').value);\n
\t\t\t}\n
\n
\t\t\treturn this.state.get(\'value\');\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:value\', function(e) {\n
\t\t\t\tif (self.getEl(\'inp\').value != e.value) {\n
\t\t\t\t\tself.getEl(\'inp\').value = e.value;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:disabled\', function(e) {\n
\t\t\t\tself.getEl(\'inp\').disabled = e.value;\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\tremove: function() {\n
\t\t\t$(this.getEl(\'inp\')).off();\n
\t\t\tthis._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/ColorBox.js\n
\n
/**\n
 * ColorBox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This widget lets you enter colors and browse for colors by pressing the color button. It also displays\n
 * a preview of the current color.\n
 *\n
 * @-x-less ColorBox.less\n
 * @class tinymce.ui.ColorBox\n
 * @extends tinymce.ui.ComboBox\n
 */\n
define("tinymce/ui/ColorBox", [\n
\t"tinymce/ui/ComboBox"\n
], function(ComboBox) {\n
\t"use strict";\n
\n
\treturn ComboBox.extend({\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tsettings.spellcheck = false;\n
\n
\t\t\tif (settings.onaction) {\n
\t\t\t\tsettings.icon = \'none\';\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\n
\t\t\tself.classes.add(\'colorbox\');\n
\t\t\tself.on(\'change keyup postrender\', function() {\n
\t\t\t\tself.repaintColor(self.value());\n
\t\t\t});\n
\t\t},\n
\n
\t\trepaintColor: function(value) {\n
\t\t\tvar elm = this.getEl().getElementsByTagName(\'i\')[0];\n
\n
\t\t\tif (elm) {\n
\t\t\t\ttry {\n
\t\t\t\t\telm.style.background = value;\n
\t\t\t\t} catch (ex) {\n
\t\t\t\t\t// Ignore\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:value\', function(e) {\n
\t\t\t\tif (self._rendered) {\n
\t\t\t\t\tself.repaintColor(e.value);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/PanelButton.js\n
\n
/**\n
 * PanelButton.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new panel button.\n
 *\n
 * @class tinymce.ui.PanelButton\n
 * @extends tinymce.ui.Button\n
 */\n
define("tinymce/ui/PanelButton", [\n
\t"tinymce/ui/Button",\n
\t"tinymce/ui/FloatPanel"\n
], function(Button, FloatPanel) {\n
\t"use strict";\n
\n
\treturn Button.extend({\n
\t\t/**\n
\t\t * Shows the panel for the button.\n
\t\t *\n
\t\t * @method showPanel\n
\t\t */\n
\t\tshowPanel: function() {\n
\t\t\tvar self = this, settings = self.settings;\n
\n
\t\t\tself.active(true);\n
\n
\t\t\tif (!self.panel) {\n
\t\t\t\tvar panelSettings = settings.panel;\n
\n
\t\t\t\t// Wrap panel in grid layout if type if specified\n
\t\t\t\t// This makes it possible to add forms or other containers directly in the panel option\n
\t\t\t\tif (panelSettings.type) {\n
\t\t\t\t\tpanelSettings = {\n
\t\t\t\t\t\tlayout: \'grid\',\n
\t\t\t\t\t\titems: panelSettings\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\tpanelSettings.role = panelSettings.role || \'dialog\';\n
\t\t\t\tpanelSettings.popover = true;\n
\t\t\t\tpanelSettings.autohide = true;\n
\t\t\t\tpanelSettings.ariaRoot = true;\n
\n
\t\t\t\tself.panel = new FloatPanel(panelSettings).on(\'hide\', function() {\n
\t\t\t\t\tself.active(false);\n
\t\t\t\t}).on(\'cancel\', function(e) {\n
\t\t\t\t\te.stopPropagation();\n
\t\t\t\t\tself.focus();\n
\t\t\t\t\tself.hidePanel();\n
\t\t\t\t}).parent(self).renderTo(self.getContainerElm());\n
\n
\t\t\t\tself.panel.fire(\'show\');\n
\t\t\t\tself.panel.reflow();\n
\t\t\t} else {\n
\t\t\t\tself.panel.show();\n
\t\t\t}\n
\n
\t\t\tself.panel.moveRel(self.getEl(), settings.popoverAlign || (self.isRtl() ? [\'bc-tr\', \'bc-tc\'] : [\'bc-tl\', \'bc-tc\']));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the panel for the button.\n
\t\t *\n
\t\t * @method hidePanel\n
\t\t */\n
\t\thidePanel: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.panel) {\n
\t\t\t\tself.panel.hide();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.aria(\'haspopup\', true);\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tif (e.control === self) {\n
\t\t\t\t\tif (self.panel && self.panel.visible()) {\n
\t\t\t\t\t\tself.hidePanel();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself.showPanel();\n
\t\t\t\t\t\tself.panel.focus(!!e.aria);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\tremove: function() {\n
\t\t\tif (this.panel) {\n
\t\t\t\tthis.panel.remove();\n
\t\t\t\tthis.panel = null;\n
\t\t\t}\n
\n
\t\t\treturn this._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/ColorButton.js\n
\n
/**\n
 * ColorButton.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates a color button control. This is a split button in which the main\n
 * button has a visual representation of the currently selected color. When clicked\n
 * the caret button displays a color picker, allowing the user to select a new color.\n
 *\n
 * @-x-less ColorButton.less\n
 * @class tinymce.ui.ColorButton\n
 * @extends tinymce.ui.PanelButton\n
 */\n
define("tinymce/ui/ColorButton", [\n
\t"tinymce/ui/PanelButton",\n
\t"tinymce/dom/DOMUtils"\n
], function(PanelButton, DomUtils) {\n
\t"use strict";\n
\n
\tvar DOM = DomUtils.DOM;\n
\n
\treturn PanelButton.extend({\n
\t\t/**\n
\t\t * Constructs a new ColorButton instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tthis._super(settings);\n
\t\t\tthis.classes.add(\'colorbutton\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Getter/setter for the current color.\n
\t\t *\n
\t\t * @method color\n
\t\t * @param {String} [color] Color to set.\n
\t\t * @return {String|tinymce.ui.ColorButton} Current color or current instance.\n
\t\t */\n
\t\tcolor: function(color) {\n
\t\t\tif (color) {\n
\t\t\t\tthis._color = color;\n
\t\t\t\tthis.getEl(\'preview\').style.backgroundColor = color;\n
\t\t\t\treturn this;\n
\t\t\t}\n
\n
\t\t\treturn this._color;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Resets the current color.\n
\t\t *\n
\t\t * @method resetColor\n
\t\t * @return {tinymce.ui.ColorButton} Current instance.\n
\t\t */\n
\t\tresetColor: function() {\n
\t\t\tthis._color = null;\n
\t\t\tthis.getEl(\'preview\').style.backgroundColor = null;\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix, text = self.state.get(\'text\');\n
\t\t\tvar icon = self.settings.icon ? prefix + \'ico \' + prefix + \'i-\' + self.settings.icon : \'\';\n
\t\t\tvar image = self.settings.image ? \' style="background-image: url(\\\'\' + self.settings.image + \'\\\')"\' : \'\';\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" role="button" tabindex="-1" aria-haspopup="true">\' +\n
\t\t\t\t\t\'<button role="presentation" hidefocus="1" type="button" tabindex="-1">\' +\n
\t\t\t\t\t\t(icon ? \'<i class="\' + icon + \'"\' + image + \'></i>\' : \'\') +\n
\t\t\t\t\t\t\'<span id="\' + id + \'-preview" class="\' + prefix + \'preview"></span>\' +\n
\t\t\t\t\t\t(text ? (icon ? \' \' : \'\') + (text) : \'\') +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\t\'<button type="button" class="\' + prefix + \'open" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t\t\' <i class="\' + prefix + \'caret"></i>\' +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, onClickHandler = self.settings.onclick;\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tif (e.aria && e.aria.key == \'down\') {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (e.control == self && !DOM.getParent(e.target, \'.\' + self.classPrefix + \'open\')) {\n
\t\t\t\t\te.stopImmediatePropagation();\n
\t\t\t\t\tonClickHandler.call(self, e);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tdelete self.settings.onclick;\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/util/Color.js\n
\n
/**\n
 * Color.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class lets you parse/serialize colors and convert rgb/hsb.\n
 *\n
 * @class tinymce.util.Color\n
 * @example\n
 * var white = new tinymce.util.Color({r: 255, g: 255, b: 255});\n
 * var red = new tinymce.util.Color(\'#FF0000\');\n
 *\n
 * console.log(white.toHex(), red.toHsv());\n
 */\n
define("tinymce/util/Color", [], function() {\n
\tvar min = Math.min, max = Math.max, round = Math.round;\n
\n
\t/**\n
\t * Constructs a new color instance.\n
\t *\n
\t * @constructor\n
\t * @method Color\n
\t * @param {String} value Optional initial value to parse.\n
\t */\n
\tfunction Color(value) {\n
\t\tvar self = this, r = 0, g = 0, b = 0;\n
\n
\t\tfunction rgb2hsv(r, g, b) {\n
\t\t\tvar h, s, v, d, minRGB, maxRGB;\n
\n
\t\t\th = 0;\n
\t\t\ts = 0;\n
\t\t\tv = 0;\n
\t\t\tr = r / 255;\n
\t\t\tg = g / 255;\n
\t\t\tb = b / 255;\n
\n
\t\t\tminRGB = min(r, min(g, b));\n
\t\t\tmaxRGB = max(r, max(g, b));\n
\n
\t\t\tif (minRGB == maxRGB) {\n
\t\t\t\tv = minRGB;\n
\n
\t\t\t\treturn {\n
\t\t\t\t\th: 0,\n
\t\t\t\t\ts: 0,\n
\t\t\t\t\tv: v * 100\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\t/*eslint no-nested-ternary:0 */\n
\t\t\td = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);\n
\t\t\th = (r == minRGB) ? 3 : ((b == minRGB) ? 1 : 5);\n
\t\t\th = 60 * (h - d / (maxRGB - minRGB));\n
\t\t\ts = (maxRGB - minRGB) / maxRGB;\n
\t\t\tv = maxRGB;\n
\n
\t\t\treturn {\n
\t\t\t\th: round(h),\n
\t\t\t\ts: round(s * 100),\n
\t\t\t\tv: round(v * 100)\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction hsvToRgb(hue, saturation, brightness) {\n
\t\t\tvar side, chroma, x, match;\n
\n
\t\t\thue = (parseInt(hue, 10) || 0) % 360;\n
\t\t\tsaturation = parseInt(saturation, 10) / 100;\n
\t\t\tbrightness = parseInt(brightness, 10) / 100;\n
\t\t\tsaturation = max(0, min(saturation, 1));\n
\t\t\tbrightness = max(0, min(brightness, 1));\n
\n
\t\t\tif (saturation === 0) {\n
\t\t\t\tr = g = b = round(255 * brightness);\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tside = hue / 60;\n
\t\t\tchroma = brightness * saturation;\n
\t\t\tx = chroma * (1 - Math.abs(side % 2 - 1));\n
\t\t\tmatch = brightness - chroma;\n
\n
\t\t\tswitch (Math.floor(side)) {\n
\t\t\t\tcase 0:\n
\t\t\t\t\tr = chroma;\n
\t\t\t\t\tg = x;\n
\t\t\t\t\tb = 0;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 1:\n
\t\t\t\t\tr = x;\n
\t\t\t\t\tg = chroma;\n
\t\t\t\t\tb = 0;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 2:\n
\t\t\t\t\tr = 0;\n
\t\t\t\t\tg = chroma;\n
\t\t\t\t\tb = x;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 3:\n
\t\t\t\t\tr = 0;\n
\t\t\t\t\tg = x;\n
\t\t\t\t\tb = chroma;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 4:\n
\t\t\t\t\tr = x;\n
\t\t\t\t\tg = 0;\n
\t\t\t\t\tb = chroma;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tcase 5:\n
\t\t\t\t\tr = chroma;\n
\t\t\t\t\tg = 0;\n
\t\t\t\t\tb = x;\n
\t\t\t\t\tbreak;\n
\n
\t\t\t\tdefault:\n
\t\t\t\t\tr = g = b = 0;\n
\t\t\t}\n
\n
\t\t\tr = round(255 * (r + match));\n
\t\t\tg = round(255 * (g + match));\n
\t\t\tb = round(255 * (b + match));\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the hex string of the current color. For example: #ff00ff\n
\t\t *\n
\t\t * @method toHex\n
\t\t * @return {String} Hex string of current color.\n
\t\t */\n
\t\tfunction toHex() {\n
\t\t\tfunction hex(val) {\n
\t\t\t\tval = parseInt(val, 10).toString(16);\n
\n
\t\t\t\treturn val.length > 1 ? val : \'0\' + val;\n
\t\t\t}\n
\n
\t\t\treturn \'#\' + hex(r) + hex(g) + hex(b);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the r, g, b values of the color. Each channel has a range from 0-255.\n
\t\t *\n
\t\t * @method toRgb\n
\t\t * @return {Object} Object with r, g, b fields.\n
\t\t */\n
\t\tfunction toRgb() {\n
\t\t\treturn {\n
\t\t\t\tr: r,\n
\t\t\t\tg: g,\n
\t\t\t\tb: b\n
\t\t\t};\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the h, s, v values of the color. Ranges: h=0-360, s=0-100, v=0-100.\n
\t\t *\n
\t\t * @method toHsv\n
\t\t * @return {Object} Object with h, s, v fields.\n
\t\t */\n
\t\tfunction toHsv() {\n
\t\t\treturn rgb2hsv(r, g, b);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Parses the specified value and populates the color instance.\n
\t\t *\n
\t\t * Supported format examples:\n
\t\t *  * rbg(255,0,0)\n
\t\t *  * #ff0000\n
\t\t *  * #fff\n
\t\t *  * {r: 255, g: 0, b: 0}\n
\t\t *  * {h: 360, s: 100, v: 100}\n
\t\t *\n
\t\t * @method parse\n
\t\t * @param {Object/String} value Color value to parse.\n
\t\t * @return {tinymce.util.Color} Current color instance.\n
\t\t */\n
\t\tfunction parse(value) {\n
\t\t\tvar matches;\n
\n
\t\t\tif (typeof value == \'object\') {\n
\t\t\t\tif ("r" in value) {\n
\t\t\t\t\tr = value.r;\n
\t\t\t\t\tg = value.g;\n
\t\t\t\t\tb = value.b;\n
\t\t\t\t} else if ("v" in value) {\n
\t\t\t\t\thsvToRgb(value.h, value.s, value.v);\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\tif ((matches = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)[^\\)]*\\)/gi.exec(value))) {\n
\t\t\t\t\tr = parseInt(matches[1], 10);\n
\t\t\t\t\tg = parseInt(matches[2], 10);\n
\t\t\t\t\tb = parseInt(matches[3], 10);\n
\t\t\t\t} else if ((matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value))) {\n
\t\t\t\t\tr = parseInt(matches[1], 16);\n
\t\t\t\t\tg = parseInt(matches[2], 16);\n
\t\t\t\t\tb = parseInt(matches[3], 16);\n
\t\t\t\t} else if ((matches = /#([0-F])([0-F])([0-F])/gi.exec(value))) {\n
\t\t\t\t\tr = parseInt(matches[1] + matches[1], 16);\n
\t\t\t\t\tg = parseInt(matches[2] + matches[2], 16);\n
\t\t\t\t\tb = parseInt(matches[3] + matches[3], 16);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tr = r < 0 ? 0 : (r > 255 ? 255 : r);\n
\t\t\tg = g < 0 ? 0 : (g > 255 ? 255 : g);\n
\t\t\tb = b < 0 ? 0 : (b > 255 ? 255 : b);\n
\n
\t\t\treturn self;\n
\t\t}\n
\n
\t\tif (value) {\n
\t\t\tparse(value);\n
\t\t}\n
\n
\t\tself.toRgb = toRgb;\n
\t\tself.toHsv = toHsv;\n
\t\tself.toHex = toHex;\n
\t\tself.parse = parse;\n
\t}\n
\n
\treturn Color;\n
});\n
\n
// Included from: js/tinymce/classes/ui/ColorPicker.js\n
\n
/**\n
 * ColorPicker.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Color picker widget lets you select colors.\n
 *\n
 * @-x-less ColorPicker.less\n
 * @class tinymce.ui.ColorPicker\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/ColorPicker", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/DragHelper",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/util/Color"\n
], function(Widget, DragHelper, DomUtils, Color) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\tDefaults: {\n
\t\t\tclasses: "widget colorpicker"\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a new colorpicker instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} color Initial color value.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tthis._super(settings);\n
\t\t},\n
\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, color = self.color(), hsv, hueRootElm, huePointElm, svRootElm, svPointElm;\n
\n
\t\t\thueRootElm = self.getEl(\'h\');\n
\t\t\thuePointElm = self.getEl(\'hp\');\n
\t\t\tsvRootElm = self.getEl(\'sv\');\n
\t\t\tsvPointElm = self.getEl(\'svp\');\n
\n
\t\t\tfunction getPos(elm, event) {\n
\t\t\t\tvar pos = DomUtils.getPos(elm), x, y;\n
\n
\t\t\t\tx = event.pageX - pos.x;\n
\t\t\t\ty = event.pageY - pos.y;\n
\n
\t\t\t\tx = Math.max(0, Math.min(x / elm.clientWidth, 1));\n
\t\t\t\ty = Math.max(0, Math.min(y / elm.clientHeight, 1));\n
\n
\t\t\t\treturn {\n
\t\t\t\t\tx: x,\n
\t\t\t\t\ty: y\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tfunction updateColor(hsv, hueUpdate) {\n
\t\t\t\tvar hue = (360 - hsv.h) / 360;\n
\n
\t\t\t\tDomUtils.css(huePointElm, {\n
\t\t\t\t\ttop: (hue * 100) + \'%\'\n
\t\t\t\t});\n
\n
\t\t\t\tif (!hueUpdate) {\n
\t\t\t\t\tDomUtils.css(svPointElm, {\n
\t\t\t\t\t\tleft: hsv.s + \'%\',\n
\t\t\t\t\t\ttop: (100 - hsv.v) + \'%\'\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\n
\t\t\t\tsvRootElm.style.background = new Color({s: 100, v: 100, h: hsv.h}).toHex();\n
\t\t\t\tself.color().parse({s: hsv.s, v: hsv.v, h: hsv.h});\n
\t\t\t}\n
\n
\t\t\tfunction updateSaturationAndValue(e) {\n
\t\t\t\tvar pos;\n
\n
\t\t\t\tpos = getPos(svRootElm, e);\n
\t\t\t\thsv.s = pos.x * 100;\n
\t\t\t\thsv.v = (1 - pos.y) * 100;\n
\n
\t\t\t\tupdateColor(hsv);\n
\t\t\t\tself.fire(\'change\');\n
\t\t\t}\n
\n
\t\t\tfunction updateHue(e) {\n
\t\t\t\tvar pos;\n
\n
\t\t\t\tpos = getPos(hueRootElm, e);\n
\t\t\t\thsv = color.toHsv();\n
\t\t\t\thsv.h = (1 - pos.y) * 360;\n
\t\t\t\tupdateColor(hsv, true);\n
\t\t\t\tself.fire(\'change\');\n
\t\t\t}\n
\n
\t\t\tself._repaint = function() {\n
\t\t\t\thsv = color.toHsv();\n
\t\t\t\tupdateColor(hsv);\n
\t\t\t};\n
\n
\t\t\tself._super();\n
\n
\t\t\tself._svdraghelper = new DragHelper(self._id + \'-sv\', {\n
\t\t\t\tstart: updateSaturationAndValue,\n
\t\t\t\tdrag: updateSaturationAndValue\n
\t\t\t});\n
\n
\t\t\tself._hdraghelper = new DragHelper(self._id + \'-h\', {\n
\t\t\t\tstart: updateHue,\n
\t\t\t\tdrag: updateHue\n
\t\t\t});\n
\n
\t\t\tself._repaint();\n
\t\t},\n
\n
\t\trgb: function() {\n
\t\t\treturn this.color().toRgb();\n
\t\t},\n
\n
\t\tvalue: function(value) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (arguments.length) {\n
\t\t\t\tself.color().parse(value);\n
\n
\t\t\t\tif (self._rendered) {\n
\t\t\t\t\tself._repaint();\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\treturn self.color().toHex();\n
\t\t\t}\n
\t\t},\n
\n
\t\tcolor: function() {\n
\t\t\tif (!this._color) {\n
\t\t\t\tthis._color = new Color();\n
\t\t\t}\n
\n
\t\t\treturn this._color;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix, hueHtml;\n
\t\t\tvar stops = \'#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000\';\n
\n
\t\t\tfunction getOldIeFallbackHtml() {\n
\t\t\t\tvar i, l, html = \'\', gradientPrefix, stopsList;\n
\n
\t\t\t\tgradientPrefix = \'filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=\';\n
\t\t\t\tstopsList = stops.split(\',\');\n
\t\t\t\tfor (i = 0, l = stopsList.length - 1; i < l; i++) {\n
\t\t\t\t\thtml += (\n
\t\t\t\t\t\t\'<div class="\' + prefix + \'colorpicker-h-chunk" style="\' +\n
\t\t\t\t\t\t\t\'height:\' + (100 / l) + \'%;\' +\n
\t\t\t\t\t\t\tgradientPrefix + stopsList[i] + \',endColorstr=\' + stopsList[i + 1] + \');\' +\n
\t\t\t\t\t\t\t\'-ms-\' + gradientPrefix + stopsList[i] + \',endColorstr=\' + stopsList[i + 1] + \')\' +\n
\t\t\t\t\t\t\'"></div>\'\n
\t\t\t\t\t);\n
\t\t\t\t}\n
\n
\t\t\t\treturn html;\n
\t\t\t}\n
\n
\t\t\tvar gradientCssText = (\n
\t\t\t\t\'background: -ms-linear-gradient(top,\' + stops + \');\' +\n
\t\t\t\t\'background: linear-gradient(to bottom,\' + stops + \');\'\n
\t\t\t);\n
\n
\t\t\thueHtml = (\n
\t\t\t\t\'<div id="\' + id + \'-h" class="\' + prefix + \'colorpicker-h" style="\' + gradientCssText + \'">\' +\n
\t\t\t\t\tgetOldIeFallbackHtml() +\n
\t\t\t\t\t\'<div id="\' + id + \'-hp" class="\' + prefix + \'colorpicker-h-marker"></div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\t\'<div id="\' + id + \'-sv" class="\' + prefix + \'colorpicker-sv">\' +\n
\t\t\t\t\t\t\'<div class="\' + prefix + \'colorpicker-overlay1">\' +\n
\t\t\t\t\t\t\t\'<div class="\' + prefix + \'colorpicker-overlay2">\' +\n
\t\t\t\t\t\t\t\t\'<div id="\' + id + \'-svp" class="\' + prefix + \'colorpicker-selector1">\' +\n
\t\t\t\t\t\t\t\t\t\'<div class="\' + prefix + \'colorpicker-selector2"></div>\' +\n
\t\t\t\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\thueHtml +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Path.js\n
\n
/**\n
 * Path.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new path control.\n
 *\n
 * @-x-less Path.less\n
 * @class tinymce.ui.Path\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Path", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {String} delimiter Delimiter to display between row in path.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!settings.delimiter) {\n
\t\t\t\tsettings.delimiter = \'\\u00BB\';\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\t\t\tself.classes.add(\'path\');\n
\t\t\tself.canFocus = true;\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tvar index, target = e.target;\n
\n
\t\t\t\tif ((index = target.getAttribute(\'data-index\'))) {\n
\t\t\t\t\tself.fire(\'select\', {value: self.row()[index], index: index});\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.row(self.settings.row);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses the current control.\n
\t\t *\n
\t\t * @method focus\n
\t\t * @return {tinymce.ui.Control} Current control instance.\n
\t\t */\n
\t\tfocus: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.getEl().firstChild.focus();\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets/gets the data to be used for the path.\n
\t\t *\n
\t\t * @method row\n
\t\t * @param {Array} row Array with row name is rendered to path.\n
\t\t */\n
\t\trow: function(row) {\n
\t\t\tif (!arguments.length) {\n
\t\t\t\treturn this.state.get(\'row\');\n
\t\t\t}\n
\n
\t\t\tthis.state.set(\'row\', row);\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\tself._getDataPathHtml(self.state.get(\'row\')) +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:row\', function(e) {\n
\t\t\t\tself.innerHtml(self._getDataPathHtml(e.value));\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t_getDataPathHtml: function(data) {\n
\t\t\tvar self = this, parts = data || [], i, l, html = \'\', prefix = self.classPrefix;\n
\n
\t\t\tfor (i = 0, l = parts.length; i < l; i++) {\n
\t\t\t\thtml += (\n
\t\t\t\t\t(i > 0 ? \'<div class="\' + prefix + \'divider" aria-hidden="true"> \' + self.settings.delimiter + \' </div>\' : \'\') +\n
\t\t\t\t\t\'<div role="button" class="\' + prefix + \'path-item\' + (i == l - 1 ? \' \' + prefix + \'last\' : \'\') + \'" data-index="\' +\n
\t\t\t\t\ti + \'" tabindex="-1" id="\' + self._id + \'-\' + i + \'" aria-level="\' + i + \'">\' + parts[i].name + \'</div>\'\n
\t\t\t\t);\n
\t\t\t}\n
\n
\t\t\tif (!html) {\n
\t\t\t\thtml = \'<div class="\' + prefix + \'path-item">\\u00a0</div>\';\n
\t\t\t}\n
\n
\t\t\treturn html;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/ElementPath.js\n
\n
/**\n
 * ElementPath.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This control creates an path for the current selections parent elements in TinyMCE.\n
 *\n
 * @class tinymce.ui.ElementPath\n
 * @extends tinymce.ui.Path\n
 */\n
define("tinymce/ui/ElementPath", [\n
\t"tinymce/ui/Path",\n
\t"tinymce/EditorManager"\n
], function(Path, EditorManager) {\n
\treturn Path.extend({\n
\t\t/**\n
\t\t * Post render method. Called after the control has been rendered to the target.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @return {tinymce.ui.ElementPath} Current combobox instance.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, editor = EditorManager.activeEditor;\n
\n
\t\t\tfunction isHidden(elm) {\n
\t\t\t\tif (elm.nodeType === 1) {\n
\t\t\t\t\tif (elm.nodeName == "BR" || !!elm.getAttribute(\'data-mce-bogus\')) {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (elm.getAttribute(\'data-mce-type\') === \'bookmark\') {\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn false;\n
\t\t\t}\n
\n
\t\t\tif (editor.settings.elementpath !== false) {\n
\t\t\t\tself.on(\'select\', function(e) {\n
\t\t\t\t\teditor.focus();\n
\t\t\t\t\teditor.selection.select(this.row()[e.index].element);\n
\t\t\t\t\teditor.nodeChanged();\n
\t\t\t\t});\n
\n
\t\t\t\teditor.on(\'nodeChange\', function(e) {\n
\t\t\t\t\tvar outParents = [], parents = e.parents, i = parents.length;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tif (parents[i].nodeType == 1 && !isHidden(parents[i])) {\n
\t\t\t\t\t\t\tvar args = editor.fire(\'ResolveName\', {\n
\t\t\t\t\t\t\t\tname: parents[i].nodeName.toLowerCase(),\n
\t\t\t\t\t\t\t\ttarget: parents[i]\n
\t\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t\tif (!args.isDefaultPrevented()) {\n
\t\t\t\t\t\t\t\toutParents.push({name: args.name, element: parents[i]});\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (args.isPropagationStopped()) {\n
\t\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.row(outParents);\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FormItem.js\n
\n
/**\n
 * FormItem.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class is a container created by the form element with\n
 * a label and control item.\n
 *\n
 * @class tinymce.ui.FormItem\n
 * @extends tinymce.ui.Container\n
 * @setting {String} label Label to display for the form item.\n
 */\n
define("tinymce/ui/FormItem", [\n
\t"tinymce/ui/Container"\n
], function(Container) {\n
\t"use strict";\n
\n
\treturn Container.extend({\n
\t\tDefaults: {\n
\t\t\tlayout: \'flex\',\n
\t\t\talign: \'center\',\n
\t\t\tdefaults: {\n
\t\t\t\tflex: 1\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, prefix = self.classPrefix;\n
\n
\t\t\tself.classes.add(\'formitem\');\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t(self.settings.title ? (\'<div id="\' + self._id + \'-title" class="\' + prefix + \'title">\' +\n
\t\t\t\t\t\tself.settings.title + \'</div>\') : \'\') +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\t(self.settings.html || \'\') + layout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Form.js\n
\n
/**\n
 * Form.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates a form container. A form container has the ability\n
 * to automatically wrap items in tinymce.ui.FormItem instances.\n
 *\n
 * Each FormItem instance is a container for the label and the item.\n
 *\n
 * @example\n
 * tinymce.ui.Factory.create({\n
 *     type: \'form\',\n
 *     items: [\n
 *         {type: \'textbox\', label: \'My text box\'}\n
 *     ]\n
 * }).renderTo(document.body);\n
 *\n
 * @class tinymce.ui.Form\n
 * @extends tinymce.ui.Container\n
 */\n
define("tinymce/ui/Form", [\n
\t"tinymce/ui/Container",\n
\t"tinymce/ui/FormItem",\n
\t"tinymce/util/Tools"\n
], function(Container, FormItem, Tools) {\n
\t"use strict";\n
\n
\treturn Container.extend({\n
\t\tDefaults: {\n
\t\t\tcontainerCls: \'form\',\n
\t\t\tlayout: \'flex\',\n
\t\t\tdirection: \'column\',\n
\t\t\talign: \'stretch\',\n
\t\t\tflex: 1,\n
\t\t\tpadding: 20,\n
\t\t\tlabelGap: 30,\n
\t\t\tspacing: 10,\n
\t\t\tcallbacks: {\n
\t\t\t\tsubmit: function() {\n
\t\t\t\t\tthis.submit();\n
\t\t\t\t}\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * This method gets invoked before the control is rendered.\n
\t\t *\n
\t\t * @method preRender\n
\t\t */\n
\t\tpreRender: function() {\n
\t\t\tvar self = this, items = self.items();\n
\n
\t\t\tif (!self.settings.formItemDefaults) {\n
\t\t\t\tself.settings.formItemDefaults = {\n
\t\t\t\t\tlayout: \'flex\',\n
\t\t\t\t\tautoResize: "overflow",\n
\t\t\t\t\tdefaults: {flex: 1}\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\t// Wrap any labeled items in FormItems\n
\t\t\titems.each(function(ctrl) {\n
\t\t\t\tvar formItem, label = ctrl.settings.label;\n
\n
\t\t\t\tif (label) {\n
\t\t\t\t\tformItem = new FormItem(Tools.extend({\n
\t\t\t\t\t\titems: {\n
\t\t\t\t\t\t\ttype: \'label\',\n
\t\t\t\t\t\t\tid: ctrl._id + \'-l\',\n
\t\t\t\t\t\t\ttext: label,\n
\t\t\t\t\t\t\tflex: 0,\n
\t\t\t\t\t\t\tforId: ctrl._id,\n
\t\t\t\t\t\t\tdisabled: ctrl.disabled()\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}, self.settings.formItemDefaults));\n
\n
\t\t\t\t\tformItem.type = \'formitem\';\n
\t\t\t\t\tctrl.aria(\'labelledby\', ctrl._id + \'-l\');\n
\n
\t\t\t\t\tif (typeof ctrl.settings.flex == "undefined") {\n
\t\t\t\t\t\tctrl.settings.flex = 1;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.replace(ctrl, formItem);\n
\t\t\t\t\tformItem.add(ctrl);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Fires a submit event with the serialized form.\n
\t\t *\n
\t\t * @method submit\n
\t\t * @return {Object} Event arguments object.\n
\t\t */\n
\t\tsubmit: function() {\n
\t\t\treturn this.fire(\'submit\', {data: this.toJSON()});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Post render method. Called after the control has been rendered to the target.\n
\t\t *\n
\t\t * @method postRender\n
\t\t * @return {tinymce.ui.ComboBox} Current combobox instance.\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super();\n
\t\t\tself.fromJSON(self.settings.data);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super();\n
\n
\t\t\tfunction recalcLabels() {\n
\t\t\t\tvar maxLabelWidth = 0, labels = [], i, labelGap, items;\n
\n
\t\t\t\tif (self.settings.labelGapCalc === false) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (self.settings.labelGapCalc == "children") {\n
\t\t\t\t\titems = self.find(\'formitem\');\n
\t\t\t\t} else {\n
\t\t\t\t\titems = self.items();\n
\t\t\t\t}\n
\n
\t\t\t\titems.filter(\'formitem\').each(function(item) {\n
\t\t\t\t\tvar labelCtrl = item.items()[0], labelWidth = labelCtrl.getEl().clientWidth;\n
\n
\t\t\t\t\tmaxLabelWidth = labelWidth > maxLabelWidth ? labelWidth : maxLabelWidth;\n
\t\t\t\t\tlabels.push(labelCtrl);\n
\t\t\t\t});\n
\n
\t\t\t\tlabelGap = self.settings.labelGap || 0;\n
\n
\t\t\t\ti = labels.length;\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tlabels[i].settings.minWidth = maxLabelWidth + labelGap;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.on(\'show\', recalcLabels);\n
\t\t\trecalcLabels();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FieldSet.js\n
\n
/**\n
 * FieldSet.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates fieldset containers.\n
 *\n
 * @-x-less FieldSet.less\n
 * @class tinymce.ui.FieldSet\n
 * @extends tinymce.ui.Form\n
 */\n
define("tinymce/ui/FieldSet", [\n
\t"tinymce/ui/Form"\n
], function(Form) {\n
\t"use strict";\n
\n
\treturn Form.extend({\n
\t\tDefaults: {\n
\t\t\tcontainerCls: \'fieldset\',\n
\t\t\tlayout: \'flex\',\n
\t\t\tdirection: \'column\',\n
\t\t\talign: \'stretch\',\n
\t\t\tflex: 1,\n
\t\t\tpadding: "25 15 5 15",\n
\t\t\tlabelGap: 30,\n
\t\t\tspacing: 10,\n
\t\t\tborder: 1\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, prefix = self.classPrefix;\n
\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\treturn (\n
\t\t\t\t\'<fieldset id="\' + self._id + \'" class="\' + self.classes + \'" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t(self.settings.title ? (\'<legend id="\' + self._id + \'-title" class="\' + prefix + \'fieldset-title">\' +\n
\t\t\t\t\t\tself.settings.title + \'</legend>\') : \'\') +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\t(self.settings.html || \'\') + layout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</fieldset>\'\n
\t\t\t);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FilePicker.js\n
\n
/**\n
 * FilePicker.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*global tinymce:true */\n
\n
/**\n
 * This class creates a file picker control.\n
 *\n
 * @class tinymce.ui.FilePicker\n
 * @extends tinymce.ui.ComboBox\n
 */\n
define("tinymce/ui/FilePicker", [\n
\t"tinymce/ui/ComboBox",\n
\t"tinymce/util/Tools"\n
], function(ComboBox, Tools) {\n
\t"use strict";\n
\n
\treturn ComboBox.extend({\n
\t\t/**\n
\t\t * Constructs a new control instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, editor = tinymce.activeEditor, editorSettings = editor.settings;\n
\t\t\tvar actionCallback, fileBrowserCallback, fileBrowserCallbackTypes;\n
\n
\t\t\tsettings.spellcheck = false;\n
\n
\t\t\tfileBrowserCallbackTypes = editorSettings.file_picker_types || editorSettings.file_browser_callback_types;\n
\t\t\tif (fileBrowserCallbackTypes) {\n
\t\t\t\tfileBrowserCallbackTypes = Tools.makeMap(fileBrowserCallbackTypes, /[, ]/);\n
\t\t\t}\n
\n
\t\t\tif (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype]) {\n
\t\t\t\tfileBrowserCallback = editorSettings.file_picker_callback;\n
\t\t\t\tif (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype])) {\n
\t\t\t\t\tactionCallback = function() {\n
\t\t\t\t\t\tvar meta = self.fire(\'beforecall\').meta;\n
\n
\t\t\t\t\t\tmeta = Tools.extend({filetype: settings.filetype}, meta);\n
\n
\t\t\t\t\t\t// file_picker_callback(callback, currentValue, metaData)\n
\t\t\t\t\t\tfileBrowserCallback.call(\n
\t\t\t\t\t\t\teditor,\n
\t\t\t\t\t\t\tfunction(value, meta) {\n
\t\t\t\t\t\t\t\tself.value(value).fire(\'change\', {meta: meta});\n
\t\t\t\t\t\t\t},\n
\t\t\t\t\t\t\tself.value(),\n
\t\t\t\t\t\t\tmeta\n
\t\t\t\t\t\t);\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\t// Legacy callback: file_picker_callback(id, currentValue, filetype, window)\n
\t\t\t\t\tfileBrowserCallback = editorSettings.file_browser_callback;\n
\t\t\t\t\tif (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype])) {\n
\t\t\t\t\t\tactionCallback = function() {\n
\t\t\t\t\t\t\tfileBrowserCallback(\n
\t\t\t\t\t\t\t\tself.getEl(\'inp\').id,\n
\t\t\t\t\t\t\t\tself.value(),\n
\t\t\t\t\t\t\t\tsettings.filetype,\n
\t\t\t\t\t\t\t\twindow\n
\t\t\t\t\t\t\t);\n
\t\t\t\t\t\t};\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (actionCallback) {\n
\t\t\t\tsettings.icon = \'browse\';\n
\t\t\t\tsettings.onaction = actionCallback;\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FitLayout.js\n
\n
/**\n
 * FitLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout manager will resize the control to be the size of it\'s parent container.\n
 * In other words width: 100% and height: 100%.\n
 *\n
 * @-x-less FitLayout.less\n
 * @class tinymce.ui.FitLayout\n
 * @extends tinymce.ui.AbsoluteLayout\n
 */\n
define("tinymce/ui/FitLayout", [\n
\t"tinymce/ui/AbsoluteLayout"\n
], function(AbsoluteLayout) {\n
\t"use strict";\n
\n
\treturn AbsoluteLayout.extend({\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\tvar contLayoutRect = container.layoutRect(), paddingBox = container.paddingBox;\n
\n
\t\t\tcontainer.items().filter(\':visible\').each(function(ctrl) {\n
\t\t\t\tctrl.layoutRect({\n
\t\t\t\t\tx: paddingBox.left,\n
\t\t\t\t\ty: paddingBox.top,\n
\t\t\t\t\tw: contLayoutRect.innerW - paddingBox.right - paddingBox.left,\n
\t\t\t\t\th: contLayoutRect.innerH - paddingBox.top - paddingBox.bottom\n
\t\t\t\t});\n
\n
\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\tctrl.recalc();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FlexLayout.js\n
\n
/**\n
 * FlexLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout manager works similar to the CSS flex box.\n
 *\n
 * @setting {String} direction row|row-reverse|column|column-reverse\n
 * @setting {Number} flex A positive-number to flex by.\n
 * @setting {String} align start|end|center|stretch\n
 * @setting {String} pack start|end|justify\n
 *\n
 * @class tinymce.ui.FlexLayout\n
 * @extends tinymce.ui.AbsoluteLayout\n
 */\n
define("tinymce/ui/FlexLayout", [\n
\t"tinymce/ui/AbsoluteLayout"\n
], function(AbsoluteLayout) {\n
\t"use strict";\n
\n
\treturn AbsoluteLayout.extend({\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\t// A ton of variables, needs to be in the same scope for performance\n
\t\t\tvar i, l, items, contLayoutRect, contPaddingBox, contSettings, align, pack, spacing, totalFlex, availableSpace, direction;\n
\t\t\tvar ctrl, ctrlLayoutRect, ctrlSettings, flex, maxSizeItems = [], size, maxSize, ratio, rect, pos, maxAlignEndPos;\n
\t\t\tvar sizeName, minSizeName, posName, maxSizeName, beforeName, innerSizeName, deltaSizeName, contentSizeName;\n
\t\t\tvar alignAxisName, alignInnerSizeName, alignSizeName, alignMinSizeName, alignBeforeName, alignAfterName;\n
\t\t\tvar alignDeltaSizeName, alignContentSizeName;\n
\t\t\tvar max = Math.max, min = Math.min;\n
\n
\t\t\t// Get container items, properties and settings\n
\t\t\titems = container.items().filter(\':visible\');\n
\t\t\tcontLayoutRect = container.layoutRect();\n
\t\t\tcontPaddingBox = container.paddingBox;\n
\t\t\tcontSettings = container.settings;\n
\t\t\tdirection = container.isRtl() ? (contSettings.direction || \'row-reversed\') : contSettings.direction;\n
\t\t\talign = contSettings.align;\n
\t\t\tpack = container.isRtl() ? (contSettings.pack || \'end\') : contSettings.pack;\n
\t\t\tspacing = contSettings.spacing || 0;\n
\n
\t\t\tif (direction == "row-reversed" || direction == "column-reverse") {\n
\t\t\t\titems = items.set(items.toArray().reverse());\n
\t\t\t\tdirection = direction.split(\'-\')[0];\n
\t\t\t}\n
\n
\t\t\t// Setup axis variable name for row/column direction since the calculations is the same\n
\t\t\tif (direction == "column") {\n
\t\t\t\tposName = "y";\n
\t\t\t\tsizeName = "h";\n
\t\t\t\tminSizeName = "minH";\n
\t\t\t\tmaxSizeName = "maxH";\n
\t\t\t\tinnerSizeName = "innerH";\n
\t\t\t\tbeforeName = \'top\';\n
\t\t\t\tdeltaSizeName = "deltaH";\n
\t\t\t\tcontentSizeName = "contentH";\n
\n
\t\t\t\talignBeforeName = "left";\n
\t\t\t\talignSizeName = "w";\n
\t\t\t\talignAxisName = "x";\n
\t\t\t\talignInnerSizeName = "innerW";\n
\t\t\t\talignMinSizeName = "minW";\n
\t\t\t\talignAfterName = "right";\n
\t\t\t\talignDeltaSizeName = "deltaW";\n
\t\t\t\talignContentSizeName = "contentW";\n
\t\t\t} else {\n
\t\t\t\tposName = "x";\n
\t\t\t\tsizeName = "w";\n
\t\t\t\tminSizeName = "minW";\n
\t\t\t\tmaxSizeName = "maxW";\n
\t\t\t\tinnerSizeName = "innerW";\n
\t\t\t\tbeforeName = \'left\';\n
\t\t\t\tdeltaSizeName = "deltaW";\n
\t\t\t\tcontentSizeName = "contentW";\n
\n
\t\t\t\talignBeforeName = "top";\n
\t\t\t\talignSizeName = "h";\n
\t\t\t\talignAxisName = "y";\n
\t\t\t\talignInnerSizeName = "innerH";\n
\t\t\t\talignMinSizeName = "minH";\n
\t\t\t\talignAfterName = "bottom";\n
\t\t\t\talignDeltaSizeName = "deltaH";\n
\t\t\t\talignContentSizeName = "contentH";\n
\t\t\t}\n
\n
\t\t\t// Figure out total flex, availableSpace and collect any max size elements\n
\t\t\tavailableSpace = contLayoutRect[innerSizeName] - contPaddingBox[beforeName] - contPaddingBox[beforeName];\n
\t\t\tmaxAlignEndPos = totalFlex = 0;\n
\t\t\tfor (i = 0, l = items.length; i < l; i++) {\n
\t\t\t\tctrl = items[i];\n
\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\tctrlSettings = ctrl.settings;\n
\t\t\t\tflex = ctrlSettings.flex;\n
\t\t\t\tavailableSpace -= (i < l - 1 ? spacing : 0);\n
\n
\t\t\t\tif (flex > 0) {\n
\t\t\t\t\ttotalFlex += flex;\n
\n
\t\t\t\t\t// Flexed item has a max size then we need to check if we will hit that size\n
\t\t\t\t\tif (ctrlLayoutRect[maxSizeName]) {\n
\t\t\t\t\t\tmaxSizeItems.push(ctrl);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrlLayoutRect.flex = flex;\n
\t\t\t\t}\n
\n
\t\t\t\tavailableSpace -= ctrlLayoutRect[minSizeName];\n
\n
\t\t\t\t// Calculate the align end position to be used to check for overflow/underflow\n
\t\t\t\tsize = contPaddingBox[alignBeforeName] + ctrlLayoutRect[alignMinSizeName] + contPaddingBox[alignAfterName];\n
\t\t\t\tif (size > maxAlignEndPos) {\n
\t\t\t\t\tmaxAlignEndPos = size;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Calculate minW/minH\n
\t\t\trect = {};\n
\t\t\tif (availableSpace < 0) {\n
\t\t\t\trect[minSizeName] = contLayoutRect[minSizeName] - availableSpace + contLayoutRect[deltaSizeName];\n
\t\t\t} else {\n
\t\t\t\trect[minSizeName] = contLayoutRect[innerSizeName] - availableSpace + contLayoutRect[deltaSizeName];\n
\t\t\t}\n
\n
\t\t\trect[alignMinSizeName] = maxAlignEndPos + contLayoutRect[alignDeltaSizeName];\n
\n
\t\t\trect[contentSizeName] = contLayoutRect[innerSizeName] - availableSpace;\n
\t\t\trect[alignContentSizeName] = maxAlignEndPos;\n
\t\t\trect.minW = min(rect.minW, contLayoutRect.maxW);\n
\t\t\trect.minH = min(rect.minH, contLayoutRect.maxH);\n
\t\t\trect.minW = max(rect.minW, contLayoutRect.startMinWidth);\n
\t\t\trect.minH = max(rect.minH, contLayoutRect.startMinHeight);\n
\n
\t\t\t// Resize container container if minSize was changed\n
\t\t\tif (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {\n
\t\t\t\trect.w = rect.minW;\n
\t\t\t\trect.h = rect.minH;\n
\n
\t\t\t\tcontainer.layoutRect(rect);\n
\t\t\t\tthis.recalc(container);\n
\n
\t\t\t\t// Forced recalc for example if items are hidden/shown\n
\t\t\t\tif (container._lastRect === null) {\n
\t\t\t\t\tvar parentCtrl = container.parent();\n
\t\t\t\t\tif (parentCtrl) {\n
\t\t\t\t\t\tparentCtrl._lastRect = null;\n
\t\t\t\t\t\tparentCtrl.recalc();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Handle max size elements, check if they will become to wide with current options\n
\t\t\tratio = availableSpace / totalFlex;\n
\t\t\tfor (i = 0, l = maxSizeItems.length; i < l; i++) {\n
\t\t\t\tctrl = maxSizeItems[i];\n
\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\tmaxSize = ctrlLayoutRect[maxSizeName];\n
\t\t\t\tsize = ctrlLayoutRect[minSizeName] + ctrlLayoutRect.flex * ratio;\n
\n
\t\t\t\tif (size > maxSize) {\n
\t\t\t\t\tavailableSpace -= (ctrlLayoutRect[maxSizeName] - ctrlLayoutRect[minSizeName]);\n
\t\t\t\t\ttotalFlex -= ctrlLayoutRect.flex;\n
\t\t\t\t\tctrlLayoutRect.flex = 0;\n
\t\t\t\t\tctrlLayoutRect.maxFlexSize = maxSize;\n
\t\t\t\t} else {\n
\t\t\t\t\tctrlLayoutRect.maxFlexSize = 0;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Setup new ratio, target layout rect, start position\n
\t\t\tratio = availableSpace / totalFlex;\n
\t\t\tpos = contPaddingBox[beforeName];\n
\t\t\trect = {};\n
\n
\t\t\t// Handle pack setting moves the start position to end, center\n
\t\t\tif (totalFlex === 0) {\n
\t\t\t\tif (pack == "end") {\n
\t\t\t\t\tpos = availableSpace + contPaddingBox[beforeName];\n
\t\t\t\t} else if (pack == "center") {\n
\t\t\t\t\tpos = Math.round(\n
\t\t\t\t\t\t(contLayoutRect[innerSizeName] / 2) - ((contLayoutRect[innerSizeName] - availableSpace) / 2)\n
\t\t\t\t\t) + contPaddingBox[beforeName];\n
\n
\t\t\t\t\tif (pos < 0) {\n
\t\t\t\t\t\tpos = contPaddingBox[beforeName];\n
\t\t\t\t\t}\n
\t\t\t\t} else if (pack == "justify") {\n
\t\t\t\t\tpos = contPaddingBox[beforeName];\n
\t\t\t\t\tspacing = Math.floor(availableSpace / (items.length - 1));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Default aligning (start) the other ones needs to be calculated while doing the layout\n
\t\t\trect[alignAxisName] = contPaddingBox[alignBeforeName];\n
\n
\t\t\t// Start laying out controls\n
\t\t\tfor (i = 0, l = items.length; i < l; i++) {\n
\t\t\t\tctrl = items[i];\n
\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\tsize = ctrlLayoutRect.maxFlexSize || ctrlLayoutRect[minSizeName];\n
\n
\t\t\t\t// Align the control on the other axis\n
\t\t\t\tif (align === "center") {\n
\t\t\t\t\trect[alignAxisName] = Math.round((contLayoutRect[alignInnerSizeName] / 2) - (ctrlLayoutRect[alignSizeName] / 2));\n
\t\t\t\t} else if (align === "stretch") {\n
\t\t\t\t\trect[alignSizeName] = max(\n
\t\t\t\t\t\tctrlLayoutRect[alignMinSizeName] || 0,\n
\t\t\t\t\t\tcontLayoutRect[alignInnerSizeName] - contPaddingBox[alignBeforeName] - contPaddingBox[alignAfterName]\n
\t\t\t\t\t);\n
\t\t\t\t\trect[alignAxisName] = contPaddingBox[alignBeforeName];\n
\t\t\t\t} else if (align === "end") {\n
\t\t\t\t\trect[alignAxisName] = contLayoutRect[alignInnerSizeName] - ctrlLayoutRect[alignSizeName] - contPaddingBox.top;\n
\t\t\t\t}\n
\n
\t\t\t\t// Calculate new size based on flex\n
\t\t\t\tif (ctrlLayoutRect.flex > 0) {\n
\t\t\t\t\tsize += ctrlLayoutRect.flex * ratio;\n
\t\t\t\t}\n
\n
\t\t\t\trect[sizeName] = size;\n
\t\t\t\trect[posName] = pos;\n
\t\t\t\tctrl.layoutRect(rect);\n
\n
\t\t\t\t// Recalculate containers\n
\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\tctrl.recalc();\n
\t\t\t\t}\n
\n
\t\t\t\t// Move x/y position\n
\t\t\t\tpos += size + spacing;\n
\t\t\t}\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FlowLayout.js\n
\n
/**\n
 * FlowLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout manager will place the controls by using the browsers native layout.\n
 *\n
 * @-x-less FlowLayout.less\n
 * @class tinymce.ui.FlowLayout\n
 * @extends tinymce.ui.Layout\n
 */\n
define("tinymce/ui/FlowLayout", [\n
\t"tinymce/ui/Layout"\n
], function(Layout) {\n
\treturn Layout.extend({\n
\t\tDefaults: {\n
\t\t\tcontainerClass: \'flow-layout\',\n
\t\t\tcontrolClass: \'flow-layout-item\',\n
\t\t\tendClass: \'break\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\tcontainer.items().filter(\':visible\').each(function(ctrl) {\n
\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\tctrl.recalc();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\tisNative: function() {\n
\t\t\treturn true;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/FormatControls.js\n
\n
/**\n
 * FormatControls.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Internal class containing all TinyMCE specific control types such as\n
 * format listboxes, fontlist boxes, toolbar buttons etc.\n
 *\n
 * @class tinymce.ui.FormatControls\n
 */\n
define("tinymce/ui/FormatControls", [\n
\t"tinymce/ui/Control",\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/FloatPanel",\n
\t"tinymce/util/Tools",\n
\t"tinymce/EditorManager",\n
\t"tinymce/Env"\n
], function(Control, Widget, FloatPanel, Tools, EditorManager, Env) {\n
\tvar each = Tools.each;\n
\n
\tEditorManager.on(\'AddEditor\', function(e) {\n
\t\tif (e.editor.rtl) {\n
\t\t\tControl.rtl = true;\n
\t\t}\n
\n
\t\tregisterControls(e.editor);\n
\t});\n
\n
\tControl.translate = function(text) {\n
\t\treturn EditorManager.translate(text);\n
\t};\n
\n
\tWidget.tooltips = !Env.iOS;\n
\n
\tfunction registerControls(editor) {\n
\t\tvar formatMenu;\n
\n
\t\tfunction createListBoxChangeHandler(items, formatName) {\n
\t\t\treturn function() {\n
\t\t\t\tvar self = this;\n
\n
\t\t\t\teditor.on(\'nodeChange\', function(e) {\n
\t\t\t\t\tvar formatter = editor.formatter;\n
\t\t\t\t\tvar value = null;\n
\n
\t\t\t\t\teach(e.parents, function(node) {\n
\t\t\t\t\t\teach(items, function(item) {\n
\t\t\t\t\t\t\tif (formatName) {\n
\t\t\t\t\t\t\t\tif (formatter.matchNode(node, formatName, {value: item.value})) {\n
\t\t\t\t\t\t\t\t\tvalue = item.value;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tif (formatter.matchNode(node, item.value)) {\n
\t\t\t\t\t\t\t\t\tvalue = item.value;\n
\t\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tif (value) {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\tif (value) {\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tself.value(value);\n
\t\t\t\t});\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction createFormats(formats) {\n
\t\t\tformats = formats.replace(/;$/, \'\').split(\';\');\n
\n
\t\t\tvar i = formats.length;\n
\t\t\twhile (i--) {\n
\t\t\t\tformats[i] = formats[i].split(\'=\');\n
\t\t\t}\n
\n
\t\t\treturn formats;\n
\t\t}\n
\n
\t\tfunction createFormatMenu() {\n
\t\t\tvar count = 0, newFormats = [];\n
\n
\t\t\tvar defaultStyleFormats = [\n
\t\t\t\t{title: \'Headings\', items: [\n
\t\t\t\t\t{title: \'Heading 1\', format: \'h1\'},\n
\t\t\t\t\t{title: \'Heading 2\', format: \'h2\'},\n
\t\t\t\t\t{title: \'Heading 3\', format: \'h3\'},\n
\t\t\t\t\t{title: \'Heading 4\', format: \'h4\'},\n
\t\t\t\t\t{title: \'Heading 5\', format: \'h5\'},\n
\t\t\t\t\t{title: \'Heading 6\', format: \'h6\'}\n
\t\t\t\t]},\n
\n
\t\t\t\t{title: \'Inline\', items: [\n
\t\t\t\t\t{title: \'Bold\', icon: \'bold\', format: \'bold\'},\n
\t\t\t\t\t{title: \'Italic\', icon: \'italic\', format: \'italic\'},\n
\t\t\t\t\t{title: \'Underline\', icon: \'underline\', format: \'underline\'},\n
\t\t\t\t\t{title: \'Strikethrough\', icon: \'strikethrough\', format: \'strikethrough\'},\n
\t\t\t\t\t{title: \'Superscript\', icon: \'superscript\', format: \'superscript\'},\n
\t\t\t\t\t{title: \'Subscript\', icon: \'subscript\', format: \'subscript\'},\n
\t\t\t\t\t{title: \'Code\', icon: \'code\', format: \'code\'}\n
\t\t\t\t]},\n
\n
\t\t\t\t{title: \'Blocks\', items: [\n
\t\t\t\t\t{title: \'Paragraph\', format: \'p\'},\n
\t\t\t\t\t{title: \'Blockquote\', format: \'blockquote\'},\n
\t\t\t\t\t{title: \'Div\', format: \'div\'},\n
\t\t\t\t\t{title: \'Pre\', format: \'pre\'}\n
\t\t\t\t]},\n
\n
\t\t\t\t{title: \'Alignment\', items: [\n
\t\t\t\t\t{title: \'Left\', icon: \'alignleft\', format: \'alignleft\'},\n
\t\t\t\t\t{title: \'Center\', icon: \'aligncenter\', format: \'aligncenter\'},\n
\t\t\t\t\t{title: \'Right\', icon: \'alignright\', format: \'alignright\'},\n
\t\t\t\t\t{title: \'Justify\', icon: \'alignjustify\', format: \'alignjustify\'}\n
\t\t\t\t]}\n
\t\t\t];\n
\n
\t\t\tfunction createMenu(formats) {\n
\t\t\t\tvar menu = [];\n
\n
\t\t\t\tif (!formats) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\teach(formats, function(format) {\n
\t\t\t\t\tvar menuItem = {\n
\t\t\t\t\t\ttext: format.title,\n
\t\t\t\t\t\ticon: format.icon\n
\t\t\t\t\t};\n
\n
\t\t\t\t\tif (format.items) {\n
\t\t\t\t\t\tmenuItem.menu = createMenu(format.items);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tvar formatName = format.format || "custom" + count++;\n
\n
\t\t\t\t\t\tif (!format.format) {\n
\t\t\t\t\t\t\tformat.name = formatName;\n
\t\t\t\t\t\t\tnewFormats.push(format);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tmenuItem.format = formatName;\n
\t\t\t\t\t\tmenuItem.cmd = format.cmd;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tmenu.push(menuItem);\n
\t\t\t\t});\n
\n
\t\t\t\treturn menu;\n
\t\t\t}\n
\n
\t\t\tfunction createStylesMenu() {\n
\t\t\t\tvar menu;\n
\n
\t\t\t\tif (editor.settings.style_formats_merge) {\n
\t\t\t\t\tif (editor.settings.style_formats) {\n
\t\t\t\t\t\tmenu = createMenu(defaultStyleFormats.concat(editor.settings.style_formats));\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tmenu = createMenu(defaultStyleFormats);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tmenu = createMenu(editor.settings.style_formats || defaultStyleFormats);\n
\t\t\t\t}\n
\n
\t\t\t\treturn menu;\n
\t\t\t}\n
\n
\t\t\teditor.on(\'init\', function() {\n
\t\t\t\teach(newFormats, function(format) {\n
\t\t\t\t\teditor.formatter.register(format.name, format);\n
\t\t\t\t});\n
\t\t\t});\n
\n
\t\t\treturn {\n
\t\t\t\ttype: \'menu\',\n
\t\t\t\titems: createStylesMenu(),\n
\t\t\t\tonPostRender: function(e) {\n
\t\t\t\t\teditor.fire(\'renderFormatsMenu\', {control: e.control});\n
\t\t\t\t},\n
\t\t\t\titemDefaults: {\n
\t\t\t\t\tpreview: true,\n
\n
\t\t\t\t\ttextStyle: function() {\n
\t\t\t\t\t\tif (this.settings.format) {\n
\t\t\t\t\t\t\treturn editor.formatter.getCssText(this.settings.format);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t},\n
\n
\t\t\t\t\tonPostRender: function() {\n
\t\t\t\t\t\tvar self = this;\n
\n
\t\t\t\t\t\tself.parent().on(\'show\', function() {\n
\t\t\t\t\t\t\tvar formatName, command;\n
\n
\t\t\t\t\t\t\tformatName = self.settings.format;\n
\t\t\t\t\t\t\tif (formatName) {\n
\t\t\t\t\t\t\t\tself.disabled(!editor.formatter.canApply(formatName));\n
\t\t\t\t\t\t\t\tself.active(editor.formatter.match(formatName));\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tcommand = self.settings.cmd;\n
\t\t\t\t\t\t\tif (command) {\n
\t\t\t\t\t\t\t\tself.active(editor.queryCommandState(command));\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t},\n
\n
\t\t\t\t\tonclick: function() {\n
\t\t\t\t\t\tif (this.settings.format) {\n
\t\t\t\t\t\t\ttoggleFormat(this.settings.format);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (this.settings.cmd) {\n
\t\t\t\t\t\t\teditor.execCommand(this.settings.cmd);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\t\t}\n
\n
\t\tformatMenu = createFormatMenu();\n
\n
\t\t// Simple format controls <control/format>:<UI text>\n
\t\teach({\n
\t\t\tbold: \'Bold\',\n
\t\t\titalic: \'Italic\',\n
\t\t\tunderline: \'Underline\',\n
\t\t\tstrikethrough: \'Strikethrough\',\n
\t\t\tsubscript: \'Subscript\',\n
\t\t\tsuperscript: \'Superscript\'\n
\t\t}, function(text, name) {\n
\t\t\teditor.addButton(name, {\n
\t\t\t\ttooltip: text,\n
\t\t\t\tonPostRender: function() {\n
\t\t\t\t\tvar self = this;\n
\n
\t\t\t\t\t// TODO: Fix this\n
\t\t\t\t\tif (editor.formatter) {\n
\t\t\t\t\t\teditor.formatter.formatChanged(name, function(state) {\n
\t\t\t\t\t\t\tself.active(state);\n
\t\t\t\t\t\t});\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.on(\'init\', function() {\n
\t\t\t\t\t\t\teditor.formatter.formatChanged(name, function(state) {\n
\t\t\t\t\t\t\t\tself.active(state);\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t},\n
\t\t\t\tonclick: function() {\n
\t\t\t\t\ttoggleFormat(name);\n
\t\t\t\t}\n
\t\t\t});\n
\t\t});\n
\n
\t\t// Simple command controls <control>:[<UI text>,<Command>]\n
\t\teach({\n
\t\t\toutdent: [\'Decrease indent\', \'Outdent\'],\n
\t\t\tindent: [\'Increase indent\', \'Indent\'],\n
\t\t\tcut: [\'Cut\', \'Cut\'],\n
\t\t\tcopy: [\'Copy\', \'Copy\'],\n
\t\t\tpaste: [\'Paste\', \'Paste\'],\n
\t\t\thelp: [\'Help\', \'mceHelp\'],\n
\t\t\tselectall: [\'Select all\', \'SelectAll\'],\n
\t\t\tremoveformat: [\'Clear formatting\', \'RemoveFormat\'],\n
\t\t\tvisualaid: [\'Visual aids\', \'mceToggleVisualAid\'],\n
\t\t\tnewdocument: [\'New document\', \'mceNewDocument\']\n
\t\t}, function(item, name) {\n
\t\t\teditor.addButton(name, {\n
\t\t\t\ttooltip: item[0],\n
\t\t\t\tcmd: item[1]\n
\t\t\t});\n
\t\t});\n
\n
\t\t// Simple command controls with format state\n
\t\teach({\n
\t\t\tblockquote: [\'Blockquote\', \'mceBlockQuote\'],\n
\t\t\tnumlist: [\'Numbered list\', \'InsertOrderedList\'],\n
\t\t\tbullist: [\'Bullet list\', \'InsertUnorderedList\'],\n
\t\t\tsubscript: [\'Subscript\', \'Subscript\'],\n
\t\t\tsuperscript: [\'Superscript\', \'Superscript\'],\n
\t\t\talignleft: [\'Align left\', \'JustifyLeft\'],\n
\t\t\taligncenter: [\'Align center\', \'JustifyCenter\'],\n
\t\t\talignright: [\'Align right\', \'JustifyRight\'],\n
\t\t\talignjustify: [\'Justify\', \'JustifyFull\'],\n
\t\t\talignnone: [\'No alignment\', \'JustifyNone\']\n
\t\t}, function(item, name) {\n
\t\t\teditor.addButton(name, {\n
\t\t\t\ttooltip: item[0],\n
\t\t\t\tcmd: item[1],\n
\t\t\t\tonPostRender: function() {\n
\t\t\t\t\tvar self = this;\n
\n
\t\t\t\t\t// TODO: Fix this\n
\t\t\t\t\tif (editor.formatter) {\n
\t\t\t\t\t\teditor.formatter.formatChanged(name, function(state) {\n
\t\t\t\t\t\t\tself.active(state);\n
\t\t\t\t\t\t});\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor.on(\'init\', function() {\n
\t\t\t\t\t\t\teditor.formatter.formatChanged(name, function(state) {\n
\t\t\t\t\t\t\t\tself.active(state);\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t});\n
\n
\t\tfunction toggleUndoRedoState(type) {\n
\t\t\treturn function() {\n
\t\t\t\tvar self = this;\n
\n
\t\t\t\ttype = type == \'redo\' ? \'hasRedo\' : \'hasUndo\';\n
\n
\t\t\t\tfunction checkState() {\n
\t\t\t\t\treturn editor.undoManager ? editor.undoManager[type]() : false;\n
\t\t\t\t}\n
\n
\t\t\t\tself.disabled(!checkState());\n
\t\t\t\teditor.on(\'Undo Redo AddUndo TypingUndo ClearUndos\', function() {\n
\t\t\t\t\tself.disabled(!checkState());\n
\t\t\t\t});\n
\t\t\t};\n
\t\t}\n
\n
\t\tfunction toggleVisualAidState() {\n
\t\t\tvar self = this;\n
\n
\t\t\teditor.on(\'VisualAid\', function(e) {\n
\t\t\t\tself.active(e.hasVisual);\n
\t\t\t});\n
\n
\t\t\tself.active(editor.hasVisual);\n
\t\t}\n
\n
\t\teditor.addButton(\'undo\', {\n
\t\t\ttooltip: \'Undo\',\n
\t\t\tonPostRender: toggleUndoRedoState(\'undo\'),\n
\t\t\tcmd: \'undo\'\n
\t\t});\n
\n
\t\teditor.addButton(\'redo\', {\n
\t\t\ttooltip: \'Redo\',\n
\t\t\tonPostRender: toggleUndoRedoState(\'redo\'),\n
\t\t\tcmd: \'redo\'\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'newdocument\', {\n
\t\t\ttext: \'New document\',\n
\t\t\ticon: \'newdocument\',\n
\t\t\tcmd: \'mceNewDocument\'\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'undo\', {\n
\t\t\ttext: \'Undo\',\n
\t\t\ticon: \'undo\',\n
\t\t\tshortcut: \'Meta+Z\',\n
\t\t\tonPostRender: toggleUndoRedoState(\'undo\'),\n
\t\t\tcmd: \'undo\'\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'redo\', {\n
\t\t\ttext: \'Redo\',\n
\t\t\ticon: \'redo\',\n
\t\t\tshortcut: \'Meta+Y\',\n
\t\t\tonPostRender: toggleUndoRedoState(\'redo\'),\n
\t\t\tcmd: \'redo\'\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'visualaid\', {\n
\t\t\ttext: \'Visual aids\',\n
\t\t\tselectable: true,\n
\t\t\tonPostRender: toggleVi

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAABA=</string> </persistent>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="16" aka="AAAAAAAAABA=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

sualAidState,\n
\t\t\tcmd: \'mceToggleVisualAid\'\n
\t\t});\n
\n
\t\teditor.addButton(\'remove\', {\n
\t\t\ttooltip: \'Remove\',\n
\t\t\ticon: \'remove\',\n
\t\t\tcmd: \'Delete\'\n
\t\t});\n
\n
\t\teach({\n
\t\t\tcut: [\'Cut\', \'Cut\', \'Meta+X\'],\n
\t\t\tcopy: [\'Copy\', \'Copy\', \'Meta+C\'],\n
\t\t\tpaste: [\'Paste\', \'Paste\', \'Meta+V\'],\n
\t\t\tselectall: [\'Select all\', \'SelectAll\', \'Meta+A\'],\n
\t\t\tbold: [\'Bold\', \'Bold\', \'Meta+B\'],\n
\t\t\titalic: [\'Italic\', \'Italic\', \'Meta+I\'],\n
\t\t\tunderline: [\'Underline\', \'Underline\'],\n
\t\t\tstrikethrough: [\'Strikethrough\', \'Strikethrough\'],\n
\t\t\tsubscript: [\'Subscript\', \'Subscript\'],\n
\t\t\tsuperscript: [\'Superscript\', \'Superscript\'],\n
\t\t\tremoveformat: [\'Clear formatting\', \'RemoveFormat\']\n
\t\t}, function(item, name) {\n
\t\t\teditor.addMenuItem(name, {\n
\t\t\t\ttext: item[0],\n
\t\t\t\ticon: name,\n
\t\t\t\tshortcut: item[2],\n
\t\t\t\tcmd: item[1]\n
\t\t\t});\n
\t\t});\n
\n
\t\teditor.on(\'mousedown\', function() {\n
\t\t\tFloatPanel.hideAll();\n
\t\t});\n
\n
\t\tfunction toggleFormat(fmt) {\n
\t\t\tif (fmt.control) {\n
\t\t\t\tfmt = fmt.control.value();\n
\t\t\t}\n
\n
\t\t\tif (fmt) {\n
\t\t\t\teditor.execCommand(\'mceToggleFormat\', false, fmt);\n
\t\t\t}\n
\t\t}\n
\n
\t\teditor.addButton(\'styleselect\', {\n
\t\t\ttype: \'menubutton\',\n
\t\t\ttext: \'Formats\',\n
\t\t\tmenu: formatMenu\n
\t\t});\n
\n
\t\teditor.addButton(\'formatselect\', function() {\n
\t\t\tvar items = [], blocks = createFormats(editor.settings.block_formats ||\n
\t\t\t\t\'Paragraph=p;\' +\n
\t\t\t\t\'Heading 1=h1;\' +\n
\t\t\t\t\'Heading 2=h2;\' +\n
\t\t\t\t\'Heading 3=h3;\' +\n
\t\t\t\t\'Heading 4=h4;\' +\n
\t\t\t\t\'Heading 5=h5;\' +\n
\t\t\t\t\'Heading 6=h6;\' +\n
\t\t\t\t\'Preformatted=pre\'\n
\t\t\t);\n
\n
\t\t\teach(blocks, function(block) {\n
\t\t\t\titems.push({\n
\t\t\t\t\ttext: block[0],\n
\t\t\t\t\tvalue: block[1],\n
\t\t\t\t\ttextStyle: function() {\n
\t\t\t\t\t\treturn editor.formatter.getCssText(block[1]);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t});\n
\n
\t\t\treturn {\n
\t\t\t\ttype: \'listbox\',\n
\t\t\t\ttext: blocks[0][0],\n
\t\t\t\tvalues: items,\n
\t\t\t\tfixedWidth: true,\n
\t\t\t\tonselect: toggleFormat,\n
\t\t\t\tonPostRender: createListBoxChangeHandler(items)\n
\t\t\t};\n
\t\t});\n
\n
\t\teditor.addButton(\'fontselect\', function() {\n
\t\t\tvar defaultFontsFormats =\n
\t\t\t\t\'Andale Mono=andale mono,monospace;\' +\n
\t\t\t\t\'Arial=arial,helvetica,sans-serif;\' +\n
\t\t\t\t\'Arial Black=arial black,sans-serif;\' +\n
\t\t\t\t\'Book Antiqua=book antiqua,palatino,serif;\' +\n
\t\t\t\t\'Comic Sans MS=comic sans ms,sans-serif;\' +\n
\t\t\t\t\'Courier New=courier new,courier,monospace;\' +\n
\t\t\t\t\'Georgia=georgia,palatino,serif;\' +\n
\t\t\t\t\'Helvetica=helvetica,arial,sans-serif;\' +\n
\t\t\t\t\'Impact=impact,sans-serif;\' +\n
\t\t\t\t\'Symbol=symbol;\' +\n
\t\t\t\t\'Tahoma=tahoma,arial,helvetica,sans-serif;\' +\n
\t\t\t\t\'Terminal=terminal,monaco,monospace;\' +\n
\t\t\t\t\'Times New Roman=times new roman,times,serif;\' +\n
\t\t\t\t\'Trebuchet MS=trebuchet ms,geneva,sans-serif;\' +\n
\t\t\t\t\'Verdana=verdana,geneva,sans-serif;\' +\n
\t\t\t\t\'Webdings=webdings;\' +\n
\t\t\t\t\'Wingdings=wingdings,zapf dingbats\';\n
\n
\t\t\tvar items = [], fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);\n
\n
\t\t\teach(fonts, function(font) {\n
\t\t\t\titems.push({\n
\t\t\t\t\ttext: {raw: font[0]},\n
\t\t\t\t\tvalue: font[1],\n
\t\t\t\t\ttextStyle: font[1].indexOf(\'dings\') == -1 ? \'font-family:\' + font[1] : \'\'\n
\t\t\t\t});\n
\t\t\t});\n
\n
\t\t\treturn {\n
\t\t\t\ttype: \'listbox\',\n
\t\t\t\ttext: \'Font Family\',\n
\t\t\t\ttooltip: \'Font Family\',\n
\t\t\t\tvalues: items,\n
\t\t\t\tfixedWidth: true,\n
\t\t\t\tonPostRender: createListBoxChangeHandler(items, \'fontname\'),\n
\t\t\t\tonselect: function(e) {\n
\t\t\t\t\tif (e.control.settings.value) {\n
\t\t\t\t\t\teditor.execCommand(\'FontName\', false, e.control.settings.value);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\t\t});\n
\n
\t\teditor.addButton(\'fontsizeselect\', function() {\n
\t\t\tvar items = [], defaultFontsizeFormats = \'8pt 10pt 12pt 14pt 18pt 24pt 36pt\';\n
\t\t\tvar fontsize_formats = editor.settings.fontsize_formats || defaultFontsizeFormats;\n
\n
\t\t\teach(fontsize_formats.split(\' \'), function(item) {\n
\t\t\t\tvar text = item, value = item;\n
\t\t\t\t// Allow text=value font sizes.\n
\t\t\t\tvar values = item.split(\'=\');\n
\t\t\t\tif (values.length > 1) {\n
\t\t\t\t\ttext = values[0];\n
\t\t\t\t\tvalue = values[1];\n
\t\t\t\t}\n
\t\t\t\titems.push({text: text, value: value});\n
\t\t\t});\n
\n
\t\t\treturn {\n
\t\t\t\ttype: \'listbox\',\n
\t\t\t\ttext: \'Font Sizes\',\n
\t\t\t\ttooltip: \'Font Sizes\',\n
\t\t\t\tvalues: items,\n
\t\t\t\tfixedWidth: true,\n
\t\t\t\tonPostRender: createListBoxChangeHandler(items, \'fontsize\'),\n
\t\t\t\tonclick: function(e) {\n
\t\t\t\t\tif (e.control.settings.value) {\n
\t\t\t\t\t\teditor.execCommand(\'FontSize\', false, e.control.settings.value);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t};\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'formats\', {\n
\t\t\ttext: \'Formats\',\n
\t\t\tmenu: formatMenu\n
\t\t});\n
\t}\n
});\n
\n
// Included from: js/tinymce/classes/ui/GridLayout.js\n
\n
/**\n
 * GridLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout manager places controls in a grid.\n
 *\n
 * @setting {Number} spacing Spacing between controls.\n
 * @setting {Number} spacingH Horizontal spacing between controls.\n
 * @setting {Number} spacingV Vertical spacing between controls.\n
 * @setting {Number} columns Number of columns to use.\n
 * @setting {String/Array} alignH start|end|center|stretch or array of values for each column.\n
 * @setting {String/Array} alignV start|end|center|stretch or array of values for each column.\n
 * @setting {String} pack start|end\n
 *\n
 * @class tinymce.ui.GridLayout\n
 * @extends tinymce.ui.AbsoluteLayout\n
 */\n
define("tinymce/ui/GridLayout", [\n
\t"tinymce/ui/AbsoluteLayout"\n
], function(AbsoluteLayout) {\n
\t"use strict";\n
\n
\treturn AbsoluteLayout.extend({\n
\t\t/**\n
\t\t * Recalculates the positions of the controls in the specified container.\n
\t\t *\n
\t\t * @method recalc\n
\t\t * @param {tinymce.ui.Container} container Container instance to recalc.\n
\t\t */\n
\t\trecalc: function(container) {\n
\t\t\tvar settings = container.settings, rows, cols, items, contLayoutRect, width, height, rect,\n
\t\t\t\tctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY,\n
\t\t\t\tcolWidths = [], rowHeights = [], ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;\n
\n
\t\t\t// Get layout settings\n
\t\t\tsettings = container.settings;\n
\t\t\titems = container.items().filter(\':visible\');\n
\t\t\tcontLayoutRect = container.layoutRect();\n
\t\t\tcols = settings.columns || Math.ceil(Math.sqrt(items.length));\n
\t\t\trows = Math.ceil(items.length / cols);\n
\t\t\tspacingH = settings.spacingH || settings.spacing || 0;\n
\t\t\tspacingV = settings.spacingV || settings.spacing || 0;\n
\t\t\talignH = settings.alignH || settings.align;\n
\t\t\talignV = settings.alignV || settings.align;\n
\t\t\tcontPaddingBox = container.paddingBox;\n
\t\t\treverseRows = \'reverseRows\' in settings ? settings.reverseRows : container.isRtl();\n
\n
\t\t\tif (alignH && typeof alignH == "string") {\n
\t\t\t\talignH = [alignH];\n
\t\t\t}\n
\n
\t\t\tif (alignV && typeof alignV == "string") {\n
\t\t\t\talignV = [alignV];\n
\t\t\t}\n
\n
\t\t\t// Zero padd columnWidths\n
\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\tcolWidths.push(0);\n
\t\t\t}\n
\n
\t\t\t// Zero padd rowHeights\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\trowHeights.push(0);\n
\t\t\t}\n
\n
\t\t\t// Calculate columnWidths and rowHeights\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\t\tctrl = items[y * cols + x];\n
\n
\t\t\t\t\t// Out of bounds\n
\t\t\t\t\tif (!ctrl) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\t\tctrlMinWidth = ctrlLayoutRect.minW;\n
\t\t\t\t\tctrlMinHeight = ctrlLayoutRect.minH;\n
\n
\t\t\t\t\tcolWidths[x] = ctrlMinWidth > colWidths[x] ? ctrlMinWidth : colWidths[x];\n
\t\t\t\t\trowHeights[y] = ctrlMinHeight > rowHeights[y] ? ctrlMinHeight : rowHeights[y];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Calculate maxX\n
\t\t\tavailableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;\n
\t\t\tfor (maxX = 0, x = 0; x < cols; x++) {\n
\t\t\t\tmaxX += colWidths[x] + (x > 0 ? spacingH : 0);\n
\t\t\t\tavailableWidth -= (x > 0 ? spacingH : 0) + colWidths[x];\n
\t\t\t}\n
\n
\t\t\t// Calculate maxY\n
\t\t\tavailableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;\n
\t\t\tfor (maxY = 0, y = 0; y < rows; y++) {\n
\t\t\t\tmaxY += rowHeights[y] + (y > 0 ? spacingV : 0);\n
\t\t\t\tavailableHeight -= (y > 0 ? spacingV : 0) + rowHeights[y];\n
\t\t\t}\n
\n
\t\t\tmaxX += contPaddingBox.left + contPaddingBox.right;\n
\t\t\tmaxY += contPaddingBox.top + contPaddingBox.bottom;\n
\n
\t\t\t// Calculate minW/minH\n
\t\t\trect = {};\n
\t\t\trect.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);\n
\t\t\trect.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);\n
\n
\t\t\trect.contentW = rect.minW - contLayoutRect.deltaW;\n
\t\t\trect.contentH = rect.minH - contLayoutRect.deltaH;\n
\t\t\trect.minW = Math.min(rect.minW, contLayoutRect.maxW);\n
\t\t\trect.minH = Math.min(rect.minH, contLayoutRect.maxH);\n
\t\t\trect.minW = Math.max(rect.minW, contLayoutRect.startMinWidth);\n
\t\t\trect.minH = Math.max(rect.minH, contLayoutRect.startMinHeight);\n
\n
\t\t\t// Resize container container if minSize was changed\n
\t\t\tif (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {\n
\t\t\t\trect.w = rect.minW;\n
\t\t\t\trect.h = rect.minH;\n
\n
\t\t\t\tcontainer.layoutRect(rect);\n
\t\t\t\tthis.recalc(container);\n
\n
\t\t\t\t// Forced recalc for example if items are hidden/shown\n
\t\t\t\tif (container._lastRect === null) {\n
\t\t\t\t\tvar parentCtrl = container.parent();\n
\t\t\t\t\tif (parentCtrl) {\n
\t\t\t\t\t\tparentCtrl._lastRect = null;\n
\t\t\t\t\t\tparentCtrl.recalc();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Update contentW/contentH so absEnd moves correctly\n
\t\t\tif (contLayoutRect.autoResize) {\n
\t\t\t\trect = container.layoutRect(rect);\n
\t\t\t\trect.contentW = rect.minW - contLayoutRect.deltaW;\n
\t\t\t\trect.contentH = rect.minH - contLayoutRect.deltaH;\n
\t\t\t}\n
\n
\t\t\tvar flexV;\n
\n
\t\t\tif (settings.packV == \'start\') {\n
\t\t\t\tflexV = 0;\n
\t\t\t} else {\n
\t\t\t\tflexV = availableHeight > 0 ? Math.floor(availableHeight / rows) : 0;\n
\t\t\t}\n
\n
\t\t\t// Calculate totalFlex\n
\t\t\tvar totalFlex = 0;\n
\t\t\tvar flexWidths = settings.flexWidths;\n
\t\t\tif (flexWidths) {\n
\t\t\t\tfor (x = 0; x < flexWidths.length; x++) {\n
\t\t\t\t\ttotalFlex += flexWidths[x];\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\ttotalFlex = cols;\n
\t\t\t}\n
\n
\t\t\t// Calculate new column widths based on flex values\n
\t\t\tvar ratio = availableWidth / totalFlex;\n
\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\tcolWidths[x] += flexWidths ? flexWidths[x] * ratio : ratio;\n
\t\t\t}\n
\n
\t\t\t// Move/resize controls\n
\t\t\tposY = contPaddingBox.top;\n
\t\t\tfor (y = 0; y < rows; y++) {\n
\t\t\t\tposX = contPaddingBox.left;\n
\t\t\t\theight = rowHeights[y] + flexV;\n
\n
\t\t\t\tfor (x = 0; x < cols; x++) {\n
\t\t\t\t\tif (reverseRows) {\n
\t\t\t\t\t\tidx = y * cols + cols - 1 - x;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tidx = y * cols + x;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrl = items[idx];\n
\n
\t\t\t\t\t// No more controls to render then break\n
\t\t\t\t\tif (!ctrl) {\n
\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Get control settings and calculate x, y\n
\t\t\t\t\tctrlSettings = ctrl.settings;\n
\t\t\t\t\tctrlLayoutRect = ctrl.layoutRect();\n
\t\t\t\t\twidth = Math.max(colWidths[x], ctrlLayoutRect.startMinWidth);\n
\t\t\t\t\tctrlLayoutRect.x = posX;\n
\t\t\t\t\tctrlLayoutRect.y = posY;\n
\n
\t\t\t\t\t// Align control horizontal\n
\t\t\t\t\talign = ctrlSettings.alignH || (alignH ? (alignH[x] || alignH[0]) : null);\n
\t\t\t\t\tif (align == "center") {\n
\t\t\t\t\t\tctrlLayoutRect.x = posX + (width / 2) - (ctrlLayoutRect.w / 2);\n
\t\t\t\t\t} else if (align == "right") {\n
\t\t\t\t\t\tctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;\n
\t\t\t\t\t} else if (align == "stretch") {\n
\t\t\t\t\t\tctrlLayoutRect.w = width;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Align control vertical\n
\t\t\t\t\talign = ctrlSettings.alignV || (alignV ? (alignV[x] || alignV[0]) : null);\n
\t\t\t\t\tif (align == "center") {\n
\t\t\t\t\t\tctrlLayoutRect.y = posY + (height / 2) - (ctrlLayoutRect.h / 2);\n
\t\t\t\t\t} else if (align == "bottom") {\n
\t\t\t\t\t\tctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;\n
\t\t\t\t\t} else if (align == "stretch") {\n
\t\t\t\t\t\tctrlLayoutRect.h = height;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tctrl.layoutRect(ctrlLayoutRect);\n
\n
\t\t\t\t\tposX += width + spacingH;\n
\n
\t\t\t\t\tif (ctrl.recalc) {\n
\t\t\t\t\t\tctrl.recalc();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tposY += height + spacingV;\n
\t\t\t}\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Iframe.js\n
\n
/**\n
 * Iframe.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*jshint scripturl:true */\n
\n
/**\n
 * This class creates an iframe.\n
 *\n
 * @setting {String} url Url to open in the iframe.\n
 *\n
 * @-x-less Iframe.less\n
 * @class tinymce.ui.Iframe\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Iframe", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.classes.add(\'iframe\');\n
\t\t\tself.canFocus = false;\n
\n
\t\t\t/*eslint no-script-url:0 */\n
\t\t\treturn (\n
\t\t\t\t\'<iframe id="\' + self._id + \'" class="\' + self.classes + \'" tabindex="-1" src="\' +\n
\t\t\t\t(self.settings.url || "javascript:\\\'\\\'") + \'" frameborder="0"></iframe>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Setter for the iframe source.\n
\t\t *\n
\t\t * @method src\n
\t\t * @param {String} src Source URL for iframe.\n
\t\t */\n
\t\tsrc: function(src) {\n
\t\t\tthis.getEl().src = src;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Inner HTML for the iframe.\n
\t\t *\n
\t\t * @method html\n
\t\t * @param {String} html HTML string to set as HTML inside the iframe.\n
\t\t * @param {function} callback Optional callback to execute when the iframe body is filled with contents.\n
\t\t * @return {tinymce.ui.Iframe} Current iframe control.\n
\t\t */\n
\t\thtml: function(html, callback) {\n
\t\t\tvar self = this, body = this.getEl().contentWindow.document.body;\n
\n
\t\t\t// Wait for iframe to initialize IE 10 takes time\n
\t\t\tif (!body) {\n
\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\tself.html(html);\n
\t\t\t\t}, 0);\n
\t\t\t} else {\n
\t\t\t\tbody.innerHTML = html;\n
\n
\t\t\t\tif (callback) {\n
\t\t\t\t\tcallback();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn this;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Label.js\n
\n
/**\n
 * Label.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class creates a label element. A label is a simple text control\n
 * that can be bound to other controls.\n
 *\n
 * @-x-less Label.less\n
 * @class tinymce.ui.Label\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Label", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/DomUtils"\n
], function(Widget, DomUtils) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @param {Boolean} multiline Multiline label.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tself.classes.add(\'widget\').add(\'label\');\n
\t\t\tself.canFocus = false;\n
\n
\t\t\tif (settings.multiline) {\n
\t\t\t\tself.classes.add(\'autoscroll\');\n
\t\t\t}\n
\n
\t\t\tif (settings.strong) {\n
\t\t\t\tself.classes.add(\'strong\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the current controls layout rect.\n
\t\t * This will be executed by the layout managers to determine the\n
\t\t * default minWidth/minHeight etc.\n
\t\t *\n
\t\t * @method initLayoutRect\n
\t\t * @return {Object} Layout rect instance.\n
\t\t */\n
\t\tinitLayoutRect: function() {\n
\t\t\tvar self = this, layoutRect = self._super();\n
\n
\t\t\tif (self.settings.multiline) {\n
\t\t\t\tvar size = DomUtils.getSize(self.getEl());\n
\n
\t\t\t\t// Check if the text fits within maxW if not then try word wrapping it\n
\t\t\t\tif (size.width > layoutRect.maxW) {\n
\t\t\t\t\tlayoutRect.minW = layoutRect.maxW;\n
\t\t\t\t\tself.classes.add(\'multiline\');\n
\t\t\t\t}\n
\n
\t\t\t\tself.getEl().style.width = layoutRect.minW + \'px\';\n
\t\t\t\tlayoutRect.startMinH = layoutRect.h = layoutRect.minH = Math.min(layoutRect.maxH, DomUtils.getSize(self.getEl()).height);\n
\t\t\t}\n
\n
\t\t\treturn layoutRect;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.settings.multiline) {\n
\t\t\t\tself.getEl().style.lineHeight = self.layoutRect().h + \'px\';\n
\t\t\t}\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, forId = self.settings.forId;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<label id="\' + self._id + \'" class="\' + self.classes + \'"\' + (forId ? \' for="\' + forId + \'"\' : \'\') + \'>\' +\n
\t\t\t\t\tself.encode(self.state.get(\'text\')) +\n
\t\t\t\t\'</label>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:text\', function(e) {\n
\t\t\t\tself.innerHtml(self.encode(e.value));\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Toolbar.js\n
\n
/**\n
 * Toolbar.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new toolbar.\n
 *\n
 * @class tinymce.ui.Toolbar\n
 * @extends tinymce.ui.Container\n
 */\n
define("tinymce/ui/Toolbar", [\n
\t"tinymce/ui/Container"\n
], function(Container) {\n
\t"use strict";\n
\n
\treturn Container.extend({\n
\t\tDefaults: {\n
\t\t\trole: \'toolbar\',\n
\t\t\tlayout: \'flow\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\t\t\tself.classes.add(\'toolbar\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.items().each(function(ctrl) {\n
\t\t\t\tctrl.classes.add(\'toolbar-item\');\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/MenuBar.js\n
\n
/**\n
 * MenuBar.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new menubar.\n
 *\n
 * @-x-less MenuBar.less\n
 * @class tinymce.ui.MenuBar\n
 * @extends tinymce.ui.Container\n
 */\n
define("tinymce/ui/MenuBar", [\n
\t"tinymce/ui/Toolbar"\n
], function(Toolbar) {\n
\t"use strict";\n
\n
\treturn Toolbar.extend({\n
\t\tDefaults: {\n
\t\t\trole: \'menubar\',\n
\t\t\tcontainerCls: \'menubar\',\n
\t\t\tariaRoot: true,\n
\t\t\tdefaults: {\n
\t\t\t\ttype: \'menubutton\'\n
\t\t\t}\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/MenuButton.js\n
\n
/**\n
 * MenuButton.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new menu button.\n
 *\n
 * @-x-less MenuButton.less\n
 * @class tinymce.ui.MenuButton\n
 * @extends tinymce.ui.Button\n
 */\n
define("tinymce/ui/MenuButton", [\n
\t"tinymce/ui/Button",\n
\t"tinymce/ui/Factory",\n
\t"tinymce/ui/MenuBar"\n
], function(Button, Factory, MenuBar) {\n
\t"use strict";\n
\n
\t// TODO: Maybe add as some global function\n
\tfunction isChildOf(node, parent) {\n
\t\twhile (node) {\n
\t\t\tif (parent === node) {\n
\t\t\t\treturn true;\n
\t\t\t}\n
\n
\t\t\tnode = node.parentNode;\n
\t\t}\n
\n
\t\treturn false;\n
\t}\n
\n
\tvar MenuButton = Button.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._renderOpen = true;\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tself.classes.add(\'menubtn\');\n
\n
\t\t\tif (settings.fixedWidth) {\n
\t\t\t\tself.classes.add(\'fixed-width\');\n
\t\t\t}\n
\n
\t\t\tself.aria(\'haspopup\', true);\n
\n
\t\t\tself.state.set(\'menu\', settings.menu || self.render());\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the menu for the button.\n
\t\t *\n
\t\t * @method showMenu\n
\t\t */\n
\t\tshowMenu: function() {\n
\t\t\tvar self = this, menu;\n
\n
\t\t\tif (self.menu && self.menu.visible()) {\n
\t\t\t\treturn self.hideMenu();\n
\t\t\t}\n
\n
\t\t\tif (!self.menu) {\n
\t\t\t\tmenu = self.state.get(\'menu\') || [];\n
\n
\t\t\t\t// Is menu array then auto constuct menu control\n
\t\t\t\tif (menu.length) {\n
\t\t\t\t\tmenu = {\n
\t\t\t\t\t\ttype: \'menu\',\n
\t\t\t\t\t\titems: menu\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\tmenu.type = menu.type || \'menu\';\n
\t\t\t\t}\n
\n
\t\t\t\tif (!menu.renderTo) {\n
\t\t\t\t\tself.menu = Factory.create(menu).parent(self).renderTo();\n
\t\t\t\t} else {\n
\t\t\t\t\tself.menu = menu.parent(self).show().renderTo();\n
\t\t\t\t}\n
\n
\t\t\t\tself.fire(\'createmenu\');\n
\t\t\t\tself.menu.reflow();\n
\t\t\t\tself.menu.on(\'cancel\', function(e) {\n
\t\t\t\t\tif (e.control.parent() === self.menu) {\n
\t\t\t\t\t\te.stopPropagation();\n
\t\t\t\t\t\tself.focus();\n
\t\t\t\t\t\tself.hideMenu();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Move focus to button when a menu item is selected/clicked\n
\t\t\t\tself.menu.on(\'select\', function() {\n
\t\t\t\t\tself.focus();\n
\t\t\t\t});\n
\n
\t\t\t\tself.menu.on(\'show hide\', function(e) {\n
\t\t\t\t\tif (e.control == self.menu) {\n
\t\t\t\t\t\tself.activeMenu(e.type == \'show\');\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.aria(\'expanded\', e.type == \'show\');\n
\t\t\t\t}).fire(\'show\');\n
\t\t\t}\n
\n
\t\t\tself.menu.show();\n
\t\t\tself.menu.layoutRect({w: self.layoutRect().w});\n
\t\t\tself.menu.moveRel(self.getEl(), self.isRtl() ? [\'br-tr\', \'tr-br\'] : [\'bl-tl\', \'tl-bl\']);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the menu for the button.\n
\t\t *\n
\t\t * @method hideMenu\n
\t\t */\n
\t\thideMenu: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.menu) {\n
\t\t\t\tself.menu.items().each(function(item) {\n
\t\t\t\t\tif (item.hideMenu) {\n
\t\t\t\t\t\titem.hideMenu();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.menu.hide();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the active menu state.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tactiveMenu: function(state) {\n
\t\t\tthis.classes.toggle(\'active\', state);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix;\n
\t\t\tvar icon = self.settings.icon, image, text = self.state.get(\'text\');\n
\n
\t\t\timage = self.settings.image;\n
\t\t\tif (image) {\n
\t\t\t\ticon = \'none\';\n
\n
\t\t\t\t// Support for [high dpi, low dpi] image sources\n
\t\t\t\tif (typeof image != "string") {\n
\t\t\t\t\timage = window.getSelection ? image[0] : image[1];\n
\t\t\t\t}\n
\n
\t\t\t\timage = \' style="background-image: url(\\\'\' + image + \'\\\')"\';\n
\t\t\t} else {\n
\t\t\t\timage = \'\';\n
\t\t\t}\n
\n
\t\t\ticon = self.settings.icon ? prefix + \'ico \' + prefix + \'i-\' + icon : \'\';\n
\n
\t\t\tself.aria(\'role\', self.parent() instanceof MenuBar ? \'menuitem\' : \'button\');\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" tabindex="-1" aria-labelledby="\' + id + \'">\' +\n
\t\t\t\t\t\'<button id="\' + id + \'-open" role="presentation" type="button" tabindex="-1">\' +\n
\t\t\t\t\t\t(icon ? \'<i class="\' + icon + \'"\' + image + \'></i>\' : \'\') +\n
\t\t\t\t\t\t(text ? (icon ? \'\\u00a0\' : \'\') + self.encode(text) : \'\') +\n
\t\t\t\t\t\t\' <i class="\' + prefix + \'caret"></i>\' +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets invoked after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tif (e.control === self && isChildOf(e.target, self.getEl())) {\n
\t\t\t\t\tself.showMenu();\n
\n
\t\t\t\t\tif (e.aria) {\n
\t\t\t\t\t\tself.menu.items()[0].focus();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.on(\'mouseenter\', function(e) {\n
\t\t\t\tvar overCtrl = e.control, parent = self.parent(), hasVisibleSiblingMenu;\n
\n
\t\t\t\tif (overCtrl && parent && overCtrl instanceof MenuButton && overCtrl.parent() == parent) {\n
\t\t\t\t\tparent.items().filter(\'MenuButton\').each(function(ctrl) {\n
\t\t\t\t\t\tif (ctrl.hideMenu && ctrl != overCtrl) {\n
\t\t\t\t\t\t\tif (ctrl.menu && ctrl.menu.visible()) {\n
\t\t\t\t\t\t\t\thasVisibleSiblingMenu = true;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tctrl.hideMenu();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tif (hasVisibleSiblingMenu) {\n
\t\t\t\t\t\toverCtrl.focus(); // Fix for: #5887\n
\t\t\t\t\t\toverCtrl.showMenu();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:menu\', function() {\n
\t\t\t\tif (self.menu) {\n
\t\t\t\t\tself.menu.remove();\n
\t\t\t\t}\n
\n
\t\t\t\tself.menu = null;\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the control and it\'s menus.\n
\t\t *\n
\t\t * @method remove\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tthis._super();\n
\n
\t\t\tif (this.menu) {\n
\t\t\t\tthis.menu.remove();\n
\t\t\t}\n
\t\t}\n
\t});\n
\n
\treturn MenuButton;\n
});\n
\n
// Included from: js/tinymce/classes/ui/MenuItem.js\n
\n
/**\n
 * MenuItem.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new menu item.\n
 *\n
 * @-x-less MenuItem.less\n
 * @class tinymce.ui.MenuItem\n
 * @extends tinymce.ui.Control\n
 */\n
define("tinymce/ui/MenuItem", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/Factory",\n
\t"tinymce/Env"\n
], function(Widget, Factory, Env) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\tDefaults: {\n
\t\t\tborder: 0,\n
\t\t\trole: \'menuitem\'\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Boolean} selectable Selectable menu.\n
\t\t * @setting {Array} menu Submenu array with items.\n
\t\t * @setting {String} shortcut Shortcut to display for menu item. Example: Ctrl+X\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, text;\n
\n
\t\t\tself._super(settings);\n
\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tself.classes.add(\'menu-item\');\n
\n
\t\t\tif (settings.menu) {\n
\t\t\t\tself.classes.add(\'menu-item-expand\');\n
\t\t\t}\n
\n
\t\t\tif (settings.preview) {\n
\t\t\t\tself.classes.add(\'menu-item-preview\');\n
\t\t\t}\n
\n
\t\t\ttext = self.state.get(\'text\');\n
\t\t\tif (text === \'-\' || text === \'|\') {\n
\t\t\t\tself.classes.add(\'menu-item-sep\');\n
\t\t\t\tself.aria(\'role\', \'separator\');\n
\t\t\t\tself.state.set(\'text\', \'-\');\n
\t\t\t}\n
\n
\t\t\tif (settings.selectable) {\n
\t\t\t\tself.aria(\'role\', \'menuitemcheckbox\');\n
\t\t\t\tself.classes.add(\'menu-item-checkbox\');\n
\t\t\t\tsettings.icon = \'selected\';\n
\t\t\t}\n
\n
\t\t\tif (!settings.preview && !settings.selectable) {\n
\t\t\t\tself.classes.add(\'menu-item-normal\');\n
\t\t\t}\n
\n
\t\t\tself.on(\'mousedown\', function(e) {\n
\t\t\t\te.preventDefault();\n
\t\t\t});\n
\n
\t\t\tif (settings.menu && !settings.ariaHideMenu) {\n
\t\t\t\tself.aria(\'haspopup\', true);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the menuitem has sub menu.\n
\t\t *\n
\t\t * @method hasMenus\n
\t\t * @return {Boolean} True/false state if it has submenu.\n
\t\t */\n
\t\thasMenus: function() {\n
\t\t\treturn !!this.settings.menu;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the menu for the menu item.\n
\t\t *\n
\t\t * @method showMenu\n
\t\t */\n
\t\tshowMenu: function() {\n
\t\t\tvar self = this, settings = self.settings, menu, parent = self.parent();\n
\n
\t\t\tparent.items().each(function(ctrl) {\n
\t\t\t\tif (ctrl !== self) {\n
\t\t\t\t\tctrl.hideMenu();\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tif (settings.menu) {\n
\t\t\t\tmenu = self.menu;\n
\n
\t\t\t\tif (!menu) {\n
\t\t\t\t\tmenu = settings.menu;\n
\n
\t\t\t\t\t// Is menu array then auto constuct menu control\n
\t\t\t\t\tif (menu.length) {\n
\t\t\t\t\t\tmenu = {\n
\t\t\t\t\t\t\ttype: \'menu\',\n
\t\t\t\t\t\t\titems: menu\n
\t\t\t\t\t\t};\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tmenu.type = menu.type || \'menu\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (parent.settings.itemDefaults) {\n
\t\t\t\t\t\tmenu.itemDefaults = parent.settings.itemDefaults;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tmenu = self.menu = Factory.create(menu).parent(self).renderTo();\n
\t\t\t\t\tmenu.reflow();\n
\t\t\t\t\tmenu.on(\'cancel\', function(e) {\n
\t\t\t\t\t\te.stopPropagation();\n
\t\t\t\t\t\tself.focus();\n
\t\t\t\t\t\tmenu.hide();\n
\t\t\t\t\t});\n
\t\t\t\t\tmenu.on(\'show hide\', function(e) {\n
\t\t\t\t\t\te.control.items().each(function(ctrl) {\n
\t\t\t\t\t\t\tctrl.active(ctrl.settings.selected);\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}).fire(\'show\');\n
\n
\t\t\t\t\tmenu.on(\'hide\', function(e) {\n
\t\t\t\t\t\tif (e.control === menu) {\n
\t\t\t\t\t\t\tself.classes.remove(\'selected\');\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tmenu.submenu = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tmenu.show();\n
\t\t\t\t}\n
\n
\t\t\t\tmenu._parentMenu = parent;\n
\n
\t\t\t\tmenu.classes.add(\'menu-sub\');\n
\n
\t\t\t\tvar rel = menu.testMoveRel(\n
\t\t\t\t\tself.getEl(),\n
\t\t\t\t\tself.isRtl() ? [\'tl-tr\', \'bl-br\', \'tr-tl\', \'br-bl\'] : [\'tr-tl\', \'br-bl\', \'tl-tr\', \'bl-br\']\n
\t\t\t\t);\n
\n
\t\t\t\tmenu.moveRel(self.getEl(), rel);\n
\t\t\t\tmenu.rel = rel;\n
\n
\t\t\t\trel = \'menu-sub-\' + rel;\n
\t\t\t\tmenu.classes.remove(menu._lastRel).add(rel);\n
\t\t\t\tmenu._lastRel = rel;\n
\n
\t\t\t\tself.classes.add(\'selected\');\n
\t\t\t\tself.aria(\'expanded\', true);\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the menu for the menu item.\n
\t\t *\n
\t\t * @method hideMenu\n
\t\t */\n
\t\thideMenu: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.menu) {\n
\t\t\t\tself.menu.items().each(function(item) {\n
\t\t\t\t\tif (item.hideMenu) {\n
\t\t\t\t\t\titem.hideMenu();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.menu.hide();\n
\t\t\t\tself.aria(\'expanded\', false);\n
\t\t\t}\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, settings = self.settings, prefix = self.classPrefix, text = self.encode(self.state.get(\'text\'));\n
\t\t\tvar icon = self.settings.icon, image = \'\', shortcut = settings.shortcut;\n
\n
\t\t\t// Converts shortcut format to Mac/PC variants\n
\t\t\tfunction convertShortcut(shortcut) {\n
\t\t\t\tvar i, value, replace = {};\n
\n
\t\t\t\tif (Env.mac) {\n
\t\t\t\t\treplace = {\n
\t\t\t\t\t\talt: \'&#x2325;\',\n
\t\t\t\t\t\tctrl: \'&#x2318;\',\n
\t\t\t\t\t\tshift: \'&#x21E7;\',\n
\t\t\t\t\t\tmeta: \'&#x2318;\'\n
\t\t\t\t\t};\n
\t\t\t\t} else {\n
\t\t\t\t\treplace = {\n
\t\t\t\t\t\tmeta: \'Ctrl\'\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\n
\t\t\t\tshortcut = shortcut.split(\'+\');\n
\n
\t\t\t\tfor (i = 0; i < shortcut.length; i++) {\n
\t\t\t\t\tvalue = replace[shortcut[i].toLowerCase()];\n
\n
\t\t\t\t\tif (value) {\n
\t\t\t\t\t\tshortcut[i] = value;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn shortcut.join(\'+\');\n
\t\t\t}\n
\n
\t\t\tif (icon) {\n
\t\t\t\tself.parent().classes.add(\'menu-has-icons\');\n
\t\t\t}\n
\n
\t\t\tif (settings.image) {\n
\t\t\t\ticon = \'none\';\n
\t\t\t\timage = \' style="background-image: url(\\\'\' + settings.image + \'\\\')"\';\n
\t\t\t}\n
\n
\t\t\tif (shortcut) {\n
\t\t\t\tshortcut = convertShortcut(shortcut);\n
\t\t\t}\n
\n
\t\t\ticon = prefix + \'ico \' + prefix + \'i-\' + (self.settings.icon || \'none\');\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" tabindex="-1">\' +\n
\t\t\t\t\t(text !== \'-\' ? \'<i class="\' + icon + \'"\' + image + \'></i>\\u00a0\' : \'\') +\n
\t\t\t\t\t(text !== \'-\' ? \'<span id="\' + id + \'-text" class="\' + prefix + \'text">\' + text + \'</span>\' : \'\') +\n
\t\t\t\t\t(shortcut ? \'<div id="\' + id + \'-shortcut" class="\' + prefix + \'menu-shortcut">\' + shortcut + \'</div>\' : \'\') +\n
\t\t\t\t\t(settings.menu ? \'<div class="\' + prefix + \'caret"></div>\' : \'\') +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets invoked after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, settings = self.settings;\n
\n
\t\t\tvar textStyle = settings.textStyle;\n
\t\t\tif (typeof textStyle == "function") {\n
\t\t\t\ttextStyle = textStyle.call(this);\n
\t\t\t}\n
\n
\t\t\tif (textStyle) {\n
\t\t\t\tvar textElm = self.getEl(\'text\');\n
\t\t\t\tif (textElm) {\n
\t\t\t\t\ttextElm.setAttribute(\'style\', textStyle);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.on(\'mouseenter click\', function(e) {\n
\t\t\t\tif (e.control === self) {\n
\t\t\t\t\tif (!settings.menu && e.type === \'click\') {\n
\t\t\t\t\t\tself.fire(\'select\');\n
\t\t\t\t\t\tself.parent().hideAll();\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tself.showMenu();\n
\n
\t\t\t\t\t\tif (e.aria) {\n
\t\t\t\t\t\t\tself.menu.focus(true);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself._super();\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\tactive: function(state) {\n
\t\t\tif (typeof state != "undefined") {\n
\t\t\t\tthis.aria(\'checked\', state);\n
\t\t\t}\n
\n
\t\t\treturn this._super(state);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the control and it\'s menus.\n
\t\t *\n
\t\t * @method remove\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tthis._super();\n
\n
\t\t\tif (this.menu) {\n
\t\t\t\tthis.menu.remove();\n
\t\t\t}\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Menu.js\n
\n
/**\n
 * Menu.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new menu.\n
 *\n
 * @-x-less Menu.less\n
 * @class tinymce.ui.Menu\n
 * @extends tinymce.ui.FloatPanel\n
 */\n
define("tinymce/ui/Menu", [\n
\t"tinymce/ui/FloatPanel",\n
\t"tinymce/ui/MenuItem",\n
\t"tinymce/util/Tools"\n
], function(FloatPanel, MenuItem, Tools) {\n
\t"use strict";\n
\n
\tvar Menu = FloatPanel.extend({\n
\t\tDefaults: {\n
\t\t\tdefaultType: \'menuitem\',\n
\t\t\tborder: 1,\n
\t\t\tlayout: \'stack\',\n
\t\t\trole: \'application\',\n
\t\t\tbodyRole: \'menu\',\n
\t\t\tariaRoot: true\n
\t\t},\n
\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tsettings.autohide = true;\n
\t\t\tsettings.constrainToViewport = true;\n
\n
\t\t\tif (settings.itemDefaults) {\n
\t\t\t\tvar items = settings.items, i = items.length;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\titems[i] = Tools.extend({}, settings.itemDefaults, items[i]);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\t\t\tself.classes.add(\'menu\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tthis.classes.toggle(\'menu-align\', true);\n
\n
\t\t\tthis._super();\n
\n
\t\t\tthis.getEl().style.height = \'\';\n
\t\t\tthis.getEl(\'body\').style.height = \'\';\n
\n
\t\t\treturn this;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides/closes the menu.\n
\t\t *\n
\t\t * @method cancel\n
\t\t */\n
\t\tcancel: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.hideAll();\n
\t\t\tself.fire(\'select\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hide menu and all sub menus.\n
\t\t *\n
\t\t * @method hideAll\n
\t\t */\n
\t\thideAll: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tthis.find(\'menuitem\').exec(\'hideMenu\');\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Invoked before the menu is rendered.\n
\t\t *\n
\t\t * @method preRender\n
\t\t */\n
\t\tpreRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.items().each(function(ctrl) {\n
\t\t\t\tvar settings = ctrl.settings;\n
\n
\t\t\t\tif (settings.icon || settings.image || settings.selectable) {\n
\t\t\t\t\tself._hasIcons = true;\n
\t\t\t\t\treturn false;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
\n
\treturn Menu;\n
});\n
\n
// Included from: js/tinymce/classes/ui/ListBox.js\n
\n
/**\n
 * ListBox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new list box control.\n
 *\n
 * @-x-less ListBox.less\n
 * @class tinymce.ui.ListBox\n
 * @extends tinymce.ui.MenuButton\n
 */\n
define("tinymce/ui/ListBox", [\n
\t"tinymce/ui/MenuButton",\n
\t"tinymce/ui/Menu"\n
], function(MenuButton, Menu) {\n
\t"use strict";\n
\n
\treturn MenuButton.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Array} values Array with values to add to list box.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this, values, selected, selectedText, lastItemCtrl;\n
\n
\t\t\tfunction setSelected(menuValues) {\n
\t\t\t\t// Try to find a selected value\n
\t\t\t\tfor (var i = 0; i < menuValues.length; i++) {\n
\t\t\t\t\tselected = menuValues[i].selected || settings.value === menuValues[i].value;\n
\n
\t\t\t\t\tif (selected) {\n
\t\t\t\t\t\tselectedText = selectedText || menuValues[i].text;\n
\t\t\t\t\t\tself.state.set(\'value\', menuValues[i].value);\n
\t\t\t\t\t\treturn true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// If the value has a submenu, try to find the selected values in that menu\n
\t\t\t\t\tif (menuValues[i].menu) {\n
\t\t\t\t\t\tif (setSelected(menuValues[i].menu)) {\n
\t\t\t\t\t\t\treturn true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\t\t\tsettings = self.settings;\n
\n
\t\t\tself._values = values = settings.values;\n
\t\t\tif (values) {\n
\t\t\t\tif (typeof settings.value != "undefined") {\n
\t\t\t\t\tsetSelected(values);\n
\t\t\t\t}\n
\n
\t\t\t\t// Default with first item\n
\t\t\t\tif (!selected && values.length > 0) {\n
\t\t\t\t\tselectedText = values[0].text;\n
\t\t\t\t\tself.state.set(\'value\', values[0].value);\n
\t\t\t\t}\n
\n
\t\t\t\tself.state.set(\'menu\', values);\n
\t\t\t}\n
\n
\t\t\tself.state.set(\'text\', settings.text || selectedText || values[0].text);\n
\n
\t\t\tself.classes.add(\'listbox\');\n
\n
\t\t\tself.on(\'select\', function(e) {\n
\t\t\t\tvar ctrl = e.control;\n
\n
\t\t\t\tif (lastItemCtrl) {\n
\t\t\t\t\te.lastControl = lastItemCtrl;\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.multiple) {\n
\t\t\t\t\tctrl.active(!ctrl.active());\n
\t\t\t\t} else {\n
\t\t\t\t\tself.value(e.control.value());\n
\t\t\t\t}\n
\n
\t\t\t\tlastItemCtrl = ctrl;\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Getter/setter function for the control value.\n
\t\t *\n
\t\t * @method value\n
\t\t * @param {String} [value] Value to be set.\n
\t\t * @return {Boolean/tinymce.ui.ListBox} Value or self if it\'s a set operation.\n
\t\t */\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tfunction activateMenuItemsByValue(menu, value) {\n
\t\t\t\tif (menu instanceof Menu) {\n
\t\t\t\t\tmenu.items().each(function(ctrl) {\n
\t\t\t\t\t\tif (!ctrl.hasMenus()) {\n
\t\t\t\t\t\t\tctrl.active(ctrl.value() === value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction getSelectedItem(menuValues, value) {\n
\t\t\t\tvar selectedItem;\n
\n
\t\t\t\tif (!menuValues) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tfor (var i = 0; i < menuValues.length; i++) {\n
\t\t\t\t\tif (menuValues[i].value === value) {\n
\t\t\t\t\t\treturn menuValues[i];\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (menuValues[i].menu) {\n
\t\t\t\t\t\tselectedItem = getSelectedItem(menuValues[i].menu, value);\n
\t\t\t\t\t\tif (selectedItem) {\n
\t\t\t\t\t\t\treturn selectedItem;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.on(\'show\', function(e) {\n
\t\t\t\tactivateMenuItemsByValue(e.control, self.value());\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:value\', function(e) {\n
\t\t\t\tvar selectedItem = getSelectedItem(self.state.get(\'menu\'), e.value);\n
\n
\t\t\t\tif (selectedItem) {\n
\t\t\t\t\tself.text(selectedItem.text);\n
\t\t\t\t} else {\n
\t\t\t\t\tself.text(self.settings.text);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Radio.js\n
\n
/**\n
 * Radio.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new radio button.\n
 *\n
 * @-x-less Radio.less\n
 * @class tinymce.ui.Radio\n
 * @extends tinymce.ui.Checkbox\n
 */\n
define("tinymce/ui/Radio", [\n
\t"tinymce/ui/Checkbox"\n
], function(Checkbox) {\n
\t"use strict";\n
\n
\treturn Checkbox.extend({\n
\t\tDefaults: {\n
\t\t\tclasses: "radio",\n
\t\t\trole: "radio"\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Rect.js\n
\n
/**\n
 * Rect.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Contains various tools for rect/position calculation.\n
 *\n
 * @class tinymce.ui.Rect\n
 */\n
define("tinymce/ui/Rect", [\n
], function() {\n
\t"use strict";\n
\n
\tvar min = Math.min, max = Math.max, round = Math.round;\n
\n
\t/**\n
\t * Returns the rect positioned based on the relative position name\n
\t * to the target rect.\n
\t *\n
\t * @method relativePosition\n
\t * @param {Rect} rect Source rect to modify into a new rect.\n
\t * @param {Rect} targetRect Rect to move relative to based on the rel option.\n
\t * @param {String} rel Relative position. For example: tr-bl.\n
\t */\n
\tfunction relativePosition(rect, targetRect, rel) {\n
\t\tvar x, y, w, h, targetW, targetH;\n
\n
\t\tx = targetRect.x;\n
\t\ty = targetRect.y;\n
\t\tw = rect.w;\n
\t\th = rect.h;\n
\t\ttargetW = targetRect.w;\n
\t\ttargetH = targetRect.h;\n
\n
\t\trel = (rel || \'\').split(\'\');\n
\n
\t\tif (rel[0] === \'b\') {\n
\t\t\ty += targetH;\n
\t\t}\n
\n
\t\tif (rel[1] === \'r\') {\n
\t\t\tx += targetW;\n
\t\t}\n
\n
\t\tif (rel[0] === \'c\') {\n
\t\t\ty += round(targetH / 2);\n
\t\t}\n
\n
\t\tif (rel[1] === \'c\') {\n
\t\t\tx += round(targetW / 2);\n
\t\t}\n
\n
\t\tif (rel[3] === \'b\') {\n
\t\t\ty -= h;\n
\t\t}\n
\n
\t\tif (rel[4] === \'r\') {\n
\t\t\tx -= w;\n
\t\t}\n
\n
\t\tif (rel[3] === \'c\') {\n
\t\t\ty -= round(h / 2);\n
\t\t}\n
\n
\t\tif (rel[4] === \'c\') {\n
\t\t\tx -= round(w / 2);\n
\t\t}\n
\n
\t\treturn {x: x, y: y, w: w, h: h};\n
\t}\n
\n
\t/**\n
\t * Tests various positions to get the most suitable one.\n
\t *\n
\t * @method findBestRelativePosition\n
\t * @param {Rect} Rect Rect to use as source.\n
\t * @param {Rect} targetRect Rect to move relative to.\n
\t * @param {Rect} constrainRect Rect to constrain within.\n
\t * @param {Array} Array of relative positions to test against.\n
\t */\n
\tfunction findBestRelativePosition(rect, targetRect, constrainRect, rels) {\n
\t\tvar pos, i;\n
\n
\t\tfor (i = 0; i < rels.length; i++) {\n
\t\t\tpos = relativePosition(rect, targetRect, rels[i]);\n
\n
\t\t\tif (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&\n
\t\t\t\tpos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n
\t\t\t\treturn rels[i];\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Inflates the rect in all directions.\n
\t *\n
\t * @method inflate\n
\t * @param {Rect} rect Rect to expand.\n
\t * @param {Number} w Relative width to expand by.\n
\t * @param {Number} h Relative height to expand by.\n
\t * @return {Rect} New expanded rect.\n
\t */\n
\tfunction inflate(rect, w, h) {\n
\t\treturn {\n
\t\t\tx: rect.x - w,\n
\t\t\ty: rect.y - h,\n
\t\t\tw: rect.w + w * 2,\n
\t\t\th: rect.h + h * 2\n
\t\t};\n
\t}\n
\n
\t/**\n
\t * Returns the intersection of the specified rectangles.\n
\t *\n
\t * @method intersect\n
\t * @param {Rect} rect The first rectangle to compare.\n
\t * @param {Rect} cropRect The second rectangle to compare.\n
\t * @return {Rect} The intersection of the two rectangles or null if they don\'t intersect.\n
\t */\n
\tfunction intersect(rect1, rect2) {\n
\t\tvar x1, y1, x2, y2;\n
\n
\t\tx1 = max(rect1.x, rect2.x);\n
\t\ty1 = max(rect1.y, rect2.y);\n
\t\tx2 = min(rect1.x + rect1.w, rect2.x + rect2.w);\n
\t\ty2 = min(rect1.y + rect1.h, rect2.y + rect2.h);\n
\n
\t\tif (x2 - x1 < 0 || y2 - y1 < 0) {\n
\t\t\treturn null;\n
\t\t}\n
\n
\t\treturn {x: x1, y: y1, w: x2 - x1, h: y2 - y1};\n
\t}\n
\n
\t/**\n
\t * Returns a rect clamped within the specified clamp rect. This forces the\n
\t * rect to be inside the clamp rect.\n
\t *\n
\t * @method clamp\n
\t * @param {Rect} rect Rectangle to force within clamp rect.\n
\t * @param {Rect} clampRect Rectable to force within.\n
\t * @param {Boolean} fixedSize True/false if size should be fixed.\n
\t * @return {Rect} Clamped rect.\n
\t */\n
\tfunction clamp(rect, clampRect, fixedSize) {\n
\t\tvar underflowX1, underflowY1, overflowX2, overflowY2,\n
\t\t\tx1, y1, x2, y2, cx2, cy2;\n
\n
\t\tx1 = rect.x;\n
\t\ty1 = rect.y;\n
\t\tx2 = rect.x + rect.w;\n
\t\ty2 = rect.y + rect.h;\n
\t\tcx2 = clampRect.x + clampRect.w;\n
\t\tcy2 = clampRect.y + clampRect.h;\n
\n
\t\tunderflowX1 = max(0, clampRect.x - x1);\n
\t\tunderflowY1 = max(0, clampRect.y - y1);\n
\t\toverflowX2 = max(0, x2 - cx2);\n
\t\toverflowY2 = max(0, y2 - cy2);\n
\n
\t\tx1 += underflowX1;\n
\t\ty1 += underflowY1;\n
\n
\t\tif (fixedSize) {\n
\t\t\tx2 += underflowX1;\n
\t\t\ty2 += underflowY1;\n
\t\t\tx1 -= overflowX2;\n
\t\t\ty1 -= overflowY2;\n
\t\t}\n
\n
\t\tx2 -= overflowX2;\n
\t\ty2 -= overflowY2;\n
\n
\t\treturn {x: x1, y: y1, w: x2 - x1, h: y2 - y1};\n
\t}\n
\n
\treturn {\n
\t\tinflate: inflate,\n
\t\trelativePosition: relativePosition,\n
\t\tfindBestRelativePosition: findBestRelativePosition,\n
\t\tintersect: intersect,\n
\t\tclamp: clamp\n
\t};\n
});\n
\n
// Included from: js/tinymce/classes/ui/ResizeHandle.js\n
\n
/**\n
 * ResizeHandle.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Renders a resize handle that fires ResizeStart, Resize and ResizeEnd events.\n
 *\n
 * @-x-less ResizeHandle.less\n
 * @class tinymce.ui.ResizeHandle\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/ResizeHandle", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/DragHelper"\n
], function(Widget, DragHelper) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, prefix = self.classPrefix;\n
\n
\t\t\tself.classes.add(\'resizehandle\');\n
\n
\t\t\tif (self.settings.direction == "both") {\n
\t\t\t\tself.classes.add(\'resizehandle-both\');\n
\t\t\t}\n
\n
\t\t\tself.canFocus = false;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\t\'<i class="\' + prefix + \'ico \' + prefix + \'i-resize"></i>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super();\n
\n
\t\t\tself.resizeDragHelper = new DragHelper(this._id, {\n
\t\t\t\tstart: function() {\n
\t\t\t\t\tself.fire(\'ResizeStart\');\n
\t\t\t\t},\n
\n
\t\t\t\tdrag: function(e) {\n
\t\t\t\t\tif (self.settings.direction != "both") {\n
\t\t\t\t\t\te.deltaX = 0;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.fire(\'Resize\', e);\n
\t\t\t\t},\n
\n
\t\t\t\tstop: function() {\n
\t\t\t\t\tself.fire(\'ResizeEnd\');\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\tremove: function() {\n
\t\t\tif (this.resizeDragHelper) {\n
\t\t\t\tthis.resizeDragHelper.destroy();\n
\t\t\t}\n
\n
\t\t\treturn this._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Slider.js\n
\n
/**\n
 * Slider.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Slider control.\n
 *\n
 * @-x-less Slider.less\n
 * @class tinymce.ui.Slider\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Slider", [\n
\t"tinymce/ui/Widget",\n
\t"tinymce/ui/DragHelper",\n
\t"tinymce/ui/DomUtils"\n
], function(Widget, DragHelper, DomUtils) {\n
\t"use strict";\n
\n
\tfunction constrain(value, minVal, maxVal) {\n
\t\tif (value < minVal) {\n
\t\t\tvalue = minVal;\n
\t\t}\n
\n
\t\tif (value > maxVal) {\n
\t\t\tvalue = maxVal;\n
\t\t}\n
\n
\t\treturn value;\n
\t}\n
\n
\tfunction updateSliderHandle(ctrl, value) {\n
\t\tvar maxHandlePos, shortSizeName, sizeName, stylePosName, styleValue;\n
\n
\t\tif (ctrl.settings.orientation == "v") {\n
\t\t\tstylePosName = "top";\n
\t\t\tsizeName = "height";\n
\t\t\tshortSizeName = "h";\n
\t\t} else {\n
\t\t\tstylePosName = "left";\n
\t\t\tsizeName = "width";\n
\t\t\tshortSizeName = "w";\n
\t\t}\n
\n
\t\tmaxHandlePos = (ctrl.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(ctrl.getEl(\'handle\'))[sizeName];\n
\n
\t\tstyleValue = (maxHandlePos * ((value - ctrl._minValue) / (ctrl._maxValue - ctrl._minValue))) + \'px\';\n
\t\tctrl.getEl(\'handle\').style[stylePosName] = styleValue;\n
\t\tctrl.getEl(\'handle\').style.height = ctrl.layoutRect().h + \'px\';\n
\t}\n
\n
\treturn Widget.extend({\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!settings.previewFilter) {\n
\t\t\t\tsettings.previewFilter = function(value) {\n
\t\t\t\t\treturn Math.round(value * 100) / 100.0;\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tself._super(settings);\n
\t\t\tself.classes.add(\'slider\');\n
\n
\t\t\tif (settings.orientation == "v") {\n
\t\t\t\tself.classes.add(\'vertical\');\n
\t\t\t}\n
\n
\t\t\tself._minValue = settings.minValue || 0;\n
\t\t\tself._maxValue = settings.maxValue || 100;\n
\t\t\tself._initValue = self.state.get(\'value\');\n
\t\t},\n
\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix;\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'">\' +\n
\t\t\t\t\t\'<div id="\' + id + \'-handle" class="\' + prefix + \'slider-handle"></div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\treset: function() {\n
\t\t\tthis.value(this._initValue).repaint();\n
\t\t},\n
\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, startPos, startHandlePos, handlePos = 0, value, minValue, maxValue, maxHandlePos;\n
\t\t\tvar screenCordName, stylePosName, sizeName, shortSizeName;\n
\n
\t\t\tminValue = self._minValue;\n
\t\t\tmaxValue = self._maxValue;\n
\t\t\tvalue = self.value();\n
\n
\t\t\tif (self.settings.orientation == "v") {\n
\t\t\t\tscreenCordName = "screenY";\n
\t\t\t\tstylePosName = "top";\n
\t\t\t\tsizeName = "height";\n
\t\t\t\tshortSizeName = "h";\n
\t\t\t} else {\n
\t\t\t\tscreenCordName = "screenX";\n
\t\t\t\tstylePosName = "left";\n
\t\t\t\tsizeName = "width";\n
\t\t\t\tshortSizeName = "w";\n
\t\t\t}\n
\n
\t\t\tself._super();\n
\n
\t\t\tself._dragHelper = new DragHelper(self._id, {\n
\t\t\t\thandle: self._id + "-handle",\n
\n
\t\t\t\tstart: function(e) {\n
\t\t\t\t\tstartPos = e[screenCordName];\n
\t\t\t\t\tstartHandlePos = parseInt(self.getEl(\'handle\').style[stylePosName], 10);\n
\t\t\t\t\tmaxHandlePos = (self.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(self.getEl(\'handle\'))[sizeName];\n
\t\t\t\t\tself.fire(\'dragstart\', {value: value});\n
\t\t\t\t},\n
\n
\t\t\t\tdrag: function(e) {\n
\t\t\t\t\tvar delta = e[screenCordName] - startPos, handleEl = self.getEl(\'handle\');\n
\n
\t\t\t\t\thandlePos = constrain(startHandlePos + delta, 0, maxHandlePos);\n
\t\t\t\t\thandleEl.style[stylePosName] = handlePos + \'px\';\n
\n
\t\t\t\t\tvalue = minValue + (handlePos / maxHandlePos) * (maxValue - minValue);\n
\t\t\t\t\tself.value(value);\n
\n
\t\t\t\t\tself.tooltip().text(\'\' + self.settings.previewFilter(value)).show().moveRel(handleEl, \'bc tc\');\n
\n
\t\t\t\t\tself.fire(\'drag\', {value: value});\n
\t\t\t\t},\n
\n
\t\t\t\tstop: function() {\n
\t\t\t\t\tself.tooltip().hide();\n
\t\t\t\t\tself.fire(\'dragend\', {value: value});\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\trepaint: function() {\n
\t\t\tthis._super();\n
\t\t\tupdateSliderHandle(this, this.value());\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:value\', function(e) {\n
\t\t\t\tupdateSliderHandle(self, e.value);\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Spacer.js\n
\n
/**\n
 * Spacer.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a spacer. This control is used in flex layouts for example.\n
 *\n
 * @-x-less Spacer.less\n
 * @class tinymce.ui.Spacer\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/Spacer", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.classes.add(\'spacer\');\n
\t\t\tself.canFocus = false;\n
\n
\t\t\treturn \'<div id="\' + self._id + \'" class="\' + self.classes + \'"></div>\';\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/SplitButton.js\n
\n
/**\n
 * SplitButton.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a split button.\n
 *\n
 * @-x-less SplitButton.less\n
 * @class tinymce.ui.SplitButton\n
 * @extends tinymce.ui.Button\n
 */\n
define("tinymce/ui/SplitButton", [\n
\t"tinymce/ui/MenuButton",\n
\t"tinymce/ui/DomUtils",\n
\t"tinymce/dom/DomQuery"\n
], function(MenuButton, DomUtils, $) {\n
\treturn MenuButton.extend({\n
\t\tDefaults: {\n
\t\t\tclasses: "widget btn splitbtn",\n
\t\t\trole: "button"\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this, elm = self.getEl(), rect = self.layoutRect(), mainButtonElm, menuButtonElm;\n
\n
\t\t\tself._super();\n
\n
\t\t\tmainButtonElm = elm.firstChild;\n
\t\t\tmenuButtonElm = elm.lastChild;\n
\n
\t\t\t$(mainButtonElm).css({\n
\t\t\t\twidth: rect.w - DomUtils.getSize(menuButtonElm).width,\n
\t\t\t\theight: rect.h - 2\n
\t\t\t});\n
\n
\t\t\t$(menuButtonElm).css({\n
\t\t\t\theight: rect.h - 2\n
\t\t\t});\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the active menu state.\n
\t\t *\n
\t\t * @private\n
\t\t */\n
\t\tactiveMenu: function(state) {\n
\t\t\tvar self = this;\n
\n
\t\t\t$(self.getEl().lastChild).toggleClass(self.classPrefix + \'active\', state);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, prefix = self.classPrefix, image;\n
\t\t\tvar icon = self.state.get(\'icon\'), text = self.state.get(\'text\');\n
\n
\t\t\timage = self.settings.image;\n
\t\t\tif (image) {\n
\t\t\t\ticon = \'none\';\n
\n
\t\t\t\t// Support for [high dpi, low dpi] image sources\n
\t\t\t\tif (typeof image != "string") {\n
\t\t\t\t\timage = window.getSelection ? image[0] : image[1];\n
\t\t\t\t}\n
\n
\t\t\t\timage = \' style="background-image: url(\\\'\' + image + \'\\\')"\';\n
\t\t\t} else {\n
\t\t\t\timage = \'\';\n
\t\t\t}\n
\n
\t\t\ticon = self.settings.icon ? prefix + \'ico \' + prefix + \'i-\' + icon : \'\';\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + id + \'" class="\' + self.classes + \'" role="button" tabindex="-1">\' +\n
\t\t\t\t\t\'<button type="button" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t\t(icon ? \'<i class="\' + icon + \'"\' + image + \'></i>\' : \'\') +\n
\t\t\t\t\t\t(text ? (icon ? \' \' : \'\') + text : \'\') +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\t\'<button type="button" class="\' + prefix + \'open" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t\t//(icon ? \'<i class="\' + icon + \'"></i>\' : \'\') +\n
\t\t\t\t\t\t(self._menuBtnText ? (icon ? \'\\u00a0\' : \'\') + self._menuBtnText : \'\') +\n
\t\t\t\t\t\t\' <i class="\' + prefix + \'caret"></i>\' +\n
\t\t\t\t\t\'</button>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this, onClickHandler = self.settings.onclick;\n
\n
\t\t\tself.on(\'click\', function(e) {\n
\t\t\t\tvar node = e.target;\n
\n
\t\t\t\tif (e.control == this) {\n
\t\t\t\t\t// Find clicks that is on the main button\n
\t\t\t\t\twhile (node) {\n
\t\t\t\t\t\tif ((e.aria && e.aria.key != \'down\') || (node.nodeName == \'BUTTON\' && node.className.indexOf(\'open\') == -1)) {\n
\t\t\t\t\t\t\te.stopImmediatePropagation();\n
\n
\t\t\t\t\t\t\tif (onClickHandler) {\n
\t\t\t\t\t\t\t\tonClickHandler.call(this, e);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode = node.parentNode;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tdelete self.settings.onclick;\n
\n
\t\t\treturn self._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/StackLayout.js\n
\n
/**\n
 * StackLayout.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This layout uses the browsers layout when the items are blocks.\n
 *\n
 * @-x-less StackLayout.less\n
 * @class tinymce.ui.StackLayout\n
 * @extends tinymce.ui.FlowLayout\n
 */\n
define("tinymce/ui/StackLayout", [\n
\t"tinymce/ui/FlowLayout"\n
], function(FlowLayout) {\n
\t"use strict";\n
\n
\treturn FlowLayout.extend({\n
\t\tDefaults: {\n
\t\t\tcontainerClass: \'stack-layout\',\n
\t\t\tcontrolClass: \'stack-layout-item\',\n
\t\t\tendClass: \'break\'\n
\t\t},\n
\n
\t\tisNative: function() {\n
\t\t\treturn true;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/TabPanel.js\n
\n
/**\n
 * TabPanel.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a tab panel control.\n
 *\n
 * @-x-less TabPanel.less\n
 * @class tinymce.ui.TabPanel\n
 * @extends tinymce.ui.Panel\n
 *\n
 * @setting {Number} activeTab Active tab index.\n
 */\n
define("tinymce/ui/TabPanel", [\n
\t"tinymce/ui/Panel",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/DomUtils"\n
], function(Panel, $, DomUtils) {\n
\t"use strict";\n
\n
\treturn Panel.extend({\n
\t\tDefaults: {\n
\t\t\tlayout: \'absolute\',\n
\t\t\tdefaults: {\n
\t\t\t\ttype: \'panel\'\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Activates the specified tab by index.\n
\t\t *\n
\t\t * @method activateTab\n
\t\t * @param {Number} idx Index of the tab to activate.\n
\t\t */\n
\t\tactivateTab: function(idx) {\n
\t\t\tvar activeTabElm;\n
\n
\t\t\tif (this.activeTabId) {\n
\t\t\t\tactiveTabElm = this.getEl(this.activeTabId);\n
\t\t\t\t$(activeTabElm).removeClass(this.classPrefix + \'active\');\n
\t\t\t\tactiveTabElm.setAttribute(\'aria-selected\', "false");\n
\t\t\t}\n
\n
\t\t\tthis.activeTabId = \'t\' + idx;\n
\n
\t\t\tactiveTabElm = this.getEl(\'t\' + idx);\n
\t\t\tactiveTabElm.setAttribute(\'aria-selected\', "true");\n
\t\t\t$(activeTabElm).addClass(this.classPrefix + \'active\');\n
\n
\t\t\tthis.items()[idx].show().fire(\'showtab\');\n
\t\t\tthis.reflow();\n
\n
\t\t\tthis.items().each(function(item, i) {\n
\t\t\t\tif (idx != i) {\n
\t\t\t\t\titem.hide();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, layout = self._layout, tabsHtml = \'\', prefix = self.classPrefix;\n
\n
\t\t\tself.preRender();\n
\t\t\tlayout.preRender(self);\n
\n
\t\t\tself.items().each(function(ctrl, i) {\n
\t\t\t\tvar id = self._id + \'-t\' + i;\n
\n
\t\t\t\tctrl.aria(\'role\', \'tabpanel\');\n
\t\t\t\tctrl.aria(\'labelledby\', id);\n
\n
\t\t\t\ttabsHtml += (\n
\t\t\t\t\t\'<div id="\' + id + \'" class="\' + prefix + \'tab" \' +\n
\t\t\t\t\t\t\'unselectable="on" role="tab" aria-controls="\' + ctrl._id + \'" aria-selected="false" tabIndex="-1">\' +\n
\t\t\t\t\t\tself.encode(ctrl.settings.title) +\n
\t\t\t\t\t\'</div>\'\n
\t\t\t\t);\n
\t\t\t});\n
\n
\t\t\treturn (\n
\t\t\t\t\'<div id="\' + self._id + \'" class="\' + self.classes + \'" hidefocus="1" tabindex="-1">\' +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-head" class="\' + prefix + \'tabs" role="tablist">\' +\n
\t\t\t\t\t\ttabsHtml +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\t\'<div id="\' + self._id + \'-body" class="\' + self.bodyClasses + \'">\' +\n
\t\t\t\t\t\tlayout.renderHtml(self) +\n
\t\t\t\t\t\'</div>\' +\n
\t\t\t\t\'</div>\'\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super();\n
\n
\t\t\tself.settings.activeTab = self.settings.activeTab || 0;\n
\t\t\tself.activateTab(self.settings.activeTab);\n
\n
\t\t\tthis.on(\'click\', function(e) {\n
\t\t\t\tvar targetParent = e.target.parentNode;\n
\n
\t\t\t\tif (e.target.parentNode.id == self._id + \'-head\') {\n
\t\t\t\t\tvar i = targetParent.childNodes.length;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tif (targetParent.childNodes[i] == e.target) {\n
\t\t\t\t\t\t\tself.activateTab(i);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the current controls layout rect.\n
\t\t * This will be executed by the layout managers to determine the\n
\t\t * default minWidth/minHeight etc.\n
\t\t *\n
\t\t * @method initLayoutRect\n
\t\t * @return {Object} Layout rect instance.\n
\t\t */\n
\t\tinitLayoutRect: function() {\n
\t\t\tvar self = this, rect, minW, minH;\n
\n
\t\t\tminW = DomUtils.getSize(self.getEl(\'head\')).width;\n
\t\t\tminW = minW < 0 ? 0 : minW;\n
\t\t\tminH = 0;\n
\n
\t\t\tself.items().each(function(item) {\n
\t\t\t\tminW = Math.max(minW, item.layoutRect().minW);\n
\t\t\t\tminH = Math.max(minH, item.layoutRect().minH);\n
\t\t\t});\n
\n
\t\t\tself.items().each(function(ctrl) {\n
\t\t\t\tctrl.settings.x = 0;\n
\t\t\t\tctrl.settings.y = 0;\n
\t\t\t\tctrl.settings.w = minW;\n
\t\t\t\tctrl.settings.h = minH;\n
\n
\t\t\t\tctrl.layoutRect({\n
\t\t\t\t\tx: 0,\n
\t\t\t\t\ty: 0,\n
\t\t\t\t\tw: minW,\n
\t\t\t\t\th: minH\n
\t\t\t\t});\n
\t\t\t});\n
\n
\t\t\tvar headH = DomUtils.getSize(self.getEl(\'head\')).height;\n
\n
\t\t\tself.settings.minWidth = minW;\n
\t\t\tself.settings.minHeight = minH + headH;\n
\n
\t\t\trect = self._super();\n
\t\t\trect.deltaH += headH;\n
\t\t\trect.innerH = rect.h - rect.deltaH;\n
\n
\t\t\treturn rect;\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/TextBox.js\n
\n
/**\n
 * TextBox.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Creates a new textbox.\n
 *\n
 * @-x-less TextBox.less\n
 * @class tinymce.ui.TextBox\n
 * @extends tinymce.ui.Widget\n
 */\n
define("tinymce/ui/TextBox", [\n
\t"tinymce/ui/Widget"\n
], function(Widget) {\n
\t"use strict";\n
\n
\treturn Widget.extend({\n
\t\t/**\n
\t\t * Constructs a instance with the specified settings.\n
\t\t *\n
\t\t * @constructor\n
\t\t * @param {Object} settings Name/value object with settings.\n
\t\t * @setting {Boolean} multiline True if the textbox is a multiline control.\n
\t\t * @setting {Number} maxLength Max length for the textbox.\n
\t\t * @setting {Number} size Size of the textbox in characters.\n
\t\t */\n
\t\tinit: function(settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super(settings);\n
\n
\t\t\tself.classes.add(\'textbox\');\n
\n
\t\t\tif (settings.multiline) {\n
\t\t\t\tself.classes.add(\'multiline\');\n
\t\t\t} else {\n
\t\t\t\tself.on(\'keydown\', function(e) {\n
\t\t\t\t\tvar rootControl;\n
\n
\t\t\t\t\tif (e.keyCode == 13) {\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\t// Find root control that we can do toJSON on\n
\t\t\t\t\t\tself.parents().reverse().each(function(ctrl) {\n
\t\t\t\t\t\t\tif (ctrl.toJSON) {\n
\t\t\t\t\t\t\t\trootControl = ctrl;\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\n
\t\t\t\t\t\t// Fire event on current text box with the serialized data of the whole form\n
\t\t\t\t\t\tself.fire(\'submit\', {data: rootControl.toJSON()});\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tself.on(\'keyup\', function(e) {\n
\t\t\t\t\tself.state.set(\'value\', e.target.value);\n
\t\t\t\t});\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Repaints the control after a layout operation.\n
\t\t *\n
\t\t * @method repaint\n
\t\t */\n
\t\trepaint: function() {\n
\t\t\tvar self = this, style, rect, borderBox, borderW = 0, borderH = 0, lastRepaintRect;\n
\n
\t\t\tstyle = self.getEl().style;\n
\t\t\trect = self._layoutRect;\n
\t\t\tlastRepaintRect = self._lastRepaintRect || {};\n
\n
\t\t\t// Detect old IE 7+8 add lineHeight to align caret vertically in the middle\n
\t\t\tvar doc = document;\n
\t\t\tif (!self.settings.multiline && doc.all && (!doc.documentMode || doc.documentMode <= 8)) {\n
\t\t\t\tstyle.lineHeight = (rect.h - borderH) + \'px\';\n
\t\t\t}\n
\n
\t\t\tborderBox = self.borderBox;\n
\t\t\tborderW = borderBox.left + borderBox.right + 8;\n
\t\t\tborderH = borderBox.top + borderBox.bottom + (self.settings.multiline ? 8 : 0);\n
\n
\t\t\tif (rect.x !== lastRepaintRect.x) {\n
\t\t\t\tstyle.left = rect.x + \'px\';\n
\t\t\t\tlastRepaintRect.x = rect.x;\n
\t\t\t}\n
\n
\t\t\tif (rect.y !== lastRepaintRect.y) {\n
\t\t\t\tstyle.top = rect.y + \'px\';\n
\t\t\t\tlastRepaintRect.y = rect.y;\n
\t\t\t}\n
\n
\t\t\tif (rect.w !== lastRepaintRect.w) {\n
\t\t\t\tstyle.width = (rect.w - borderW) + \'px\';\n
\t\t\t\tlastRepaintRect.w = rect.w;\n
\t\t\t}\n
\n
\t\t\tif (rect.h !== lastRepaintRect.h) {\n
\t\t\t\tstyle.height = (rect.h - borderH) + \'px\';\n
\t\t\t\tlastRepaintRect.h = rect.h;\n
\t\t\t}\n
\n
\t\t\tself._lastRepaintRect = lastRepaintRect;\n
\t\t\tself.fire(\'repaint\', {}, false);\n
\n
\t\t\treturn self;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Renders the control as a HTML string.\n
\t\t *\n
\t\t * @method renderHtml\n
\t\t * @return {String} HTML representing the control.\n
\t\t */\n
\t\trenderHtml: function() {\n
\t\t\tvar self = this, id = self._id, settings = self.settings, value = self.encode(self.state.get(\'value\'), false), extraAttrs = \'\';\n
\n
\t\t\tif ("spellcheck" in settings) {\n
\t\t\t\textraAttrs += \' spellcheck="\' + settings.spellcheck + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.maxLength) {\n
\t\t\t\textraAttrs += \' maxlength="\' + settings.maxLength + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.size) {\n
\t\t\t\textraAttrs += \' size="\' + settings.size + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.subtype) {\n
\t\t\t\textraAttrs += \' type="\' + settings.subtype + \'"\';\n
\t\t\t}\n
\n
\t\t\tif (self.disabled()) {\n
\t\t\t\textraAttrs += \' disabled="disabled"\';\n
\t\t\t}\n
\n
\t\t\tif (settings.multiline) {\n
\t\t\t\treturn (\n
\t\t\t\t\t\'<textarea id="\' + id + \'" class="\' + self.classes + \'" \' +\n
\t\t\t\t\t(settings.rows ? \' rows="\' + settings.rows + \'"\' : \'\') +\n
\t\t\t\t\t\' hidefocus="1"\' + extraAttrs + \'>\' + value +\n
\t\t\t\t\t\'</textarea>\'\n
\t\t\t\t);\n
\t\t\t}\n
\n
\t\t\treturn \'<input id="\' + id + \'" class="\' + self.classes + \'" value="\' + value + \'" hidefocus="1"\' + extraAttrs + \' />\';\n
\t\t},\n
\n
\t\tvalue: function(value) {\n
\t\t\tif (arguments.length) {\n
\t\t\t\tthis.state.set(\'value\', value);\n
\t\t\t\treturn this;\n
\t\t\t}\n
\n
\t\t\t// Make sure the real state is in sync\n
\t\t\tif (this.state.get(\'rendered\')) {\n
\t\t\t\tthis.state.set(\'value\', this.getEl().value);\n
\t\t\t}\n
\n
\t\t\treturn this.state.get(\'value\');\n
\t\t},\n
\n
\t\t/**\n
\t\t * Called after the control has been rendered.\n
\t\t *\n
\t\t * @method postRender\n
\t\t */\n
\t\tpostRender: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself._super();\n
\n
\t\t\tself.$el.on(\'change\', function(e) {\n
\t\t\t\tself.state.set(\'value\', e.target.value);\n
\t\t\t\tself.fire(\'change\', e);\n
\t\t\t});\n
\t\t},\n
\n
\t\tbindStates: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tself.state.on(\'change:value\', function(e) {\n
\t\t\t\tif (self.getEl().value != e.value) {\n
\t\t\t\t\tself.getEl().value = e.value;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.state.on(\'change:disabled\', function(e) {\n
\t\t\t\tself.getEl().disabled = e.value;\n
\t\t\t});\n
\n
\t\t\treturn self._super();\n
\t\t},\n
\n
\t\tremove: function() {\n
\t\t\tthis.$el.off();\n
\t\t\tthis._super();\n
\t\t}\n
\t});\n
});\n
\n
// Included from: js/tinymce/classes/ui/Throbber.js\n
\n
/**\n
 * Throbber.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class enables you to display a Throbber for any element.\n
 *\n
 * @-x-less Throbber.less\n
 * @class tinymce.ui.Throbber\n
 */\n
define("tinymce/ui/Throbber", [\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/ui/Control"\n
], function($, Control) {\n
\t"use strict";\n
\n
\t/**\n
\t * Constructs a new throbber.\n
\t *\n
\t * @constructor\n
\t * @param {Element} elm DOM Html element to display throbber in.\n
\t * @param {Boolean} inline Optional true/false state if the throbber should be appended to end of element for infinite scroll.\n
\t */\n
\treturn function(elm, inline) {\n
\t\tvar self = this, state, classPrefix = Control.classPrefix;\n
\n
\t\t/**\n
\t\t * Shows the throbber.\n
\t\t *\n
\t\t * @method show\n
\t\t * @param {Number} [time] Time to wait before showing.\n
\t\t * @param {function} [callback] Optional callback to execute when the throbber is shown.\n
\t\t * @return {tinymce.ui.Throbber} Current throbber instance.\n
\t\t */\n
\t\tself.show = function(time, callback) {\n
\t\t\tself.hide();\n
\n
\t\t\tstate = true;\n
\n
\t\t\twindow.setTimeout(function() {\n
\t\t\t\tif (state) {\n
\t\t\t\t\t$(elm).append(\n
\t\t\t\t\t\t\'<div class="\' + classPrefix + \'throbber\' + (inline ? \' \' + classPrefix + \'throbber-inline\' : \'\') + \'"></div>\'\n
\t\t\t\t\t);\n
\n
\t\t\t\t\tif (callback) {\n
\t\t\t\t\t\tcallback();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}, time || 0);\n
\n
\t\t\treturn self;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Hides the throbber.\n
\t\t *\n
\t\t * @method hide\n
\t\t * @return {tinymce.ui.Throbber} Current throbber instance.\n
\t\t */\n
\t\tself.hide = function() {\n
\t\t\tvar child = elm.lastChild;\n
\n
\t\t\tif (child && child.className.indexOf(\'throbber\') != -1) {\n
\t\t\t\tchild.parentNode.removeChild(child);\n
\t\t\t}\n
\n
\t\t\tstate = false;\n
\n
\t\t\treturn self;\n
\t\t};\n
\t};\n
});\n
\n
expose(["tinymce/dom/EventUtils","tinymce/dom/Sizzle","tinymce/Env","tinymce/util/Tools","tinymce/dom/DomQuery","tinymce/html/Styles","tinymce/dom/TreeWalker","tinymce/dom/Range","tinymce/html/Entities","tinymce/dom/DOMUtils","tinymce/dom/ScriptLoader","tinymce/AddOnManager","tinymce/dom/RangeUtils","tinymce/html/Node","tinymce/html/Schema","tinymce/html/SaxParser","tinymce/html/DomParser","tinymce/html/Writer","tinymce/html/Serializer","tinymce/dom/Serializer","tinymce/dom/TridentSelection","tinymce/util/VK","tinymce/dom/ControlSelection","tinymce/dom/BookmarkManager","tinymce/dom/Selection","tinymce/dom/ElementUtils","tinymce/Formatter","tinymce/UndoManager","tinymce/EnterKey","tinymce/ForceBlocks","tinymce/EditorCommands","tinymce/util/URI","tinymce/util/Class","tinymce/util/EventDispatcher","tinymce/data/Binding","tinymce/util/Observable","tinymce/data/ObservableObject","tinymce/ui/Selector","tinymce/ui/Collection","tinymce/ui/DomUtils","tinymce/ui/BoxUtils","tinymce/ui/ClassList","tinymce/ui/ReflowQueue","tinymce/ui/Control","tinymce/ui/Factory","tinymce/ui/KeyboardNavigation","tinymce/ui/Container","tinymce/ui/DragHelper","tinymce/ui/Scrollable","tinymce/ui/Panel","tinymce/ui/Movable","tinymce/ui/Resizable","tinymce/ui/FloatPanel","tinymce/ui/Window","tinymce/ui/MessageBox","tinymce/WindowManager","tinymce/util/Quirks","tinymce/EditorObservable","tinymce/Shortcuts","tinymce/util/Promise","tinymce/file/Conversions","tinymce/Editor","tinymce/util/I18n","tinymce/FocusManager","tinymce/EditorManager","tinymce/LegacyInput","tinymce/util/XHR","tinymce/util/JSON","tinymce/util/JSONRequest","tinymce/util/JSONP","tinymce/util/LocalStorage","tinymce/Compat","tinymce/ui/Layout","tinymce/ui/AbsoluteLayout","tinymce/ui/Tooltip","tinymce/ui/Widget","tinymce/ui/Button","tinymce/ui/ButtonGroup","tinymce/ui/Checkbox","tinymce/ui/ComboBox","tinymce/ui/ColorBox","tinymce/ui/PanelButton","tinymce/ui/ColorButton","tinymce/util/Color","tinymce/ui/ColorPicker","tinymce/ui/Path","tinymce/ui/ElementPath","tinymce/ui/FormItem","tinymce/ui/Form","tinymce/ui/FieldSet","tinymce/ui/FilePicker","tinymce/ui/FitLayout","tinymce/ui/FlexLayout","tinymce/ui/FlowLayout","tinymce/ui/FormatControls","tinymce/ui/GridLayout","tinymce/ui/Iframe","tinymce/ui/Label","tinymce/ui/Toolbar","tinymce/ui/MenuBar","tinymce/ui/MenuButton","tinymce/ui/MenuItem","tinymce/ui/Menu","tinymce/ui/ListBox","tinymce/ui/Radio","tinymce/ui/Rect","tinymce/ui/ResizeHandle","tinymce/ui/Slider","tinymce/ui/Spacer","tinymce/ui/SplitButton","tinymce/ui/StackLayout","tinymce/ui/TabPanel","tinymce/ui/TextBox","tinymce/ui/Throbber"]);\n
})(this);

]]></string> </value>
        </item>
        <item>
            <key> <string>next</string> </key>
            <value>
              <none/>
            </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
