<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268383.46</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Editor.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Editor.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/*jshint scripturl:true */\n
\n
/**\n
 * Include the base event class documentation.\n
 *\n
 * @include ../../../tools/docs/tinymce.Event.js\n
 */\n
\n
/**\n
 * This class contains the core logic for a TinyMCE editor.\n
 *\n
 * @class tinymce.Editor\n
 * @mixes tinymce.util.Observable\n
 * @example\n
 * // Add a class to all paragraphs in the editor.\n
 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'someclass\');\n
 *\n
 * // Gets the current editors selection as text\n
 * tinymce.activeEditor.selection.getContent({format: \'text\'});\n
 *\n
 * // Creates a new editor instance\n
 * var ed = new tinymce.Editor(\'textareaid\', {\n
 *     some_setting: 1\n
 * }, tinymce.EditorManager);\n
 *\n
 * // Select each item the user clicks on\n
 * ed.on(\'click\', function(e) {\n
 *     ed.selection.select(e.target);\n
 * });\n
 *\n
 * ed.render();\n
 */\n
define("tinymce/Editor", [\n
\t"tinymce/dom/DOMUtils",\n
\t"tinymce/dom/DomQuery",\n
\t"tinymce/AddOnManager",\n
\t"tinymce/NodeChange",\n
\t"tinymce/html/Node",\n
\t"tinymce/dom/Serializer",\n
\t"tinymce/html/Serializer",\n
\t"tinymce/dom/Selection",\n
\t"tinymce/Formatter",\n
\t"tinymce/UndoManager",\n
\t"tinymce/EnterKey",\n
\t"tinymce/ForceBlocks",\n
\t"tinymce/EditorCommands",\n
\t"tinymce/util/URI",\n
\t"tinymce/dom/ScriptLoader",\n
\t"tinymce/dom/EventUtils",\n
\t"tinymce/WindowManager",\n
\t"tinymce/html/Schema",\n
\t"tinymce/html/DomParser",\n
\t"tinymce/util/Quirks",\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/EditorObservable",\n
\t"tinymce/Shortcuts",\n
\t"tinymce/EditorUpload"\n
], function(\n
\tDOMUtils, DomQuery, AddOnManager, NodeChange, Node, DomSerializer, Serializer,\n
\tSelection, Formatter, UndoManager, EnterKey, ForceBlocks, EditorCommands,\n
\tURI, ScriptLoader, EventUtils, WindowManager,\n
\tSchema, DomParser, Quirks, Env, Tools, EditorObservable, Shortcuts, EditorUpload\n
) {\n
\t// Shorten these names\n
\tvar DOM = DOMUtils.DOM, ThemeManager = AddOnManager.ThemeManager, PluginManager = AddOnManager.PluginManager;\n
\tvar extend = Tools.extend, each = Tools.each, explode = Tools.explode;\n
\tvar inArray = Tools.inArray, trim = Tools.trim, resolve = Tools.resolve;\n
\tvar Event = EventUtils.Event;\n
\tvar isGecko = Env.gecko, ie = Env.ie;\n
\n
\t/**\n
\t * Include documentation for all the events.\n
\t *\n
\t * @include ../../../tools/docs/tinymce.Editor.js\n
\t */\n
\n
\t/**\n
\t * Constructs a editor instance by id.\n
\t *\n
\t * @constructor\n
\t * @method Editor\n
\t * @param {String} id Unique id for the editor.\n
\t * @param {Object} settings Settings for the editor.\n
\t * @param {tinymce.EditorManager} editorManager EditorManager instance.\n
\t */\n
\tfunction Editor(id, settings, editorManager) {\n
\t\tvar self = this, documentBaseUrl, baseUri;\n
\n
\t\tdocumentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;\n
\t\tbaseUri = editorManager.baseURI;\n
\n
\t\t/**\n
\t\t * Name/value collection with editor settings.\n
\t\t *\n
\t\t * @property settings\n
\t\t * @type Object\n
\t\t * @example\n
\t\t * // Get the value of the theme setting\n
\t\t * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");\n
\t\t */\n
\t\tself.settings = settings = extend({\n
\t\t\tid: id,\n
\t\t\ttheme: \'modern\',\n
\t\t\tdelta_width: 0,\n
\t\t\tdelta_height: 0,\n
\t\t\tpopup_css: \'\',\n
\t\t\tplugins: \'\',\n
\t\t\tdocument_base_url: documentBaseUrl,\n
\t\t\tadd_form_submit_trigger: true,\n
\t\t\tsubmit_patch: true,\n
\t\t\tadd_unload_trigger: true,\n
\t\t\tconvert_urls: true,\n
\t\t\trelative_urls: true,\n
\t\t\tremove_script_host: true,\n
\t\t\tobject_resizing: true,\n
\t\t\tdoctype: \'<!DOCTYPE html>\',\n
\t\t\tvisual: true,\n
\t\t\tfont_size_style_values: \'xx-small,x-small,small,medium,large,x-large,xx-large\',\n
\n
\t\t\t// See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size\n
\t\t\tfont_size_legacy_values: \'xx-small,small,medium,large,x-large,xx-large,300%\',\n
\t\t\tforced_root_block: \'p\',\n
\t\t\thidden_input: true,\n
\t\t\tpadd_empty_editor: true,\n
\t\t\trender_ui: true,\n
\t\t\tindentation: \'30px\',\n
\t\t\tinline_styles: true,\n
\t\t\tconvert_fonts_to_spans: true,\n
\t\t\tindent: \'simple\',\n
\t\t\tindent_before: \'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,\' +\n
\t\t\t\t\'tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist\',\n
\t\t\tindent_after: \'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,\' +\n
\t\t\t\t\'tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist\',\n
\t\t\tvalidate: true,\n
\t\t\tentity_encoding: \'named\',\n
\t\t\turl_converter: self.convertURL,\n
\t\t\turl_converter_scope: self,\n
\t\t\tie7_compat: true\n
\t\t}, settings);\n
\n
\t\tAddOnManager.language = settings.language || \'en\';\n
\t\tAddOnManager.languageLoad = settings.language_load;\n
\n
\t\tAddOnManager.baseURL = editorManager.baseURL;\n
\n
\t\t/**\n
\t\t * Editor instance id, normally the same as the div/textarea that was replaced.\n
\t\t *\n
\t\t * @property id\n
\t\t * @type String\n
\t\t */\n
\t\tself.id = settings.id = id;\n
\n
\t\t/**\n
\t\t * State to force the editor to return false on a isDirty call.\n
\t\t *\n
\t\t * @property isNotDirty\n
\t\t * @type Boolean\n
\t\t * @example\n
\t\t * function ajaxSave() {\n
\t\t *     var ed = tinymce.get(\'elm1\');\n
\t\t *\n
\t\t *     // Save contents using some XHR call\n
\t\t *     alert(ed.getContent());\n
\t\t *\n
\t\t *     ed.isNotDirty = true; // Force not dirty state\n
\t\t * }\n
\t\t */\n
\t\tself.isNotDirty = true;\n
\n
\t\t/**\n
\t\t * Name/Value object containting plugin instances.\n
\t\t *\n
\t\t * @property plugins\n
\t\t * @type Object\n
\t\t * @example\n
\t\t * // Execute a method inside a plugin directly\n
\t\t * tinymce.activeEditor.plugins.someplugin.someMethod();\n
\t\t */\n
\t\tself.plugins = {};\n
\n
\t\t/**\n
\t\t * URI object to document configured for the TinyMCE instance.\n
\t\t *\n
\t\t * @property documentBaseURI\n
\t\t * @type tinymce.util.URI\n
\t\t * @example\n
\t\t * // Get relative URL from the location of document_base_url\n
\t\t * tinymce.activeEditor.documentBaseURI.toRelative(\'/somedir/somefile.htm\');\n
\t\t *\n
\t\t * // Get absolute URL from the location of document_base_url\n
\t\t * tinymce.activeEditor.documentBaseURI.toAbsolute(\'somefile.htm\');\n
\t\t */\n
\t\tself.documentBaseURI = new URI(settings.document_base_url || documentBaseUrl, {\n
\t\t\tbase_uri: baseUri\n
\t\t});\n
\n
\t\t/**\n
\t\t * URI object to current document that holds the TinyMCE editor instance.\n
\t\t *\n
\t\t * @property baseURI\n
\t\t * @type tinymce.util.URI\n
\t\t * @example\n
\t\t * // Get relative URL from the location of the API\n
\t\t * tinymce.activeEditor.baseURI.toRelative(\'/somedir/somefile.htm\');\n
\t\t *\n
\t\t * // Get absolute URL from the location of the API\n
\t\t * tinymce.activeEditor.baseURI.toAbsolute(\'somefile.htm\');\n
\t\t */\n
\t\tself.baseURI = baseUri;\n
\n
\t\t/**\n
\t\t * Array with CSS files to load into the iframe.\n
\t\t *\n
\t\t * @property contentCSS\n
\t\t * @type Array\n
\t\t */\n
\t\tself.contentCSS = [];\n
\n
\t\t/**\n
\t\t * Array of CSS styles to add to head of document when the editor loads.\n
\t\t *\n
\t\t * @property contentStyles\n
\t\t * @type Array\n
\t\t */\n
\t\tself.contentStyles = [];\n
\n
\t\t// Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic\n
\t\tself.shortcuts = new Shortcuts(self);\n
\t\tself.loadedCSS = {};\n
\t\tself.editorCommands = new EditorCommands(self);\n
\n
\t\tif (settings.target) {\n
\t\t\tself.targetElm = settings.target;\n
\t\t}\n
\n
\t\tself.suffix = editorManager.suffix;\n
\t\tself.editorManager = editorManager;\n
\t\tself.inline = settings.inline;\n
\n
\t\tif (settings.cache_suffix) {\n
\t\t\tEnv.cacheSuffix = settings.cache_suffix.replace(/^[\\?\\&]+/, \'\');\n
\t\t}\n
\n
\t\tif (settings.override_viewport === false) {\n
\t\t\tEnv.overrideViewPort = false;\n
\t\t}\n
\n
\t\t// Call setup\n
\t\teditorManager.fire(\'SetupEditor\', self);\n
\t\tself.execCallback(\'setup\', self);\n
\n
\t\t/**\n
\t\t * Dom query instance with default scope to the editor document and default element is the body of the editor.\n
\t\t *\n
\t\t * @property $\n
\t\t * @type tinymce.dom.DomQuery\n
\t\t * @example\n
\t\t * tinymce.activeEditor.$(\'p\').css(\'color\', \'red\');\n
\t\t * tinymce.activeEditor.$().append(\'<p>new</p>\');\n
\t\t */\n
\t\tself.$ = DomQuery.overrideDefaults(function() {\n
\t\t\treturn {\n
\t\t\t\tcontext: self.inline ? self.getBody() : self.getDoc(),\n
\t\t\t\telement: self.getBody()\n
\t\t\t};\n
\t\t});\n
\t}\n
\n
\tEditor.prototype = {\n
\t\t/**\n
\t\t * Renderes the editor/adds it to the page.\n
\t\t *\n
\t\t * @method render\n
\t\t */\n
\t\trender: function() {\n
\t\t\tvar self = this, settings = self.settings, id = self.id, suffix = self.suffix;\n
\n
\t\t\tfunction readyHandler() {\n
\t\t\t\tDOM.unbind(window, \'ready\', readyHandler);\n
\t\t\t\tself.render();\n
\t\t\t}\n
\n
\t\t\t// Page is not loaded yet, wait for it\n
\t\t\tif (!Event.domLoaded) {\n
\t\t\t\tDOM.bind(window, \'ready\', readyHandler);\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Element not found, then skip initialization\n
\t\t\tif (!self.getElement()) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// No editable support old iOS versions etc\n
\t\t\tif (!Env.contentEditable) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Hide target element early to prevent content flashing\n
\t\t\tif (!settings.inline) {\n
\t\t\t\tself.orgVisibility = self.getElement().style.visibility;\n
\t\t\t\tself.getElement().style.visibility = \'hidden\';\n
\t\t\t} else {\n
\t\t\t\tself.inline = true;\n
\t\t\t}\n
\n
\t\t\tvar form = self.getElement().form || DOM.getParent(id, \'form\');\n
\t\t\tif (form) {\n
\t\t\t\tself.formElement = form;\n
\n
\t\t\t\t// Add hidden input for non input elements inside form elements\n
\t\t\t\tif (settings.hidden_input && !/TEXTAREA|INPUT/i.test(self.getElement().nodeName)) {\n
\t\t\t\t\tDOM.insertAfter(DOM.create(\'input\', {type: \'hidden\', name: id}), id);\n
\t\t\t\t\tself.hasHiddenInput = true;\n
\t\t\t\t}\n
\n
\t\t\t\t// Pass submit/reset from form to editor instance\n
\t\t\t\tself.formEventDelegate = function(e) {\n
\t\t\t\t\tself.fire(e.type, e);\n
\t\t\t\t};\n
\n
\t\t\t\tDOM.bind(form, \'submit reset\', self.formEventDelegate);\n
\n
\t\t\t\t// Reset contents in editor when the form is reset\n
\t\t\t\tself.on(\'reset\', function() {\n
\t\t\t\t\tself.setContent(self.startContent, {format: \'raw\'});\n
\t\t\t\t});\n
\n
\t\t\t\t// Check page uses id="submit" or name="submit" for it\'s submit button\n
\t\t\t\tif (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n
\t\t\t\t\tform._mceOldSubmit = form.submit;\n
\t\t\t\t\tform.submit = function() {\n
\t\t\t\t\t\tself.editorManager.triggerSave();\n
\t\t\t\t\t\tself.isNotDirty = true;\n
\n
\t\t\t\t\t\treturn form._mceOldSubmit(form);\n
\t\t\t\t\t};\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Window manager reference, use this to open new windows and dialogs.\n
\t\t\t *\n
\t\t\t * @property windowManager\n
\t\t\t * @type tinymce.WindowManager\n
\t\t\t * @example\n
\t\t\t * // Shows an alert message\n
\t\t\t * tinymce.activeEditor.windowManager.alert(\'Hello world!\');\n
\t\t\t *\n
\t\t\t * // Opens a new dialog with the file.htm file and the size 320x240\n
\t\t\t * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.\n
\t\t\t * tinymce.activeEditor.windowManager.open({\n
\t\t\t *    url: \'file.htm\',\n
\t\t\t *    width: 320,\n
\t\t\t *    height: 240\n
\t\t\t * }, {\n
\t\t\t *    custom_param: 1\n
\t\t\t * });\n
\t\t\t */\n
\t\t\tself.windowManager = new WindowManager(self);\n
\n
\t\t\tif (settings.encoding == \'xml\') {\n
\t\t\t\tself.on(\'GetContent\', function(e) {\n
\t\t\t\t\tif (e.save) {\n
\t\t\t\t\t\te.content = DOM.encode(e.content);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (settings.add_form_submit_trigger) {\n
\t\t\t\tself.on(\'submit\', function() {\n
\t\t\t\t\tif (self.initialized) {\n
\t\t\t\t\t\tself.save();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tif (settings.add_unload_trigger) {\n
\t\t\t\tself._beforeUnload = function() {\n
\t\t\t\t\tif (self.initialized && !self.destroyed && !self.isHidden()) {\n
\t\t\t\t\t\tself.save({format: \'raw\', no_events: true, set_dirty: false});\n
\t\t\t\t\t}\n
\t\t\t\t};\n
\n
\t\t\t\tself.editorManager.on(\'BeforeUnload\', self._beforeUnload);\n
\t\t\t}\n
\n
\t\t\t// Load scripts\n
\t\t\tfunction loadScripts() {\n
\t\t\t\tvar scriptLoader = ScriptLoader.ScriptLoader;\n
\n
\t\t\t\tif (settings.language && settings.language != \'en\' && !settings.language_url) {\n
\t\t\t\t\tsettings.language_url = self.editorManager.baseURL + \'/langs/\' + settings.language + \'.js\';\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.language_url) {\n
\t\t\t\t\tscriptLoader.add(settings.language_url);\n
\t\t\t\t}\n
\n
\t\t\t\tif (settings.theme && typeof settings.theme != "function" &&\n
\t\t\t\t\tsettings.theme.charAt(0) != \'-\' && !ThemeManager.urls[settings.theme]) {\n
\t\t\t\t\tvar themeUrl = settings.theme_url;\n
\n
\t\t\t\t\tif (themeUrl) {\n
\t\t\t\t\t\tthemeUrl = self.documentBaseURI.toAbsolute(themeUrl);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tthemeUrl = \'themes/\' + settings.theme + \'/theme\' + suffix + \'.js\';\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tThemeManager.load(settings.theme, themeUrl);\n
\t\t\t\t}\n
\n
\t\t\t\tif (Tools.isArray(settings.plugins)) {\n
\t\t\t\t\tsettings.plugins = settings.plugins.join(\' \');\n
\t\t\t\t}\n
\n
\t\t\t\teach(settings.external_plugins, function(url, name) {\n
\t\t\t\t\tPluginManager.load(name, url);\n
\t\t\t\t\tsettings.plugins += \' \' + name;\n
\t\t\t\t});\n
\n
\t\t\t\teach(settings.plugins.split(/[ ,]/), function(plugin) {\n
\t\t\t\t\tplugin = trim(plugin);\n
\n
\t\t\t\t\tif (plugin && !PluginManager.urls[plugin]) {\n
\t\t\t\t\t\tif (plugin.charAt(0) == \'-\') {\n
\t\t\t\t\t\t\tplugin = plugin.substr(1, plugin.length);\n
\n
\t\t\t\t\t\t\tvar dependencies = PluginManager.dependencies(plugin);\n
\n
\t\t\t\t\t\t\teach(dependencies, function(dep) {\n
\t\t\t\t\t\t\t\tvar defaultSettings = {\n
\t\t\t\t\t\t\t\t\tprefix: \'plugins/\',\n
\t\t\t\t\t\t\t\t\tresource: dep,\n
\t\t\t\t\t\t\t\t\tsuffix: \'/plugin\' + suffix + \'.js\'\n
\t\t\t\t\t\t\t\t};\n
\n
\t\t\t\t\t\t\t\tdep = PluginManager.createUrl(defaultSettings, dep);\n
\t\t\t\t\t\t\t\tPluginManager.load(dep.resource, dep);\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tPluginManager.load(plugin, {\n
\t\t\t\t\t\t\t\tprefix: \'plugins/\',\n
\t\t\t\t\t\t\t\tresource: plugin,\n
\t\t\t\t\t\t\t\tsuffix: \'/plugin\' + suffix + \'.js\'\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\tscriptLoader.loadQueue(function() {\n
\t\t\t\t\tif (!self.removed) {\n
\t\t\t\t\t\tself.init();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tloadScripts();\n
\t\t},\n
\n
\t\t/**\n
\t\t * Initializes the editor this will be called automatically when\n
\t\t * all plugins/themes and language packs are loaded by the rendered method.\n
\t\t * This method will setup the iframe and create the theme and plugin instances.\n
\t\t *\n
\t\t * @method init\n
\t\t */\n
\t\tinit: function() {\n
\t\t\tvar self = this, settings = self.settings, elm = self.getElement();\n
\t\t\tvar w, h, minHeight, n, o, Theme, url, bodyId, bodyClass, re, i, initializedPlugins = [];\n
\n
\t\t\tthis.editorManager.i18n.setCode(settings.language);\n
\t\t\tself.rtl = settings.rtl_ui || this.editorManager.i18n.rtl;\n
\t\t\tself.editorManager.add(self);\n
\n
\t\t\tsettings.aria_label = settings.aria_label || DOM.getAttrib(elm, \'aria-label\', self.getLang(\'aria.rich_text_area\'));\n
\n
\t\t\t/**\n
\t\t\t * Reference to the theme instance that was used to generate the UI.\n
\t\t\t *\n
\t\t\t * @property theme\n
\t\t\t * @type tinymce.Theme\n
\t\t\t * @example\n
\t\t\t * // Executes a method on the theme directly\n
\t\t\t * tinymce.activeEditor.theme.someMethod();\n
\t\t\t */\n
\t\t\tif (settings.theme) {\n
\t\t\t\tif (typeof settings.theme != "function") {\n
\t\t\t\t\tsettings.theme = settings.theme.replace(/-/, \'\');\n
\t\t\t\t\tTheme = ThemeManager.get(settings.theme);\n
\t\t\t\t\tself.theme = new Theme(self, ThemeManager.urls[settings.theme]);\n
\n
\t\t\t\t\tif (self.theme.init) {\n
\t\t\t\t\t\tself.theme.init(self, ThemeManager.urls[settings.theme] || self.documentBaseUrl.replace(/\\/$/, \'\'), self.$);\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tself.theme = settings.theme;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction initPlugin(plugin) {\n
\t\t\t\tvar Plugin = PluginManager.get(plugin), pluginUrl, pluginInstance;\n
\n
\t\t\t\tpluginUrl = PluginManager.urls[plugin] || self.documentBaseUrl.replace(/\\/$/, \'\');\n
\t\t\t\tplugin = trim(plugin);\n
\t\t\t\tif (Plugin && inArray(initializedPlugins, plugin) === -1) {\n
\t\t\t\t\teach(PluginManager.dependencies(plugin), function(dep) {\n
\t\t\t\t\t\tinitPlugin(dep);\n
\t\t\t\t\t});\n
\n
\t\t\t\t\tpluginInstance = new Plugin(self, pluginUrl, self.$);\n
\n
\t\t\t\t\tself.plugins[plugin] = pluginInstance;\n
\n
\t\t\t\t\tif (pluginInstance.init) {\n
\t\t\t\t\t\tpluginInstance.init(self, pluginUrl);\n
\t\t\t\t\t\tinitializedPlugins.push(plugin);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Create all plugins\n
\t\t\teach(settings.plugins.replace(/\\-/g, \'\').split(/[ ,]/), initPlugin);\n
\n
\t\t\t// Measure box\n
\t\t\tif (settings.render_ui && self.theme) {\n
\t\t\t\tself.orgDisplay = elm.style.display;\n
\n
\t\t\t\tif (typeof settings.theme != "function") {\n
\t\t\t\t\tw = settings.width || elm.style.width || elm.offsetWidth;\n
\t\t\t\t\th = settings.height || elm.style.height || elm.offsetHeight;\n
\t\t\t\t\tminHeight = settings.min_height || 100;\n
\t\t\t\t\tre = /^[0-9\\.]+(|px)$/i;\n
\n
\t\t\t\t\tif (re.test(\'\' + w)) {\n
\t\t\t\t\t\tw = Math.max(parseInt(w, 10), 100);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (re.test(\'\' + h)) {\n
\t\t\t\t\t\th = Math.max(parseInt(h, 10), minHeight);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Render UI\n
\t\t\t\t\to = self.theme.renderUI({\n
\t\t\t\t\t\ttargetNode: elm,\n
\t\t\t\t\t\twidth: w,\n
\t\t\t\t\t\theight: h,\n
\t\t\t\t\t\tdeltaWidth: settings.delta_width,\n
\t\t\t\t\t\tdeltaHeight: settings.delta_height\n
\t\t\t\t\t});\n
\n
\t\t\t\t\t// Resize editor\n
\t\t\t\t\tif (!settings.content_editable) {\n
\t\t\t\t\t\th = (o.iframeHeight || h) + (typeof h == \'number\' ? (o.deltaHeight || 0) : \'\');\n
\t\t\t\t\t\tif (h < minHeight) {\n
\t\t\t\t\t\t\th = minHeight;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\to = settings.theme(self, elm);\n
\n
\t\t\t\t\t// Convert element type to id:s\n
\t\t\t\t\tif (o.editorContainer.nodeType) {\n
\t\t\t\t\t\to.editorContainer = o.editorContainer.id = o.editorContainer.id || self.id + "_parent";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Convert element type to id:s\n
\t\t\t\t\tif (o.iframeContainer.nodeType) {\n
\t\t\t\t\t\to.iframeContainer = o.iframeContainer.id = o.iframeContainer.id || self.id + "_iframecontainer";\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Use specified iframe height or the targets offsetHeight\n
\t\t\t\t\th = o.iframeHeight || elm.offsetHeight;\n
\t\t\t\t}\n
\n
\t\t\t\tself.editorContainer = o.editorContainer;\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\tif (settings.content_css) {\n
\t\t\t\teach(explode(settings.content_css), function(u) {\n
\t\t\t\t\tself.contentCSS.push(self.documentBaseURI.toAbsolute(u));\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\tif (settings.content_style) {\n
\t\t\t\tself.contentStyles.push(settings.content_style);\n
\t\t\t}\n
\n
\t\t\t// Content editable mode ends here\n
\t\t\tif (settings.content_editable) {\n
\t\t\t\telm = n = o = null; // Fix IE leak\n
\t\t\t\treturn self.initContentBody();\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML = settings.doctype + \'<html><head>\';\n
\n
\t\t\t// We only need to override paths if we have to\n
\t\t\t// IE has a bug where it remove site absolute urls to relative ones if this is specified\n
\t\t\tif (settings.document_base_url != self.documentBaseUrl) {\n
\t\t\t\tself.iframeHTML += \'<base href="\' + self.documentBaseURI.getURI() + \'" />\';\n
\t\t\t}\n
\n
\t\t\t// IE8 doesn\'t support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.\n
\t\t\tif (!Env.caretAfter && settings.ie7_compat) {\n
\t\t\t\tself.iframeHTML += \'<meta http-equiv="X-UA-Compatible" content="IE=7" />\';\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML += \'<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\';\n
\n
\t\t\t// Load the CSS by injecting them into the HTML this will reduce "flicker"\n
\t\t\tfor (i = 0; i < self.contentCSS.length; i++) {\n
\t\t\t\tvar cssUrl = self.contentCSS[i];\n
\t\t\t\tself.iframeHTML += (\n
\t\t\t\t\t\'<link type="text/css" \' +\n
\t\t\t\t\t\t\'rel="stylesheet" \' +\n
\t\t\t\t\t\t\'href="\' + Tools._addCacheSuffix(cssUrl) + \'" />\'\n
\t\t\t\t);\n
\t\t\t\tself.loadedCSS[cssUrl] = true;\n
\t\t\t}\n
\n
\t\t\tbodyId = settings.body_id || \'tinymce\';\n
\t\t\tif (bodyId.indexOf(\'=\') != -1) {\n
\t\t\t\tbodyId = self.getParam(\'body_id\', \'\', \'hash\');\n
\t\t\t\tbodyId = bodyId[self.id] || bodyId;\n
\t\t\t}\n
\n
\t\t\tbodyClass = settings.body_class || \'\';\n
\t\t\tif (bodyClass.indexOf(\'=\') != -1) {\n
\t\t\t\tbodyClass = self.getParam(\'body_class\', \'\', \'hash\');\n
\t\t\t\tbodyClass = bodyClass[self.id] || \'\';\n
\t\t\t}\n
\n
\t\t\tif (settings.content_security_policy) {\n
\t\t\t\tself.iframeHTML += \'<meta http-equiv="Content-Security-Policy" content="\' + settings.content_security_policy + \'" />\';\n
\t\t\t}\n
\n
\t\t\tself.iframeHTML += \'</head><body id="\' + bodyId +\n
\t\t\t\t\'" class="mce-content-body \' + bodyClass +\n
\t\t\t\t\'" data-id="\' + self.id + \'"><br></body></html>\';\n
\n
\t\t\t/*eslint no-script-url:0 */\n
\t\t\tvar domainRelaxUrl = \'javascript:(function(){\' +\n
\t\t\t\t\'document.open();document.domain="\' + document.domain + \'";\' +\n
\t\t\t\t\'var ed = window.parent.tinymce.get("\' + self.id + \'");document.write(ed.iframeHTML);\' +\n
\t\t\t\t\'document.close();ed.initContentBody(true);})()\';\n
\n
\t\t\t// Domain relaxing is required since the user has messed around with document.domain\n
\t\t\tif (document.domain != location.hostname) {\n
\t\t\t\turl = domainRelaxUrl;\n
\t\t\t}\n
\n
\t\t\t// Create iframe\n
\t\t\t// TODO: ACC add the appropriate description on this.\n
\t\t\tvar ifr = DOM.create(\'iframe\', {\n
\t\t\t\tid: self.id + "_ifr",\n
\t\t\t\t//src: url || \'javascript:""\', // Workaround for HTTPS warning in IE6/7\n
\t\t\t\tframeBorder: \'0\',\n
\t\t\t\tallowTransparency: "true",\n
\t\t\t\ttitle: self.editorManager.translate(\n
\t\t\t\t\t\t"Rich Text Area. Press ALT-F9 for menu. " +\n
\t\t\t\t\t\t"Press ALT-F10 for toolbar. Press ALT-0 for help"\n
\t\t\t\t),\n
\t\t\t\tstyle: {\n
\t\t\t\t\twidth: \'100%\',\n
\t\t\t\t\theight: h,\n
\t\t\t\t\tdisplay: \'block\' // Important for Gecko to render the iframe correctly\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tifr.onload = function() {\n
\t\t\t\tifr.onload = null;\n
\t\t\t\tself.fire("load");\n
\t\t\t};\n
\n
\t\t\tDOM.setAttrib(ifr, "src", url || \'javascript:""\');\n
\n
\t\t\tself.contentAreaContainer = o.iframeContainer;\n
\t\t\tself.iframeElement = ifr;\n
\n
\t\t\tn = DOM.add(o.iframeContainer, ifr);\n
\n
\t\t\t// Try accessing the document this will fail on IE when document.domain is set to the same as location.hostname\n
\t\t\t// Then we have to force domain relaxing using the domainRelaxUrl approach very ugly!!\n
\t\t\tif (ie) {\n
\t\t\t\ttry {\n
\t\t\t\t\tself.getDoc();\n
\t\t\t\t} catch (e) {\n
\t\t\t\t\tn.src = url = domainRelaxUrl;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tif (o.editorContainer) {\n
\t\t\t\tDOM.get(o.editorContainer).style.display = self.orgDisplay;\n
\t\t\t\tself.hidden = DOM.isHidden(o.editorContainer);\n
\t\t\t}\n
\n
\t\t\tself.getElement().style.display = \'none\';\n
\t\t\tDOM.setAttrib(self.id, \'aria-hidden\', true);\n
\n
\t\t\tif (!url) {\n
\t\t\t\tself.initContentBody();\n
\t\t\t}\n
\n
\t\t\telm = n = o = null; // Cleanup\n
\t\t},\n
\n
\t\t/**\n
\t\t * This method get called by the init method ones the iframe is loaded.\n
\t\t * It will fill the iframe with contents, setups DOM and selection objects for the iframe.\n
\t\t *\n
\t\t * @method initContentBody\n
\t\t * @private\n
\t\t */\n
\t\tinitContentBody: function(skipWrite) {\n
\t\t\tvar self = this, settings = self.settings, targetElm = self.getElement(), doc = self.getDoc(), body, contentCssText;\n
\n
\t\t\t// Restore visibility on target element\n
\t\t\tif (!settings.inline) {\n
\t\t\t\tself.getElement().style.visibility = self.orgVisibility;\n
\t\t\t}\n
\n
\t\t\t// Setup iframe body\n
\t\t\tif (!skipWrite && !settings.content_editable) {\n
\t\t\t\tdoc.open();\n
\t\t\t\tdoc.write(self.iframeHTML);\n
\t\t\t\tdoc.close();\n
\t\t\t}\n
\n
\t\t\tif (settings.content_editable) {\n
\t\t\t\tself.on(\'remove\', function() {\n
\t\t\t\t\tvar bodyEl = this.getBody();\n
\n
\t\t\t\t\tDOM.removeClass(bodyEl, \'mce-content-body\');\n
\t\t\t\t\tDOM.removeClass(bodyEl, \'mce-edit-focus\');\n
\t\t\t\t\tDOM.setAttrib(bodyEl, \'contentEditable\', null);\n
\t\t\t\t});\n
\n
\t\t\t\tDOM.addClass(targetElm, \'mce-content-body\');\n
\t\t\t\tself.contentDocument = doc = settings.content_document || document;\n
\t\t\t\tself.contentWindow = settings.content_window || window;\n
\t\t\t\tself.bodyElement = targetElm;\n
\n
\t\t\t\t// Prevent leak in IE\n
\t\t\t\tsettings.content_document = settings.content_window = null;\n
\n
\t\t\t\t// TODO: Fix this\n
\t\t\t\tsettings.root_name = targetElm.nodeName.toLowerCase();\n
\t\t\t}\n
\n
\t\t\t// It will not steal focus while setting contentEditable\n
\t\t\tbody = self.getBody();\n
\t\t\tbody.disabled = true;\n
\n
\t\t\tif (!settings.readonly) {\n
\t\t\t\tif (self.inline && DOM.getStyle(body, \'position\', true) == \'static\') {\n
\t\t\t\t\tbody.style.position = \'relative\';\n
\t\t\t\t}\n
\n
\t\t\t\tbody.contentEditable = self.getParam(\'content_editable_state\', true);\n
\t\t\t}\n
\n
\t\t\tbody.disabled = false;\n
\n
\t\t\tself.editorUpload = new EditorUpload(self);\n
\n
\t\t\t/**\n
\t\t\t * Schema instance, enables you to validate elements and it\'s children.\n
\t\t\t *\n
\t\t\t * @property schema\n
\t\t\t * @type tinymce.html.Schema\n
\t\t\t */\n
\t\t\tself.schema = new Schema(settings);\n
\n
\t\t\t/**\n
\t\t\t * DOM instance for the editor.\n
\t\t\t *\n
\t\t\t * @property dom\n
\t\t\t * @type tinymce.dom.DOMUtils\n
\t\t\t * @example\n
\t\t\t * // Adds a class to all paragraphs within the editor\n
\t\t\t * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select(\'p\'), \'someclass\');\n
\t\t\t */\n
\t\t\tself.dom = new DOMUtils(doc, {\n
\t\t\t\tkeep_values: true,\n
\t\t\t\turl_converter: self.convertURL,\n
\t\t\t\turl_converter_scope: self,\n
\t\t\t\thex_colors: settings.force_hex_style_colors,\n
\t\t\t\tclass_filter: settings.class_filter,\n
\t\t\t\tupdate_styles: true,\n
\t\t\t\troot_element: self.inline ? self.getBody() : null,\n
\t\t\t\tcollect: settings.content_editable,\n
\t\t\t\tschema: self.schema,\n
\t\t\t\tonSetAttrib: function(e) {\n
\t\t\t\t\tself.fire(\'SetAttrib\', e);\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t/**\n
\t\t\t * HTML parser will be used when contents is inserted into the editor.\n
\t\t\t *\n
\t\t\t * @property parser\n
\t\t\t * @type tinymce.html.DomParser\n
\t\t\t */\n
\t\t\tself.parser = new DomParser(settings, self.schema);\n
\n
\t\t\t// Convert src and href into data-mce-src, data-mce-href and data-mce-style\n
\t\t\tself.parser.addAttributeFilter(\'src,href,style,tabindex\', function(nodes, name) {\n
\t\t\t\tvar i = nodes.length, node, dom = self.dom, value, internalName;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tvalue = node.attr(name);\n
\t\t\t\t\tinternalName = \'data-mce-\' + name;\n
\n
\t\t\t\t\t// Add internal attribute if we need to we don\'t on a refresh of the document\n
\t\t\t\t\tif (!node.attributes.map[internalName]) {\n
\t\t\t\t\t\t// Don\'t duplicate these since they won\'t get modified by any browser\n
\t\t\t\t\t\tif (value.indexOf(\'data:\') === 0 || value.indexOf(\'blob:\') === 0) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (name === "style") {\n
\t\t\t\t\t\t\tvalue = dom.serializeStyle(dom.parseStyle(value), node.name);\n
\n
\t\t\t\t\t\t\tif (!value.length) {\n
\t\t\t\t\t\t\t\tvalue = null;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tnode.attr(internalName, value);\n
\t\t\t\t\t\t\tnode.attr(name, value);\n
\t\t\t\t\t\t} else if (name === "tabindex") {\n
\t\t\t\t\t\t\tnode.attr(internalName, value);\n
\t\t\t\t\t\t\tnode.attr(name, null);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tnode.attr(internalName, self.convertURL(value, name, node.name));\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Keep scripts from executing\n
\t\t\tself.parser.addNodeFilter(\'script\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tnode.attr(\'type\', \'mce-\' + (node.attr(\'type\') || \'no/type\'));\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.parser.addNodeFilter(\'#cdata\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node;\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\tnode.type = 8;\n
\t\t\t\t\tnode.name = \'#comment\';\n
\t\t\t\t\tnode.value = \'[CDATA[\' + node.value + \']]\';\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.parser.addNodeFilter(\'p,h1,h2,h3,h4,h5,h6,div\', function(nodes) {\n
\t\t\t\tvar i = nodes.length, node, nonEmptyElements = self.schema.getNonEmptyElements();\n
\n
\t\t\t\twhile (i--) {\n
\t\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\t\tif (node.isEmpty(nonEmptyElements)) {\n
\t\t\t\t\t\tnode.append(new Node(\'br\', 1)).shortEnded = true;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t/**\n
\t\t\t * DOM serializer for the editor. Will be used when contents is extracted from the editor.\n
\t\t\t *\n
\t\t\t * @property serializer\n
\t\t\t * @type tinymce.dom.Serializer\n
\t\t\t * @example\n
\t\t\t * // Serializes the first paragraph in the editor into a string\n
\t\t\t * tinymce.activeEditor.serializer.serialize(tinymce.activeEditor.dom.select(\'p\')[0]);\n
\t\t\t */\n
\t\t\tself.serializer = new DomSerializer(settings, self);\n
\n
\t\t\t/**\n
\t\t\t * Selection instance for the editor.\n
\t\t\t *\n
\t\t\t * @property selection\n
\t\t\t * @type tinymce.dom.Selection\n
\t\t\t * @example\n
\t\t\t * // Sets some contents to the current selection in the editor\n
\t\t\t * tinymce.activeEditor.selection.setContent(\'Some contents\');\n
\t\t\t *\n
\t\t\t * // Gets the current selection\n
\t\t\t * alert(tinymce.activeEditor.selection.getContent());\n
\t\t\t *\n
\t\t\t * // Selects the first paragraph found\n
\t\t\t * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select(\'p\')[0]);\n
\t\t\t */\n
\t\t\tself.selection = new Selection(self.dom, self.getWin(), self.serializer, self);\n
\n
\t\t\t/**\n
\t\t\t * Formatter instance.\n
\t\t\t *\n
\t\t\t * @property formatter\n
\t\t\t * @type tinymce.Formatter\n
\t\t\t */\n
\t\t\tself.formatter = new Formatter(self);\n
\n
\t\t\t/**\n
\t\t\t * Undo manager instance, responsible for handling undo levels.\n
\t\t\t *\n
\t\t\t * @property undoManager\n
\t\t\t * @type tinymce.UndoManager\n
\t\t\t * @example\n
\t\t\t * // Undoes the last modification to the editor\n
\t\t\t * tinymce.activeEditor.undoManager.undo();\n
\t\t\t */\n
\t\t\tself.undoManager = new UndoManager(self);\n
\n
\t\t\tself.forceBlocks = new ForceBlocks(self);\n
\t\t\tself.enterKey = new EnterKey(self);\n
\t\t\tself._nodeChangeDispatcher = new NodeChange(self);\n
\n
\t\t\tself.fire(\'PreInit\');\n
\n
\t\t\tif (!settings.browser_spellcheck && !settings.gecko_spellcheck) {\n
\t\t\t\tdoc.body.spellcheck = false; // Gecko\n
\t\t\t\tDOM.setAttrib(body, "spellcheck", "false");\n
\t\t\t}\n
\n
\t\t\tself.fire(\'PostRender\');\n
\n
\t\t\tself.quirks = new Quirks(self);\n
\n
\t\t\tif (settings.directionality) {\n
\t\t\t\tbody.dir = settings.directionality;\n
\t\t\t}\n
\n
\t\t\tif (settings.nowrap) {\n
\t\t\t\tbody.style.whiteSpace = "nowrap";\n
\t\t\t}\n
\n
\t\t\tif (settings.protect) {\n
\t\t\t\tself.on(\'BeforeSetContent\', function(e) {\n
\t\t\t\t\teach(settings.protect, function(pattern) {\n
\t\t\t\t\t\te.content = e.content.replace(pattern, function(str) {\n
\t\t\t\t\t\t\treturn \'<!--mce:protected \' + escape(str) + \'-->\';\n
\t\t\t\t\t\t});\n
\t\t\t\t\t});\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.on(\'SetContent\', function() {\n
\t\t\t\tself.addVisual(self.getBody());\n
\t\t\t});\n
\n
\t\t\t// Remove empty contents\n
\t\t\tif (settings.padd_empty_editor) {\n
\t\t\t\tself.on(\'PostProcess\', function(e) {\n
\t\t\t\t\te.content = e.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\\s|\\u00a0|)<\\/p>[\\r\\n]*|<br \\/>[\\r\\n]*)$/, \'\');\n
\t\t\t\t});\n
\t\t\t}\n
\n
\t\t\tself.load({initial: true, format: \'html\'});\n
\t\t\tself.startContent = self.getContent({format: \'raw\'});\n
\n
\t\t\t/**\n
\t\t\t * Is set to true after the editor instance has been initialized\n
\t\t\t *\n
\t\t\t * @property initialized\n
\t\t\t * @type Boolean\n
\t\t\t * @example\n
\t\t\t * function isEditorInitialized(editor) {\n
\t\t\t *     return editor && editor.initialized;\n
\t\t\t * }\n
\t\t\t */\n
\t\t\tself.initialized = true;\n
\t\t\tself.bindPendingEventDelegates();\n
\n
\t\t\tself.fire(\'init\');\n
\t\t\tself.focus(true);\n
\t\t\tself.nodeChanged({initial: true});\n
\t\t\tself.execCallback(\'init_instance_callback\', self);\n
\n
\t\t\t// Add editor specific CSS styles\n
\t\t\tif (self.contentStyles.length > 0) {\n
\t\t\t\tcontentCssText = \'\';\n
\n
\t\t\t\teach(self.contentStyles, function(style) {\n
\t\t\t\t\tcontentCssText += style + "\\r\\n";\n
\t\t\t\t});\n
\n
\t\t\t\tself.dom.addStyle(contentCssText);\n
\t\t\t}\n
\n
\t\t\t// Load specified content CSS last\n
\t\t\teach(self.contentCSS, function(cssUrl) {\n
\t\t\t\tif (!self.loadedCSS[cssUrl]) {\n
\t\t\t\t\tself.dom.loadCSS(cssUrl);\n
\t\t\t\t\tself.loadedCSS[cssUrl] = true;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\t// Handle auto focus\n
\t\t\tif (settings.auto_focus) {\n
\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\tvar editor;\n
\n
\t\t\t\t\tif (settings.auto_focus === true) {\n
\t\t\t\t\t\teditor = self;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\teditor = self.editorManager.get(settings.auto_focus);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!editor.destroyed) {\n
\t\t\t\t\t\teditor.focus();\n
\t\t\t\t\t}\n
\t\t\t\t}, 100);\n
\t\t\t}\n
\n
\t\t\t// Clean up references for IE\n
\t\t\ttargetElm = doc = body = null;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection\n
\t\t * it will also place DOM focus inside the editor.\n
\t\t *\n
\t\t * @method focus\n
\t\t * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.\n
\t\t */\n
\t\tfocus: function(skipFocus) {\n
\t\t\tvar self = this, selection = self.selection, contentEditable = self.settings.content_editable, rng;\n
\t\t\tvar controlElm, doc = self.getDoc(), body;\n
\n
\t\t\tif (!skipFocus) {\n
\t\t\t\t// Get selected control element\n
\t\t\t\trng = selection.getRng();\n
\t\t\t\tif (rng.item) {\n
\t\t\t\t\tcontrolElm = rng.item(0);\n
\t\t\t\t}\n
\n
\t\t\t\tself._refreshContentEditable();\n
\n
\t\t\t\t// Focus the window iframe\n
\t\t\t\tif (!contentEditable) {\n
\t\t\t\t\t// WebKit needs this call to fire focusin event properly see #5948\n
\t\t\t\t\t// But Opera pre Blink engine will produce an empty selection so skip Opera\n
\t\t\t\t\tif (!Env.opera) {\n
\t\t\t\t\t\tself.getBody().focus();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tself.getWin().focus();\n
\t\t\t\t}\n
\n
\t\t\t\t// Focus the body as well since it\'s contentEditable\n
\t\t\t\tif (isGecko || contentEditable) {\n
\t\t\t\t\tbody = self.getBody();\n
\n
\t\t\t\t\t// Check for setActive since it doesn\'t scroll to the element\n
\t\t\t\t\tif (body.setActive) {\n
\t\t\t\t\t\t// IE 11 sometimes throws "Invalid function" then fallback to focus\n
\t\t\t\t\t\ttry {\n
\t\t\t\t\t\t\tbody.setActive();\n
\t\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t\tbody.focus();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tbody.focus();\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (contentEditable) {\n
\t\t\t\t\t\tselection.normalize();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Restore selected control element\n
\t\t\t\t// This is needed when for example an image is selected within a\n
\t\t\t\t// layer a call to focus will then remove the control selection\n
\t\t\t\tif (controlElm && controlElm.ownerDocument == doc) {\n
\t\t\t\t\trng = doc.body.createControlRange();\n
\t\t\t\t\trng.addElement(controlElm);\n
\t\t\t\t\trng.select();\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tself.editorManager.setActive(self);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes a legacy callback. This method is useful to call old 2.x option callbacks.\n
\t\t * There new event model is a better way to add callback so this method might be removed in the future.\n
\t\t *\n
\t\t * @method execCallback\n
\t\t * @param {String} name Name of the callback to execute.\n
\t\t * @return {Object} Return value passed from callback function.\n
\t\t */\n
\t\texecCallback: function(name) {\n
\t\t\tvar self = this, callback = self.settings[name], scope;\n
\n
\t\t\tif (!callback) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Look through lookup\n
\t\t\tif (self.callbackLookup && (scope = self.callbackLookup[name])) {\n
\t\t\t\tcallback = scope.func;\n
\t\t\t\tscope = scope.scope;\n
\t\t\t}\n
\n
\t\t\tif (typeof callback === \'string\') {\n
\t\t\t\tscope = callback.replace(/\\.\\w+$/, \'\');\n
\t\t\t\tscope = scope ? resolve(scope) : 0;\n
\t\t\t\tcallback = resolve(callback);\n
\t\t\t\tself.callbackLookup = self.callbackLookup || {};\n
\t\t\t\tself.callbackLookup[name] = {func: callback, scope: scope};\n
\t\t\t}\n
\n
\t\t\treturn callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));\n
\t\t},\n
\n
\t\t/**\n
\t\t * Translates the specified string by replacing variables with language pack items it will also check if there is\n
\t\t * a key mathcin the input.\n
\t\t *\n
\t\t * @method translate\n
\t\t * @param {String} text String to translate by the language pack data.\n
\t\t * @return {String} Translated string.\n
\t\t */\n
\t\ttranslate: function(text) {\n
\t\t\tvar lang = this.settings.language || \'en\', i18n = this.editorManager.i18n;\n
\n
\t\t\tif (!text) {\n
\t\t\t\treturn \'\';\n
\t\t\t}\n
\n
\t\t\treturn i18n.data[lang + \'.\' + text] || text.replace(/\\{\\#([^\\}]+)\\}/g, function(a, b) {\n
\t\t\t\treturn i18n.data[lang + \'.\' + b] || \'{#\' + b + \'}\';\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a language pack item by name/key.\n
\t\t *\n
\t\t * @method getLang\n
\t\t * @param {String} name Name/key to get from the language pack.\n
\t\t * @param {String} defaultVal Optional default value to retrive.\n
\t\t */\n
\t\tgetLang: function(name, defaultVal) {\n
\t\t\treturn (\n
\t\t\t\tthis.editorManager.i18n.data[(this.settings.language || \'en\') + \'.\' + name] ||\n
\t\t\t\t(defaultVal !== undefined ? defaultVal : \'{#\' + name + \'}\')\n
\t\t\t);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a configuration parameter by name.\n
\t\t *\n
\t\t * @method getParam\n
\t\t * @param {String} name Configruation parameter to retrive.\n
\t\t * @param {String} defaultVal Optional default value to return.\n
\t\t * @param {String} type Optional type parameter.\n
\t\t * @return {String} Configuration parameter value or default value.\n
\t\t * @example\n
\t\t * // Returns a specific config value from the currently active editor\n
\t\t * var someval = tinymce.activeEditor.getParam(\'myvalue\');\n
\t\t *\n
\t\t * // Returns a specific config value from a specific editor instance by id\n
\t\t * var someval2 = tinymce.get(\'my_editor\').getParam(\'myvalue\');\n
\t\t */\n
\t\tgetParam: function(name, defaultVal, type) {\n
\t\t\tvar value = name in this.settings ? this.settings[name] : defaultVal, output;\n
\n
\t\t\tif (type === \'hash\') {\n
\t\t\t\toutput = {};\n
\n
\t\t\t\tif (typeof value === \'string\') {\n
\t\t\t\t\teach(value.indexOf(\'=\') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(\',\'), function(value) {\n
\t\t\t\t\t\tvalue = value.split(\'=\');\n
\n
\t\t\t\t\t\tif (value.length > 1) {\n
\t\t\t\t\t\t\toutput[trim(value[0])] = trim(value[1]);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\toutput[trim(value[0])] = trim(value);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t} else {\n
\t\t\t\t\toutput = value;\n
\t\t\t\t}\n
\n
\t\t\t\treturn output;\n
\t\t\t}\n
\n
\t\t\treturn value;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Distpaches out a onNodeChange event to all observers. This method should be called when you\n
\t\t * need to update the UI states or element path etc.\n
\t\t *\n
\t\t * @method nodeChanged\n
\t\t * @param {Object} args Optional args to pass to NodeChange event handlers.\n
\t\t */\n
\t\tnodeChanged: function(args) {\n
\t\t\tthis._nodeChangeDispatcher.nodeChanged(args);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a button that later gets created by the theme in the editors toolbars.\n
\t\t *\n
\t\t * @method addButton\n
\t\t * @param {String} name Button name to add.\n
\t\t * @param {Object} settings Settings object with title, cmd etc.\n
\t\t * @example\n
\t\t * // Adds a custom button to the editor that inserts contents when clicked\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    toolbar: \'example\'\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       ed.addButton(\'example\', {\n
\t\t *          title: \'My title\',\n
\t\t *          image: \'../js/tinymce/plugins/example/img/example.gif\',\n
\t\t *          onclick: function() {\n
\t\t *             ed.insertContent(\'Hello world!!\');\n
\t\t *          }\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddButton: function(name, settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (settings.cmd) {\n
\t\t\t\tsettings.onclick = function() {\n
\t\t\t\t\tself.execCommand(settings.cmd);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tif (!settings.text && !settings.icon) {\n
\t\t\t\tsettings.icon = name;\n
\t\t\t}\n
\n
\t\t\tself.buttons = self.buttons || {};\n
\t\t\tsettings.tooltip = settings.tooltip || settings.title;\n
\t\t\tself.buttons[name] = settings;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a menu item to be used in the menus of the theme. There might be multiple instances\n
\t\t * of this menu item for example it might be used in the main menus of the theme but also in\n
\t\t * the context menu so make sure that it\'s self contained and supports multiple instances.\n
\t\t *\n
\t\t * @method addMenuItem\n
\t\t * @param {String} name Menu item name to add.\n
\t\t * @param {Object} settings Settings object with title, cmd etc.\n
\t\t * @example\n
\t\t * // Adds a custom menu item to the editor that inserts contents when clicked\n
\t\t * // The context option allows you to add the menu item to an existing default menu\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       ed.addMenuItem(\'example\', {\n
\t\t *          text: \'My menu item\',\n
\t\t *          context: \'tools\',\n
\t\t *          onclick: function() {\n
\t\t *             ed.insertContent(\'Hello world!!\');\n
\t\t *          }\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddMenuItem: function(name, settings) {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (settings.cmd) {\n
\t\t\t\tsettings.onclick = function() {\n
\t\t\t\t\tself.execCommand(settings.cmd);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tself.menuItems = self.menuItems || {};\n
\t\t\tself.menuItems[name] = settings;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a contextual toolbar to be rendered when the selector matches.\n
\t\t *\n
\t\t * @method addContextToolbar\n
\t\t * @param {function/string} predicate Predicate that needs to return true if provided strings get converted into CSS predicates.\n
\t\t * @param {String/Array} items String or array with items to add to the context toolbar.\n
\t\t */\n
\t\taddContextToolbar: function(predicate, items) {\n
\t\t\tvar self = this, selector;\n
\n
\t\t\tself.contextToolbars = self.contextToolbars || [];\n
\n
\t\t\t// Convert selector to predicate\n
\t\t\tif (typeof predicate == "string") {\n
\t\t\t\tselector = predicate;\n
\t\t\t\tpredicate = function(elm) {\n
\t\t\t\t\treturn self.dom.is(elm, selector);\n
\t\t\t\t};\n
\t\t\t}\n
\n
\t\t\tself.contextToolbars.push({\n
\t\t\t\tpredicate: predicate,\n
\t\t\t\titems: items\n
\t\t\t});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with execCommand.\n
\t\t *\n
\t\t * @method addCommand\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addCommandCallback} callback Function to execute when the command occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t * @example\n
\t\t * // Adds a custom command that later can be executed using execCommand\n
\t\t * tinymce.init({\n
\t\t *    ...\n
\t\t *\n
\t\t *    setup: function(ed) {\n
\t\t *       // Register example command\n
\t\t *       ed.addCommand(\'mycommand\', function(ui, v) {\n
\t\t *          ed.windowManager.alert(\'Hello world!! Selection: \' + ed.selection.getContent({format: \'text\'}));\n
\t\t *       });\n
\t\t *    }\n
\t\t * });\n
\t\t */\n
\t\taddCommand: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a command is executed.\n
\t\t\t *\n
\t\t\t * @callback addCommandCallback\n
\t\t\t * @param {Boolean} ui Display UI state true/false.\n
\t\t\t * @param {Object} value Optional value for command.\n
\t\t\t * @return {Boolean} True/false state if the command was handled or not.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addCommand(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom query state command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with queryCommandState function.\n
\t\t *\n
\t\t * @method addQueryStateHandler\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrival occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t */\n
\t\taddQueryStateHandler: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a queryCommandState is executed.\n
\t\t\t *\n
\t\t\t * @callback addQueryStateHandlerCallback\n
\t\t\t * @return {Boolean} True/false state if the command is enabled or not like is it bold.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addQueryStateHandler(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a custom query value command to the editor, you can also override existing commands with this method.\n
\t\t * The command that you add can be executed with queryCommandValue function.\n
\t\t *\n
\t\t * @method addQueryValueHandler\n
\t\t * @param {String} name Command name to add/override.\n
\t\t * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrival occurs.\n
\t\t * @param {Object} scope Optional scope to execute the function in.\n
\t\t */\n
\t\taddQueryValueHandler: function(name, callback, scope) {\n
\t\t\t/**\n
\t\t\t * Callback function that gets called when a queryCommandValue is executed.\n
\t\t\t *\n
\t\t\t * @callback addQueryValueHandlerCallback\n
\t\t\t * @return {Object} Value of the command or undefined.\n
\t\t\t */\n
\t\t\tthis.editorCommands.addQueryValueHandler(name, callback, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds a keyboard shortcut for some command or function.\n
\t\t *\n
\t\t * @method addShortcut\n
\t\t * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.\n
\t\t * @param {String} desc Text description for the command.\n
\t\t * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.\n
\t\t * @param {Object} sc Optional scope to execute the function in.\n
\t\t * @return {Boolean} true/false state if the shortcut was added or not.\n
\t\t */\n
\t\taddShortcut: function(pattern, desc, cmdFunc, scope) {\n
\t\t\tthis.shortcuts.add(pattern, desc, cmdFunc, scope);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or\n
\t\t * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.\n
\t\t * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these\n
\t\t * return true it will handle the command as a internal browser command.\n
\t\t *\n
\t\t * @method execCommand\n
\t\t * @param {String} cmd Command name to execute, for example mceLink or Bold.\n
\t\t * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.\n
\t\t * @param {mixed} value Optional command value, this can be anything.\n
\t\t * @param {Object} args Optional arguments object.\n
\t\t */\n
\t\texecCommand: function(cmd, ui, value, args) {\n
\t\t\treturn this.editorCommands.execCommand(cmd, ui, value, args);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a command specific state, for example if bold is enabled or not.\n
\t\t *\n
\t\t * @method queryCommandState\n
\t\t * @param {string} cmd Command to query state from.\n
\t\t * @return {Boolean} Command specific state, for example if bold is enabled or not.\n
\t\t */\n
\t\tqueryCommandState: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandState(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns a command specific value, for example the current font size.\n
\t\t *\n
\t\t * @method queryCommandValue\n
\t\t * @param {string} cmd Command to query value from.\n
\t\t * @return {Object} Command specific value, for example the current font size.\n
\t\t */\n
\t\tqueryCommandValue: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandValue(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the command is supported or not.\n
\t\t *\n
\t\t * @method queryCommandSupported\n
\t\t * @param {String} cmd Command that we check support for.\n
\t\t * @return {Boolean} true/false if the command is supported or not.\n
\t\t */\n
\t\tqueryCommandSupported: function(cmd) {\n
\t\t\treturn this.editorCommands.queryCommandSupported(cmd);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Shows the editor and hides any textarea/div that the editor is supposed to replace.\n
\t\t *\n
\t\t * @method show\n
\t\t */\n
\t\tshow: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (self.hidden) {\n
\t\t\t\tself.hidden = false;\n
\n
\t\t\t\tif (self.inline) {\n
\t\t\t\t\tself.getBody().contentEditable = true;\n
\t\t\t\t} else {\n
\t\t\t\t\tDOM.show(self.getContainer());\n
\t\t\t\t\tDOM.hide(self.id);\n
\t\t\t\t}\n
\n
\t\t\t\tself.load();\n
\t\t\t\tself.fire(\'show\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Hides the editor and shows any textarea/div that the editor is supposed to replace.\n
\t\t *\n
\t\t * @method hide\n
\t\t */\n
\t\thide: function() {\n
\t\t\tvar self = this, doc = self.getDoc();\n
\n
\t\t\tif (!self.hidden) {\n
\t\t\t\t// Fixed bug where IE has a blinking cursor left from the editor\n
\t\t\t\tif (ie && doc && !self.inline) {\n
\t\t\t\t\tdoc.execCommand(\'SelectAll\');\n
\t\t\t\t}\n
\n
\t\t\t\t// We must save before we hide so Safari doesn\'t crash\n
\t\t\t\tself.save();\n
\n
\t\t\t\tif (self.inline) {\n
\t\t\t\t\tself.getBody().contentEditable = false;\n
\n
\t\t\t\t\t// Make sure the editor gets blurred\n
\t\t\t\t\tif (self == self.editorManager.focusedEditor) {\n
\t\t\t\t\t\tself.editorManager.focusedEditor = null;\n
\t\t\t\t\t}\n
\t\t\t\t} else {\n
\t\t\t\t\tDOM.hide(self.getContainer());\n
\t\t\t\t\tDOM.setStyle(self.id, \'display\', self.orgDisplay);\n
\t\t\t\t}\n
\n
\t\t\t\tself.hidden = true;\n
\t\t\t\tself.fire(\'hide\');\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the editor is hidden or not.\n
\t\t *\n
\t\t * @method isHidden\n
\t\t * @return {Boolean} True/false if the editor is hidden or not.\n
\t\t */\n
\t\tisHidden: function() {\n
\t\t\treturn !!this.hidden;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the progress state, this will display a throbber/progess for the editor.\n
\t\t * This is ideal for asycronous operations like an AJAX save call.\n
\t\t *\n
\t\t * @method setProgressState\n
\t\t * @param {Boolean} state Boolean state if the progress should be shown or hidden.\n
\t\t * @param {Number} time Optional time to wait before the progress gets shown.\n
\t\t * @return {Boolean} Same as the input state.\n
\t\t * @example\n
\t\t * // Show progress for the active editor\n
\t\t * tinymce.activeEditor.setProgressState(true);\n
\t\t *\n
\t\t * // Hide progress for the active editor\n
\t\t * tinymce.activeEditor.setProgressState(false);\n
\t\t *\n
\t\t * // Show progress after 3 seconds\n
\t\t * tinymce.activeEditor.setProgressState(true, 3000);\n
\t\t */\n
\t\tsetProgressState: function(state, time) {\n
\t\t\tthis.fire(\'ProgressState\', {state: state, time: time});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Loads contents from the textarea or div element that got converted into an editor instance.\n
\t\t * This method will move the contents from that textarea or div into the editor by using setContent\n
\t\t * so all events etc that method has will get dispatched as well.\n
\t\t *\n
\t\t * @method load\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole load process.\n
\t\t * @return {String} HTML string that got set into the editor.\n
\t\t */\n
\t\tload: function(args) {\n
\t\t\tvar self = this, elm = self.getElement(), html;\n
\n
\t\t\tif (elm) {\n
\t\t\t\targs = args || {};\n
\t\t\t\targs.load = true;\n
\n
\t\t\t\thtml = self.setContent(elm.value !== undefined ? elm.value : elm.innerHTML, args);\n
\t\t\t\targs.element = elm;\n
\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\tself.fire(\'LoadContent\', args);\n
\t\t\t\t}\n
\n
\t\t\t\targs.element = elm = null;\n
\n
\t\t\t\treturn html;\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.\n
\t\t * This method will move the HTML contents from the editor into that textarea or div by getContent\n
\t\t * so all events etc that method has will get dispatched as well.\n
\t\t *\n
\t\t * @method save\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole save process.\n
\t\t * @return {String} HTML string that got set into the textarea/div.\n
\t\t */\n
\t\tsave: function(args) {\n
\t\t\tvar self = this, elm = self.getElement(), html, form;\n
\n
\t\t\tif (!elm || !self.initialized) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\targs = args || {};\n
\t\t\targs.save = true;\n
\n
\t\t\targs.element = elm;\n
\t\t\thtml = args.content = self.getContent(args);\n
\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'SaveContent\', args);\n
\t\t\t}\n
\n
\t\t\t// Always run this internal event\n
\t\t\tif (args.format == \'raw\') {\n
\t\t\t\tself.fire(\'RawSaveContent\', args);\n
\t\t\t}\n
\n
\t\t\thtml = args.content;\n
\n
\t\t\tif (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {\n
\t\t\t\t// Update DIV element when not in inline mode\n
\t\t\t\tif (!self.inline) {\n
\t\t\t\t\telm.innerHTML = html;\n
\t\t\t\t}\n
\n
\t\t\t\t// Update hidden form element\n
\t\t\t\tif ((form = DOM.getParent(self.id, \'form\'))) {\n
\t\t\t\t\teach(form.elements, function(elm) {\n
\t\t\t\t\t\tif (elm.name == self.id) {\n
\t\t\t\t\t\t\telm.value = html;\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t} else {\n
\t\t\t\telm.value = html;\n
\t\t\t}\n
\n
\t\t\targs.element = elm = null;\n
\n
\t\t\tif (args.set_dirty !== false) {\n
\t\t\t\tself.isNotDirty = true;\n
\t\t\t}\n
\n
\t\t\treturn html;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Sets the specified content to the editor instance, this will cleanup the content before it gets set using\n
\t\t * the different cleanup rules options.\n
\t\t *\n
\t\t * @method setContent\n
\t\t * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole set process.\n
\t\t * @return {String} HTML string that got set into the editor.\n
\t\t * @example\n
\t\t * // Sets the HTML contents of the activeEditor editor\n
\t\t * tinymce.activeEditor.setContent(\'<span>some</span> html\');\n
\t\t *\n
\t\t * // Sets the raw contents of the activeEditor editor\n
\t\t * tinymce.activeEditor.setContent(\'<span>some</span> html\', {format: \'raw\'});\n
\t\t *\n
\t\t * // Sets the content of a specific editor (my_editor in this example)\n
\t\t * tinymce.get(\'my_editor\').setContent(data);\n
\t\t *\n
\t\t * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added\n
\t\t * tinymce.activeEditor.setContent(\'[b]some[/b] html\', {format: \'bbcode\'});\n
\t\t */\n
\t\tsetContent: function(content, args) {\n
\t\t\tvar self = this, body = self.getBody(), forcedRootBlockName;\n
\n
\t\t\t// Setup args object\n
\t\t\targs = args || {};\n
\t\t\targs.format = args.format || \'html\';\n
\t\t\targs.set = true;\n
\t\t\targs.content = content;\n
\n
\t\t\t// Do preprocessing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'BeforeSetContent\', args);\n
\t\t\t}\n
\n
\t\t\tcontent = args.content;\n
\n
\t\t\t// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content\n
\t\t\t// It will also be impossible to place the caret in the editor unless there is a BR element present\n
\t\t\tif (content.length === 0 || /^\\s+$/.test(content)) {\n
\t\t\t\tforcedRootBlockName = self.settings.forced_root_block;\n
\n
\t\t\t\t// Check if forcedRootBlock is configured and that the block is a valid child of the body\n
\t\t\t\tif (forcedRootBlockName && self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n
\t\t\t\t\t// Padd with bogus BR elements on modern browsers and IE 7 and 8 since they don\'t render empty P tags properly\n
\t\t\t\t\tcontent = ie && ie < 11 ? \'\' : \'<br data-mce-bogus="1">\';\n
\t\t\t\t\tcontent = self.dom.createHTML(forcedRootBlockName, self.settings.forced_root_block_attrs, content);\n
\t\t\t\t} else if (!ie) {\n
\t\t\t\t\t// We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret\n
\t\t\t\t\tcontent = \'<br data-mce-bogus="1">\';\n
\t\t\t\t}\n
\n
\t\t\t\tself.dom.setHTML(body, content);\n
\n
\t\t\t\tself.fire(\'SetContent\', args);\n
\t\t\t} else {\n
\t\t\t\t// Parse and serialize the html\n
\t\t\t\tif (args.format !== \'raw\') {\n
\t\t\t\t\tcontent = new Serializer({}, self.schema).serialize(\n
\t\t\t\t\t\tself.parser.parse(content, {isRootContent: true})\n
\t\t\t\t\t);\n
\t\t\t\t}\n
\n
\t\t\t\t// Set the new cleaned contents to the editor\n
\t\t\t\targs.content = trim(content);\n
\t\t\t\tself.dom.setHTML(body, args.content);\n
\n
\t\t\t\t// Do post processing\n
\t\t\t\tif (!args.no_events) {\n
\t\t\t\t\tself.fire(\'SetContent\', args);\n
\t\t\t\t}\n
\n
\t\t\t\t// Don\'t normalize selection if the focused element isn\'t the body in\n
\t\t\t\t// content editable mode since it will steal focus otherwise\n
\t\t\t\t/*if (!self.settings.content_editable || document.activeElement === self.getBody()) {\n
\t\t\t\t\tself.selection.normalize();\n
\t\t\t\t}*/\n
\t\t\t}\n
\n
\t\t\treturn args.content;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Gets the content from the editor instance, this will cleanup the content before it gets returned using\n
\t\t * the different cleanup rules options.\n
\t\t *\n
\t\t * @method getContent\n
\t\t * @param {Object} args Optional content object, this gets passed around through the whole get process.\n
\t\t * @return {String} Cleaned content string, normally HTML contents.\n
\t\t * @example\n
\t\t * // Get the HTML contents of the currently active editor\n
\t\t * console.debug(tinymce.activeEditor.getContent());\n
\t\t *\n
\t\t * // Get the raw contents of the currently active editor\n
\t\t * tinymce.activeEditor.getContent({format: \'raw\'});\n
\t\t *\n
\t\t * // Get content of a specific editor:\n
\t\t * tinymce.get(\'content id\').getContent()\n
\t\t */\n
\t\tgetContent: function(args) {\n
\t\t\tvar self = this, content, body = self.getBody();\n
\n
\t\t\t// Setup args object\n
\t\t\targs = args || {};\n
\t\t\targs.format = args.format || \'html\';\n
\t\t\targs.get = true;\n
\t\t\targs.getInner = true;\n
\n
\t\t\t// Do preprocessing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'BeforeGetContent\', args);\n
\t\t\t}\n
\n
\t\t\t// Get raw contents or by default the cleaned contents\n
\t\t\tif (args.format == \'raw\') {\n
\t\t\t\tcontent = body.innerHTML;\n
\t\t\t} else if (args.format == \'text\') {\n
\t\t\t\tcontent = body.innerText || body.textContent;\n
\t\t\t} else {\n
\t\t\t\tcontent = self.serializer.serialize(body, args);\n
\t\t\t}\n
\n
\t\t\t// Trim whitespace in beginning/end of HTML\n
\t\t\tif (args.format != \'text\') {\n
\t\t\t\targs.content = trim(content);\n
\t\t\t} else {\n
\t\t\t\targs.content = content;\n
\t\t\t}\n
\n
\t\t\t// Do post processing\n
\t\t\tif (!args.no_events) {\n
\t\t\t\tself.fire(\'GetContent\', args);\n
\t\t\t}\n
\n
\t\t\treturn args.content;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Inserts content at caret position.\n
\t\t *\n
\t\t * @method insertContent\n
\t\t * @param {String} content Content to insert.\n
\t\t * @param {Object} args Optional args to pass to insert call.\n
\t\t */\n
\t\tinsertContent: function(content, args) {\n
\t\t\tif (args) {\n
\t\t\t\tcontent = extend({content: content}, args);\n
\t\t\t}\n
\n
\t\t\tthis.execCommand(\'mceInsertContent\', false, content);\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\n
\t\t *\n
\t\t * @method isDirty\n
\t\t * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.\n
\t\t * @example\n
\t\t * if (tinymce.activeEditor.isDirty())\n
\t\t *     alert("You must save your contents.");\n
\t\t */\n
\t\tisDirty: function() {\n
\t\t\treturn !this.isNotDirty;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the editors container element. The container element wrappes in\n
\t\t * all the elements added to the page for the editor. Such as UI, iframe etc.\n
\t\t *\n
\t\t * @method getContainer\n
\t\t * @return {Element} HTML DOM element for the editor container.\n
\t\t */\n
\t\tgetContainer: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.container) {\n
\t\t\t\tself.container = DOM.get(self.editorContainer || self.id + \'_parent\');\n
\t\t\t}\n
\n
\t\t\treturn self.container;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the editors content area container element. The this element is the one who\n
\t\t * holds the iframe or the editable element.\n
\t\t *\n
\t\t * @method getContentAreaContainer\n
\t\t * @return {Element} HTML DOM element for the editor area container.\n
\t\t */\n
\t\tgetContentAreaContainer: function() {\n
\t\t\treturn this.contentAreaContainer;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the target element/textarea that got replaced with a TinyMCE editor instance.\n
\t\t *\n
\t\t * @method getElement\n
\t\t * @return {Element} HTML DOM element for the replaced element.\n
\t\t */\n
\t\tgetElement: function() {\n
\t\t\tif (!this.targetElm) {\n
\t\t\t\tthis.targetElm = DOM.get(this.id);\n
\t\t\t}\n
\n
\t\t\treturn this.targetElm;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the iframes window object.\n
\t\t *\n
\t\t * @method getWin\n
\t\t * @return {Window} Iframe DOM window object.\n
\t\t */\n
\t\tgetWin: function() {\n
\t\t\tvar self = this, elm;\n
\n
\t\t\tif (!self.contentWindow) {\n
\t\t\t\telm = self.iframeElement;\n
\n
\t\t\t\tif (elm) {\n
\t\t\t\t\tself.contentWindow = elm.contentWindow;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self.contentWindow;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the iframes document object.\n
\t\t *\n
\t\t * @method getDoc\n
\t\t * @return {Document} Iframe DOM document object.\n
\t\t */\n
\t\tgetDoc: function() {\n
\t\t\tvar self = this, win;\n
\n
\t\t\tif (!self.contentDocument) {\n
\t\t\t\twin = self.getWin();\n
\n
\t\t\t\tif (win) {\n
\t\t\t\t\tself.contentDocument = win.document;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn self.contentDocument;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Returns the root element of the editable area.\n
\t\t * For a non-inline iframe-based editor, returns the iframe\'s body element.\n
\t\t *\n
\t\t * @method getBody\n
\t\t * @return {Element} The root element of the editable area.\n
\t\t */\n
\t\tgetBody: function() {\n
\t\t\treturn this.bodyElement || this.getDoc().body;\n
\t\t},\n
\n
\t\t/**\n
\t\t * URL converter function this gets executed each time a user adds an img, a or\n
\t\t * any other element that has a URL in it. This will be called both by the DOM and HTML\n
\t\t * manipulation functions.\n
\t\t *\n
\t\t * @method convertURL\n
\t\t * @param {string} url URL to convert.\n
\t\t * @param {string} name Attribute name src, href etc.\n
\t\t * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.\n
\t\t * @return {string} Converted URL string.\n
\t\t */\n
\t\tconvertURL: function(url, name, elm) {\n
\t\t\tvar self = this, settings = self.settings;\n
\n
\t\t\t// Use callback instead\n
\t\t\tif (settings.urlconverter_callback) {\n
\t\t\t\treturn self.execCallback(\'urlconverter_callback\', url, elm, true, name);\n
\t\t\t}\n
\n
\t\t\t// Don\'t convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs\n
\t\t\tif (!settings.convert_urls || (elm && elm.nodeName == \'LINK\') || url.indexOf(\'file:\') === 0 || url.length === 0) {\n
\t\t\t\treturn url;\n
\t\t\t}\n
\n
\t\t\t// Convert to relative\n
\t\t\tif (settings.relative_urls) {\n
\t\t\t\treturn self.documentBaseURI.toRelative(url);\n
\t\t\t}\n
\n
\t\t\t// Convert to absolute\n
\t\t\turl = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);\n
\n
\t\t\treturn url;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.\n
\t\t *\n
\t\t * @method addVisual\n
\t\t * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.\n
\t\t */\n
\t\taddVisual: function(elm) {\n
\t\t\tvar self = this, settings = self.settings, dom = self.dom, cls;\n
\n
\t\t\telm = elm || self.getBody();\n
\n
\t\t\tif (self.hasVisual === undefined) {\n
\t\t\t\tself.hasVisual = settings.visual;\n
\t\t\t}\n
\n
\t\t\teach(dom.select(\'table,a\', elm), function(elm) {\n
\t\t\t\tvar value;\n
\n
\t\t\t\tswitch (elm.nodeName) {\n
\t\t\t\t\tcase \'TABLE\':\n
\t\t\t\t\t\tcls = settings.visual_table_class || \'mce-item-table\';\n
\t\t\t\t\t\tvalue = dom.getAttrib(elm, \'border\');\n
\n
\t\t\t\t\t\tif ((!value || value == \'0\') && self.hasVisual) {\n
\t\t\t\t\t\t\tdom.addClass(elm, cls);\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tdom.removeClass(elm, cls);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\tcase \'A\':\n
\t\t\t\t\t\tif (!dom.getAttrib(elm, \'href\', false)) {\n
\t\t\t\t\t\t\tvalue = dom.getAttrib(elm, \'name\') || elm.id;\n
\t\t\t\t\t\t\tcls = settings.visual_anchor_class || \'mce-item-anchor\';\n
\n
\t\t\t\t\t\t\tif (value && self.hasVisual) {\n
\t\t\t\t\t\t\t\tdom.addClass(elm, cls);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tdom.removeClass(elm, cls);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\tself.fire(\'VisualAid\', {element: elm, hasVisual: self.hasVisual});\n
\t\t},\n
\n
\t\t/**\n
\t\t * Removes the editor from the dom and tinymce collection.\n
\t\t *\n
\t\t * @method remove\n
\t\t */\n
\t\tremove: function() {\n
\t\t\tvar self = this;\n
\n
\t\t\tif (!self.removed) {\n
\t\t\t\tself.save();\n
\t\t\t\tself.removed = 1;\n
\t\t\t\tself.unbindAllNativeEvents();\n
\n
\t\t\t\t// Remove any hidden input\n
\t\t\t\tif (self.hasHiddenInput) {\n
\t\t\t\t\tDOM.remove(self.getElement().nextSibling);\n
\t\t\t\t}\n
\n
\t\t\t\tif (!self.inline) {\n
\t\t\t\t\t// IE 9 has a bug where the selection stops working if you place the\n
\t\t\t\t\t// caret inside the editor then remove the iframe\n
\t\t\t\t\tif (ie && ie < 10) {\n
\t\t\t\t\t\tself.getDoc().execCommand(\'SelectAll\', false, null);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tDOM.setStyle(self.id, \'display\', self.orgDisplay);\n
\t\t\t\t\tself.getBody().onload = null; // Prevent #6816\n
\t\t\t\t}\n
\n
\t\t\t\tself.fire(\'remove\');\n
\n
\t\t\t\tself.editorManager.remove(self);\n
\t\t\t\tDOM.remove(self.getContainer());\n
\t\t\t\tself.editorUpload.destroy();\n
\t\t\t\tself.destroy();\n
\t\t\t}\n
\t\t},\n
\n
\t\t/**\n
\t\t * Destroys the editor instance by removing all events, element references or other resources\n
\t\t * that could leak memory. This method will be called automatically when the page is unloaded\n
\t\t * but you can also call it directly if you know what you are doing.\n
\t\t *\n
\t\t * @method destroy\n
\t\t * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.\n
\t\t */\n
\t\tdestroy: function(automatic) {\n
\t\t\tvar self = this, form;\n
\n
\t\t\t// One time is enough\n
\t\t\tif (self.destroyed) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// If user manually calls destroy and not remove\n
\t\t\t// Users seems to have logic that calls destroy instead of remove\n
\t\t\tif (!automatic && !self.removed) {\n
\t\t\t\tself.remove();\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (!automatic) {\n
\t\t\t\tself.editorManager.off(\'beforeunload\', self._beforeUnload);\n
\n
\t\t\t\t// Manual destroy\n
\t\t\t\tif (self.theme && self.theme.destroy) {\n
\t\t\t\t\tself.theme.destroy();\n
\t\t\t\t}\n
\n
\t\t\t\t// Destroy controls, selection and dom\n
\t\t\t\tself.selection.destroy();\n
\t\t\t\tself.dom.destroy();\n
\t\t\t}\n
\n
\t\t\tform = self.formElement;\n
\t\t\tif (form) {\n
\t\t\t\tif (form._mceOldSubmit) {\n
\t\t\t\t\tform.submit = form._mceOldSubmit;\n
\t\t\t\t\tform._mceOldSubmit = null;\n
\t\t\t\t}\n
\n
\t\t\t\tDOM.unbind(form, \'submit reset\', self.formEventDelegate);\n
\t\t\t}\n
\n
\t\t\tself.contentAreaContainer = self.formElement = self.container = self.editorContainer = null;\n
\t\t\tself.bodyElement = self.contentDocument = self.contentWindow = null;\n
\t\t\tself.iframeElement = self.targetElm = null;\n
\n
\t\t\tif (self.selection) {\n
\t\t\t\tself.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = null;\n
\t\t\t}\n
\n
\t\t\tself.destroyed = 1;\n
\t\t},\n
\n
\t\t/**\n
\t\t * Uploads all data uri/blob uri images in the editor contents to server.\n
\t\t *\n
\t\t * @method uploadImages\n
\t\t * @param {function} callback Optional callback with images and status for each image.\n
\t\t * @return {tinymce.util.Promise} Promise instance.\n
\t\t */\n
\t\tuploadImages: function(callback) {\n
\t\t\treturn this.editorUpload.uploadImages(callback);\n
\t\t},\n
\n
\t\t// Internal functions\n
\n
\t\t_scanForImages: function() {\n
\t\t\treturn this.editorUpload.scanForImages();\n
\t\t},\n
\n
\t\t_refreshContentEditable: function() {\n
\t\t\tvar self = this, body, parent;\n
\n
\t\t\t// Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again\n
\t\t\tif (self._isHidden()) {\n
\t\t\t\tbody = self.getBody();\n
\t\t\t\tparent = body.parentNode;\n
\n
\t\t\t\tparent.removeChild(body);\n
\t\t\t\tparent.appendChild(body);\n
\n
\t\t\t\tbody.focus();\n
\t\t\t}\n
\t\t},\n
\n
\t\t_isHidden: function() {\n
\t\t\tvar sel;\n
\n
\t\t\tif (!isGecko) {\n
\t\t\t\treturn 0;\n
\t\t\t}\n
\n
\t\t\t// Weird, wheres that cursor selection?\n
\t\t\tsel = this.selection.getSel();\n
\t\t\treturn (!sel || !sel.rangeCount || sel.rangeCount === 0);\n
\t\t}\n
\t};\n
\n
\textend(Editor.prototype, EditorObservable);\n
\n
\treturn Editor;\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>62155</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Editor.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
