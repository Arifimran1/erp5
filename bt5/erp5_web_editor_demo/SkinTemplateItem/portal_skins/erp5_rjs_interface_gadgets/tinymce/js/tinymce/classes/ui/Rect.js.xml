<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268332.93</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Rect.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Rect.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * Contains various tools for rect/position calculation.\n
 *\n
 * @class tinymce.ui.Rect\n
 */\n
define("tinymce/ui/Rect", [\n
], function() {\n
\t"use strict";\n
\n
\tvar min = Math.min, max = Math.max, round = Math.round;\n
\n
\t/**\n
\t * Returns the rect positioned based on the relative position name\n
\t * to the target rect.\n
\t *\n
\t * @method relativePosition\n
\t * @param {Rect} rect Source rect to modify into a new rect.\n
\t * @param {Rect} targetRect Rect to move relative to based on the rel option.\n
\t * @param {String} rel Relative position. For example: tr-bl.\n
\t */\n
\tfunction relativePosition(rect, targetRect, rel) {\n
\t\tvar x, y, w, h, targetW, targetH;\n
\n
\t\tx = targetRect.x;\n
\t\ty = targetRect.y;\n
\t\tw = rect.w;\n
\t\th = rect.h;\n
\t\ttargetW = targetRect.w;\n
\t\ttargetH = targetRect.h;\n
\n
\t\trel = (rel || \'\').split(\'\');\n
\n
\t\tif (rel[0] === \'b\') {\n
\t\t\ty += targetH;\n
\t\t}\n
\n
\t\tif (rel[1] === \'r\') {\n
\t\t\tx += targetW;\n
\t\t}\n
\n
\t\tif (rel[0] === \'c\') {\n
\t\t\ty += round(targetH / 2);\n
\t\t}\n
\n
\t\tif (rel[1] === \'c\') {\n
\t\t\tx += round(targetW / 2);\n
\t\t}\n
\n
\t\tif (rel[3] === \'b\') {\n
\t\t\ty -= h;\n
\t\t}\n
\n
\t\tif (rel[4] === \'r\') {\n
\t\t\tx -= w;\n
\t\t}\n
\n
\t\tif (rel[3] === \'c\') {\n
\t\t\ty -= round(h / 2);\n
\t\t}\n
\n
\t\tif (rel[4] === \'c\') {\n
\t\t\tx -= round(w / 2);\n
\t\t}\n
\n
\t\treturn {x: x, y: y, w: w, h: h};\n
\t}\n
\n
\t/**\n
\t * Tests various positions to get the most suitable one.\n
\t *\n
\t * @method findBestRelativePosition\n
\t * @param {Rect} Rect Rect to use as source.\n
\t * @param {Rect} targetRect Rect to move relative to.\n
\t * @param {Rect} constrainRect Rect to constrain within.\n
\t * @param {Array} Array of relative positions to test against.\n
\t */\n
\tfunction findBestRelativePosition(rect, targetRect, constrainRect, rels) {\n
\t\tvar pos, i;\n
\n
\t\tfor (i = 0; i < rels.length; i++) {\n
\t\t\tpos = relativePosition(rect, targetRect, rels[i]);\n
\n
\t\t\tif (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&\n
\t\t\t\tpos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n
\t\t\t\treturn rels[i];\n
\t\t\t}\n
\t\t}\n
\t}\n
\n
\t/**\n
\t * Inflates the rect in all directions.\n
\t *\n
\t * @method inflate\n
\t * @param {Rect} rect Rect to expand.\n
\t * @param {Number} w Relative width to expand by.\n
\t * @param {Number} h Relative height to expand by.\n
\t * @return {Rect} New expanded rect.\n
\t */\n
\tfunction inflate(rect, w, h) {\n
\t\treturn {\n
\t\t\tx: rect.x - w,\n
\t\t\ty: rect.y - h,\n
\t\t\tw: rect.w + w * 2,\n
\t\t\th: rect.h + h * 2\n
\t\t};\n
\t}\n
\n
\t/**\n
\t * Returns the intersection of the specified rectangles.\n
\t *\n
\t * @method intersect\n
\t * @param {Rect} rect The first rectangle to compare.\n
\t * @param {Rect} cropRect The second rectangle to compare.\n
\t * @return {Rect} The intersection of the two rectangles or null if they don\'t intersect.\n
\t */\n
\tfunction intersect(rect1, rect2) {\n
\t\tvar x1, y1, x2, y2;\n
\n
\t\tx1 = max(rect1.x, rect2.x);\n
\t\ty1 = max(rect1.y, rect2.y);\n
\t\tx2 = min(rect1.x + rect1.w, rect2.x + rect2.w);\n
\t\ty2 = min(rect1.y + rect1.h, rect2.y + rect2.h);\n
\n
\t\tif (x2 - x1 < 0 || y2 - y1 < 0) {\n
\t\t\treturn null;\n
\t\t}\n
\n
\t\treturn {x: x1, y: y1, w: x2 - x1, h: y2 - y1};\n
\t}\n
\n
\t/**\n
\t * Returns a rect clamped within the specified clamp rect. This forces the\n
\t * rect to be inside the clamp rect.\n
\t *\n
\t * @method clamp\n
\t * @param {Rect} rect Rectangle to force within clamp rect.\n
\t * @param {Rect} clampRect Rectable to force within.\n
\t * @param {Boolean} fixedSize True/false if size should be fixed.\n
\t * @return {Rect} Clamped rect.\n
\t */\n
\tfunction clamp(rect, clampRect, fixedSize) {\n
\t\tvar underflowX1, underflowY1, overflowX2, overflowY2,\n
\t\t\tx1, y1, x2, y2, cx2, cy2;\n
\n
\t\tx1 = rect.x;\n
\t\ty1 = rect.y;\n
\t\tx2 = rect.x + rect.w;\n
\t\ty2 = rect.y + rect.h;\n
\t\tcx2 = clampRect.x + clampRect.w;\n
\t\tcy2 = clampRect.y + clampRect.h;\n
\n
\t\tunderflowX1 = max(0, clampRect.x - x1);\n
\t\tunderflowY1 = max(0, clampRect.y - y1);\n
\t\toverflowX2 = max(0, x2 - cx2);\n
\t\toverflowY2 = max(0, y2 - cy2);\n
\n
\t\tx1 += underflowX1;\n
\t\ty1 += underflowY1;\n
\n
\t\tif (fixedSize) {\n
\t\t\tx2 += underflowX1;\n
\t\t\ty2 += underflowY1;\n
\t\t\tx1 -= overflowX2;\n
\t\t\ty1 -= overflowY2;\n
\t\t}\n
\n
\t\tx2 -= overflowX2;\n
\t\ty2 -= overflowY2;\n
\n
\t\treturn {x: x1, y: y1, w: x2 - x1, h: y2 - y1};\n
\t}\n
\n
\treturn {\n
\t\tinflate: inflate,\n
\t\trelativePosition: relativePosition,\n
\t\tfindBestRelativePosition: findBestRelativePosition,\n
\t\tintersect: intersect,\n
\t\tclamp: clamp\n
\t};\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>4382</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>Rect.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
