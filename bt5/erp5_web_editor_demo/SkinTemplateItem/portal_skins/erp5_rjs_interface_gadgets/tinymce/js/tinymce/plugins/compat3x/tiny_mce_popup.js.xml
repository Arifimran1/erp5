<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268406.94</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>tiny_mce_popup.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * tinymce_mce_popup.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
var tinymce, tinyMCE;\n
\n
/**\n
 * TinyMCE popup/dialog helper class. This gives you easy access to the\n
 * parent editor instance and a bunch of other things. It\'s higly recommended\n
 * that you load this script into your dialogs.\n
 *\n
 * @static\n
 * @class tinyMCEPopup\n
 */\n
var tinyMCEPopup = {\n
\t/**\n
\t * Initializes the popup this will be called automatically.\n
\t *\n
\t * @method init\n
\t */\n
\tinit: function() {\n
\t\tvar self = this, parentWin, settings, uiWindow;\n
\n
\t\t// Find window & API\n
\t\tparentWin = self.getWin();\n
\t\ttinymce = tinyMCE = parentWin.tinymce;\n
\t\tself.editor = tinymce.EditorManager.activeEditor;\n
\t\tself.params = self.editor.windowManager.getParams();\n
\n
\t\tuiWindow = self.editor.windowManager.windows[self.editor.windowManager.windows.length - 1];\n
\t\tself.features = uiWindow.features;\n
\t\tself.uiWindow = uiWindow;\n
\n
\t\tsettings = self.editor.settings;\n
\n
\t\t// Setup popup CSS path(s)\n
\t\tif (settings.popup_css !== false) {\n
\t\t\tif (settings.popup_css) {\n
\t\t\t\tsettings.popup_css = self.editor.documentBaseURI.toAbsolute(settings.popup_css);\n
\t\t\t} else {\n
\t\t\t\tsettings.popup_css = self.editor.baseURI.toAbsolute("plugins/compat3x/css/dialog.css");\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (settings.popup_css_add) {\n
\t\t\tsettings.popup_css += \',\' + self.editor.documentBaseURI.toAbsolute(settings.popup_css_add);\n
\t\t}\n
\n
\t\t// Setup local DOM\n
\t\tself.dom = self.editor.windowManager.createInstance(\'tinymce.dom.DOMUtils\', document, {\n
\t\t\townEvents: true,\n
\t\t\tproxy: tinyMCEPopup._eventProxy\n
\t\t});\n
\n
\t\tself.dom.bind(window, \'ready\', self._onDOMLoaded, self);\n
\n
\t\t// Enables you to skip loading the default css\n
\t\tif (self.features.popup_css !== false) {\n
\t\t\tself.dom.loadCSS(self.features.popup_css || self.editor.settings.popup_css);\n
\t\t}\n
\n
\t\t// Setup on init listeners\n
\t\tself.listeners = [];\n
\n
\t\t/**\n
\t\t * Fires when the popup is initialized.\n
\t\t *\n
\t\t * @event onInit\n
\t\t * @param {tinymce.Editor} editor Editor instance.\n
\t\t * @example\n
\t\t * // Alerts the selected contents when the dialog is loaded\n
\t\t * tinyMCEPopup.onInit.add(function(ed) {\n
\t\t *     alert(ed.selection.getContent());\n
\t\t * });\n
\t\t *\n
\t\t * // Executes the init method on page load in some object using the SomeObject scope\n
\t\t * tinyMCEPopup.onInit.add(SomeObject.init, SomeObject);\n
\t\t */\n
\t\tself.onInit = {\n
\t\t\tadd: function(func, scope) {\n
\t\t\t\tself.listeners.push({func : func, scope : scope});\n
\t\t\t}\n
\t\t};\n
\n
\t\tself.isWindow = !self.getWindowArg(\'mce_inline\');\n
\t\tself.id = self.getWindowArg(\'mce_window_id\');\n
\t},\n
\n
\t/**\n
\t * Returns the reference to the parent window that opened the dialog.\n
\t *\n
\t * @method getWin\n
\t * @return {Window} Reference to the parent window that opened the dialog.\n
\t */\n
\tgetWin: function() {\n
\t\t// Added frameElement check to fix bug: #2817583\n
\t\treturn (!window.frameElement && window.dialogArguments) || opener || parent || top;\n
\t},\n
\n
\t/**\n
\t * Returns a window argument/parameter by name.\n
\t *\n
\t * @method getWindowArg\n
\t * @param {String} name Name of the window argument to retrive.\n
\t * @param {String} defaultValue Optional default value to return.\n
\t * @return {String} Argument value or default value if it wasn\'t found.\n
\t */\n
\tgetWindowArg : function(name, defaultValue) {\n
\t\tvar value = this.params[name];\n
\n
\t\treturn tinymce.is(value) ? value : defaultValue;\n
\t},\n
\n
\t/**\n
\t * Returns a editor parameter/config option value.\n
\t *\n
\t * @method getParam\n
\t * @param {String} name Name of the editor config option to retrive.\n
\t * @param {String} defaultValue Optional default value to return.\n
\t * @return {String} Parameter value or default value if it wasn\'t found.\n
\t */\n
\tgetParam : function(name, defaultValue) {\n
\t\treturn this.editor.getParam(name, defaultValue);\n
\t},\n
\n
\t/**\n
\t * Returns a language item by key.\n
\t *\n
\t * @method getLang\n
\t * @param {String} name Language item like mydialog.something.\n
\t * @param {String} defaultValue Optional default value to return.\n
\t * @return {String} Language value for the item like "my string" or the default value if it wasn\'t found.\n
\t */\n
\tgetLang : function(name, defaultValue) {\n
\t\treturn this.editor.getLang(name, defaultValue);\n
\t},\n
\n
\t/**\n
\t * Executed a command on editor that opened the dialog/popup.\n
\t *\n
\t * @method execCommand\n
\t * @param {String} cmd Command to execute.\n
\t * @param {Boolean} ui Optional boolean value if the UI for the command should be presented or not.\n
\t * @param {Object} val Optional value to pass with the comman like an URL.\n
\t * @param {Object} a Optional arguments object.\n
\t */\n
\texecCommand : function(cmd, ui, val, args) {\n
\t\targs = args || {};\n
\t\targs.skip_focus = 1;\n
\n
\t\tthis.restoreSelection();\n
\t\treturn this.editor.execCommand(cmd, ui, val, args);\n
\t},\n
\n
\t/**\n
\t * Resizes the dialog to the inner size of the window. This is needed since various browsers\n
\t * have different border sizes on windows.\n
\t *\n
\t * @method resizeToInnerSize\n
\t */\n
\tresizeToInnerSize : function() {\n
\t\t/*var self = this;\n
\n
\t\t// Detach it to workaround a Chrome specific bug\n
\t\t// https://sourceforge.net/tracker/?func=detail&atid=635682&aid=2926339&group_id=103281\n
\t\tsetTimeout(function() {\n
\t\t\tvar vp = self.dom.getViewPort(window);\n
\n
\t\t\tself.editor.windowManager.resizeBy(\n
\t\t\t\tself.getWindowArg(\'mce_width\') - vp.w,\n
\t\t\t\tself.getWindowArg(\'mce_height\') - vp.h,\n
\t\t\t\tself.id || window\n
\t\t\t);\n
\t\t}, 10);*/\n
\t},\n
\n
\t/**\n
\t * Will executed the specified string when the page has been loaded. This function\n
\t * was added for compatibility with the 2.x branch.\n
\t *\n
\t * @method executeOnLoad\n
\t * @param {String} evil String to evalutate on init.\n
\t */\n
\texecuteOnLoad : function(evil) {\n
\t\tthis.onInit.add(function() {\n
\t\t\teval(evil);\n
\t\t});\n
\t},\n
\n
\t/**\n
\t * Stores the current editor selection for later restoration. This can be useful since some browsers\n
\t * looses it\'s selection if a control element is selected/focused inside the dialogs.\n
\t *\n
\t * @method storeSelection\n
\t */\n
\tstoreSelection : function() {\n
\t\tthis.editor.windowManager.bookmark = tinyMCEPopup.editor.selection.getBookmark(1);\n
\t},\n
\n
\t/**\n
\t * Restores any stored selection. This can be useful since some browsers\n
\t * looses it\'s selection if a control element is selected/focused inside the dialogs.\n
\t *\n
\t * @method restoreSelection\n
\t */\n
\trestoreSelection : function() {\n
\t\tvar self = tinyMCEPopup;\n
\n
\t\tif (!self.isWindow && tinymce.isIE) {\n
\t\t\tself.editor.selection.moveToBookmark(self.editor.windowManager.bookmark);\n
\t\t}\n
\t},\n
\n
\t/**\n
\t * Loads a specific dialog language pack. If you pass in plugin_url as a argument\n
\t * when you open the window it will load the <plugin url>/langs/<code>_dlg.js lang pack file.\n
\t *\n
\t * @method requireLangPack\n
\t */\n
\trequireLangPack : function() {\n
\t\tvar self = this, url = self.getWindowArg(\'plugin_url\') || self.getWindowArg(\'theme_url\'), settings = self.editor.settings, lang;\n
\n
\t\tif (settings.language !== false) {\n
\t\t\tlang = settings.language || "en";\n
\t\t}\n
\n
\t\tif (url && lang && self.features.translate_i18n !== false && settings.language_load !== false) {\n
\t\t\turl += \'/langs/\' + lang + \'_dlg.js\';\n
\n
\t\t\tif (!tinymce.ScriptLoader.isDone(url)) {\n
\t\t\t\tdocument.write(\'<script type="text/javascript" src="\' + url + \'"></script>\');\n
\t\t\t\ttinymce.ScriptLoader.markDone(url);\n
\t\t\t}\n
\t\t}\n
\t},\n
\n
\t/**\n
\t * Executes a color picker on the specified element id. When the user\n
\t * then selects a color it will be set as the value of the specified element.\n
\t *\n
\t * @method pickColor\n
\t * @param {DOMEvent} e DOM event object.\n
\t * @param {string} element_id Element id to be filled with the color value from the picker.\n
\t */\n
\tpickColor : function(e, element_id) {\n
\t\tvar el = document.getElementById(element_id), colorPickerCallback = this.editor.settings.color_picker_callback;\n
\t\tif (colorPickerCallback) {\n
\t\t\tcolorPickerCallback.call(\n
\t\t\t\tthis.editor,\n
\t\t\t\tfunction (value) {\n
\t\t\t\t\tel.value = value;\n
\t\t\t\t\ttry {\n
\t\t\t\t\t\tel.onchange();\n
\t\t\t\t\t} catch (ex) {\n
\t\t\t\t\t\t// Try fire event, ignore errors\n
\t\t\t\t\t}\n
\t\t\t\t},\n
\t\t\t\tel.value\n
\t\t\t);\n
\t\t}\n
\t},\n
\n
\t/**\n
\t * Opens a filebrowser/imagebrowser this will set the output value from\n
\t * the browser as a value on the specified element.\n
\t *\n
\t * @method openBrowser\n
\t * @param {string} element_id Id of the element to set value in.\n
\t * @param {string} type Type of browser to open image/file/flash.\n
\t * @param {string} option Option name to get the file_broswer_callback function name from.\n
\t */\n
\topenBrowser : function(element_id, type) {\n
\t\ttinyMCEPopup.restoreSelection();\n
\t\tthis.editor.execCallback(\'file_browser_callback\', element_id, document.getElementById(element_id).value, type, window);\n
\t},\n
\n
\t/**\n
\t * Creates a confirm dialog. Please don\'t use the blocking behavior of this\n
\t * native version use the callback method instead then it can be extended.\n
\t *\n
\t * @method confirm\n
\t * @param {String} t Title for the new confirm dialog.\n
\t * @param {function} cb Callback function to be executed after the user has selected ok or cancel.\n
\t * @param {Object} s Optional scope to execute the callback in.\n
\t */\n
\tconfirm : function(t, cb, s) {\n
\t\tthis.editor.windowManager.confirm(t, cb, s, window);\n
\t},\n
\n
\t/**\n
\t * Creates a alert dialog. Please don\'t use the blocking behavior of this\n
\t * native version use the callback method instead then it can be extended.\n
\t *\n
\t * @method alert\n
\t * @param {String} tx Title for the new alert dialog.\n
\t * @param {function} cb Callback function to be executed after the user has selected ok.\n
\t * @param {Object} s Optional scope to execute the callback in.\n
\t */\n
\talert : function(tx, cb, s) {\n
\t\tthis.editor.windowManager.alert(tx, cb, s, window);\n
\t},\n
\n
\t/**\n
\t * Closes the current window.\n
\t *\n
\t * @method close\n
\t */\n
\tclose : function() {\n
\t\tvar t = this;\n
\n
\t\t// To avoid domain relaxing issue in Opera\n
\t\tfunction close() {\n
\t\t\tt.editor.windowManager.close(window);\n
\t\t\ttinymce = tinyMCE = t.editor = t.params = t.dom = t.dom.doc = null; // Cleanup\n
\t\t}\n
\n
\t\tif (tinymce.isOpera) {\n
\t\t\tt.getWin().setTimeout(close, 0);\n
\t\t} else {\n
\t\t\tclose();\n
\t\t}\n
\t},\n
\n
\t// Internal functions\n
\n
\t_restoreSelection : function() {\n
\t\tvar e = window.event.srcElement;\n
\n
\t\tif (e.nodeName == \'INPUT\' && (e.type == \'submit\' || e.type == \'button\')) {\n
\t\t\ttinyMCEPopup.restoreSelection();\n
\t\t}\n
\t},\n
\n
/*\t_restoreSelection : function() {\n
\t\tvar e = window.event.srcElement;\n
\n
\t\t// If user focus a non text input or textarea\n
\t\tif ((e.nodeName != \'INPUT\' && e.nodeName != \'TEXTAREA\') || e.type != \'text\')\n
\t\t\ttinyMCEPopup.restoreSelection();\n
\t},*/\n
\n
\t_onDOMLoaded : function() {\n
\t\tvar t = tinyMCEPopup, ti = document.title, h, nv;\n
\n
\t\t// Translate page\n
\t\tif (t.features.translate_i18n !== false) {\n
\t\t\tvar map = {\n
\t\t\t\t"update": "Ok",\n
\t\t\t\t"insert": "Ok",\n
\t\t\t\t"cancel": "Cancel",\n
\t\t\t\t"not_set": "--",\n
\t\t\t\t"class_name": "Class name",\n
\t\t\t\t"browse": "Browse"\n
\t\t\t};\n
\n
\t\t\tvar langCode = (tinymce.settings ? tinymce.settings : t.editor.settings).language || \'en\';\n
\t\t\tfor (var key in map) {\n
\t\t\t\ttinymce.i18n.data[langCode + "." + key] = tinymce.i18n.translate(map[key]);\n
\t\t\t}\n
\n
\t\t\th = document.body.innerHTML;\n
\n
\t\t\t// Replace a=x with a="x" in IE\n
\t\t\tif (tinymce.isIE) {\n
\t\t\t\th = h.replace(/ (value|title|alt)=([^"][^\\s>]+)/gi, \' $1="$2"\');\n
\t\t\t}\n
\n
\t\t\tdocument.dir = t.editor.getParam(\'directionality\',\'\');\n
\n
\t\t\tif ((nv = t.editor.translate(h)) && nv != h) {\n
\t\t\t\tdocument.body.innerHTML = nv;\n
\t\t\t}\n
\n
\t\t\tif ((nv = t.editor.translate(ti)) && nv != ti) {\n
\t\t\t\tdocument.title = ti = nv;\n
\t\t\t}\n
\t\t}\n
\n
\t\tif (!t.editor.getParam(\'browser_preferred_colors\', false) || !t.isWindow) {\n
\t\t\tt.dom.addClass(document.body, \'forceColors\');\n
\t\t}\n
\n
\t\tdocument.body.style.display = \'\';\n
\n
\t\t// Restore selection in IE when focus is placed on a non textarea or input element of the type text\n
\t\tif (tinymce.Env.ie) {\n
\t\t\tif (tinymce.Env.ie < 11) {\n
\t\t\t\tdocument.attachEvent(\'onmouseup\', tinyMCEPopup._restoreSelection);\n
\n
\t\t\t\t// Add base target element for it since it would fail with modal dialogs\n
\t\t\t\tt.dom.add(t.dom.select(\'head\')[0], \'base\', {target: \'_self\'});\n
\t\t\t} else {\n
\t\t\t\tdocument.addEventListener(\'mouseup\', tinyMCEPopup._restoreSelection, false);\n
\t\t\t}\n
\t\t}\n
\n
\t\tt.restoreSelection();\n
\t\tt.resizeToInnerSize();\n
\n
\t\t// Set inline title\n
\t\tif (!t.isWindow) {\n
\t\t\tt.editor.windowManager.setTitle(window, ti);\n
\t\t} else {\n
\t\t\twindow.focus();\n
\t\t}\n
\n
\t\tif (!tinymce.isIE && !t.isWindow) {\n
\t\t\tt.dom.bind(document, \'focus\', function() {\n
\t\t\t\tt.editor.windowManager.focus(t.id);\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Patch for accessibility\n
\t\ttinymce.each(t.dom.select(\'select\'), function(e) {\n
\t\t\te.onkeydown = tinyMCEPopup._accessHandler;\n
\t\t});\n
\n
\t\t// Call onInit\n
\t\t// Init must be called before focus so the selection won\'t get lost by the focus call\n
\t\ttinymce.each(t.listeners, function(o) {\n
\t\t\to.func.call(o.scope, t.editor);\n
\t\t});\n
\n
\t\t// Move focus to window\n
\t\tif (t.getWindowArg(\'mce_auto_focus\', true)) {\n
\t\t\twindow.focus();\n
\n
\t\t\t// Focus element with mceFocus class\n
\t\t\ttinymce.each(document.forms, function(f) {\n
\t\t\t\ttinymce.each(f.elements, function(e) {\n
\t\t\t\t\tif (t.dom.hasClass(e, \'mceFocus\') && !e.disabled) {\n
\t\t\t\t\t\te.focus();\n
\t\t\t\t\t\treturn false; // Break loop\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\t\t\t});\n
\t\t}\n
\n
\t\tdocument.onkeyup = tinyMCEPopup._closeWinKeyHandler;\n
\n
\t\tif (\'textContent\' in document) {\n
\t\t\tt.uiWindow.getEl(\'head\').firstChild.textContent = document.title;\n
\t\t} else {\n
\t\t\tt.uiWindow.getEl(\'head\').firstChild.innerText = document.title;\n
\t\t}\n
\t},\n
\n
\t_accessHandler : function(e) {\n
\t\te = e || window.event;\n
\n
\t\tif (e.keyCode == 13 || e.keyCode == 32) {\n
\t\t\tvar elm = e.target || e.srcElement;\n
\n
\t\t\tif (elm.onchange) {\n
\t\t\t\telm.onchange();\n
\t\t\t}\n
\n
\t\t\treturn tinymce.dom.Event.cancel(e);\n
\t\t}\n
\t},\n
\n
\t_closeWinKeyHandler : function(e) {\n
\t\te = e || window.event;\n
\n
\t\tif (e.keyCode == 27) {\n
\t\t\ttinyMCEPopup.close();\n
\t\t}\n
\t},\n
\n
\t_eventProxy: function(id) {\n
\t\treturn function(evt) {\n
\t\t\ttinyMCEPopup.dom.events.callNativeHandler(id, evt);\n
\t\t};\n
\t}\n
};\n
\n
tinyMCEPopup.init();\n
\n
tinymce.util.Dispatcher = function(scope) {\n
\tthis.scope = scope || this;\n
\tthis.listeners = [];\n
\n
\tthis.add = function(callback, scope) {\n
\t\tthis.listeners.push({cb : callback, scope : scope || this.scope});\n
\n
\t\treturn callback;\n
\t};\n
\n
\tthis.addToTop = function(callback, scope) {\n
\t\tvar self = this, listener = {cb : callback, scope : scope || self.scope};\n
\n
\t\t// Create new listeners if addToTop is executed in a dispatch loop\n
\t\tif (self.inDispatch) {\n
\t\t\tself.listeners = [listener].concat(self.listeners);\n
\t\t} else {\n
\t\t\tself.listeners.unshift(listener);\n
\t\t}\n
\n
\t\treturn callback;\n
\t};\n
\n
\tthis.remove = function(callback) {\n
\t\tvar listeners = this.listeners, output = null;\n
\n
\t\ttinymce.each(listeners, function(listener, i) {\n
\t\t\tif (callback == listener.cb) {\n
\t\t\t\toutput = listener;\n
\t\t\t\tlisteners.splice(i, 1);\n
\t\t\t\treturn false;\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn output;\n
\t};\n
\n
\tthis.dispatch = function() {\n
\t\tvar self = this, returnValue, args = arguments, i, listeners = self.listeners, listener;\n
\n
\t\tself.inDispatch = true;\n
\n
\t\t// Needs to be a real loop since the listener count might change while looping\n
\t\t// And this is also more efficient\n
\t\tfor (i = 0; i < listeners.length; i++) {\n
\t\t\tlistener = listeners[i];\n
\t\t\treturnValue = listener.cb.apply(listener.scope, args.length > 0 ? args : [listener.scope]);\n
\n
\t\t\tif (returnValue === false) {\n
\t\t\t\tbreak;\n
\t\t\t}\n
\t\t}\n
\n
\t\tself.inDispatch = false;\n
\n
\t\treturn returnValue;\n
\t};\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>15089</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>tiny_mce_popup.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
