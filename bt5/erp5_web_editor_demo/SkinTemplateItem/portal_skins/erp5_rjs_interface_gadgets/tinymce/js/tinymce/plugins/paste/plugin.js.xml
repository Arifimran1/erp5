<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268454.94</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>plugin.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * Compiled inline version. (Library mode)\n
 */\n
\n
/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */\n
/*globals $code */\n
\n
(function(exports, undefined) {\n
\t"use strict";\n
\n
\tvar modules = {};\n
\n
\tfunction require(ids, callback) {\n
\t\tvar module, defs = [];\n
\n
\t\tfor (var i = 0; i < ids.length; ++i) {\n
\t\t\tmodule = modules[ids[i]] || resolve(ids[i]);\n
\t\t\tif (!module) {\n
\t\t\t\tthrow \'module definition dependecy not found: \' + ids[i];\n
\t\t\t}\n
\n
\t\t\tdefs.push(module);\n
\t\t}\n
\n
\t\tcallback.apply(null, defs);\n
\t}\n
\n
\tfunction define(id, dependencies, definition) {\n
\t\tif (typeof id !== \'string\') {\n
\t\t\tthrow \'invalid module definition, module id must be defined and be a string\';\n
\t\t}\n
\n
\t\tif (dependencies === undefined) {\n
\t\t\tthrow \'invalid module definition, dependencies must be specified\';\n
\t\t}\n
\n
\t\tif (definition === undefined) {\n
\t\t\tthrow \'invalid module definition, definition function must be specified\';\n
\t\t}\n
\n
\t\trequire(dependencies, function() {\n
\t\t\tmodules[id] = definition.apply(null, arguments);\n
\t\t});\n
\t}\n
\n
\tfunction defined(id) {\n
\t\treturn !!modules[id];\n
\t}\n
\n
\tfunction resolve(id) {\n
\t\tvar target = exports;\n
\t\tvar fragments = id.split(/[.\\/]/);\n
\n
\t\tfor (var fi = 0; fi < fragments.length; ++fi) {\n
\t\t\tif (!target[fragments[fi]]) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\ttarget = target[fragments[fi]];\n
\t\t}\n
\n
\t\treturn target;\n
\t}\n
\n
\tfunction expose(ids) {\n
\t\tfor (var i = 0; i < ids.length; i++) {\n
\t\t\tvar target = exports;\n
\t\t\tvar id = ids[i];\n
\t\t\tvar fragments = id.split(/[.\\/]/);\n
\n
\t\t\tfor (var fi = 0; fi < fragments.length - 1; ++fi) {\n
\t\t\t\tif (target[fragments[fi]] === undefined) {\n
\t\t\t\t\ttarget[fragments[fi]] = {};\n
\t\t\t\t}\n
\n
\t\t\t\ttarget = target[fragments[fi]];\n
\t\t\t}\n
\n
\t\t\ttarget[fragments[fragments.length - 1]] = modules[id];\n
\t\t}\n
\t}\n
\n
// Included from: js/tinymce/plugins/paste/classes/Utils.js\n
\n
/**\n
 * Utils.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contails various utility functions for the paste plugin.\n
 *\n
 * @class tinymce.pasteplugin.Utils\n
 */\n
define("tinymce/pasteplugin/Utils", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/html/DomParser",\n
\t"tinymce/html/Schema"\n
], function(Tools, DomParser, Schema) {\n
\tfunction filter(content, items) {\n
\t\tTools.each(items, function(v) {\n
\t\t\tif (v.constructor == RegExp) {\n
\t\t\t\tcontent = content.replace(v, \'\');\n
\t\t\t} else {\n
\t\t\t\tcontent = content.replace(v[0], v[1]);\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn content;\n
\t}\n
\n
\t/**\n
\t * Gets the innerText of the specified element. It will handle edge cases\n
\t * and works better than textContent on Gecko.\n
\t *\n
\t * @param {String} html HTML string to get text from.\n
\t * @return {String} String of text with line feeds.\n
\t */\n
\tfunction innerText(html) {\n
\t\tvar schema = new Schema(), domParser = new DomParser({}, schema), text = \'\';\n
\t\tvar shortEndedElements = schema.getShortEndedElements();\n
\t\tvar ignoreElements = Tools.makeMap(\'script noscript style textarea video audio iframe object\', \' \');\n
\t\tvar blockElements = schema.getBlockElements();\n
\n
\t\tfunction walk(node) {\n
\t\t\tvar name = node.name, currentNode = node;\n
\n
\t\t\tif (name === \'br\') {\n
\t\t\t\ttext += \'\\n\';\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// img/input/hr\n
\t\t\tif (shortEndedElements[name]) {\n
\t\t\t\ttext += \' \';\n
\t\t\t}\n
\n
\t\t\t// Ingore script, video contents\n
\t\t\tif (ignoreElements[name]) {\n
\t\t\t\ttext += \' \';\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\tif (node.type == 3) {\n
\t\t\t\ttext += node.value;\n
\t\t\t}\n
\n
\t\t\t// Walk all children\n
\t\t\tif (!node.shortEnded) {\n
\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\tdo {\n
\t\t\t\t\t\twalk(node);\n
\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Add \\n or \\n\\n for blocks or P\n
\t\t\tif (blockElements[name] && currentNode.next) {\n
\t\t\t\ttext += \'\\n\';\n
\n
\t\t\t\tif (name == \'p\') {\n
\t\t\t\t\ttext += \'\\n\';\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\thtml = filter(html, [\n
\t\t\t/<!\\[[^\\]]+\\]>/g // Conditional comments\n
\t\t]);\n
\n
\t\twalk(domParser.parse(html));\n
\n
\t\treturn text;\n
\t}\n
\n
\t/**\n
\t * Trims the specified HTML by removing all WebKit fragments, all elements wrapping the body trailing BR elements etc.\n
\t *\n
\t * @param {String} html Html string to trim contents on.\n
\t * @return {String} Html contents that got trimmed.\n
\t */\n
\tfunction trimHtml(html) {\n
\t\tfunction trimSpaces(all, s1, s2) {\n
\t\t\t// WebKit &nbsp; meant to preserve multiple spaces but instead inserted around all inline tags,\n
\t\t\t// including the spans with inline styles created on paste\n
\t\t\tif (!s1 && !s2) {\n
\t\t\t\treturn \' \';\n
\t\t\t}\n
\n
\t\t\treturn \'\\u00a0\';\n
\t\t}\n
\n
\t\thtml = filter(html, [\n
\t\t\t/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/g, // Remove anything but the contents within the BODY element\n
\t\t\t/<!--StartFragment-->|<!--EndFragment-->/g, // Inner fragments (tables from excel on mac)\n
\t\t\t[/( ?)<span class="Apple-converted-space">\\u00a0<\\/span>( ?)/g, trimSpaces],\n
\t\t\t/<br>$/i // Trailing BR elements\n
\t\t]);\n
\n
\t\treturn html;\n
\t}\n
\n
\treturn {\n
\t\tfilter: filter,\n
\t\tinnerText: innerText,\n
\t\ttrimHtml: trimHtml\n
\t};\n
});\n
\n
// Included from: js/tinymce/plugins/paste/classes/Clipboard.js\n
\n
/**\n
 * Clipboard.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains logic for getting HTML contents out of the clipboard.\n
 *\n
 * We need to make a lot of ugly hacks to get the contents out of the clipboard since\n
 * the W3C Clipboard API is broken in all browsers that have it: Gecko/WebKit/Blink.\n
 * We might rewrite this the way those API:s stabilize. Browsers doesn\'t handle pasting\n
 * from applications like Word the same way as it does when pasting into a contentEditable area\n
 * so we need to do lots of extra work to try to get to this clipboard data.\n
 *\n
 * Current implementation steps:\n
 *  1. On keydown with paste keys Ctrl+V or Shift+Insert create\n
 *     a paste bin element and move focus to that element.\n
 *  2. Wait for the browser to fire a "paste" event and get the contents out of the paste bin.\n
 *  3. Check if the paste was successful if true, process the HTML.\n
 *  (4). If the paste was unsuccessful use IE execCommand, Clipboard API, document.dataTransfer old WebKit API etc.\n
 *\n
 * @class tinymce.pasteplugin.Clipboard\n
 * @private\n
 */\n
define("tinymce/pasteplugin/Clipboard", [\n
\t"tinymce/Env",\n
\t"tinymce/dom/RangeUtils",\n
\t"tinymce/util/VK",\n
\t"tinymce/pasteplugin/Utils"\n
], function(Env, RangeUtils, VK, Utils) {\n
\treturn function(editor) {\n
\t\tvar self = this, pasteBinElm, lastRng, keyboardPasteTimeStamp = 0, draggingInternally = false;\n
\t\tvar pasteBinDefaultContent = \'%MCEPASTEBIN%\', keyboardPastePlainTextState;\n
\t\tvar mceInternalUrlPrefix = \'data:text/mce-internal,\';\n
\n
\t\t/**\n
\t\t * Pastes the specified HTML. This means that the HTML is filtered and then\n
\t\t * inserted at the current selection in the editor. It will also fire paste events\n
\t\t * for custom user filtering.\n
\t\t *\n
\t\t * @param {String} html HTML code to paste into the current selection.\n
\t\t */\n
\t\tfunction pasteHtml(html) {\n
\t\t\tvar args, dom = editor.dom;\n
\n
\t\t\targs = editor.fire(\'BeforePastePreProcess\', {content: html}); // Internal event used by Quirks\n
\t\t\targs = editor.fire(\'PastePreProcess\', args);\n
\t\t\thtml = args.content;\n
\n
\t\t\tif (!args.isDefaultPrevented()) {\n
\t\t\t\t// User has bound PastePostProcess events then we need to pass it through a DOM node\n
\t\t\t\t// This is not ideal but we don\'t want to let the browser mess up the HTML for example\n
\t\t\t\t// some browsers add &nbsp; to P tags etc\n
\t\t\t\tif (editor.hasEventListeners(\'PastePostProcess\') && !args.isDefaultPrevented()) {\n
\t\t\t\t\t// We need to attach the element to the DOM so Sizzle selectors work on the contents\n
\t\t\t\t\tvar tempBody = dom.add(editor.getBody(), \'div\', {style: \'display:none\'}, html);\n
\t\t\t\t\targs = editor.fire(\'PastePostProcess\', {node: tempBody});\n
\t\t\t\t\tdom.remove(tempBody);\n
\t\t\t\t\thtml = args.node.innerHTML;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!args.isDefaultPrevented()) {\n
\t\t\t\t\teditor.insertContent(html, {merge: editor.settings.paste_merge_formats !== false, data: {paste: true}});\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Pastes the specified text. This means that the plain text is processed\n
\t\t * and converted into BR and P elements. It will fire paste events for custom filtering.\n
\t\t *\n
\t\t * @param {String} text Text to paste as the current selection location.\n
\t\t */\n
\t\tfunction pasteText(text) {\n
\t\t\ttext = editor.dom.encode(text).replace(/\\r\\n/g, \'\\n\');\n
\n
\t\t\tvar startBlock = editor.dom.getParent(editor.selection.getStart(), editor.dom.isBlock);\n
\n
\t\t\t// Create start block html for example <p attr="value">\n
\t\t\tvar forcedRootBlockName = editor.settings.forced_root_block;\n
\t\t\tvar forcedRootBlockStartHtml;\n
\t\t\tif (forcedRootBlockName) {\n
\t\t\t\tforcedRootBlockStartHtml = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs);\n
\t\t\t\tforcedRootBlockStartHtml = forcedRootBlockStartHtml.substr(0, forcedRootBlockStartHtml.length - 3) + \'>\';\n
\t\t\t}\n
\n
\t\t\tif ((startBlock && /^(PRE|DIV)$/.test(startBlock.nodeName)) || !forcedRootBlockName) {\n
\t\t\t\ttext = Utils.filter(text, [\n
\t\t\t\t\t[/\\n/g, "<br>"]\n
\t\t\t\t]);\n
\t\t\t} else {\n
\t\t\t\ttext = Utils.filter(text, [\n
\t\t\t\t\t[/\\n\\n/g, "</p>" + forcedRootBlockStartHtml],\n
\t\t\t\t\t[/^(.*<\\/p>)(<p>)$/, forcedRootBlockStartHtml + \'$1\'],\n
\t\t\t\t\t[/\\n/g, "<br />"]\n
\t\t\t\t]);\n
\n
\t\t\t\tif (text.indexOf(\'<p>\') != -1) {\n
\t\t\t\t\ttext = forcedRootBlockStartHtml + text;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tpasteHtml(text);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Creates a paste bin element as close as possible to the current caret location and places the focus inside that element\n
\t\t * so that when the real paste event occurs the contents gets inserted into this element\n
\t\t * instead of the current editor selection element.\n
\t\t */\n
\t\tfunction createPasteBin() {\n
\t\t\tvar dom = editor.dom, body = editor.getBody();\n
\t\t\tvar viewport = editor.dom.getViewPort(editor.getWin()), scrollTop = viewport.y, top = 20;\n
\t\t\tvar scrollContainer;\n
\n
\t\t\tlastRng = editor.selection.getRng();\n
\n
\t\t\tif (editor.inline) {\n
\t\t\t\tscrollContainer = editor.selection.getScrollContainer();\n
\n
\t\t\t\t// Can\'t always rely on scrollTop returning a useful value.\n
\t\t\t\t// It returns 0 if the browser doesn\'t support scrollTop for the element or is non-scrollable\n
\t\t\t\tif (scrollContainer && scrollContainer.scrollTop > 0) {\n
\t\t\t\t\tscrollTop = scrollContainer.scrollTop;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Returns the rect of the current caret if the caret is in an empty block before a\n
\t\t\t * BR we insert a temporary invisible character that we get the rect this way we always get a proper rect.\n
\t\t\t *\n
\t\t\t * TODO: This might be useful in core.\n
\t\t\t */\n
\t\t\tfunction getCaretRect(rng) {\n
\t\t\t\tvar rects, textNode, node, container = rng.startContainer;\n
\n
\t\t\t\trects = rng.getClientRects();\n
\t\t\t\tif (rects.length) {\n
\t\t\t\t\treturn rects[0];\n
\t\t\t\t}\n
\n
\t\t\t\tif (!rng.collapsed || container.nodeType != 1) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tnode = container.childNodes[lastRng.startOffset];\n
\n
\t\t\t\t// Skip empty whitespace nodes\n
\t\t\t\twhile (node && node.nodeType == 3 && !node.data.length) {\n
\t\t\t\t\tnode = node.nextSibling;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!node) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Check if the location is |<br>\n
\t\t\t\t// TODO: Might need to expand this to say |<table>\n
\t\t\t\tif (node.tagName == \'BR\') {\n
\t\t\t\t\ttextNode = dom.doc.createTextNode(\'\\uFEFF\');\n
\t\t\t\t\tnode.parentNode.insertBefore(textNode, node);\n
\n
\t\t\t\t\trng = dom.createRng();\n
\t\t\t\t\trng.setStartBefore(textNode);\n
\t\t\t\t\trng.setEndAfter(textNode);\n
\n
\t\t\t\t\trects = rng.getClientRects();\n
\t\t\t\t\tdom.remove(textNode);\n
\t\t\t\t}\n
\n
\t\t\t\tif (rects.length) {\n
\t\t\t\t\treturn rects[0];\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Calculate top cordinate this is needed to avoid scrolling to top of document\n
\t\t\t// We want the paste bin to be as close to the caret as possible to avoid scrolling\n
\t\t\tif (lastRng.getClientRects) {\n
\t\t\t\tvar rect = getCaretRect(lastRng);\n
\n
\t\t\t\tif (rect) {\n
\t\t\t\t\t// Client rects gets us closes to the actual\n
\t\t\t\t\t// caret location in for example a wrapped paragraph block\n
\t\t\t\t\ttop = scrollTop + (rect.top - dom.getPos(body).y);\n
\t\t\t\t} else {\n
\t\t\t\t\ttop = scrollTop;\n
\n
\t\t\t\t\t// Check if we can find a closer location by checking the range element\n
\t\t\t\t\tvar container = lastRng.startContainer;\n
\t\t\t\t\tif (container) {\n
\t\t\t\t\t\tif (container.nodeType == 3 && container.parentNode != body) {\n
\t\t\t\t\t\t\tcontainer = container.parentNode;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (container.nodeType == 1) {\n
\t\t\t\t\t\t\ttop = dom.getPos(container, scrollContainer || body).y;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\t// Create a pastebin\n
\t\t\tpasteBinElm = dom.add(editor.getBody(), \'div\', {\n
\t\t\t\tid: "mcepastebin",\n
\t\t\t\tcontentEditable: true,\n
\t\t\t\t"data-mce-bogus": "all",\n
\t\t\t\tstyle: \'position: absolute; top: \' + top + \'px;\' +\n
\t\t\t\t\t\'width: 10px; height: 10px; overflow: hidden; opacity: 0\'\n
\t\t\t}, pasteBinDefaultContent);\n
\n
\t\t\t// Move paste bin out of sight since the controlSelection rect gets displayed otherwise on IE and Gecko\n
\t\t\tif (Env.ie || Env.gecko) {\n
\t\t\t\tdom.setStyle(pasteBinElm, \'left\', dom.getStyle(body, \'direction\', true) == \'rtl\' ? 0xFFFF : -0xFFFF);\n
\t\t\t}\n
\n
\t\t\t// Prevent focus events from bubbeling fixed FocusManager issues\n
\t\t\tdom.bind(pasteBinElm, \'beforedeactivate focusin focusout\', function(e) {\n
\t\t\t\te.stopPropagation();\n
\t\t\t});\n
\n
\t\t\tpasteBinElm.focus();\n
\t\t\teditor.selection.select(pasteBinElm, true);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes the paste bin if it exists.\n
\t\t */\n
\t\tfunction removePasteBin() {\n
\t\t\tif (pasteBinElm) {\n
\t\t\t\tvar pasteBinClone;\n
\n
\t\t\t\t// WebKit/Blink might clone the div so\n
\t\t\t\t// lets make sure we remove all clones\n
\t\t\t\t// TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!\n
\t\t\t\twhile ((pasteBinClone = editor.dom.get(\'mcepastebin\'))) {\n
\t\t\t\t\teditor.dom.remove(pasteBinClone);\n
\t\t\t\t\teditor.dom.unbind(pasteBinClone);\n
\t\t\t\t}\n
\n
\t\t\t\tif (lastRng) {\n
\t\t\t\t\teditor.selection.setRng(lastRng);\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tpasteBinElm = lastRng = null;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the contents of the paste bin as a HTML string.\n
\t\t *\n
\t\t * @return {String} Get the contents of the paste bin.\n
\t\t */\n
\t\tfunction getPasteBinHtml() {\n
\t\t\tvar html = \'\', pasteBinClones, i, clone, cloneHtml;\n
\n
\t\t\t// Since WebKit/Chrome might clone the paste bin when pasting\n
\t\t\t// for example: <img style="float: right"> we need to check if any of them contains some useful html.\n
\t\t\t// TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!\n
\t\t\tpasteBinClones = editor.dom.select(\'div[id=mcepastebin]\');\n
\t\t\tfor (i = 0; i < pasteBinClones.length; i++) {\n
\t\t\t\tclone = pasteBinClones[i];\n
\n
\t\t\t\t// Pasting plain text produces pastebins in pastebinds makes sence right!?\n
\t\t\t\tif (clone.firstChild && clone.firstChild.id == \'mcepastebin\') {\n
\t\t\t\t\tclone = clone.firstChild;\n
\t\t\t\t}\n
\n
\t\t\t\tcloneHtml = clone.innerHTML;\n
\t\t\t\tif (html != pasteBinDefaultContent) {\n
\t\t\t\t\thtml += cloneHtml;\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn html;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Gets various content types out of a datatransfer object.\n
\t\t *\n
\t\t * @param {DataTransfer} dataTransfer Event fired on paste.\n
\t\t * @return {Object} Object with mime types and data for those mime types.\n
\t\t */\n
\t\tfunction getDataTransferItems(dataTransfer) {\n
\t\t\tvar data = {};\n
\n
\t\t\tif (dataTransfer) {\n
\t\t\t\t// Use old WebKit/IE API\n
\t\t\t\tif (dataTransfer.getData) {\n
\t\t\t\t\tvar legacyText = dataTransfer.getData(\'Text\');\n
\t\t\t\t\tif (legacyText && legacyText.length > 0) {\n
\t\t\t\t\t\tif (legacyText.indexOf(mceInternalUrlPrefix) == -1) {\n
\t\t\t\t\t\t\tdata[\'text/plain\'] = legacyText;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tif (dataTransfer.types) {\n
\t\t\t\t\tfor (var i = 0; i < dataTransfer.types.length; i++) {\n
\t\t\t\t\t\tvar contentType = dataTransfer.types[i];\n
\t\t\t\t\t\tdata[contentType] = dataTransfer.getData(contentType);\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\treturn data;\n
\t\t}\n
\n
\t\t/**\n
\t\t * Gets various content types out of the Clipboard API. It will also get the\n
\t\t * plain text using older IE and WebKit API:s.\n
\t\t *\n
\t\t * @param {ClipboardEvent} clipboardEvent Event fired on paste.\n
\t\t * @return {Object} Object with mime types and data for those mime types.\n
\t\t */\n
\t\tfunction getClipboardContent(clipboardEvent) {\n
\t\t\treturn getDataTransferItems(clipboardEvent.clipboardData || editor.getDoc().dataTransfer);\n
\t\t}\n
\n
\t\t/**\n
\t\t * Checks if the clipboard contains image data if it does it will take that data\n
\t\t * and convert it into a data url image and paste that image at the caret location.\n
\t\t *\n
\t\t * @param  {ClipboardEvent} e Paste/drop event object.\n
\t\t * @param  {DOMRange} rng Optional rng object to move selection to.\n
\t\t * @return {Boolean} true/false if the image data was found or not.\n
\t\t */\n
\t\tfunction pasteImageData(e, rng) {\n
\t\t\tvar dataTransfer = e.clipboardData || e.dataTransfer;\n
\n
\t\t\tfunction processItems(items) {\n
\t\t\t\tvar i, item, reader, hadImage = false;\n
\n
\t\t\t\tfunction pasteImage(reader) {\n
\t\t\t\t\tif (rng) {\n
\t\t\t\t\t\teditor.selection.setRng(rng);\n
\t\t\t\t\t\trng = null;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tpasteHtml(\'<img src="\' + reader.result + \'">\');\n
\t\t\t\t}\n
\n
\t\t\t\tif (items) {\n
\t\t\t\t\tfor (i = 0; i < items.length; i++) {\n
\t\t\t\t\t\titem = items[i];\n
\n
\t\t\t\t\t\tif (/^image\\/(jpeg|png|gif|bmp)$/.test(item.type)) {\n
\t\t\t\t\t\t\treader = new FileReader();\n
\t\t\t\t\t\t\treader.onload = pasteImage.bind(null, reader);\n
\t\t\t\t\t\t\treader.readAsDataURL(item.getAsFile ? item.getAsFile() : item);\n
\n
\t\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\t\thadImage = true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\treturn hadImage;\n
\t\t\t}\n
\n
\t\t\tif (editor.settings.paste_data_images && dataTransfer) {\n
\t\t\t\treturn processItems(dataTransfer.items) || processItems(dataTransfer.files);\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Chrome on Android doesn\'t support proper clipboard access so we have no choice but to allow the browser default behavior.\n
\t\t *\n
\t\t * @param {Event} e Paste event object to check if it contains any data.\n
\t\t * @return {Boolean} true/false if the clipboard is empty or not.\n
\t\t */\n
\t\tfunction isBrokenAndroidClipboardEvent(e) {\n
\t\t\tvar clipboardData = e.clipboardData;\n
\n
\t\t\treturn navigator.userAgent.indexOf(\'Android\') != -1 && clipboardData && clipboardData.items && clipboardData.items.length === 0;\n
\t\t}\n
\n
\t\tfunction getCaretRangeFromEvent(e) {\n
\t\t\treturn RangeUtils.getCaretRangeFromPoint(e.clientX, e.clientY, editor.getDoc());\n
\t\t}\n
\n
\t\tfunction hasContentType(clipboardContent, mimeType) {\n
\t\t\treturn mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n
\t\t}\n
\n
\t\tfunction isKeyboardPasteEvent(e) {\n
\t\t\treturn (VK.metaKeyPressed(e) && e.keyCode == 86) || (e.shiftKey && e.keyCode == 45);\n
\t\t}\n
\n
\t\tfunction registerEventHandlers() {\n
\t\t\teditor.on(\'keydown\', function(e) {\n
\t\t\t\tfunction removePasteBinOnKeyUp(e) {\n
\t\t\t\t\t// Ctrl+V or Shift+Insert\n
\t\t\t\t\tif (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n
\t\t\t\t\t\tremovePasteBin();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\t// Ctrl+V or Shift+Insert\n
\t\t\t\tif (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n
\t\t\t\t\tkeyboardPastePlainTextState = e.shiftKey && e.keyCode == 86;\n
\n
\t\t\t\t\t// Edge case on Safari on Mac where it doesn\'t handle Cmd+Shift+V correctly\n
\t\t\t\t\t// it fires the keydown but no paste or keyup so we are left with a paste bin\n
\t\t\t\t\tif (keyboardPastePlainTextState && Env.webkit && navigator.userAgent.indexOf(\'Version/\') != -1) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Prevent undoManager keydown handler from making an undo level with the pastebin in it\n
\t\t\t\t\te.stopImmediatePropagation();\n
\n
\t\t\t\t\tkeyboardPasteTimeStamp = new Date().getTime();\n
\n
\t\t\t\t\t// IE doesn\'t support Ctrl+Shift+V and it doesn\'t even produce a paste event\n
\t\t\t\t\t// so lets fake a paste event and let IE use the execCommand/dataTransfer methods\n
\t\t\t\t\tif (Env.ie && keyboardPastePlainTextState) {\n
\t\t\t\t\t\te.preventDefault();\n
\t\t\t\t\t\teditor.fire(\'paste\', {ieFake: true});\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tremovePasteBin();\n
\t\t\t\t\tcreatePasteBin();\n
\n
\t\t\t\t\t// Remove pastebin if we get a keyup and no paste event\n
\t\t\t\t\t// For example pasting a file in IE 11 will not produce a paste event\n
\t\t\t\t\teditor.once(\'keyup\', removePasteBinOnKeyUp);\n
\t\t\t\t\teditor.once(\'paste\', function() {\n
\t\t\t\t\t\teditor.off(\'keyup\', removePasteBinOnKeyUp);\n
\t\t\t\t\t});\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.on(\'paste\', function(e) {\n
\t\t\t\t// Getting content from the Clipboard can take some time\n
\t\t\t\tvar clipboardTimer = new Date().getTime();\n
\t\t\t\tvar clipboardContent = getClipboardContent(e);\n
\t\t\t\tvar clipboardDelay = new Date().getTime() - clipboardTimer;\n
\n
\t\t\t\tvar isKeyBoardPaste = (new Date().getTime() - keyboardPasteTimeStamp - clipboardDelay) < 1000;\n
\t\t\t\tvar plainTextMode = self.pasteFormat == "text" || keyboardPastePlainTextState;\n
\n
\t\t\t\tkeyboardPastePlainTextState = false;\n
\n
\t\t\t\tif (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n
\t\t\t\t\tremovePasteBin();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (pasteImageData(e)) {\n
\t\t\t\t\tremovePasteBin();\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\t// Not a keyboard paste prevent default paste and try to grab the clipboard contents using different APIs\n
\t\t\t\tif (!isKeyBoardPaste) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t}\n
\n
\t\t\t\t// Try IE only method if paste isn\'t a keyboard paste\n
\t\t\t\tif (Env.ie && (!isKeyBoardPaste || e.ieFake)) {\n
\t\t\t\t\tcreatePasteBin();\n
\n
\t\t\t\t\teditor.dom.bind(pasteBinElm, \'paste\', function(e) {\n
\t\t\t\t\t\te.stopPropagation();\n
\t\t\t\t\t});\n
\n
\t\t\t\t\teditor.getDoc().execCommand(\'Paste\', false, null);\n
\t\t\t\t\tclipboardContent["text/html"] = getPasteBinHtml();\n
\t\t\t\t}\n
\n
\t\t\t\tsetTimeout(function() {\n
\t\t\t\t\tvar content;\n
\n
\t\t\t\t\t// Grab HTML from Clipboard API or paste bin as a fallback\n
\t\t\t\t\tif (hasContentType(clipboardContent, \'text/html\')) {\n
\t\t\t\t\t\tcontent = clipboardContent[\'text/html\'];\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tcontent = getPasteBinHtml();\n
\n
\t\t\t\t\t\t// If paste bin is empty try using plain text mode\n
\t\t\t\t\t\t// since that is better than nothing right\n
\t\t\t\t\t\tif (content == pasteBinDefaultContent) {\n
\t\t\t\t\t\t\tplainTextMode = true;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tcontent = Utils.trimHtml(content);\n
\n
\t\t\t\t\t// WebKit has a nice bug where it clones the paste bin if you paste from for example notepad\n
\t\t\t\t\t// so we need to force plain text mode in this case\n
\t\t\t\t\tif (pasteBinElm && pasteBinElm.firstChild && pasteBinElm.firstChild.id === \'mcepastebin\') {\n
\t\t\t\t\t\tplainTextMode = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tremovePasteBin();\n
\n
\t\t\t\t\t// If we got nothing from clipboard API and pastebin then we could try the last resort: plain/text\n
\t\t\t\t\tif (!content.length) {\n
\t\t\t\t\t\tplainTextMode = true;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Grab plain text from Clipboard API or convert existing HTML to plain text\n
\t\t\t\t\tif (plainTextMode) {\n
\t\t\t\t\t\t// Use plain text contents from Clipboard API unless the HTML contains paragraphs then\n
\t\t\t\t\t\t// we should convert the HTML to plain text since works better when pasting HTML/Word contents as plain text\n
\t\t\t\t\t\tif (hasContentType(clipboardContent, \'text/plain\') && content.indexOf(\'</p>\') == -1) {\n
\t\t\t\t\t\t\tcontent = clipboardContent[\'text/plain\'];\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\tcontent = Utils.innerText(content);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// If the content is the paste bin default HTML then it was\n
\t\t\t\t\t// impossible to get the cliboard data out.\n
\t\t\t\t\tif (content == pasteBinDefaultContent) {\n
\t\t\t\t\t\tif (!isKeyBoardPaste) {\n
\t\t\t\t\t\t\teditor.windowManager.alert(\'Please use Ctrl+V/Cmd+V keyboard shortcuts to paste contents.\');\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (plainTextMode) {\n
\t\t\t\t\t\tpasteText(content);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tpasteHtml(content);\n
\t\t\t\t\t}\n
\t\t\t\t}, 0);\n
\t\t\t});\n
\n
\t\t\teditor.on(\'dragstart dragend\', function(e) {\n
\t\t\t\tdraggingInternally = e.type == \'dragstart\';\n
\t\t\t});\n
\n
\t\t\teditor.on(\'drop\', function(e) {\n
\t\t\t\tvar rng = getCaretRangeFromEvent(e);\n
\n
\t\t\t\tif (e.isDefaultPrevented() || draggingInternally) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (pasteImageData(e, rng)) {\n
\t\t\t\t\treturn;\n
\t\t\t\t}\n
\n
\t\t\t\tif (rng && editor.settings.paste_filter_drop !== false) {\n
\t\t\t\t\tvar dropContent = getDataTransferItems(e.dataTransfer);\n
\t\t\t\t\tvar content = dropContent[\'mce-internal\'] || dropContent[\'text/html\'] || dropContent[\'text/plain\'];\n
\n
\t\t\t\t\tif (content) {\n
\t\t\t\t\t\te.preventDefault();\n
\n
\t\t\t\t\t\teditor.undoManager.transact(function() {\n
\t\t\t\t\t\t\tif (dropContent[\'mce-internal\']) {\n
\t\t\t\t\t\t\t\teditor.execCommand(\'Delete\');\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\teditor.selection.setRng(rng);\n
\n
\t\t\t\t\t\t\tcontent = Utils.trimHtml(content);\n
\n
\t\t\t\t\t\t\tif (!dropContent[\'text/html\']) {\n
\t\t\t\t\t\t\t\tpasteText(content);\n
\t\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t\tpasteHtml(content);\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t});\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\n
\t\t\teditor.on(\'dragover dragend\', function(e) {\n
\t\t\t\tif (editor.settings.paste_data_images) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\tself.pasteHtml = pasteHtml;\n
\t\tself.pasteText = pasteText;\n
\n
\t\teditor.on(\'preInit\', function() {\n
\t\t\tregisterEventHandlers();\n
\n
\t\t\t// Remove all data images from paste for example from Gecko\n
\t\t\t// except internal images like video elements\n
\t\t\teditor.parser.addNodeFilter(\'img\', function(nodes, name, args) {\n
\t\t\t\tfunction isPasteInsert(args) {\n
\t\t\t\t\treturn args.data && args.data.paste === true;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction remove(node) {\n
\t\t\t\t\tif (!node.attr(\'data-mce-object\') && src !== Env.transparentSrc) {\n
\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction isWebKitFakeUrl(src) {\n
\t\t\t\t\treturn src.indexOf("webkit-fake-url") === 0;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction isDataUri(src) {\n
\t\t\t\t\treturn src.indexOf("data:") === 0;\n
\t\t\t\t}\n
\n
\t\t\t\tif (!editor.settings.paste_data_images && isPasteInsert(args)) {\n
\t\t\t\t\tvar i = nodes.length;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tvar src = nodes[i].attributes.map.src;\n
\n
\t\t\t\t\t\tif (!src) {\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Safari on Mac produces webkit-fake-url see: https://bugs.webkit.org/show_bug.cgi?id=49141\n
\t\t\t\t\t\tif (isWebKitFakeUrl(src)) {\n
\t\t\t\t\t\t\tremove(nodes[i]);\n
\t\t\t\t\t\t} else if (!editor.settings.allow_html_data_urls && isDataUri(src)) {\n
\t\t\t\t\t\t\tremove(nodes[i]);\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t});\n
\t\t});\n
\t};\n
});\n
\n
// Included from: js/tinymce/plugins/paste/classes/WordFilter.js\n
\n
/**\n
 * WordFilter.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class parses word HTML into proper TinyMCE markup.\n
 *\n
 * @class tinymce.pasteplugin.WordFilter\n
 * @private\n
 */\n
define("tinymce/pasteplugin/WordFilter", [\n
\t"tinymce/util/Tools",\n
\t"tinymce/html/DomParser",\n
\t"tinymce/html/Schema",\n
\t"tinymce/html/Serializer",\n
\t"tinymce/html/Node",\n
\t"tinymce/pasteplugin/Utils"\n
], function(Tools, DomParser, Schema, Serializer, Node, Utils) {\n
\t/**\n
\t * Checks if the specified content is from any of the following sources: MS Word/Office 365/Google docs.\n
\t */\n
\tfunction isWordContent(content) {\n
\t\treturn (\n
\t\t\t(/<font face="Times New Roman"|class="?Mso|style="[^"]*\\bmso-|style=\'[^\'\']*\\bmso-|w:WordDocument/i).test(content) ||\n
\t\t\t(/class="OutlineElement/).test(content) ||\n
\t\t\t(/id="?docs\\-internal\\-guid\\-/.test(content))\n
\t\t);\n
\t}\n
\n
\t/**\n
\t * Checks if the specified text starts with "1. " or "a. " etc.\n
\t */\n
\tfunction isNumericList(text) {\n
\t\tvar found, patterns;\n
\n
\t\tpatterns = [\n
\t\t\t/^[IVXLMCD]{1,2}\\.[ \\u00a0]/,  // Roman upper case\n
\t\t\t/^[ivxlmcd]{1,2}\\.[ \\u00a0]/,  // Roman lower case\n
\t\t\t/^[a-z]{1,2}[\\.\\)][ \\u00a0]/,  // Alphabetical a-z\n
\t\t\t/^[A-Z]{1,2}[\\.\\)][ \\u00a0]/,  // Alphabetical A-Z\n
\t\t\t/^[0-9]+\\.[ \\u00a0]/,          // Numeric lists\n
\t\t\t/^[\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d]+\\.[ \\u00a0]/, // Japanese\n
\t\t\t/^[\\u58f1\\u5f10\\u53c2\\u56db\\u4f0d\\u516d\\u4e03\\u516b\\u4e5d\\u62fe]+\\.[ \\u00a0]/  // Chinese\n
\t\t];\n
\n
\t\ttext = text.replace(/^[\\u00a0 ]+/, \'\');\n
\n
\t\tTools.each(patterns, function(pattern) {\n
\t\t\tif (pattern.test(text)) {\n
\t\t\t\tfound = true;\n
\t\t\t\treturn false;\n
\t\t\t}\n
\t\t});\n
\n
\t\treturn found;\n
\t}\n
\n
\tfunction isBulletList(text) {\n
\t\treturn /^[\\s\\u00a0]*[\\u2022\\u00b7\\u00a7\\u25CF]\\s*/.test(text);\n
\t}\n
\n
\tfunction WordFilter(editor) {\n
\t\tvar settings = editor.settings;\n
\n
\t\teditor.on(\'BeforePastePreProcess\', function(e) {\n
\t\t\tvar content = e.content, retainStyleProperties, validStyles;\n
\n
\t\t\t// Remove google docs internal guid markers\n
\t\t\tcontent = content.replace(/<b[^>]+id="?docs-internal-[^>]*>/gi, \'\');\n
\t\t\tcontent = content.replace(/<br class="?Apple-interchange-newline"?>/gi, \'\');\n
\n
\t\t\tretainStyleProperties = settings.paste_retain_style_properties;\n
\t\t\tif (retainStyleProperties) {\n
\t\t\t\tvalidStyles = Tools.makeMap(retainStyleProperties.split(/[, ]/));\n
\t\t\t}\n
\n
\t\t\t/**\n
\t\t\t * Converts fake bullet and numbered lists to real semantic OL/UL.\n
\t\t\t *\n
\t\t\t * @param {tinymce.html.Node} node Root node to convert children of.\n
\t\t\t */\n
\t\t\tfunction convertFakeListsToProperLists(node) {\n
\t\t\t\tvar currentListNode, prevListNode, lastLevel = 1;\n
\n
\t\t\t\tfunction getText(node) {\n
\t\t\t\t\tvar txt = \'\';\n
\n
\t\t\t\t\tif (node.type === 3) {\n
\t\t\t\t\t\treturn node.value;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\ttxt += getText(node);\n
\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn txt;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction trimListStart(node, regExp) {\n
\t\t\t\t\tif (node.type === 3) {\n
\t\t\t\t\t\tif (regExp.test(node.value)) {\n
\t\t\t\t\t\t\tnode.value = node.value.replace(regExp, \'\');\n
\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\tif (!trimListStart(node, regExp)) {\n
\t\t\t\t\t\t\t\treturn false;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn true;\n
\t\t\t\t}\n
\n
\t\t\t\tfunction removeIgnoredNodes(node) {\n
\t\t\t\t\tif (node._listIgnore) {\n
\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif ((node = node.firstChild)) {\n
\t\t\t\t\t\tdo {\n
\t\t\t\t\t\t\tremoveIgnoredNodes(node);\n
\t\t\t\t\t\t} while ((node = node.next));\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfunction convertParagraphToLi(paragraphNode, listName, start) {\n
\t\t\t\t\tvar level = paragraphNode._listLevel || lastLevel;\n
\n
\t\t\t\t\t// Handle list nesting\n
\t\t\t\t\tif (level != lastLevel) {\n
\t\t\t\t\t\tif (level < lastLevel) {\n
\t\t\t\t\t\t\t// Move to parent list\n
\t\t\t\t\t\t\tif (currentListNode) {\n
\t\t\t\t\t\t\t\tcurrentListNode = currentListNode.parent.parent;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Create new list\n
\t\t\t\t\t\t\tprevListNode = currentListNode;\n
\t\t\t\t\t\t\tcurrentListNode = null;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!currentListNode || currentListNode.name != listName) {\n
\t\t\t\t\t\tprevListNode = prevListNode || currentListNode;\n
\t\t\t\t\t\tcurrentListNode = new Node(listName, 1);\n
\n
\t\t\t\t\t\tif (start > 1) {\n
\t\t\t\t\t\t\tcurrentListNode.attr(\'start\', \'\' + start);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tparagraphNode.wrap(currentListNode);\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\tcurrentListNode.append(paragraphNode);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tparagraphNode.name = \'li\';\n
\n
\t\t\t\t\t// Append list to previous list if it exists\n
\t\t\t\t\tif (level > lastLevel && prevListNode) {\n
\t\t\t\t\t\tprevListNode.lastChild.append(currentListNode);\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tlastLevel = level;\n
\n
\t\t\t\t\t// Remove start of list item "1. " or "&middot; " etc\n
\t\t\t\t\tremoveIgnoredNodes(paragraphNode);\n
\t\t\t\t\ttrimListStart(paragraphNode, /^\\u00a0+/);\n
\t\t\t\t\ttrimListStart(paragraphNode, /^\\s*([\\u2022\\u00b7\\u00a7\\u25CF]|\\w+\\.)/);\n
\t\t\t\t\ttrimListStart(paragraphNode, /^\\u00a0+/);\n
\t\t\t\t}\n
\n
\t\t\t\t// Build a list of all root level elements before we start\n
\t\t\t\t// altering them in the loop below.\n
\t\t\t\tvar elements = [], child = node.firstChild;\n
\t\t\t\twhile (typeof child !== \'undefined\' && child !== null) {\n
\t\t\t\t\telements.push(child);\n
\n
\t\t\t\t\tchild = child.walk();\n
\t\t\t\t\tif (child !== null) {\n
\t\t\t\t\t\twhile (typeof child !== \'undefined\' && child.parent !== node) {\n
\t\t\t\t\t\t\tchild = child.walk();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\n
\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n
\t\t\t\t\tnode = elements[i];\n
\n
\t\t\t\t\tif (node.name == \'p\' && node.firstChild) {\n
\t\t\t\t\t\t// Find first text node in paragraph\n
\t\t\t\t\t\tvar nodeText = getText(node);\n
\n
\t\t\t\t\t\t// Detect unordered lists look for bullets\n
\t\t\t\t\t\tif (isBulletList(nodeText)) {\n
\t\t\t\t\t\t\tconvertParagraphToLi(node, \'ul\');\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Detect ordered lists 1., a. or ixv.\n
\t\t\t\t\t\tif (isNumericList(nodeText)) {\n
\t\t\t\t\t\t\t// Parse OL start number\n
\t\t\t\t\t\t\tvar matches = /([0-9]+)\\./.exec(nodeText);\n
\t\t\t\t\t\t\tvar start = 1;\n
\t\t\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\t\t\tstart = parseInt(matches[1], 10);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tconvertParagraphToLi(node, \'ol\', start);\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t// Convert paragraphs marked as lists but doesn\'t look like anything\n
\t\t\t\t\t\tif (node._listLevel) {\n
\t\t\t\t\t\t\tconvertParagraphToLi(node, \'ul\', 1);\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tcurrentListNode = null;\n
\t\t\t\t\t} else {\n
\t\t\t\t\t\t// If the root level element isn\'t a p tag which can be\n
\t\t\t\t\t\t// processed by convertParagraphToLi, it interrupts the\n
\t\t\t\t\t\t// lists, causing a new list to start instead of having\n
\t\t\t\t\t\t// elements from the next list inserted above this tag.\n
\t\t\t\t\t\tprevListNode = currentListNode;\n
\t\t\t\t\t\tcurrentListNode = null;\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\n
\t\t\tfunction filterStyles(node, styleValue) {\n
\t\t\t\tvar outputStyles = {}, matches, styles = editor.dom.parseStyle(styleValue);\n
\n
\t\t\t\tTools.each(styles, function(value, name) {\n
\t\t\t\t\t// Convert various MS styles to W3C styles\n
\t\t\t\t\tswitch (name) {\n
\t\t\t\t\t\tcase \'mso-list\':\n
\t\t\t\t\t\t\t// Parse out list indent level for lists\n
\t\t\t\t\t\t\tmatches = /\\w+ \\w+([0-9]+)/i.exec(styleValue);\n
\t\t\t\t\t\t\tif (matches) {\n
\t\t\t\t\t\t\t\tnode._listLevel = parseInt(matches[1], 10);\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\t// Remove these nodes <span style="mso-list:Ignore">o</span>\n
\t\t\t\t\t\t\t// Since the span gets removed we mark the text node and the span\n
\t\t\t\t\t\t\tif (/Ignore/i.test(value) && node.firstChild) {\n
\t\t\t\t\t\t\t\tnode._listIgnore = true;\n
\t\t\t\t\t\t\t\tnode.firstChild._listIgnore = true;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "horiz-align":\n
\t\t\t\t\t\t\tname = "text-align";\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "vert-align":\n
\t\t\t\t\t\t\tname = "vertical-align";\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "font-color":\n
\t\t\t\t\t\tcase "mso-foreground":\n
\t\t\t\t\t\t\tname = "color";\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "mso-background":\n
\t\t\t\t\t\tcase "mso-highlight":\n
\t\t\t\t\t\t\tname = "background";\n
\t\t\t\t\t\t\tbreak;\n
\n
\t\t\t\t\t\tcase "font-weight":\n
\t\t\t\t\t\tcase "font-style":\n
\t\t\t\t\t\t\tif (value != "normal") {\n
\t\t\t\t\t\t\t\toutputStyles[name] = value;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t\treturn;\n
\n
\t\t\t\t\t\tcase "mso-element":\n
\t\t\t\t\t\t\t// Remove track changes code\n
\t\t\t\t\t\t\tif (/^(comment|comment-list)$/i.test(value)) {\n
\t\t\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t\t\t\treturn;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tbreak;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (name.indexOf(\'mso-comment\') === 0) {\n
\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Never allow mso- prefixed names\n
\t\t\t\t\tif (name.indexOf(\'mso-\') === 0) {\n
\t\t\t\t\t\treturn;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Output only valid styles\n
\t\t\t\t\tif (retainStyleProperties == "all" || (validStyles && validStyles[name])) {\n
\t\t\t\t\t\toutputStyles[name] = value;\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Convert bold style to "b" element\n
\t\t\t\tif (/(bold)/i.test(outputStyles["font-weight"])) {\n
\t\t\t\t\tdelete outputStyles["font-weight"];\n
\t\t\t\t\tnode.wrap(new Node("b", 1));\n
\t\t\t\t}\n
\n
\t\t\t\t// Convert italic style to "i" element\n
\t\t\t\tif (/(italic)/i.test(outputStyles["font-style"])) {\n
\t\t\t\t\tdelete outputStyles["font-style"];\n
\t\t\t\t\tnode.wrap(new Node("i", 1));\n
\t\t\t\t}\n
\n
\t\t\t\t// Serialize the styles and see if there is something left to keep\n
\t\t\t\toutputStyles = editor.dom.serializeStyle(outputStyles, node.name);\n
\t\t\t\tif (outputStyles) {\n
\t\t\t\t\treturn outputStyles;\n
\t\t\t\t}\n
\n
\t\t\t\treturn null;\n
\t\t\t}\n
\n
\t\t\tif (settings.paste_enable_default_filters === false) {\n
\t\t\t\treturn;\n
\t\t\t}\n
\n
\t\t\t// Detect is the contents is Word junk HTML\n
\t\t\tif (isWordContent(e.content)) {\n
\t\t\t\te.wordContent = true; // Mark it for other processors\n
\n
\t\t\t\t// Remove basic Word junk\n
\t\t\t\tcontent = Utils.filter(content, [\n
\t\t\t\t\t// Word comments like conditional comments etc\n
\t\t\t\t\t/<!--[\\s\\S]+?-->/gi,\n
\n
\t\t\t\t\t// Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,\n
\t\t\t\t\t// MS Office namespaced tags, and a few other tags\n
\t\t\t\t\t/<(!|script[^>]*>.*?<\\/script(?=[>\\s])|\\/?(\\?xml(:\\w+)?|img|meta|link|style|\\w:\\w+)(?=[\\s\\/>]))[^>]*>/gi,\n
\n
\t\t\t\t\t// Convert <s> into <strike> for line-though\n
\t\t\t\t\t[/<(\\/?)s>/gi, "<$1strike>"],\n
\n
\t\t\t\t\t// Replace nsbp entites to char since it\'s easier to handle\n
\t\t\t\t\t[/&nbsp;/gi, "\\u00a0"],\n
\n
\t\t\t\t\t// Convert <span style="mso-spacerun:yes">___</span> to string of alternating\n
\t\t\t\t\t// breaking/non-breaking spaces of same length\n
\t\t\t\t\t[/<span\\s+style\\s*=\\s*"\\s*mso-spacerun\\s*:\\s*yes\\s*;?\\s*"\\s*>([\\s\\u00a0]*)<\\/span>/gi,\n
\t\t\t\t\t\tfunction(str, spaces) {\n
\t\t\t\t\t\t\treturn (spaces.length > 0) ?\n
\t\t\t\t\t\t\t\tspaces.replace(/./, " ").slice(Math.floor(spaces.length / 2)).split("").join("\\u00a0") : "";\n
\t\t\t\t\t\t}\n
\t\t\t\t\t]\n
\t\t\t\t]);\n
\n
\t\t\t\tvar validElements = settings.paste_word_valid_elements;\n
\t\t\t\tif (!validElements) {\n
\t\t\t\t\tvalidElements = (\n
\t\t\t\t\t\t\'-strong/b,-em/i,-u,-span,-p,-ol,-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,\' +\n
\t\t\t\t\t\t\'-p/div,-a[href|name],sub,sup,strike,br,del,table[width],tr,\' +\n
\t\t\t\t\t\t\'td[colspan|rowspan|width],th[colspan|rowspan|width],thead,tfoot,tbody\'\n
\t\t\t\t\t);\n
\t\t\t\t}\n
\n
\t\t\t\t// Setup strict schema\n
\t\t\t\tvar schema = new Schema({\n
\t\t\t\t\tvalid_elements: validElements,\n
\t\t\t\t\tvalid_children: \'-li[p]\'\n
\t\t\t\t});\n
\n
\t\t\t\t// Add style/class attribute to all element rules since the user might have removed them from\n
\t\t\t\t// paste_word_valid_elements config option and we need to check them for properties\n
\t\t\t\tTools.each(schema.elements, function(rule) {\n
\t\t\t\t\t/*eslint dot-notation:0*/\n
\t\t\t\t\tif (!rule.attributes["class"]) {\n
\t\t\t\t\t\trule.attributes["class"] = {};\n
\t\t\t\t\t\trule.attributesOrder.push("class");\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tif (!rule.attributes.style) {\n
\t\t\t\t\t\trule.attributes.style = {};\n
\t\t\t\t\t\trule.attributesOrder.push("style");\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Parse HTML into DOM structure\n
\t\t\t\tvar domParser = new DomParser({}, schema);\n
\n
\t\t\t\t// Filter styles to remove "mso" specific styles and convert some of them\n
\t\t\t\tdomParser.addAttributeFilter(\'style\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length, node;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\t\tnode.attr(\'style\', filterStyles(node, node.attr(\'style\')));\n
\n
\t\t\t\t\t\t// Remove pointess spans\n
\t\t\t\t\t\tif (node.name == \'span\' && node.parent && !node.attributes.length) {\n
\t\t\t\t\t\t\tnode.unwrap();\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Check the class attribute for comments or del items and remove those\n
\t\t\t\tdomParser.addAttributeFilter(\'class\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length, node, className;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnode = nodes[i];\n
\n
\t\t\t\t\t\tclassName = node.attr(\'class\');\n
\t\t\t\t\t\tif (/^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(className)) {\n
\t\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tnode.attr(\'class\', null);\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Remove all del elements since we don\'t want the track changes code in the editor\n
\t\t\t\tdomParser.addNodeFilter(\'del\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnodes[i].remove();\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Keep some of the links and anchors\n
\t\t\t\tdomParser.addNodeFilter(\'a\', function(nodes) {\n
\t\t\t\t\tvar i = nodes.length, node, href, name;\n
\n
\t\t\t\t\twhile (i--) {\n
\t\t\t\t\t\tnode = nodes[i];\n
\t\t\t\t\t\thref = node.attr(\'href\');\n
\t\t\t\t\t\tname = node.attr(\'name\');\n
\n
\t\t\t\t\t\tif (href && href.indexOf(\'#_msocom_\') != -1) {\n
\t\t\t\t\t\t\tnode.remove();\n
\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (href && href.indexOf(\'file://\') === 0) {\n
\t\t\t\t\t\t\thref = href.split(\'#\')[1];\n
\t\t\t\t\t\t\tif (href) {\n
\t\t\t\t\t\t\t\thref = \'#\' + href;\n
\t\t\t\t\t\t\t}\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (!href && !name) {\n
\t\t\t\t\t\t\tnode.unwrap();\n
\t\t\t\t\t\t} else {\n
\t\t\t\t\t\t\t// Remove all named anchors that aren\'t specific to TOC, Footnotes or Endnotes\n
\t\t\t\t\t\t\tif (name && !/^_?(?:toc|edn|ftn)/i.test(name)) {\n
\t\t\t\t\t\t\t\tnode.unwrap();\n
\t\t\t\t\t\t\t\tcontinue;\n
\t\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\t\tnode.attr({\n
\t\t\t\t\t\t\t\thref: href,\n
\t\t\t\t\t\t\t\tname: name\n
\t\t\t\t\t\t\t});\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t});\n
\n
\t\t\t\t// Parse into DOM structure\n
\t\t\t\tvar rootNode = domParser.parse(content);\n
\n
\t\t\t\t// Process DOM\n
\t\t\t\tif (settings.paste_convert_word_fake_lists !== false) {\n
\t\t\t\t\tconvertFakeListsToProperLists(rootNode);\n
\t\t\t\t}\n
\n
\t\t\t\t// Serialize DOM back to HTML\n
\t\t\t\te.content = new Serializer({}, schema).serialize(rootNode);\n
\t\t\t}\n
\t\t});\n
\t}\n
\n
\tWordFilter.isWordContent = isWordContent;\n
\n
\treturn WordFilter;\n
});\n
\n
// Included from: js/tinymce/plugins/paste/classes/Quirks.js\n
\n
/**\n
 * Quirks.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains various fixes for browsers. These issues can not be feature\n
 * detected since we have no direct control over the clipboard. However we might be able\n
 * to remove some of these fixes once the browsers gets updated/fixed.\n
 *\n
 * @class tinymce.pasteplugin.Quirks\n
 * @private\n
 */\n
define("tinymce/pasteplugin/Quirks", [\n
\t"tinymce/Env",\n
\t"tinymce/util/Tools",\n
\t"tinymce/pasteplugin/WordFilter",\n
\t"tinymce/pasteplugin/Utils"\n
], function(Env, Tools, WordFilter, Utils) {\n
\t"use strict";\n
\n
\treturn function(editor) {\n
\t\tfunction addPreProcessFilter(filterFunc) {\n
\t\t\teditor.on(\'BeforePastePreProcess\', function(e) {\n
\t\t\t\te.content = filterFunc(e.content);\n
\t\t\t});\n
\t\t}\n
\n
\t\t/**\n
\t\t * Removes BR elements after block elements. IE9 has a nasty bug where it puts a BR element after each\n
\t\t * block element when pasting from word. This removes those elements.\n
\t\t *\n
\t\t * This:\n
\t\t *  <p>a</p><br><p>b</p>\n
\t\t *\n
\t\t * Becomes:\n
\t\t *  <p>a</p><p>b</p>\n
\t\t */\n
\t\tfunction removeExplorerBrElementsAfterBlocks(html) {\n
\t\t\t// Only filter word specific content\n
\t\t\tif (!WordFilter.isWordContent(html)) {\n
\t\t\t\treturn html;\n
\t\t\t}\n
\n
\t\t\t// Produce block regexp based on the block elements in schema\n
\t\t\tvar blockElements = [];\n
\n
\t\t\tTools.each(editor.schema.getBlockElements(), function(block, blockName) {\n
\t\t\t\tblockElements.push(blockName);\n
\t\t\t});\n
\n
\t\t\tvar explorerBlocksRegExp = new RegExp(\n
\t\t\t\t\'(?:<br>&nbsp;[\\\\s\\\\r\\\\n]+|<br>)*(<\\\\/?(\' + blockElements.join(\'|\') + \')[^>]*>)(?:<br>&nbsp;[\\\\s\\\\r\\\\n]+|<br>)*\',\n
\t\t\t\t\'g\'\n
\t\t\t);\n
\n
\t\t\t// Remove BR:s from: <BLOCK>X</BLOCK><BR>\n
\t\t\thtml = Utils.filter(html, [\n
\t\t\t\t[explorerBlocksRegExp, \'$1\']\n
\t\t\t]);\n
\n
\t\t\t// IE9 also adds an extra BR element for each soft-linefeed and it also adds a BR for each word wrap break\n
\t\t\thtml = Utils.filter(html, [\n
\t\t\t\t[/<br><br>/g, \'<BR><BR>\'], // Replace multiple BR elements with uppercase BR to keep them intact\n
\t\t\t\t[/<br>/g, \' \'],            // Replace single br elements with space since they are word wrap BR:s\n
\t\t\t\t[/<BR><BR>/g, \'<br>\']      // Replace back the double brs but into a single BR\n
\t\t\t]);\n
\n
\t\t\treturn html;\n
\t\t}\n
\n
\t\t/**\n
\t\t * WebKit has a nasty bug where the all computed styles gets added to style attributes when copy/pasting contents.\n
\t\t * This fix solves that by simply removing the whole style attribute.\n
\t\t *\n
\t\t * The paste_webkit_styles option can be set to specify what to keep:\n
\t\t *  paste_webkit_styles: "none" // Keep no styles\n
\t\t *  paste_webkit_styles: "all", // Keep all of them\n
\t\t *  paste_webkit_styles: "font-weight color" // Keep specific ones\n
\t\t *\n
\t\t * @param {String} content Content that needs to be processed.\n
\t\t * @return {String} Processed contents.\n
\t\t */\n
\t\tfunction removeWebKitStyles(content) {\n
\t\t\t// Passthrough all styles from Word and let the WordFilter handle that junk\n
\t\t\tif (WordFilter.isWordContent(content)) {\n
\t\t\t\treturn content;\n
\t\t\t}\n
\n
\t\t\t// Filter away styles that isn\'t matching the target node\n
\t\t\tvar webKitStyles = editor.settings.paste_webkit_styles;\n
\n
\t\t\tif (editor.settings.paste_remove_styles_if_webkit === false || webKitStyles == "all") {\n
\t\t\t\treturn content;\n
\t\t\t}\n
\n
\t\t\tif (webKitStyles) {\n
\t\t\t\twebKitStyles = webKitStyles.split(/[, ]/);\n
\t\t\t}\n
\n
\t\t\t// Keep specific styles that doesn\'t match the current node computed style\n
\t\t\tif (webKitStyles) {\n
\t\t\t\tvar dom = editor.dom, node = editor.selection.getNode();\n
\n
\t\t\t\tcontent = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, function(all, before, value, after) {\n
\t\t\t\t\tvar inputStyles = dom.parseStyle(value, \'span\'), outputStyles = {};\n
\n
\t\t\t\t\tif (webKitStyles === "none") {\n
\t\t\t\t\t\treturn before + after;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\tfor (var i = 0; i < webKitStyles.length; i++) {\n
\t\t\t\t\t\tvar inputValue = inputStyles[webKitStyles[i]], currentValue = dom.getStyle(node, webKitStyles[i], true);\n
\n
\t\t\t\t\t\tif (/color/.test(webKitStyles[i])) {\n
\t\t\t\t\t\t\tinputValue = dom.toHex(inputValue);\n
\t\t\t\t\t\t\tcurrentValue = dom.toHex(currentValue);\n
\t\t\t\t\t\t}\n
\n
\t\t\t\t\t\tif (currentValue != inputValue) {\n
\t\t\t\t\t\t\toutputStyles[webKitStyles[i]] = inputValue;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\n
\t\t\t\t\toutputStyles = dom.serializeStyle(outputStyles, \'span\');\n
\t\t\t\t\tif (outputStyles) {\n
\t\t\t\t\t\treturn before + \' style="\' + outputStyles + \'"\' + after;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\treturn before + after;\n
\t\t\t\t});\n
\t\t\t} else {\n
\t\t\t\t// Remove all external styles\n
\t\t\t\tcontent = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, \'$1$3\');\n
\t\t\t}\n
\n
\t\t\t// Keep internal styles\n
\t\t\tcontent = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, function(all, before, value, after) {\n
\t\t\t\treturn before + \' style="\' + value + \'"\' + after;\n
\t\t\t});\n
\n
\t\t\treturn content;\n
\t\t}\n
\n
\t\t// Sniff browsers and apply fixes since we can\'t feature detect\n
\t\tif (Env.webkit) {\n
\t\t\taddPreProcessFilter(removeWebKitStyles);\n
\t\t}\n
\n
\t\tif (Env.ie) {\n
\t\t\taddPreProcessFilter(removeExplorerBrElementsAfterBlocks);\n
\t\t}\n
\t};\n
});\n
\n
// Included from: js/tinymce/plugins/paste/classes/Plugin.js\n
\n
/**\n
 * Plugin.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * This class contains the tinymce plugin logic for the paste plugin.\n
 *\n
 * @class tinymce.pasteplugin.Plugin\n
 * @private\n
 */\n
define("tinymce/pasteplugin/Plugin", [\n
\t"tinymce/PluginManager",\n
\t"tinymce/pasteplugin/Clipboard",\n
\t"tinymce/pasteplugin/WordFilter",\n
\t"tinymce/pasteplugin/Quirks"\n
], function(PluginManager, Clipboard, WordFilter, Quirks) {\n
\tvar userIsInformed;\n
\n
\tPluginManager.add(\'paste\', function(editor) {\n
\t\tvar self = this, clipboard, settings = editor.settings;\n
\n
\t\tfunction togglePlainTextPaste() {\n
\t\t\tif (clipboard.pasteFormat == "text") {\n
\t\t\t\tthis.active(false);\n
\t\t\t\tclipboard.pasteFormat = "html";\n
\t\t\t} else {\n
\t\t\t\tclipboard.pasteFormat = "text";\n
\t\t\t\tthis.active(true);\n
\n
\t\t\t\tif (!userIsInformed) {\n
\t\t\t\t\teditor.windowManager.alert(\n
\t\t\t\t\t\t\'Paste is now in plain text mode. Contents will now \' +\n
\t\t\t\t\t\t\'be pasted as plain text until you toggle this option off.\'\n
\t\t\t\t\t);\n
\n
\t\t\t\t\tuserIsInformed = true;\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\tself.clipboard = clipboard = new Clipboard(editor);\n
\t\tself.quirks = new Quirks(editor);\n
\t\tself.wordFilter = new WordFilter(editor);\n
\n
\t\tif (editor.settings.paste_as_text) {\n
\t\t\tself.clipboard.pasteFormat = "text";\n
\t\t}\n
\n
\t\tif (settings.paste_preprocess) {\n
\t\t\teditor.on(\'PastePreProcess\', function(e) {\n
\t\t\t\tsettings.paste_preprocess.call(self, self, e);\n
\t\t\t});\n
\t\t}\n
\n
\t\tif (settings.paste_postprocess) {\n
\t\t\teditor.on(\'PastePostProcess\', function(e) {\n
\t\t\t\tsettings.paste_postprocess.call(self, self, e);\n
\t\t\t});\n
\t\t}\n
\n
\t\teditor.addCommand(\'mceInsertClipboardContent\', function(ui, value) {\n
\t\t\tif (value.content) {\n
\t\t\t\tself.clipboard.pasteHtml(value.content);\n
\t\t\t}\n
\n
\t\t\tif (value.text) {\n
\t\t\t\tself.clipboard.pasteText(value.text);\n
\t\t\t}\n
\t\t});\n
\n
\t\t// Block all drag/drop events\n
\t\tif (editor.paste_block_drop) {\n
\t\t\teditor.on(\'dragend dragover draggesture dragdrop drop drag\', function(e) {\n
\t\t\t\te.preventDefault();\n
\t\t\t\te.stopPropagation();\n
\t\t\t});\n
\t\t}\n
\n
\t\t// Prevent users from dropping data images on Gecko\n
\t\tif (!editor.settings.paste_data_images) {\n
\t\t\teditor.on(\'drop\', function(e) {\n
\t\t\t\tvar dataTransfer = e.dataTransfer;\n
\n
\t\t\t\tif (dataTransfer && dataTransfer.files && dataTransfer.files.length > 0) {\n
\t\t\t\t\te.preventDefault();\n
\t\t\t\t}\n
\t\t\t});\n
\t\t}\n
\n
\t\teditor.addButton(\'pastetext\', {\n
\t\t\ticon: \'pastetext\',\n
\t\t\ttooltip: \'Paste as text\',\n
\t\t\tonclick: togglePlainTextPaste,\n
\t\t\tactive: self.clipboard.pasteFormat == "text"\n
\t\t});\n
\n
\t\teditor.addMenuItem(\'pastetext\', {\n
\t\t\ttext: \'Paste as text\',\n
\t\t\tselectable: true,\n
\t\t\tactive: clipboard.pasteFormat,\n
\t\t\tonclick: togglePlainTextPaste\n
\t\t});\n
\t});\n
});\n
\n
expose(["tinymce/pasteplugin/Utils"]);\n
})(this);

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>46371</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>plugin.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
