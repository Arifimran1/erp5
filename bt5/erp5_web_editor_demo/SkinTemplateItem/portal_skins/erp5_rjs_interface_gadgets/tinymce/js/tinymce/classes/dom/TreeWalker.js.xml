<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts41268373.02</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>TreeWalker.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/**\n
 * TreeWalker.js\n
 *\n
 * Released under LGPL License.\n
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved\n
 *\n
 * License: http://www.tinymce.com/license\n
 * Contributing: http://www.tinymce.com/contributing\n
 */\n
\n
/**\n
 * TreeWalker class enables you to walk the DOM in a linear manner.\n
 *\n
 * @class tinymce.dom.TreeWalker\n
 * @example\n
 * var walker = new tinymce.dom.TreeWalker(startNode);\n
 *\n
 * do {\n
 *     console.log(walker.current());\n
 * } while (walker.next());\n
 */\n
define("tinymce/dom/TreeWalker", [], function() {\n
\t/**\n
\t * Constructs a new TreeWalker instance.\n
\t *\n
\t * @constructor\n
\t * @method TreeWalker\n
\t * @param {Node} startNode Node to start walking from.\n
\t * @param {node} rootNode Optional root node to never walk out of.\n
\t */\n
\treturn function(startNode, rootNode) {\n
\t\tvar node = startNode;\n
\n
\t\tfunction findSibling(node, startName, siblingName, shallow) {\n
\t\t\tvar sibling, parent;\n
\n
\t\t\tif (node) {\n
\t\t\t\t// Walk into nodes if it has a start\n
\t\t\t\tif (!shallow && node[startName]) {\n
\t\t\t\t\treturn node[startName];\n
\t\t\t\t}\n
\n
\t\t\t\t// Return the sibling if it has one\n
\t\t\t\tif (node != rootNode) {\n
\t\t\t\t\tsibling = node[siblingName];\n
\t\t\t\t\tif (sibling) {\n
\t\t\t\t\t\treturn sibling;\n
\t\t\t\t\t}\n
\n
\t\t\t\t\t// Walk up the parents to look for siblings\n
\t\t\t\t\tfor (parent = node.parentNode; parent && parent != rootNode; parent = parent.parentNode) {\n
\t\t\t\t\t\tsibling = parent[siblingName];\n
\t\t\t\t\t\tif (sibling) {\n
\t\t\t\t\t\t\treturn sibling;\n
\t\t\t\t\t\t}\n
\t\t\t\t\t}\n
\t\t\t\t}\n
\t\t\t}\n
\t\t}\n
\n
\t\t/**\n
\t\t * Returns the current node.\n
\t\t *\n
\t\t * @method current\n
\t\t * @return {Node} Current node where the walker is.\n
\t\t */\n
\t\tthis.current = function() {\n
\t\t\treturn node;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Walks to the next node in tree.\n
\t\t *\n
\t\t * @method next\n
\t\t * @return {Node} Current node where the walker is after moving to the next node.\n
\t\t */\n
\t\tthis.next = function(shallow) {\n
\t\t\tnode = findSibling(node, \'firstChild\', \'nextSibling\', shallow);\n
\t\t\treturn node;\n
\t\t};\n
\n
\t\t/**\n
\t\t * Walks to the previous node in tree.\n
\t\t *\n
\t\t * @method prev\n
\t\t * @return {Node} Current node where the walker is after moving to the previous node.\n
\t\t */\n
\t\tthis.prev = function(shallow) {\n
\t\t\tnode = findSibling(node, \'lastChild\', \'previousSibling\', shallow);\n
\t\t\treturn node;\n
\t\t};\n
\t};\n
});

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>2189</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>TreeWalker.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
