##############################################################################
#
# Copyright (c) 2007 Nexedi SA and Contributors. All Rights Reserved.
#                    Yoshinori Okuji <yo@nexedi.com>
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsability of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# garantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################

"""This is another patch for importing Business Templates generated by Zope 2.8
into Zope 2.7. Also, look at Connection.py for the other part.

In Zope 2.8 (i.e. ZODB 3.4), persistent objects are based on new-style class,
while Zope 2.7 (i.e. ZODB 3.2) uses old-style class only. To instantiate
objects in ZODB 3.4 and later, copy_reg.__newobj__ is utilized, which
supports only new-style class. On the other hand, ZODB 3.2 makes an empty
object by calling the class object with None.

However, this is based on the analysis of some observation, and theoretically
not very certain. There might be an occasion where non-None arguments are
used to instantiate a ghost object. I am not sure. If this is not true,
we must patch __newobj__ differently.

Note that this file is named copy_reg_patch instead of copy_reg by intention.
Otherwise, importing copy_reg results in importing itself. SO DO NOT RENAME
THIS FILE TO copy_reg.py.
"""

try:
    from ZODB import serialize
    del serialize
except ImportError:
    import copy_reg

    original_newobj = copy_reg.__newobj__
    def __newobj__(cls, *args):
        # If this method is used for new-style class, call the original.
        # Otherwise, just call the class object with None.
        if issubclass(cls, object):
            return original_newobj(cls, *args)
        return cls(None)

    copy_reg.__newobj__ = __newobj__
