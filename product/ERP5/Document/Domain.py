##############################################################################
#
# Copyright (c) 2002 Nexedi SARL and Contributors. All Rights Reserved.
#                    Jean-Paul Smets-Solanes <jp@nexedi.com>
#
# WARNING: This program as such is intended to be used by professional
# programmers who take the whole responsability of assessing all potential
# consequences resulting from its eventual inadequacies and bugs
# End users who are looking for a ready-to-use solution with commercial
# garantees and support are strongly adviced to contract a Free Software
# Service Company
#
# This program is Free Software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################

from Globals import InitializeClass
from AccessControl import ClassSecurityInfo

from Products.ERP5Type import Permissions, PropertySheet, Constraint, Interface

from Products.ERP5.Document.MetaResource import MetaResource
from Products.ERP5.Document.MetaNode import MetaNode
from Products.ERP5.Document.Predicate import Predicate

class Domain(Predicate, MetaNode, MetaResource):
  """
    Domain can be used as MetaNodes or MetaResources. For example,
    a Domain viewed as a MetaNode can search for all emerging movements
    and compare it with its capacity.
        
    Structure is:
       - base domain (like base category)
       - sub domain (like category)
       
    Allows to define ranges:
       - price between X and Y
       - portal_type in (a, b, c)
       - price between X and Y and region in (a, b, c)
       
    Reports:
       - listbox allows to produce reports
         - output to html, pdf or ooffice
         - definition through the web (ie. which field in which column, which statistics)
         - definition of selection (to list)
         - ability for use to "save" favourite report (user reports)
         - library of favourite reports (global reports)
       - matrixbox allows to produce reports       
         - output to html, pdf or ooffice
         - definition through the web (ie. which base_category or base_domain in which axis)
         - definition of selection (to map to matrix)
         - ability for use to "save" favourite report (user reports)
         - library of favourite reports (global reports)

    Domain and Domain Generators are now unified. Any domain may act
    as a domain generator or as a simple predicate.

    A Domain Generator uses a method (SQL, Python) to select objects
    which are then wrapped as Virtual Domains. This can be used for
    example to provide the list the 10 best selling shops to 
    a report tree.
  """
  meta_type = 'ERP5 Domain'
  portal_type = 'Domain'
  add_permission = Permissions.AddPortalContent
  isPortalContent = 1
  isRADContent = 1

  # Declarative security
  security = ClassSecurityInfo()
  security.declareObjectProtected(Permissions.AccessContentsInformation)

  # Declarative interfaces
  __implements__ = ( Interface.Predicate, )

  security.declareProtected( Permissions.AccessContentsInformation, 'getRelativeUrl' )
  def getRelativeUrl(self):
    """
      We must eliminate portal_categories in the RelativeUrl
      since it is never present in the category list
    """
    return '/'.join(self.portal_url.getRelativeContentPath(self)[1:])

  # Generator API - DRAFT

  # We must overload objectValues and friends
  def DRAFT_objectValues(self):
    # We must return objects which are inside the domain
    # + objects which are generated by the domain generator
    return super.objectValues() + self.getDomainGeneratorList()
    pass

  # How to define a generated subdomain
  def getDomainGeneratorList(self, depth=0):
    # We call a script which builds for us a list DomainGenerator instances
    # We need a way to know how deep we are in the domain generation
    # to prevent infinite recursion
    pass

# # Hand made temp object (rather than ERP5Type generated) because we need
# # it now
# class DomainGenerator(TempDomain):
#   """
#     This class defines a predicate as well as all necessary
#     information to generate subdomains.

#     Instances are stored in RAM as temp objects

#     Generator API - DRAFT
#   """

#   # We must overload objectValues and friends
#   def objectValues(self):
#     # We must return objects which are generated by the domain generator
#     return self.getDomainGeneratorList(depth = self.depth + 1)


